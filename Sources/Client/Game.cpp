// Game.cpp: implementation of the CGame class.
//
//////////////////////////////////////////////////////////////////////


#include "Game.h"
#include "lan_eng.h"


extern char G_cSpriteAlphaDegree;

extern char G_cCmdLine[256], G_cCmdLineTokenA[120], G_cCmdLineTokenA_Lowercase[120], G_cCmdLineTokenB[120], G_cCmdLineTokenC[120], G_cCmdLineTokenD[120], G_cCmdLineTokenE[120];
extern class XSocket * G_pCalcSocket;
extern BOOL G_bIsCalcSocketConnected;
extern DWORD G_dwCalcSocketTime, G_dwCalcSocketSendTime;
extern HWND	G_hWnd, G_hEditWnd;
extern HINSTANCE G_hInstance;

char _cDrawingOrder[]            = {0, 1, 0, 0, 0, 0, 0, 1, 1};
char _cMantleDrawingOrder[]      = {0, 1, 1, 1, 0, 0, 0, 2, 2};
char _cMantleDrawingOrderOnRun[] = {0, 1, 1, 1, 1, 1, 1, 1, 1};


short _tmp_sOwnerType, _tmp_sAppr1, _tmp_sAppr2, _tmp_sAppr3, _tmp_sAppr4;//, _tmp_iStatus;
//CInt _tmp_iStatus;
int _tmp_iStatus;
char  _tmp_cAction, _tmp_cDir, _tmp_cFrame, _tmp_cName[12];
int   _tmp_iChatIndex, _tmp_dx, _tmp_dy, _tmp_iApprColor, _tmp_iEffectType, _tmp_iEffectFrame, _tmp_dX, _tmp_dY; // 21.171 2002-6-14
WORD  _tmp_wObjectID;
char cDynamicObjectData1, cDynamicObjectData2, cDynamicObjectData3, cDynamicObjectData4;
WORD  wFocusObjectID;
short sFocus_dX, sFocus_dY;
char  cFocusAction, cFocusFrame, cFocusDir, cFocusName[12];
short sFocusX, sFocusY, sFocusOwnerType, sFocusAppr1, sFocusAppr2, sFocusAppr3, sFocusAppr4;
int iFocuiStatus;
int   iFocusApprColor;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

void CGame::ReadSettings()
{	m_sMagicShortCut = -1;
	m_sRecentShortCut = -1;
	for( int i=0 ; i<6 ; i++ ) m_sShortCut[i] = -1;

	HKEY key;
	DWORD dwDisp;
	UINT Result;
	DWORD Size = sizeof(LONG);
	if( RegCreateKeyEx( HKEY_CURRENT_USER, "Software\\Siementech\\Helbreath\\Settings", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &key, &dwDisp ) != ERROR_SUCCESS ) return;

	if( RegQueryValueEx(key, "Magic", 0, NULL, (LPBYTE)&Result, &Size) != ERROR_SUCCESS )
	{	RegCloseKey(key);
		return;
	}
	if( Result > 0 && Result < 101 ) m_sMagicShortCut = Result - 1;
	else m_sMagicShortCut = -1;

	if( RegQueryValueEx(key, "ShortCut0", 0, NULL, (LPBYTE)&Result, &Size) != ERROR_SUCCESS )
	{	RegCloseKey(key);
		return;
	}
	if( Result > 0 && Result < 201 ) m_sShortCut[0] = Result - 1;
	else m_sShortCut[0] = -1;

	if( RegQueryValueEx(key, "ShortCut1", 0, NULL, (LPBYTE)&Result, &Size) != ERROR_SUCCESS )
	{	RegCloseKey(key);
		return;
	}
	if( Result > 0 && Result < 201 ) m_sShortCut[1] = Result - 1;
	else m_sShortCut[1] = -1;

	if( RegQueryValueEx(key, "ShortCut2", 0, NULL, (LPBYTE)&Result, &Size) != ERROR_SUCCESS )
	{	RegCloseKey(key);
		return;
	}
	if( Result > 0 && Result < 201 ) m_sShortCut[2] = Result - 1;
	else m_sShortCut[2] = -1;

	if( RegQueryValueEx(key, "ShortCut3", 0, NULL, (LPBYTE)&Result, &Size) != ERROR_SUCCESS )
	{	RegCloseKey(key);
		return;
	}
	if( Result > 0 && Result < 201 ) m_sShortCut[3] = Result - 1;
	else m_sShortCut[3] = -1;

	if( RegQueryValueEx(key, "ShortCut4", 0, NULL, (LPBYTE)&Result, &Size) != ERROR_SUCCESS )
	{	RegCloseKey(key);
		return;
	}
	if( Result > 0 && Result < 201 ) m_sShortCut[4] = Result - 1;
	else m_sShortCut[4] = -1;

#ifdef DEF_MULTI_SHORTCUT	// 6th sortcut
	if( RegQueryValueEx(key, "ShortCut5", 0, NULL, (LPBYTE)&Result, &Size) != ERROR_SUCCESS )
	{	RegCloseKey(key); // Snoopy: Added 6th shortcut
		return;
	}
	if( Result > 0 && Result < 201 ) m_sShortCut[5] = Result - 1;
	else m_sShortCut[5] = -1;
#endif

	RegCloseKey(key);
}

void CGame::WriteSettings()
{HKEY key;
 DWORD dwDisp;
 UINT nData;
	if( RegCreateKeyEx( HKEY_CURRENT_USER, "Software\\Siementech\\Helbreath\\Settings", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &key, &dwDisp ) != ERROR_SUCCESS ) return;

	if( m_sMagicShortCut >= 0 && m_sMagicShortCut < 100 ) nData = m_sMagicShortCut + 1;
	else nData = 0;
	if( RegSetValueEx(key, "Magic", 0, REG_DWORD, (LPBYTE)&nData, sizeof(UINT) ) != ERROR_SUCCESS )
	{	RegCloseKey(key);
		return;
	}

	if( m_sShortCut[0] >= 0 && m_sShortCut[0] < 200 ) nData = m_sShortCut[0] + 1;
	else nData = 0;
	if( RegSetValueEx(key, "ShortCut0", 0, REG_DWORD, (LPBYTE)&nData, sizeof(UINT) ) != ERROR_SUCCESS )
	{	RegCloseKey(key);
		return;
	}

	if( m_sShortCut[1] >= 0 && m_sShortCut[1] < 200 ) nData = m_sShortCut[1] + 1;
	else nData = 0;
	if( RegSetValueEx(key, "ShortCut1", 0, REG_DWORD, (LPBYTE)&nData, sizeof(UINT) ) != ERROR_SUCCESS )
	{	RegCloseKey(key);
		return;
	}

	if( m_sShortCut[2] >= 0 && m_sShortCut[2] < 200 ) nData = m_sShortCut[2] + 1;
	else nData = 0;
	if( RegSetValueEx(key, "ShortCut2", 0, REG_DWORD, (LPBYTE)&nData, sizeof(UINT) ) != ERROR_SUCCESS )
	{	RegCloseKey(key);
		return;
	}

	if( m_sShortCut[3] >= 0 && m_sShortCut[3] < 200 ) nData = m_sShortCut[3] + 1;
	else nData = 0;
	if( RegSetValueEx(key, "ShortCut3", 0, REG_DWORD, (LPBYTE)&nData, sizeof(UINT) ) != ERROR_SUCCESS )
	{	RegCloseKey(key);
		return;
	}

	if( m_sShortCut[4] >= 0 && m_sShortCut[4] < 200 ) nData = m_sShortCut[4] + 1;
	else nData = 0;
	if( RegSetValueEx(key, "ShortCut4", 0, REG_DWORD, (LPBYTE)&nData, sizeof(UINT) ) != ERROR_SUCCESS )
	{	RegCloseKey(key);
		return;
	}
#ifdef DEF_MULTI_SHORTCUT	// 6th shortcut
	if( m_sShortCut[5] >= 0 && m_sShortCut[5] < 200 ) nData = m_sShortCut[5] + 1; // Snoopy: 6th shortcut
	else nData = 0;
	if( RegSetValueEx(key, "ShortCut5", 0, REG_DWORD, (LPBYTE)&nData, sizeof(UINT) ) != ERROR_SUCCESS )
	{	RegCloseKey(key);
		return;
	}
#endif
	RegCloseKey(key);
}

CGame::CGame()
{	m_dwCheckSprTime = 0;
	int i;
	srand( (unsigned)time( NULL ) );
	ReadSettings();

#ifdef _DEBUG
	m_bToggleScreen = TRUE;
#else
	m_bToggleScreen = FALSE;
#endif

	m_bShowFPS = FALSE;
	m_cDetailLevel = 2;
	m_cLoading = 0;
	m_bZoomMap = TRUE;
	m_bIsFirstConn = TRUE;
	m_iItemDropCnt = 0;
	m_bItemDrop = FALSE;
	m_bIsSpecial = FALSE;
	m_cGameMode = DEF_GAMEMODE_ONLOADING;
	m_cWhisperIndex = DEF_MAXWHISPERMSG;
	m_cGameModeCount = 0;
	ZeroMemory(m_cMapName, sizeof(m_cMapName));
	m_pGSock   = NULL;
	m_pLSock   = NULL;
	m_pMapData = NULL;
	m_cCommandCount  = 0;
	m_dwCommandTime = 0; //v2.15 SpeedHack
	m_sPlayerX = NULL;
	m_sPlayerY = NULL;
	m_sViewDX  = NULL;
	m_sViewDY  = NULL;
	m_cCommand = DEF_OBJECTSTOP;
	m_bIsObserverMode = FALSE;
	for (i = 0; i < DEF_MAXSPRITES; i++) m_pSprite[i] = NULL;
	for (i = 0; i < DEF_MAXTILES; i++) m_pTileSpr[i] = NULL;
	for (i = 0; i < DEF_MAXEFFECTSPR; i++) m_pEffectSpr[i] = NULL;
	m_pBGM = NULL;
	for (i = 0; i < DEF_MAXSOUNDEFFECTS; i++)
	{	m_pCSound[i]  = NULL;
		m_pESound[i]  = NULL;
		m_pMSound[i]  = NULL;
	}

	for (i = 0; i < DEF_MAXCHATMSGS; i++) m_pChatMsgList[i] = NULL;

	for (i = 0; i < DEF_MAXEFFECTS; i++) m_pEffectList[i] = NULL;

	for (i = 0; i < DEF_MAXITEMS; i++) m_pItemList[i] = NULL;

	for (i = 0; i < DEF_MAXBANKITEMS; i++) m_pBankList[i] = NULL;

	for (i = 0; i < 4; i++) m_pCharList[i] = NULL;
	// Snoopy: Fixed here
	for (i = 0; i < 61; i++) m_cDialogBoxOrder[i] = NULL;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) m_pMagicCfgList[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++) m_pSkillCfgList[i] = NULL;

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		m_pMsgTextList[i] = NULL;
		m_pMsgTextList2[i] = NULL;
		m_pAgreeMsgTextList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pBuildItemList[i] = NULL;

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pDispBuildItemList[i] = NULL;

	// Crafting:
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pCraftItemList[i] = NULL;
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pDispCraftItemList[i] = NULL;
	


	for (i = 0; i < DEF_MAXGAMEMSGS; i++) m_pGameMsgList[i] = NULL;

	m_pExID = NULL;

	for (i = 0; i < DEF_MAXITEMNAMES; i++) m_pItemNameList[i] = NULL;

	m_stMCursor.cPrevStatus       = DEF_CURSORSTATUS_NULL;
	m_stMCursor.dwSelectClickTime = NULL;

	ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
	m_iGameServerMode = 2; // Snoopy: Default is INTERNET

	for (i = 0; i < DEF_MAXMENUITEMS; i++)
		m_pItemForSaleList[i] = NULL;

	// CLEROTh - INIT DIALOG BOXES

	//Character-Info Dialog(F5)
	m_stDialogBoxInfo[1].sX = 30;
	m_stDialogBoxInfo[1].sY = 30;
	m_stDialogBoxInfo[1].sSizeX = 270;
	m_stDialogBoxInfo[1].sSizeY = 376;

	//Inventory Dialog(F6)
	m_stDialogBoxInfo[2].sX = 380;
	m_stDialogBoxInfo[2].sY = 210;
	m_stDialogBoxInfo[2].sSizeX = 225;
	m_stDialogBoxInfo[2].sSizeY = 185;

	//Magic Circle Dialog(F7)
	m_stDialogBoxInfo[3].sX = 337;
	m_stDialogBoxInfo[3].sY = 57;
	m_stDialogBoxInfo[3].sSizeX = 258;//280;
	m_stDialogBoxInfo[3].sSizeY = 328;//346;

	// Item drop confirmation
	m_stDialogBoxInfo[4].sX = 0;
	m_stDialogBoxInfo[4].sY = 0;
	m_stDialogBoxInfo[4].sSizeX = 270;
	m_stDialogBoxInfo[4].sSizeY = 105;

	// Age <15 box !?!?!?
	m_stDialogBoxInfo[5].sX = 0;
	m_stDialogBoxInfo[5].sY = 0;
	m_stDialogBoxInfo[5].sSizeX = 310;
	m_stDialogBoxInfo[5].sSizeY = 170;

	// ** This is a battle area **
	m_stDialogBoxInfo[6].sX = 0;
	m_stDialogBoxInfo[6].sY = 0;
	m_stDialogBoxInfo[6].sSizeX = 310;
	m_stDialogBoxInfo[6].sSizeY = 170;

	//Guild Menu Dialog
	m_stDialogBoxInfo[7].sX = 337;
	m_stDialogBoxInfo[7].sY = 57;
	m_stDialogBoxInfo[7].sSizeX = 258;
	m_stDialogBoxInfo[7].sSizeY = 339;

	//Guild Operation Dialog
	m_stDialogBoxInfo[8].sX = 337;
	m_stDialogBoxInfo[8].sY = 57;
	m_stDialogBoxInfo[8].sSizeX = 295;
	m_stDialogBoxInfo[8].sSizeY = 346;

	//Guide Map Dialog
	m_stDialogBoxInfo[9].sX = 512;
	m_stDialogBoxInfo[9].sY = 0;
	m_stDialogBoxInfo[9].sSizeX = 128;
	m_stDialogBoxInfo[9].sSizeY = 128;

	//Chatting History Dialog(F9)
	m_stDialogBoxInfo[10].sX = 135;
	m_stDialogBoxInfo[10].sY = 273;
	m_stDialogBoxInfo[10].sSizeX = 364;
	m_stDialogBoxInfo[10].sSizeY = 162;

	//Sale Menu Dialog
	m_stDialogBoxInfo[11].sX = 70;
	m_stDialogBoxInfo[11].sY = 50;
	m_stDialogBoxInfo[11].sSizeX = 258;
	m_stDialogBoxInfo[11].sSizeY = 339;

	//Level-Up Setting Dialog
	m_stDialogBoxInfo[12].sX = 0;
	m_stDialogBoxInfo[12].sY = 0;
	m_stDialogBoxInfo[12].sSizeX = 258;
	m_stDialogBoxInfo[12].sSizeY = 339;

	//City Hall Menu Dialog
	m_stDialogBoxInfo[13].sX = 337;
	m_stDialogBoxInfo[13].sY = 57;
	m_stDialogBoxInfo[13].sSizeX = 258;
	m_stDialogBoxInfo[13].sSizeY = 339;

	//Bank Dialog
	m_stDialogBoxInfo[14].sX = 60; //337
	m_stDialogBoxInfo[14].sY = 50;
	m_stDialogBoxInfo[14].sSizeX = 258;
	m_stDialogBoxInfo[14].sSizeY = 339;
	m_stDialogBoxInfo[14].sV1 = 13;

	//Skill Menu(F8)
	m_stDialogBoxInfo[15].sX = 337;
	m_stDialogBoxInfo[15].sY = 57;
	m_stDialogBoxInfo[15].sSizeX = 258;
	m_stDialogBoxInfo[15].sSizeY = 339;

	//Magic Shop Menu
	m_stDialogBoxInfo[16].sX = 30;
	m_stDialogBoxInfo[16].sY = 30;
	m_stDialogBoxInfo[16].sSizeX = 304;
	m_stDialogBoxInfo[16].sSizeY = 328;

	//Dialog items drop external screen
	m_stDialogBoxInfo[17].sX = 0;
	m_stDialogBoxInfo[17].sY = 0;
	m_stDialogBoxInfo[17].sSizeX = 215;
	m_stDialogBoxInfo[17].sSizeY = 87;

	//Text Dialog
	m_stDialogBoxInfo[18].sX = 20;
	m_stDialogBoxInfo[18].sY = 65;
	m_stDialogBoxInfo[18].sSizeX = 258; // 238
	m_stDialogBoxInfo[18].sSizeY = 339; // 274

	//System Menu Dialog(F12)
	m_stDialogBoxInfo[19].sX = 337;
	m_stDialogBoxInfo[19].sY = 107;
	m_stDialogBoxInfo[19].sSizeX = 258;//270; //v2.18
	m_stDialogBoxInfo[19].sSizeY = 268;//346;

	//NpcActionQuery Dialog
	m_stDialogBoxInfo[20].sX = 237;
	m_stDialogBoxInfo[20].sY = 57;
	m_stDialogBoxInfo[20].sSizeX = 252;
	m_stDialogBoxInfo[20].sSizeY = 87;

	//NpcTalk Dialog
	m_stDialogBoxInfo[21].sX = 337;
	m_stDialogBoxInfo[21].sY = 57;
	m_stDialogBoxInfo[21].sSizeX = 258;
	m_stDialogBoxInfo[21].sSizeY = 339;

	//Map
	m_stDialogBoxInfo[22].sX = 336;
	m_stDialogBoxInfo[22].sY = 88;
	m_stDialogBoxInfo[22].sSizeX = 270;
	m_stDialogBoxInfo[22].sSizeY = 346;

	//ItemSellorRepair Dialog
	m_stDialogBoxInfo[23].sX = 337;
	m_stDialogBoxInfo[23].sY = 57;
	m_stDialogBoxInfo[23].sSizeX = 258;
	m_stDialogBoxInfo[23].sSizeY = 339;

	//Fishing Dialog
	m_stDialogBoxInfo[24].sX = 193;
	m_stDialogBoxInfo[24].sY = 241;
	m_stDialogBoxInfo[24].sSizeX = 263;
	m_stDialogBoxInfo[24].sSizeY = 100;

	//Noticement Dialog
	m_stDialogBoxInfo[25].sX = 162;
	m_stDialogBoxInfo[25].sY = 40;
	m_stDialogBoxInfo[25].sSizeX = 315;
	m_stDialogBoxInfo[25].sSizeY = 171;

	//Manufacture Dialog
	m_stDialogBoxInfo[26].sX = 100;
	m_stDialogBoxInfo[26].sY = 60;
	m_stDialogBoxInfo[26].sSizeX = 258;
	m_stDialogBoxInfo[26].sSizeY = 339;

	//Exchange Dialog
	m_stDialogBoxInfo[27].sX = 100;
	m_stDialogBoxInfo[27].sY = 30;
	m_stDialogBoxInfo[27].sSizeX = 520;
	m_stDialogBoxInfo[27].sSizeY = 357;

	//Quest Dialog
	m_stDialogBoxInfo[28].sX = 0;
	m_stDialogBoxInfo[28].sY = 0;
	m_stDialogBoxInfo[28].sSizeX = 258;
	m_stDialogBoxInfo[28].sSizeY = 339;

	//Gauge Pannel
	m_stDialogBoxInfo[29].sX = 0;
	m_stDialogBoxInfo[29].sY = 434;
	m_stDialogBoxInfo[29].sSizeX = 157;
	m_stDialogBoxInfo[29].sSizeY = 53;

	//Icon Pannel
	m_stDialogBoxInfo[30].sX = 0;
	m_stDialogBoxInfo[30].sY = 427;
	m_stDialogBoxInfo[30].sSizeX = 640;
	m_stDialogBoxInfo[30].sSizeY = 53;//47;

	//Sell List Dialog
	m_stDialogBoxInfo[31].sX = 170;
	m_stDialogBoxInfo[31].sY = 70;
	m_stDialogBoxInfo[31].sSizeX = 258;
	m_stDialogBoxInfo[31].sSizeY = 339;

	//Party Dialog
	m_stDialogBoxInfo[32].sX = 0;
	m_stDialogBoxInfo[32].sY = 0;
	m_stDialogBoxInfo[32].sSizeX = 258;
	m_stDialogBoxInfo[32].sSizeY = 339;

	//Crusade Job Dialog
	m_stDialogBoxInfo[33].sX = 360;
	m_stDialogBoxInfo[33].sY = 65;
	m_stDialogBoxInfo[33].sSizeX = 258;
	m_stDialogBoxInfo[33].sSizeY = 339;

	//Item Upgrade Dialog
	m_stDialogBoxInfo[34].sX = 60;
	m_stDialogBoxInfo[34].sY = 50;
	m_stDialogBoxInfo[34].sSizeX = 258;
	m_stDialogBoxInfo[34].sSizeY = 339;

	//Help Menu Dialog(F1)
	m_stDialogBoxInfo[35].sX = 358;
	m_stDialogBoxInfo[35].sY = 65;
	m_stDialogBoxInfo[35].sSizeX = 258;
	m_stDialogBoxInfo[35].sSizeY = 339;

	//Crusade Commander Dialog
	m_stDialogBoxInfo[36].sX = 20;
	m_stDialogBoxInfo[36].sY = 20;
	m_stDialogBoxInfo[36].sSizeX = 310;
	m_stDialogBoxInfo[36].sSizeY = 386;

	//Crusade Constructor Dialog
	m_stDialogBoxInfo[37].sX = 20;
	m_stDialogBoxInfo[37].sY = 20;
	m_stDialogBoxInfo[37].sSizeX = 310;
	m_stDialogBoxInfo[37].sSizeY = 386;

	//Crusade Soldier Dialog
	m_stDialogBoxInfo[38].sX = 20;
	m_stDialogBoxInfo[38].sY = 20;
	m_stDialogBoxInfo[38].sSizeX = 310;
	m_stDialogBoxInfo[38].sSizeY = 386;

	// Give item ???
	m_stDialogBoxInfo[39].sX = 0;
	m_stDialogBoxInfo[39].sY = 0;
	m_stDialogBoxInfo[39].sSizeX = 291;
	m_stDialogBoxInfo[39].sSizeY = 413;

	// 3.51 Slates Dialog - Diuuude
	m_stDialogBoxInfo[40].sX = 100;
	m_stDialogBoxInfo[40].sY = 60;
	m_stDialogBoxInfo[40].sSizeX = 258;
	m_stDialogBoxInfo[40].sSizeY = 339;

	// Snoopy: Item exchange confirmation
	m_stDialogBoxInfo[41].sX = 285;
	m_stDialogBoxInfo[41].sY = 200;
	m_stDialogBoxInfo[41].sSizeX = 270;
	m_stDialogBoxInfo[41].sSizeY = 105;

	// MJ Stats Change DialogBox - Diuuude
	m_stDialogBoxInfo[42].sX = 0;
	m_stDialogBoxInfo[42].sY = 0;
	m_stDialogBoxInfo[42].sSizeX = 258;
	m_stDialogBoxInfo[42].sSizeY = 339;

	// Snoopy: Resurection
	m_stDialogBoxInfo[50].sX = 185;
	m_stDialogBoxInfo[50].sY = 100;
	m_stDialogBoxInfo[50].sSizeX = 270;
	m_stDialogBoxInfo[50].sSizeY = 105;

	//Guild Hall Menu Dialog
	m_stDialogBoxInfo[51].sX = 337;
	m_stDialogBoxInfo[51].sY = 57;
	m_stDialogBoxInfo[51].sSizeX = 258;
	m_stDialogBoxInfo[51].sSizeY = 339;

	m_bCtrlPressed  = FALSE;
	m_bShiftPressed = FALSE;
	m_bVK_OEM_7Pressed = FALSE;
	m_bEnterPressed = FALSE;
	m_bEscPressed	= FALSE;
	m_bSoundFlag = FALSE;
	m_dwDialogCloseTime = 0;
	m_iTimeLeftSecAccount = NULL;
	m_iTimeLeftSecIP      = NULL;
	m_bWhisper = TRUE;
	m_bShout   = TRUE;
}

CGame::~CGame()
{}

BOOL CGame::bInit(HWND hWnd, HINSTANCE hInst, char * pCmdLine)
{int iIndex;
 int i;
 class CStrTok * pStrTok;
 char seps[] = "&= ,\t\n";
 char * token;
 // CLEROTH - BUG
	for (i = 0; i < DEF_MAXSPRITES; i++)
		m_pSprite[i] = NULL;
	if (pCmdLine != NULL)
	{	ZeroMemory(G_cCmdLine, sizeof(G_cCmdLine));
		ZeroMemory(G_cCmdLineTokenA, sizeof(G_cCmdLineTokenA));
		ZeroMemory(G_cCmdLineTokenB, sizeof(G_cCmdLineTokenB));
		ZeroMemory(G_cCmdLineTokenC, sizeof(G_cCmdLineTokenC));
		ZeroMemory(G_cCmdLineTokenD, sizeof(G_cCmdLineTokenD));
		ZeroMemory(G_cCmdLineTokenE, sizeof(G_cCmdLineTokenE));

		strcpy(G_cCmdLine, pCmdLine);

		iIndex = 0;
		pStrTok = new class CStrTok(pCmdLine, seps);
		token = pStrTok->pGet();
		while( token != NULL )
		{	switch (iIndex) {
			case 0:	strcpy(G_cCmdLineTokenA, token); break;
			case 1: strcpy(G_cCmdLineTokenB, token); break;
			case 2: strcpy(G_cCmdLineTokenC, token); break;
			case 3: strcpy(G_cCmdLineTokenD, token); break;
			case 4: strcpy(G_cCmdLineTokenE, token); break;
			}
			token = pStrTok->pGet();
			iIndex++;
		}
		delete pStrTok;
	}

	ZeroMemory(G_cCmdLineTokenA_Lowercase, sizeof(G_cCmdLineTokenA_Lowercase));
	strcpy(G_cCmdLineTokenA_Lowercase, G_cCmdLineTokenA);
	_strlwr(G_cCmdLineTokenA_Lowercase);

	if (memcmp(G_cCmdLineTokenA_Lowercase, "/egparam", 8) == 0)
	{	ZeroMemory(G_cCmdLineTokenA, sizeof(G_cCmdLineTokenA));
		memcpy(G_cCmdLineTokenA,"dataq",5);
	}
	m_hWnd = hWnd;
	m_bCommandAvailable = TRUE;
	m_pCGameMonitor = NULL;
	m_dwTime = G_dwGlobalTime;
	m_bSoundFlag = m_DSound.Create(m_hWnd);
	m_bMusicStat = m_bSoundStat = m_bSoundFlag;
	m_bIsHideLocalCursor = FALSE;
	m_cEnterCheck = m_cTabCheck = m_cLeftArrowCheck = NULL;

	if (bCheckImportantFile() == FALSE)
	{	MessageBox(m_hWnd, "File checksum error! Get Update again please!", "ERROR1", MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}

	if (_bDecodeBuildItemContents() == FALSE)
	{	MessageBox(m_hWnd, "File checksum error! Get Update again please!","ERROR2",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}

	if(bReadLoginConfigFile("login.cfg") == FALSE)
	{	MessageBox(m_hWnd, "login.cfg file contains wrong infomation.","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}

	if(bReadItemNameConfigFile() == FALSE)
	{	MessageBox(m_hWnd, "ItemName.cfg file contains wrong infomation.","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}

	if (bInitMagicCfgList() == FALSE) {
		MessageBox(m_hWnd, "MAGICCFG.TXT file contains wrong infomation.","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}
	// Skill
	if (bInitSkillCfgList() == FALSE)
	{	MessageBox(m_hWnd, "SKILLCFG.TXT file contains wrong infomation.","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}

	if (m_DDraw.bInit(m_hWnd) == FALSE)
	{	MessageBox(m_hWnd, "This program requires DirectX7.0a!","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}

	if (m_DInput.bInit(hWnd, hInst) == FALSE) {
		MessageBox(m_hWnd, "This program requires DirectX7.0a!","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}


	m_hPakFile = CreateFile("sprites\\New-Dialog.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] = new class CSprite(m_hPakFile, &m_DDraw, "New-Dialog", 0, FALSE);
	CloseHandle(m_hPakFile);

	m_hPakFile = CreateFile("sprites\\interface2.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE] = new class CSprite(m_hPakFile, &m_DDraw, "interface2", 0, FALSE);
	m_pSprite[DEF_SPRID_INTERFACE_CRAFTING] = new class CSprite(m_hPakFile, &m_DDraw, "interface2", 3, FALSE);
	CloseHandle(m_hPakFile);

	// CLEROTH - LOAD FONTS BEFORE MAIN LOADING
	m_hPakFile = CreateFile("sprites\\interface2.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if( m_hPakFile != INVALID_HANDLE_VALUE )
	{	m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2] = new class CSprite(m_hPakFile, &m_DDraw, "interface2", 1, FALSE);
		m_pSprite[DEF_SPRID_INTERFACE_F1HELPWINDOWS] = new class CSprite(m_hPakFile, &m_DDraw, "interface2", 2, FALSE);
		CloseHandle(m_hPakFile);
	}

	m_hPakFile = CreateFile("sprites\\sprfonts.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if( m_hPakFile != INVALID_HANDLE_VALUE )
	{	m_pSprite[DEF_SPRID_INTERFACE_FONT1] = new class CSprite(m_hPakFile, &m_DDraw, "sprfonts", 0, FALSE);
		m_pSprite[DEF_SPRID_INTERFACE_FONT2] = new class CSprite(m_hPakFile, &m_DDraw, "sprfonts", 1, FALSE);
		CloseHandle(m_hPakFile);
	}

	m_stMCursor.sX = 0;
	m_stMCursor.sY = 0;
	m_pMapData = new class CMapData(this);
	ZeroMemory(m_cPlayerName, sizeof(m_cPlayerName));
	ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
	ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));

	m_sPlayerType = 2;
	m_cPlayerTurn = 0;
// Snoopy: fixed here
	m_cDialogBoxOrder[60] = 29;
	m_cDialogBoxOrder[59] = 30; // 29¹ø GaugePannel

	m_cMenuDir    = 4;
	m_cMenuDirCnt = 0;
	m_cMenuFrame  = 0;

	m_cSoundVolume = 100;
	m_cMusicVolume = 100;

#ifdef DEF_EQUILIBRIUM_PROJECT // couleurs
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  80,  70,  70), &m_wWR[1], &m_wWG[1], &m_wWB[1]); // Light-blue Special agile
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  70,  70,  80), &m_wWR[2], &m_wWG[2], &m_wWB[2]); // light-blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  70,  70,  80), &m_wWR[3], &m_wWG[3], &m_wWB[3]); // light-blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  70, 100,  70), &m_wWR[4], &m_wWG[4], &m_wWB[4]); // Green
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 130,  90,  10), &m_wWR[5], &m_wWG[5], &m_wWB[5]); // Critical
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  42,  53, 111), &m_wWR[6], &m_wWG[6], &m_wWB[6]); // Heavy-blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 145, 145, 145), &m_wWR[7], &m_wWG[7], &m_wWB[7]); // White
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 120, 100, 120), &m_wWR[8], &m_wWG[8], &m_wWB[8]); // Violet
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  75,  10,  10), &m_wWR[9], &m_wWG[9], &m_wWB[9]); // Heavy-Red
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(   0,   0,   0), &m_wWR[10],&m_wWG[10], &m_wWB[10]); // Noir 
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(   0,   0,  30), &m_wWR[11],&m_wWG[11], &m_wWB[11]); // Knight (noir bleuté)
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(   0,   0,   0), &m_wWR[12],&m_wWG[12], &m_wWB[12]); // Noir  <-> rouge (StormBringer)
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 145, 145, 145), &m_wWR[13],&m_wWG[13], &m_wWB[13]); // Blanc <-> Jaune
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  70,  70,  70), &m_wWR[14],&m_wWG[14], &m_wWB[14]); // Bleu  <-> rouge
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 135, 104,  30), &m_wWR[15],&m_wWG[15], &m_wWB[15]); // Golden special weapon


	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 200/2,  200/2,  200/2),  &m_wR[0], &m_wG[0], &m_wB[0]);
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x50/2, 0x50/2, 0xC0/2),  &m_wR[1], &m_wG[1], &m_wB[1]); // Indigo Blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(    79,     79,     62),  &m_wR[2], &m_wG[2], &m_wB[2]); // Custom-Weapon Color
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(   135,    104,     30),  &m_wR[3], &m_wG[3], &m_wB[3]); // Gold
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 255/2,   36/2,      0),  &m_wR[4], &m_wG[4], &m_wB[4]); // Crimson
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(    10,     60,     10),  &m_wR[5], &m_wG[5], &m_wB[5]); // Green
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x50/2, 0x50/2, 0x50/2),  &m_wR[6], &m_wG[6], &m_wB[6]); // Gray
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x5F/2, 0x9E/2, 0xA0/2),  &m_wR[7], &m_wG[7], &m_wB[7]); // Aqua
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0xFF/2, 0x69/2, 0xB4/2),  &m_wR[8], &m_wG[8], &m_wB[8]); // Pink
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(    90,     60,     90),  &m_wR[9], &m_wG[9], &m_wB[9]); // Violet

	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(     0,     35,     60),  &m_wR[10], &m_wG[10], &m_wB[10]); // Blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0xD2/2, 0xB4/2, 0x8C/2),  &m_wR[11], &m_wG[11], &m_wB[11]); // Tan
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0xBD/2, 0xB7/2, 0x6B/2),  &m_wR[12], &m_wG[12], &m_wB[12]); // Khaki
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(    85,     85,      8),  &m_wR[13], &m_wG[13], &m_wB[13]); // Yellow
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(    75,      8,      8),  &m_wR[14], &m_wG[14], &m_wB[14]); // Red
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(     8,      8,      8),  &m_wR[15], &m_wG[15], &m_wB[15]); // Black

#else
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  70,  70,  80), &m_wWR[1], &m_wWG[1], &m_wWB[1]); // Light-blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  70,  70,  80), &m_wWR[2], &m_wWG[2], &m_wWB[2]); // light-blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  70,  70,  80), &m_wWR[3], &m_wWG[3], &m_wWB[3]); // light-blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  70, 100,  70), &m_wWR[4], &m_wWG[4], &m_wWB[4]); // Green
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 130,  90,  10), &m_wWR[5], &m_wWG[5], &m_wWB[5]); // Critical
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  42,  53, 111), &m_wWR[6], &m_wWG[6], &m_wWB[6]); // Heavy-blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 145, 145, 145), &m_wWR[7], &m_wWG[7], &m_wWB[7]); // White
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 120, 100, 120), &m_wWR[8], &m_wWG[8], &m_wWB[8]); // Violet
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  75,  10,  10), &m_wWR[9], &m_wWG[9], &m_wWB[9]); // Heavy-Red
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 135, 104,  30), &m_wR[10], &m_wG[10], &m_wB[10]);	// Gold, buggy

	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 200/2,  200/2,  200/2),  &m_wR[0], &m_wG[0], &m_wB[0]);
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x50/2, 0x50/2, 0xC0/2),  &m_wR[1], &m_wG[1], &m_wB[1]); // Indigo Blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(    79,     79,     62),  &m_wR[2], &m_wG[2], &m_wB[2]); // Custom-Weapon Color
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(   135,    104,     30),  &m_wR[3], &m_wG[3], &m_wB[3]); // Gold
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB( 255/2,   36/2,      0),  &m_wR[4], &m_wG[4], &m_wB[4]); // Crimson
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(    10,     60,     10),  &m_wR[5], &m_wG[5], &m_wB[5]); // Green
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x50/2, 0x50/2, 0x50/2),  &m_wR[6], &m_wG[6], &m_wB[6]); // Gray
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0x5F/2, 0x9E/2, 0xA0/2),  &m_wR[7], &m_wG[7], &m_wB[7]); // Aqua
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0xFF/2, 0x69/2, 0xB4/2),  &m_wR[8], &m_wG[8], &m_wB[8]); // Pink
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(    90,     60,     90),  &m_wR[9], &m_wG[9], &m_wB[9]); // Violet

	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(     0,     35,     60),  &m_wR[10], &m_wG[10], &m_wB[10]); // Blue
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0xD2/2, 0xB4/2, 0x8C/2),  &m_wR[11], &m_wG[11], &m_wB[11]); // Tan
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0xBD/2, 0xB7/2, 0x6B/2),  &m_wR[12], &m_wG[12], &m_wB[12]); // Khaki
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(    85,     85,      8),  &m_wR[13], &m_wG[13], &m_wB[13]); // Yellow
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(    75,     10,     10),  &m_wR[14], &m_wG[14], &m_wB[14]); // Red
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(  0x30,   0x30,   0x30),  &m_wR[15], &m_wG[15], &m_wB[15]); // Black

#endif

#ifndef DEF_EQUILIBRIUM_PROJECT // badword
#ifndef _DEBUG
	m_pCGameMonitor = new class CGameMonitor;
	//===============================================
	// badword.txt
	if(!m_Misc._iConvertFileXor("contents\\badword.txt", "contents\\badword.tmp", 35))
	{	MessageBox(m_hWnd, "BADWORD.TXT file contains wrong infomation.","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}
	m_pCGameMonitor->iReadBadWordFileList("contents\\badword.tmp");
	DeleteFile("contents\\badword.tmp");

	if(!m_Misc._iConvertFileXor("contents\\Curse.txt", "contents\\Curse.tmp", 35))
	{	MessageBox(m_hWnd, "CURSE.TXT file contains wrong infomation.","ERROR",MB_ICONEXCLAMATION | MB_OK);
		return FALSE;
	}
	m_curse.LoadCurse( "contents\\Curse.tmp" );
	DeleteFile("contents\\Curse.tmp");
	//==============================================
#endif
#endif

	_LoadGameMsgTextContents();
	ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));

	return TRUE;
}

void CGame::Quit()
{int i;
	WriteSettings();
	ChangeGameMode(DEF_GAMEMODE_NULL);

	for (i = 0; i < DEF_MAXSPRITES; i++)
	if (m_pSprite[i] != NULL) delete m_pSprite[i];
	for (i = 0; i < DEF_MAXTILES; i++)
	if (m_pTileSpr[i] != NULL) delete m_pTileSpr[i];
	for (i = 0; i < DEF_MAXEFFECTSPR; i++)
	if (m_pEffectSpr[i] != NULL) delete m_pEffectSpr[i];

	for (i = 0; i < DEF_MAXSOUNDEFFECTS; i++) {
		if (m_pCSound[i] != NULL) delete m_pCSound[i];
		if (m_pMSound[i] != NULL) delete m_pMSound[i];
		if (m_pESound[i] != NULL) delete m_pESound[i];
	}

	if (m_pBGM != NULL) delete m_pBGM;

	for (i = 0; i < 4; i++)
	if (m_pCharList[i] != NULL) delete m_pCharList[i];

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] != NULL)	delete m_pItemList[i];

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pBankList[i] != NULL)	delete m_pBankList[i];

	for (i = 0; i < DEF_MAXEFFECTS; i++)
	if (m_pEffectList[i] != NULL) delete m_pEffectList[i];

	for (i = 0; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] != NULL) delete m_pChatMsgList[i];

	for (i = 0; i < DEF_MAXCHATSCROLLMSGS; i++)
		if (m_pChatScrollList[i] != NULL) delete m_pChatScrollList[i];

	for (i = 0; i < DEF_MAXWHISPERMSG; i++)
		if (m_pWhisperMsg[i] != NULL) delete m_pWhisperMsg[i];

	for (i = 0; i < DEF_MAXMENUITEMS; i++)
		if (m_pItemForSaleList[i] != NULL) delete m_pItemForSaleList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicCfgList[i] != NULL) delete m_pMagicCfgList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillCfgList[i] != NULL) delete m_pSkillCfgList[i];

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pMsgTextList[i] != NULL)  delete m_pMsgTextList[i];
		if (m_pMsgTextList2[i] != NULL) delete m_pMsgTextList2[i];
		if (m_pAgreeMsgTextList[i] != NULL) delete m_pAgreeMsgTextList[i];
	}

	if (m_pExID != NULL) delete m_pExID;

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pDispBuildItemList[i] != NULL) delete m_pDispBuildItemList[i];

	// Crafting:
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		if (m_pCraftItemList[i] != NULL) delete m_pCraftItemList[i];
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		if (m_pDispCraftItemList[i] != NULL) delete m_pDispCraftItemList[i];


	for (i = 0; i < DEF_MAXGAMEMSGS; i++)
		if (m_pGameMsgList[i] != NULL) delete m_pGameMsgList[i];

	for (i = 0; i < DEF_MAXITEMNAMES; i++)
		if (m_pItemNameList[i] != NULL) delete m_pItemNameList[i];

	delete m_pMapData;

	if (m_pGSock != NULL) delete m_pGSock;
	if (m_pLSock != NULL) delete m_pLSock;
	if (G_pCalcSocket != NULL) delete G_pCalcSocket;
	if (m_pCGameMonitor != NULL) delete m_pCGameMonitor;
}


void CGame::UpdateScreen()
{ 	G_dwGlobalTime = timeGetTime();
	if (m_cGameMode != DEF_GAMEMODE_ONMAINGAME)	StopBGM(); // MP3
	switch (m_cGameMode) {
#ifdef DEF_MAKE_ACCOUNT
	case DEF_GAMEMODE_ONAGREEMENT:
		// UpdateScreen_OnAgreement(); //unused by HBx server..
		break;

	case DEF_GAMEMODE_ONCREATENEWACCOUNT:
		UpdateScreen_OnCreateNewAccount();
		break;
#endif

	case DEF_GAMEMODE_ONVERSIONNOTMATCH:
		UpdateScreen_OnVersionNotMatch();
		break;

	case DEF_GAMEMODE_ONCONNECTING:
		UpdateScreen_OnConnecting();
		break;

	case DEF_GAMEMODE_ONMAINMENU:
		UpdateScreen_OnMainMenu();
		break;

	case DEF_GAMEMODE_ONLOADING:
		UpdateScreen_OnLoading(TRUE);
		break;

	case DEF_GAMEMODE_ONMAINGAME:
		UpdateScreen_OnGame();
		break;

	case DEF_GAMEMODE_ONWAITINGINITDATA:
		UpdateScreen_OnWaitInitData();
		break;

	case DEF_GAMEMODE_ONCONNECTIONLOST:
		UpdateScreen_OnConnectionLost();
		break;

	case DEF_GAMEMODE_ONMSG:
		UpdateScreen_OnMsg();
		break;

	case DEF_GAMEMODE_ONLOGIN:
		UpdateScreen_OnLogin();
		break;

	case DEF_GAMEMODE_ONSELECTSERVER:
		UpdateScreen_OnSelectServer();
		break;

	case DEF_GAMEMODE_ONQUIT:
		UpdateScreen_OnQuit();
		break;

	case DEF_GAMEMODE_ONQUERYFORCELOGIN:
		UpdateScreen_OnQueryForceLogin();
		break;

	case DEF_GAMEMODE_ONSELECTCHARACTER:
		UpdateScreen_OnSelectCharacter();
		break;

	case DEF_GAMEMODE_ONCREATENEWCHARACTER:
		UpdateScreen_OnCreateNewCharacter();
		break;

	case DEF_GAMEMODE_ONWAITINGRESPONSE:
		UpdateScreen_OnWaitingResponse();
		break;

	case DEF_GAMEMODE_ONQUERYDELETECHARACTER:
		UpdateScreen_OnQueryDeleteCharacter();
		break;

	case DEF_GAMEMODE_ONLOGRESMSG:
		UpdateScreen_OnLogResMsg();
		break;

	case DEF_GAMEMODE_ONCHANGEPASSWORD:
		UpdateScreen_OnChangePassword();
		break;
	}

#ifdef DEF_USING_WIN_IME

	if (GetAsyncKeyState(VK_RETURN) != NULL) m_cEnterCheck = 1;
	if ((m_cEnterCheck == 1) && (GetAsyncKeyState(VK_RETURN) == NULL))
	{	m_bEnterPressed = TRUE;
		m_cEnterCheck = NULL;
	}
	if (GetAsyncKeyState(VK_TAB) != NULL) m_cTabCheck = 1;
 	if ((m_cTabCheck == 1) && (GetAsyncKeyState(VK_TAB) == NULL))
	{	m_cCurFocus++;
		if( m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME) bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLECOMBATMODE, NULL, NULL, NULL, NULL, NULL);
		m_cTabCheck = NULL;
	}
	if( m_bInputStatus )
	{	if (GetAsyncKeyState(VK_LEFT) != NULL) m_cLeftArrowCheck = 1;
		if ((m_cLeftArrowCheck == 1) && (GetAsyncKeyState(VK_LEFT) == NULL))
		{	m_cLeftArrowCheck = NULL;
			if( G_hEditWnd != NULL )
			{	int iStrLen = strlen(m_pInputBuffer);
				SendMessage( G_hEditWnd, EM_SETSEL, iStrLen, iStrLen );
	}	}	}
#endif
}


void CGame::CalcViewPoint()
{ short dX, dY;
	dX = m_sViewPointX - m_sViewDstX;
	dY = m_sViewPointY - m_sViewDstY;
	if (abs(dX) < abs(m_sViewDX))
	{	m_sViewPointX = m_sViewDstX;
		m_sViewDX = 0;
	}else
	{	if (dX > 0) m_sViewDX--;
		if (dX < 0) m_sViewDX++;
		if (dX == 0) m_sViewDX = 0;
		if (abs(dX) < 40) {
			if (m_sViewDX > 4)  m_sViewDX = 4;
			else if (m_sViewDX < -4) m_sViewDX = -4;
		}
		m_sViewPointX += m_sViewDX;
	}

	if (abs(dY) < abs(m_sViewDY))
	{	m_sViewPointY = m_sViewDstY;
		m_sViewDY = 0;
	}else
	{	if (dY > 0) m_sViewDY--;
		if (dY < 0) m_sViewDY++;
		if (dY == 0) m_sViewDY = 0;
		if (abs(dY) < 40) {
			if (m_sViewDY > 4)  m_sViewDY = 4;
			else if (m_sViewDY < -4) m_sViewDY = -4;
		}
		m_sViewPointY += m_sViewDY;
	}
}

void CGame::OnGameSocketEvent(WPARAM wParam, LPARAM lParam)
{int iRet;
 char * pData;
 DWORD  dwMsgSize;

	if (m_pGSock == NULL) return;

	iRet = m_pGSock->iOnSocketEvent(wParam, lParam);
	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		ConnectionEstablishHandler(DEF_SERVERTYPE_GAME);
		break;

	case DEF_XSOCKEVENT_READCOMPLETE:
		pData = m_pGSock->pGetRcvDataPointer(&dwMsgSize);
		GameRecvMsgHandler(dwMsgSize, pData);
		m_dwTime = G_dwGlobalTime;
		break;

	case DEF_XSOCKEVENT_SOCKETCLOSED:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		delete m_pGSock;
		m_pGSock = NULL;
		break;

	case DEF_XSOCKEVENT_SOCKETERROR:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		delete m_pGSock;
		m_pGSock = NULL;
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		delete m_pGSock;
		m_pGSock = NULL;
		if (G_pCalcSocket != NULL)
		{	delete G_pCalcSocket;
			G_pCalcSocket = NULL;
		}
		break;
	}
}

void CGame::RestoreSprites()
{
	for (int i = 0; i < DEF_MAXSPRITES; i++)
	if (m_pSprite[i] != NULL) m_pSprite[i]->iRestore();
}

char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };
char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, BOOL bMoveCheck, BOOL bMIM)
{
 char  cDir, cTmpDir;
 //int   aX, aY, aX2, aY2, dX, dY;
 int   aX, aY, dX, dY;
 int   i;
	if ((sX == dstX) && (sY == dstY)) return 0;
	dX = sX;
	dY = sY;
	if (bMIM == FALSE) // MIM Fix
		 cDir = m_Misc.cGetNextMoveDir(dX, dY, dstX, dstY);
	else cDir = m_Misc.cGetNextMoveDir(dstX, dstY, dX, dY);

	if (m_cPlayerTurn == 0)
	for (i = cDir; i <= cDir + 2;i++)
	{	cTmpDir = i;
		if (cTmpDir > 8) cTmpDir -= 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (((dX + aX) == m_iPrevMoveX) && ((dY + aY) == m_iPrevMoveY) && (m_bIsPrevMoveBlocked == TRUE) && (bMoveCheck == TRUE))
		{	m_bIsPrevMoveBlocked = FALSE;
		}else if (m_pMapData->bGetIsLocateable(dX + aX, dY + aY) == TRUE)
		{	if( m_pMapData->bIsTeleportLoc(dX + aX, dY + aY) == TRUE )
			{	if( _bCheckMoveable(dX + aX, dY + aY) == TRUE ) return cTmpDir;
				else
				{	SetTopMsg( DEF_MSG_GETNEXTMOVEDIR, 5 );
				}
			}else return cTmpDir;
	}	}

	if (m_cPlayerTurn == 1)
	for (i = cDir; i >= cDir - 2;i--)
	{	cTmpDir = i;
		if (cTmpDir < 1) cTmpDir += 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (((dX + aX) == m_iPrevMoveX) && ((dY + aY) == m_iPrevMoveY) && (m_bIsPrevMoveBlocked == TRUE) && (bMoveCheck == TRUE))
		{	m_bIsPrevMoveBlocked = FALSE;
		}else if (m_pMapData->bGetIsLocateable(dX + aX, dY + aY) == TRUE)
		{	if( m_pMapData->bIsTeleportLoc(dX + aX, dY + aY) == TRUE )
			{	if( _bCheckMoveable(dX + aX, dY + aY) == TRUE ) return cTmpDir;
				else
				{	SetTopMsg( DEF_MSG_GETNEXTMOVEDIR, 5 );
				}
			}else return cTmpDir;
	}	}
	return 0;
}

BOOL CGame::_bCheckMoveable( short sx, short sy )
{	// Snoopy: This function prevents the client from asking at TP from some maps to
	// ML or PL if not citizen
	// Incomplete function and useless (the server will handle such cases)
/*	if( m_bIsCrusadeMode ) return TRUE;
	if( m_bHunter == FALSE ) return TRUE;
	if( m_bCitizen == FALSE ) return TRUE;
	if( m_bAresden == TRUE && m_cMapIndex == 11 )
	{	if( sy == 20 )
		{	if( (sx>=39) && (sx<=47) ) return FALSE;
			if( (sx>=360) && (sx<=368) ) return FALSE;
		}
	}
	if( m_bAresden == FALSE && m_cMapIndex == 3 )
	{
		if( sy == 373 )
		{	if( (sx>=27) && (sx<=32) ) return FALSE;
		}
		if( sy == 374 )
		{	if( (sx>=298) && (sx<=305) ) return FALSE;
		}
	}*/
	return TRUE;
}

BOOL CGame::bSendCommand(DWORD dwMsgID, WORD wCommand, char cDir, int iV1, int iV2, int iV3, char * pString, int iV4)
{char  * cp, cMsg[300], cTxt[256], cKey;
 WORD  * wp;
 DWORD * dwp, dwTime;
 short * sp;
 int   * ip, iRet, i, * fightzonenum ;

	if ((m_pGSock == NULL) && (m_pLSock == NULL)) return FALSE;
	dwTime = timeGetTime();
	ZeroMemory(cMsg, sizeof(cMsg));

#ifdef DEF_ANTI_HACK
	cKey = (char)(rand() % 245) +1;
#else
	cKey = (char)(rand() % 255) +1;
#endif

	switch (dwMsgID) {

	case MSGID_REQUEST_ANGEL:	// to Game Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;
		cp = (char*)(cMsg + 6);
		memset( cp, 0, 20 );
		memcpy((char *)cp, pString, strlen(pString) + 1);
		cp += 20;
		ip = (int *)cp;
		*ip = iV1; // Angel ID
		iRet = m_pGSock->iSendMsg(cMsg, 30, cKey);
		break;

	case MSGID_REQUEST_RESURRECTPLAYER_YES: // By snoopy
	case MSGID_REQUEST_RESURRECTPLAYER_NO:  // By snoopy
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;
		iRet = m_pGSock->iSendMsg(cMsg, 6, cKey);
		break;

	case MSGID_REQUEST_HELDENIAN_SCROLL:// By snoopy
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;
		cp = (char*)(cMsg + 6);
		memset( cp, 0, 20 );
		memcpy((char *)cp, pString, strlen(pString) + 1);
		cp += 20;
		wp = (WORD *)cp;
		*wp = wCommand; // Item ID
		iRet = m_pGSock->iSendMsg(cMsg, 28, cKey);
		break;

	case MSGID_REQUEST_TELEPORT_LIST:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;
		cp = (char*)(cMsg + 6);
		memset( cp, 0, 20 );
		memcpy( cp, "William", 20 );
		iRet = m_pGSock->iSendMsg(cMsg, 26, cKey);
		break;

	case MSGID_REQUEST_HELDENIAN_TP_LIST: // Snoopy: Heldenian TP
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;
		cp = (char*)(cMsg + 6);
		memset( cp, 0, 20 );
		memcpy( cp, "Gail", 20 );
		iRet = m_pGSock->iSendMsg(cMsg, 26, cKey);
		break;

	case MSGID_REQUEST_HELDENIAN_TP: // Snoopy: Heldenian TP
	case MSGID_REQUEST_CHARGED_TELEPORT:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;
		ip  = (int *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		*ip = iV1;
		iRet = m_pGSock->iSendMsg(cMsg, 10, cKey);
		break;

	case MSGID_REQUEST_SELLITEMLIST:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;
		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		for (i = 0; i < DEF_MAXSELLLIST; i++)
		{	*cp = m_stSellItemList[i].iIndex;
			cp++;
			ip = (int *)cp;
			*ip = m_stSellItemList[i].iAmount;
			cp += 4;
		}

		iRet = m_pGSock->iSendMsg(cMsg, 70, cKey);
		break;

	case MSGID_REQUEST_RESTART:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		iRet = m_pGSock->iSendMsg(cMsg, 6, cKey);
		break;

	case MSGID_REQUEST_PANNING:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		*cp = cDir;
		cp++;

		iRet = m_pGSock->iSendMsg(cMsg, 7, cKey);
		break;

	case MSGID_REQUEST_CHANGEPASSWORD:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cNewPassword, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cNewPassConfirm, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		iRet = m_pLSock->iSendMsg(cMsg, 46, cKey);
		break;

	case MSGID_REQUEST_CREATENEWACCOUNT:
		// to MainLog Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		ZeroMemory(cTxt, sizeof(cTxt));
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt));
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		memcpy(cp, m_cEmailAddr, 50);
		cp += 50;

		ZeroMemory(cTxt, sizeof(cTxt));
		strcpy(cTxt, " "); // gender
		memcpy(cp, cTxt, 10);
		cp += 10;

		memcpy(cp, m_cAccountAge, 10);
		cp += 10;

		memcpy(cp, " ", 4);
		cp += 4;

		memcpy(cp, " ", 2);
		cp += 2;

		memcpy(cp, " ", 2);
		cp += 2;

		memcpy(cp, m_cAccountCountry, 17);
		cp += 17;

		memcpy(cp, m_cAccountSSN, 28);
		cp += 28;

 		memcpy(cp, m_cAccountQuiz, 45);
		cp += 45;

		memcpy(cp, m_cAccountAnswer, 20);
		cp += 20;

		memcpy(cp, G_cCmdLineTokenA_Lowercase, 50);

		iRet = m_pLSock->iSendMsg(cMsg, 214	+50, cKey);
		break;

	case MSGID_GETMINIMUMLOADGATEWAY:
	case MSGID_REQUEST_LOGIN:
		// to MainLog Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;
		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;
		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;
		memcpy(cp, m_cWorldServerName, 30);
		cp += 30;
		iRet = m_pLSock->iSendMsg(cMsg, 56, cKey);

		break;

	case MSGID_REQUEST_CREATENEWCHARACTER:
		// to MainLog Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = (WORD)NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cp, m_cPlayerName, 10);
		cp += 10;

		memcpy(cp, m_cAccountName, 10);
		cp += 10;

		memcpy(cp, m_cAccountPassword, 10);
		cp += 10;

		memcpy(cp, m_cWorldServerName, 30);
		cp += 30;

		*cp = m_cGender;
		cp++;

		*cp = m_cSkinCol;
		cp++;

		*cp = m_cHairStyle;
		cp++;

		*cp = m_cHairCol;
		cp++;

		*cp = m_cUnderCol;
		cp++;

		*cp = m_ccStr;
		cp++;

		*cp = m_ccVit;
		cp++;

		*cp = m_ccDex;
		cp++;

		*cp = m_ccInt;
		cp++;

		*cp = m_ccMag;
		cp++;

		*cp = m_ccChr;
		cp++;

		iRet = m_pLSock->iSendMsg(cMsg, 77, cKey);
		break;

	case MSGID_REQUEST_ENTERGAME:
		// to MainLog Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = (WORD)m_wEnterGameType;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cPlayerName, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.43
		memcpy(cTxt, m_cMapName, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_iLevel;
		cp += 4;

		memcpy(cp, m_cWorldServerName, 30);
		cp += 30;

		memcpy(cp, G_cCmdLineTokenA, 120);
		cp += 120;

		iRet = m_pLSock->iSendMsg(cMsg, 200, cKey);
		break;

	case MSGID_REQUEST_DELETECHARACTER:
		// to MainLog Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = (WORD)m_wEnterGameType;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cp, m_pCharList[m_wEnterGameType - 1]->m_cName, 10);
		cp += 10;

		memcpy(cp, m_cAccountName, 10);
		cp += 10;

		memcpy(cp, m_cAccountPassword, 10);
		cp += 10;

		memcpy(cp, m_cWorldServerName, 30);
		cp += 30;

		iRet = m_pLSock->iSendMsg(cMsg, 66, cKey);
		break;

	case MSGID_REQUEST_SETITEMPOS:
		// to Game Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		*cp = cDir;

		cp++;

		sp = (short *)cp;
		*sp = (short)iV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)iV2;
		cp += 2;

		iRet = m_pGSock->iSendMsg(cMsg, 11);
		break;

	case MSGID_COMMAND_CHECKCONNECTION:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);

#ifdef DEF_ANTI_HACK
		// Envoyer le CRC au serveur...
		if (m_bUseCRC_2 == TRUE)
		{	m_bUseCRC_2 = FALSE;
			*wp = m_wCRC16_2;
			//wsprintf(G_cTxt,"CRC envoyé: %#04X", m_wCRC16_1);
		}else
		{	m_bUseCRC_2 = TRUE;
			*wp = m_wCRC16_1;
			//wsprintf(G_cTxt,"CRC envoyé: %#04X", m_wCRC16_2);
		}
#else
		*wp = NULL;
#endif

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		dwp = (DWORD *)cp;

#ifdef DEF_ANTI_HACK
		*dwp = (DWORD) iV1;
		CheckProcesses(); // Bloque simplement les mouvements.
		// Mais la detection de la fenêtre correspondante, blocquera le CCM et -> lag / deco par serveur.
#else
		*dwp = dwTime;
#endif

		cp += 4;
		iRet = m_pGSock->iSendMsg(cMsg, 10, cKey);

		break;

	case MSGID_REQUEST_INITDATA:
	case MSGID_REQUEST_INITPLAYER:
		// to Game Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		ZeroMemory(cTxt, sizeof(cTxt));
		memcpy(cTxt, m_cPlayerName, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt));
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt));
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		*cp = (char)m_bIsObserverMode;
		cp++;

		// v2.04 Gateway
		memcpy(cp, m_cGameServerName, 20);
		cp += 20;

		iRet = m_pGSock->iSendMsg(cMsg, 37 +21, cKey);

		//m_bIsObserverMode = FALSE;
		break;
	case MSGID_LEVELUPSETTINGS:
		// CLEROTH
		//if ((m_cLU_Str + m_cLU_Vit + m_cLU_Dex + m_cLU_Int + m_cLU_Mag + m_cLU_Char) > 3) return FALSE;

		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		*cp = m_cLU_Str;
		cp++;

		*cp = m_cLU_Vit;
		cp++;

		*cp = m_cLU_Dex;
		cp++;

		*cp = m_cLU_Int;
		cp++;

		*cp = m_cLU_Mag;
		cp++;

		*cp = m_cLU_Char;
		cp++;

		iRet = m_pGSock->iSendMsg(cMsg, 12);
		break;

	case MSGID_COMMAND_CHATMSG:
		if (m_bIsTeleportRequested == TRUE) return FALSE;

		// to Game Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		*sp = m_sPlayerX;
		cp += 2;

		sp = (short *)cp;
		*sp = m_sPlayerY;
		cp += 2;

		memcpy(cp, m_cPlayerName, 10);
		cp += 10;

		*cp = (char)iV1;
		cp++;

		if (bCheckLocalChatCommand(pString) == TRUE) return FALSE;
		memcpy((char *)cp, pString, strlen(pString) + 1);

		iRet = m_pGSock->iSendMsg(cMsg, 22 + strlen(pString));
		break;

	case MSGID_COMMAND_COMMON:
		if (m_bIsTeleportRequested == TRUE) return FALSE;
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = wCommand;
		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		*sp = m_sPlayerX;
		cp += 2;
		sp = (short *)cp;
		*sp = m_sPlayerY;
		cp += 2;
		*cp = cDir;
		cp++;
		switch (wCommand) {
		case DEF_COMMONTYPE_BUILDITEM:
			memcpy(cp, pString, 20);
			cp += 20;
			*cp = (char)m_stDialogBoxInfo[26].sV1;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV2;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV3;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV4;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV5;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV6;
			cp++;
			iRet = m_pGSock->iSendMsg(cMsg, 37);
			break;

		case DEF_COMMONTYPE_REQ_CREATEPORTION:
			*cp = (char)m_stDialogBoxInfo[26].sV1;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV2;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV3;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV4;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV5;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV6;
			cp++;
			iRet = m_pGSock->iSendMsg(cMsg, 18);
			break;
			
		//Crafting
		case DEF_COMMONTYPE_CRAFTITEM:
			memcpy(cp, "                    ", 20);
			cp += 20;
			*cp = (char)m_stDialogBoxInfo[26].sV1;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV2;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV3;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV4;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV5;
			cp++;
			*cp = (char)m_stDialogBoxInfo[26].sV6;
			cp++;
			iRet = m_pGSock->iSendMsg(cMsg, 37);
			break;

		// Create Slate Request - Diuuude
		case DEF_COMMONTYPE_REQ_CREATESLATE:
			*cp = (char)m_stDialogBoxInfo[40].sV1;
			cp++;
			*cp = (char)m_stDialogBoxInfo[40].sV2;
			cp++;
			*cp = (char)m_stDialogBoxInfo[40].sV3;
			cp++;
			*cp = (char)m_stDialogBoxInfo[40].sV4;
			cp++;
			*cp = (char)m_stDialogBoxInfo[40].sV5;
			cp++;
			*cp = (char)m_stDialogBoxInfo[40].sV6;
			cp++;
			iRet = m_pGSock->iSendMsg(cMsg, 18);
			break;

		default:
			if (pString == NULL)
			{	ip = (int *)cp;
				*ip = iV1;
				cp += 4;
				ip = (int *)cp;
				*ip = iV2;
				cp += 4;
				ip = (int *)cp;
				*ip = iV3;
				cp += 4;
				dwp = (DWORD *)cp;
				*dwp = dwTime;
				cp += 4;
				iRet = m_pGSock->iSendMsg(cMsg, 23 +4);
			}else
			{	ip = (int *)cp;
				*ip = iV1;
				cp += 4;
				ip = (int *)cp;
				*ip = iV2;
				cp += 4;
				ip = (int *)cp;
				*ip = iV3;
				cp += 4;
				memcpy(cp, pString, 30);
				cp += 30;
				ip = (int *)cp;
				*ip = iV4;
				cp += 4;
				iRet = m_pGSock->iSendMsg(cMsg, 23 + 34);
			}
			break;
		}

		break;

	case MSGID_REQUEST_CREATENEWGUILD:
	case MSGID_REQUEST_DISBANDGUILD:
		// to Game Server
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cPlayerName, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountName, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, m_cAccountPassword, 10);
		memcpy(cp, cTxt, 10);
		cp += 10;
		char cTemp[21];
		ZeroMemory(cTemp, sizeof(cTemp));
		memcpy(cTemp, m_cGuildName, 20);
		m_Misc.ReplaceString(cTemp, ' ', '_');
		memcpy(cp, cTemp, 20);
		cp += 20;

		iRet = m_pGSock->iSendMsg(cMsg, 56, cKey);
		break;

	case MSGID_REQUEST_TELEPORT:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_CONFIRM;

		iRet = m_pGSock->iSendMsg(cMsg, 6);

		m_bIsTeleportRequested = TRUE;
		break;

	case MSGID_REQUEST_CIVILRIGHT:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_CONFIRM;

		iRet = m_pGSock->iSendMsg(cMsg, 6);
		break;

	case MSGID_REQUEST_RETRIEVEITEM:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		*cp = (char)iV1;

		iRet = m_pGSock->iSendMsg(cMsg, 7);
		break;

	case MSGID_REQUEST_NOTICEMENT:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		*ip = iV1;
		cp += 4;

		iRet = m_pGSock->iSendMsg(cMsg, 10, cKey);
		break;

	case  MSGID_REQUEST_FIGHTZONE_RESERVE:
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		fightzonenum = (int *)cp;
		*fightzonenum = iV1;
		cp += 4;

		iRet = m_pGSock->iSendMsg(cMsg, 10);
		break;

	case MSGID_STATECHANGEPOINT:
		// Diuuude
		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = NULL;
		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
		*cp = cStateChange1;
		cp++;
		*cp = cStateChange2;
		cp++;
		*cp = cStateChange3;
		cp++;
		iRet = m_pGSock->iSendMsg(cMsg, 12);
		break;

	default:
		if (m_bIsTeleportRequested == TRUE) return FALSE;

		dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp = wCommand;

		cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		*sp = m_sPlayerX;
		cp += 2;

		sp = (short *)cp;
		*sp = m_sPlayerY;
		cp += 2;

		*cp = cDir;
		cp++;

		sp  = (short *)cp;
		*sp = (short)iV1;
		cp += 2;

		sp  = (short *)cp;
		*sp = (short)iV2;
		cp += 2;

		sp  = (short *)cp;
		*sp = (short)iV3;
		cp += 2;
		if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE))
		{	sp  = (short *)cp;
			*sp = (short)iV4;
			cp += 2;
			dwp = (DWORD *)cp;
			*dwp = dwTime;
			cp += 4;
			iRet = m_pGSock->iSendMsg(cMsg, 19 +4);
		}else
		{	dwp = (DWORD *)cp;
			*dwp = dwTime;
			cp += 4;

			iRet = m_pGSock->iSendMsg(cMsg, 17 +4); //v2.171
		}
		m_cCommandCount++;
		break;
	}
	switch (iRet) {
	case DEF_XSOCKEVENT_SOCKETCLOSED:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_QUENEFULL:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		delete m_pGSock;
		m_pGSock = NULL;
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		delete m_pGSock;
		m_pGSock = NULL;
		if (G_pCalcSocket != NULL) {
			delete G_pCalcSocket;
			G_pCalcSocket = NULL;
		}
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
		break;
	}
	return TRUE;
}


void CGame::DrawObjects(short sPivotX, short sPivotY, short sDivX, short sDivY, short sModX, short sModY, short msX, short msY)
{int ix, iy, indexX, indexY, dX, dY, iDvalue;
 char cItemColor;
 BOOL bIsPlayerDrawed = FALSE;
 BOOL bContact = FALSE;
 BOOL bRet = FALSE;
 BOOL bIsBehindOtherBug = FALSE; // By Snoopy (fix for drawing transparent statues..
 short sItemSprite, sItemSpriteFrame, sObjSpr, sObjSprFrame, sDynamicObject, sDynamicObjectFrame;
 static DWORD dwMCAnimTime = G_dwGlobalTime;
 static short sMCAnimFrame = 1;
// Xmas
 static int ix1[100];
 static int iy2[100];
 static int iXmasTreeBulbDelay = 76;
 int idelay = 75;

	if( sDivY < 0 || sDivX < 0) return ;
	m_sMCX = NULL;
	m_sMCY = NULL;
	ZeroMemory(m_cMCName, sizeof(m_cMCName));

	//dwTime = G_dwGlobalTime;
	DWORD dwTime = m_dwCurTime;
	m_stMCursor.sCursorFrame = 0;

	indexY = sDivY + sPivotY - 7;
	for (iy = -sModY-224; iy <= 427+352; iy += 32)
	{	indexX = sDivX + sPivotX-4;
		for (ix = -sModX-128 ; ix <= 640 + 128; ix += 32)
		{	sDynamicObject = NULL;
			bRet = FALSE;
			if ((ix >= -sModX) && (ix <= 640+16) && (iy >= -sModY) && (iy <= 427+32+16))
			{	_tmp_wObjectID = _tmp_sOwnerType = _tmp_sAppr1 = _tmp_sAppr2 = _tmp_sAppr3 = _tmp_sAppr4 = _tmp_iStatus = NULL;
				_tmp_cDir = _tmp_cFrame = 0;
				_tmp_iEffectType = _tmp_iEffectFrame = _tmp_iChatIndex = 0;
				ZeroMemory(_tmp_cName, sizeof(_tmp_cName));
				if ((indexX < m_pMapData->m_sPivotX) || (indexX > m_pMapData->m_sPivotX + MAPDATASIZEX) ||
					(indexY < m_pMapData->m_sPivotY) || (indexY > m_pMapData->m_sPivotY + MAPDATASIZEY))
				{	sItemSprite = NULL;
					sItemSpriteFrame = NULL;
					bRet = FALSE;
					cItemColor = NULL;
				}else
				{	_tmp_dX = dX = indexX - m_pMapData->m_sPivotX;
					_tmp_dY = dY = indexY - m_pMapData->m_sPivotY;
					_tmp_wObjectID  = m_pMapData->m_pData[dX][dY].m_wDeadObjectID;
					_tmp_sOwnerType = m_pMapData->m_pData[dX][dY].m_sDeadOwnerType;
					_tmp_cDir       = m_pMapData->m_pData[dX][dY].m_cDeadDir;
					_tmp_sAppr1     = m_pMapData->m_pData[dX][dY].m_sDeadAppr1;
					_tmp_sAppr2     = m_pMapData->m_pData[dX][dY].m_sDeadAppr2;
					_tmp_sAppr3     = m_pMapData->m_pData[dX][dY].m_sDeadAppr3;
					_tmp_sAppr4     = m_pMapData->m_pData[dX][dY].m_sDeadAppr4;
					_tmp_iApprColor = m_pMapData->m_pData[dX][dY].m_iDeadApprColor;
					_tmp_cFrame     = m_pMapData->m_pData[dX][dY].m_cDeadOwnerFrame;
					_tmp_iChatIndex = m_pMapData->m_pData[dX][dY].m_iDeadChatMsg;
					_tmp_iStatus    = m_pMapData->m_pData[dX][dY].m_iDeadStatus;
					strcpy(_tmp_cName, m_pMapData->m_pData[dX][dY].m_cDeadOwnerName);
					sItemSprite      = m_pMapData->m_pData[dX][dY].m_sItemSprite;
					sItemSpriteFrame = m_pMapData->m_pData[dX][dY].m_sItemSpriteFrame;
					cItemColor       = m_pMapData->m_pData[dX][dY].m_cItemColor;
					sDynamicObject      = m_pMapData->m_pData[dX][dY].m_sDynamicObjectType;
					sDynamicObjectFrame = (short)m_pMapData->m_pData[dX][dY].m_cDynamicObjectFrame;
					cDynamicObjectData1 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData1;
					cDynamicObjectData2 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData2;
					cDynamicObjectData3 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData3;
					cDynamicObjectData4 = m_pMapData->m_pData[dX][dY].m_cDynamicObjectData4;
					bRet = TRUE;
			 	}

				if ((bRet == TRUE) && (sItemSprite != 0))
				{	if (cItemColor == 0)
						 m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + sItemSprite]->PutSpriteFast(ix, iy, sItemSpriteFrame, dwTime);
					else
					{	switch (sItemSprite) {
						case 1: // Swds
						case 2: // Bows
						case 3: // Shields
						case 15: // Axes hammers
						case 17: // Wands
							m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + sItemSprite]->PutSpriteRGB(ix, iy
								, sItemSpriteFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
							break;
						default:
							m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT + sItemSprite]->PutSpriteRGB(ix, iy
								, sItemSpriteFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
							break;
					}	}

					if ((ix - 13 < msX)	&& (ix + 13 > msX) && (iy - 13 < msY) && (iy + 13 > msY))
					{	if ((dwTime - dwMCAnimTime)	> 200)
						{	dwMCAnimTime = dwTime;
							if (sMCAnimFrame == 1)
								 sMCAnimFrame = 2;
							else sMCAnimFrame = 1;
						}
						m_stMCursor.sCursorFrame  = sMCAnimFrame;
				}	}

				if ((bRet == TRUE) && (_tmp_wObjectID != NULL))
				{	bContact = DrawObject_OnDead(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
				}

				if ((bContact == TRUE) && (msY <= 431))
				{	m_sMCX = indexX;
					m_sMCY = indexY;
					sFocusX = ix;
					sFocusY = iy;
					sFocusOwnerType = _tmp_sOwnerType;
					cFocusAction = DEF_OBJECTDEAD;
					wFocusObjectID = _tmp_wObjectID;
					cFocusFrame  = _tmp_cFrame;
					cFocusDir    = _tmp_cDir;
					sFocusAppr1  = _tmp_sAppr1;
					sFocusAppr2  = _tmp_sAppr2;
					sFocusAppr3  = _tmp_sAppr3;
					sFocusAppr4  = _tmp_sAppr4;
					iFocusApprColor = _tmp_iApprColor;
					iFocuiStatus = _tmp_iStatus;
					ZeroMemory(cFocusName, sizeof(cFocusName));
					strcpy(cFocusName, _tmp_cName);
					ZeroMemory(m_cMCName, sizeof(m_cMCName));
					strcpy(m_cMCName,  _tmp_cName);
					sFocus_dX = _tmp_dX;
					sFocus_dY = _tmp_dY;
					bContact = FALSE;
				}

				_tmp_wObjectID = _tmp_sOwnerType = _tmp_sAppr1 = _tmp_sAppr2 = _tmp_sAppr3 = _tmp_sAppr4 = _tmp_iStatus = NULL;
				_tmp_cFrame = _tmp_cDir = 0;
				_tmp_iEffectType = _tmp_iEffectFrame = _tmp_iApprColor = _tmp_iChatIndex = 0;
				ZeroMemory(_tmp_cName, sizeof(_tmp_cName));

				if ((indexX < m_pMapData->m_sPivotX) || (indexX > m_pMapData->m_sPivotX + MAPDATASIZEX) ||
					(indexY < m_pMapData->m_sPivotY) || (indexY > m_pMapData->m_sPivotY + MAPDATASIZEY))
				{	sItemSprite = NULL;
					bRet = FALSE;
				}else
				{	_tmp_dX = dX = indexX - m_pMapData->m_sPivotX; // v2.171 2002-6-14
					_tmp_dY = dY = indexY - m_pMapData->m_sPivotY; // v2.171 2002-6-14
					_tmp_wObjectID  = m_pMapData->m_pData[dX][dY].m_wObjectID;
					_tmp_sOwnerType = m_pMapData->m_pData[dX][dY].m_sOwnerType;
					_tmp_cAction    = m_pMapData->m_pData[dX][dY].m_cOwnerAction;
					_tmp_iStatus    = m_pMapData->m_pData[dX][dY].m_iStatus;
					_tmp_cDir       = m_pMapData->m_pData[dX][dY].m_cDir;
					_tmp_sAppr1     = m_pMapData->m_pData[dX][dY].m_sAppr1;
					_tmp_sAppr2     = m_pMapData->m_pData[dX][dY].m_sAppr2;
					_tmp_sAppr3     = m_pMapData->m_pData[dX][dY].m_sAppr3;
					_tmp_sAppr4     = m_pMapData->m_pData[dX][dY].m_sAppr4;
					_tmp_iApprColor = m_pMapData->m_pData[dX][dY].m_iApprColor; // v1.4
					_tmp_cFrame     = m_pMapData->m_pData[dX][dY].m_cOwnerFrame;
					_tmp_iChatIndex = m_pMapData->m_pData[dX][dY].m_iChatMsg;
					_tmp_iEffectType  = m_pMapData->m_pData[dX][dY].m_iEffectType;
					_tmp_iEffectFrame = m_pMapData->m_pData[dX][dY].m_iEffectFrame;

					strcpy(_tmp_cName, m_pMapData->m_pData[dX][dY].m_cOwnerName);
					bRet = TRUE;

					if (m_iIlusionOwnerH != NULL)
					{	if ((strcmp(_tmp_cName, m_cPlayerName) != 0) && (_tmp_sOwnerType < 10))
						{	_tmp_sOwnerType = m_cIlusionOwnerType;
							_tmp_iStatus    = m_iStatus_IE;
							_tmp_sAppr1     = m_sAppr1_IE;
							_tmp_sAppr2     = m_sAppr2_IE;
							_tmp_sAppr3     = m_sAppr3_IE;
							_tmp_sAppr4     = m_sAppr4_IE;
							_tmp_iApprColor = m_iApprColor_IE;
			 	}	}	}

				if ((bRet == TRUE) && (strlen(_tmp_cName) > 0))
				{	_tmp_dx = 0;
					_tmp_dy = 0;
					switch (_tmp_cAction) {
					case DEF_OBJECTSTOP:
						bContact = DrawObject_OnStop(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTMOVE:
						bContact = DrawObject_OnMove(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTDAMAGEMOVE:
						bContact = DrawObject_OnDamageMove(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTRUN:
						bContact = DrawObject_OnRun(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTATTACK:
						bContact = DrawObject_OnAttack(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTATTACKMOVE:
						bContact = DrawObject_OnAttackMove(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTMAGIC:
						bContact = DrawObject_OnMagic(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTGETITEM:
						bContact = DrawObject_OnGetItem(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTDAMAGE:
						bContact = DrawObject_OnDamage(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;

					case DEF_OBJECTDYING:
						bContact = DrawObject_OnDying(indexX, indexY, ix, iy, FALSE, dwTime, msX, msY);
						break;
					}

					if ((bContact == TRUE) && (msY <= 431))
					{	m_sMCX = indexX;
						m_sMCY = indexY;
						sFocusX = ix;
						sFocusY = iy;
						wFocusObjectID = _tmp_wObjectID;
						sFocusOwnerType = _tmp_sOwnerType;
						cFocusAction = _tmp_cAction;
						cFocusFrame  = _tmp_cFrame;
						cFocusDir    = _tmp_cDir;
						sFocusAppr1  = _tmp_sAppr1;
						sFocusAppr2  = _tmp_sAppr2;
						sFocusAppr3  = _tmp_sAppr3;
						sFocusAppr4  = _tmp_sAppr4;
						iFocusApprColor = _tmp_iApprColor; // v1.4
						iFocuiStatus = _tmp_iStatus;
						ZeroMemory(cFocusName, sizeof(cFocusName));
						strcpy(cFocusName, _tmp_cName);
						ZeroMemory(m_cMCName, sizeof(m_cMCName));
						strcpy(m_cMCName,  _tmp_cName);
						sFocus_dX = _tmp_dX; // v2.171
						sFocus_dY = _tmp_dY; // v2.171
						bContact = FALSE;
					}

					if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0)
					{	if (m_bIsObserverMode == FALSE)
						{	m_sViewDstX = (indexX*32) - 288 - 32;
							m_sViewDstY = (indexY*32) - 224;
						}
						SetRect(&m_rcPlayerRect, m_rcBodyRect.left, m_rcBodyRect.top, m_rcBodyRect.right, m_rcBodyRect.bottom);
						bIsPlayerDrawed = TRUE;
		   	}	}	}

			// CLEROTH
			sObjSpr      = m_pMapData->m_tile[indexX][indexY].m_sObjectSprite;
			sObjSprFrame = m_pMapData->m_tile[indexX][indexY].m_sObjectSpriteFrame;

			if (sObjSpr != 0)
			{	if ((sObjSpr < 100) || (sObjSpr >= 200))
				{	switch (sObjSpr) {
					case 200:
					case 223:
						m_pTileSpr[sObjSpr]->PutShadowSprite(ix - 16, iy - 16, sObjSprFrame, dwTime);
						break;

					case 224:
						switch (sObjSprFrame) {
						case 24:
						case 34:
						case 35:
						case 36:
						case 37:
						case 38:
							break;
						default:
							m_pTileSpr[sObjSpr]->PutShadowSprite(ix - 16, iy - 16, sObjSprFrame, dwTime);
							break;
					}	}
					if (m_cDetailLevel == 0) // Special Grass & Flowers
					{	if ((sObjSpr != 6) && (sObjSpr != 9))
							m_pTileSpr[sObjSpr]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
					}else
					{	m_pTileSpr[sObjSpr]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
					}

					switch (sObjSpr) {
					case 223:
						if (sObjSprFrame == 4)
						{	if (G_cSpriteAlphaDegree == 2) //nuit
							{	int iDvalue1 = -1*(rand() % 5);
								int iDvalue2 = -1*(rand() % 5);
								int iDvalue3 = -1*(rand() % 5);
								m_pEffectSpr[0]->PutTransSpriteRGB(ix+2 -17,  iy - 147 -15, 1, iDvalue1, iDvalue1, iDvalue1, dwTime);
								m_pEffectSpr[0]->PutTransSpriteRGB(ix+16 -17, iy - 96 -15,  1, iDvalue2, iDvalue2, iDvalue2, dwTime);
								m_pEffectSpr[0]->PutTransSpriteRGB(ix-19 -17, iy - 126 -15, 1, iDvalue3, iDvalue3, iDvalue3, dwTime);
						}	}
						break;

					case 370: // nuit
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 9) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix -16 +30, m_sViewPointY + iy -16 -334, NULL, NULL, NULL, 0);
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 11) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX +ix -16 +17, m_sViewPointY + iy -16 -300, NULL, NULL, NULL, 0);
						break;

					case 374: // nuit
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 2) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix -7, m_sViewPointY + iy -122, NULL, NULL, NULL, 0);
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 6) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix -14, m_sViewPointY + iy -321, NULL, NULL, NULL, 0);
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 7) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX +ix +7, m_sViewPointY + iy -356, NULL, NULL, NULL, 0);
						break;

					case 376: // nuit
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 12) && (G_cSpriteAlphaDegree == 2)) {
							bAddNewEffect(65, m_sViewPointX + ix -16, m_sViewPointY + iy -346, NULL, NULL, NULL, 0);
							bAddNewEffect(65, m_sViewPointX + ix +11, m_sViewPointY + iy -308, NULL, NULL, NULL, 0);
						}
						break;

					case 378: // nuit
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 11) && (G_cSpriteAlphaDegree == 2)) bAddNewEffect(65, m_sViewPointX + ix, m_sViewPointY + iy -91, NULL, NULL, NULL, 0);
						break;

					case 382: // nuit
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 9) && (G_cSpriteAlphaDegree == 2)) {
							bAddNewEffect(65, m_sViewPointX + ix +73, m_sViewPointY + iy -264, NULL, NULL, NULL, 0);
							bAddNewEffect(65, m_sViewPointX + ix +23, m_sViewPointY + iy -228, NULL, NULL, NULL, 0);
						}
						break;

					case 429:
						if ( ((dwTime - m_dwEnvEffectTime) > 400) && (sObjSprFrame == 2)) bAddNewEffect(65, m_sViewPointX + ix -15, m_sViewPointY + iy -224, NULL, NULL, NULL, 0);
						break;
					}
				}else // sprites 100..199: Trees and tree shadows
				{	m_pTileSpr[sObjSpr]->_GetSpriteRect(ix - 16, iy - 16, sObjSprFrame);

#ifdef DEF_EQUILIBRIUM_PROJECT // Arbres invisibles en Medium resol
					if (m_cDetailLevel<=1)
#else
					if (m_cDetailLevel==0)
#endif

					{	if( sObjSpr < 100 + 11 ) m_pTileSpr[100 + 4]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
						else if( sObjSpr < 100 + 23 ) m_pTileSpr[100 + 9]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
						else if( sObjSpr < 100 + 32 ) m_pTileSpr[100 + 23]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
						else m_pTileSpr[100 + 32]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
					}else
					{	if ((bIsPlayerDrawed == TRUE) && (m_pTileSpr[sObjSpr]->m_rcBound.top <= m_rcPlayerRect.top) && (m_pTileSpr[sObjSpr]->m_rcBound.bottom >= m_rcPlayerRect.bottom) &&
							(m_cDetailLevel >= 2) && (m_pTileSpr[sObjSpr]->m_rcBound.left <= m_rcPlayerRect.left) && (m_pTileSpr[sObjSpr]->m_rcBound.right >= m_rcPlayerRect.right))
						{	m_pTileSpr[sObjSpr + 50]->PutFadeSprite(ix , iy , sObjSprFrame, dwTime);
							m_pTileSpr[sObjSpr]->PutTransSprite2(ix - 16, iy - 16, sObjSprFrame, dwTime);
						}else
						{	m_pTileSpr[sObjSpr + 50]->PutSpriteFast(ix , iy , sObjSprFrame, dwTime);
							m_pTileSpr[sObjSpr]->PutSpriteFast(ix - 16, iy - 16, sObjSprFrame, dwTime);
						}
						if (m_bIsXmas == TRUE)
						{	if (G_cSpriteAlphaDegree == 2) // nuit
							{	if( iXmasTreeBulbDelay < 0 || iXmasTreeBulbDelay > idelay + 1) iXmasTreeBulbDelay = 0;
								if( iXmasTreeBulbDelay > idelay )
								{	for (int i = 0; i < 100; i++) {
										ix1[i] = 1*(rand() % 400)-200;
										iy2[i] = -1*(rand() % 300);
									}
									iXmasTreeBulbDelay = 0;
								}	else iXmasTreeBulbDelay++;

								for (int j = 0; j < 100; j++)
								{	if( m_pTileSpr[sObjSpr]->_bCheckCollison(ix-16, iy-16, sObjSprFrame, ix + ix1[j], iy + iy2[j]) )
									{	m_pEffectSpr[66+(j%6)]->PutTransSprite(ix + ix1[j], iy + iy2[j], (iXmasTreeBulbDelay>>2), dwTime);
			}	}	}	}	}	}	}

			// Dynamic Object
			if ( (bRet == TRUE) && (sDynamicObject != NULL) ) 
			{	switch (sDynamicObject) {
				case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:	// 10
					if (sDynamicObjectFrame >= 0)
						m_pEffectSpr[23]->PutTransSprite50_NoColorKey(ix+(rand() % 2), iy+(rand() % 2), sDynamicObjectFrame, dwTime);
					break;

				case DEF_DYNAMICOBJECT_PCLOUD_LOOP:		// 11
					m_pEffectSpr[23]->PutTransSprite50_NoColorKey(ix+(rand() % 2), iy+(rand() % 2), sDynamicObjectFrame+8, dwTime);
					break;

				case DEF_DYNAMICOBJECT_PCLOUD_END:		// 12
					m_pEffectSpr[23]->PutTransSprite50_NoColorKey(ix+(rand() % 2), iy+(rand() % 2), sDynamicObjectFrame+16, dwTime);
					break;

				case DEF_DYNAMICOBJECT_ICESTORM:		// 8
					iDvalue = (rand() % 5)*(-1);
					m_pEffectSpr[0]->PutTransSpriteRGB(ix, iy, 1, iDvalue, iDvalue, iDvalue, dwTime);
					m_pEffectSpr[13]->PutTransSprite70_NoColorKey(ix, iy, sDynamicObjectFrame, dwTime);
					break;

				case DEF_DYNAMICOBJECT_FIRE:			// 1
				case DEF_DYNAMICOBJECT_FIRE3:			// 14
					switch (rand() % 3) {
					case 0: m_pEffectSpr[0]->PutTransSprite25_NoColorKey(ix, iy, 1, dwTime); break;
					case 1: m_pEffectSpr[0]->PutTransSprite50_NoColorKey(ix, iy, 1, dwTime); break;
					case 2: m_pEffectSpr[0]->PutTransSprite70_NoColorKey(ix, iy, 1, dwTime); break;
					}
					m_pEffectSpr[9]->PutTransSprite70_NoColorKey(ix, iy, sDynamicObjectFrame/3, dwTime);
					break;

				case DEF_DYNAMICOBJECT_FIRE2:			// 13
					switch (rand() % 3) {
					case 0: m_pEffectSpr[0]->PutTransSprite25_NoColorKey(ix, iy, 1, dwTime); break;
					case 1: m_pEffectSpr[0]->PutTransSprite50_NoColorKey(ix, iy, 1, dwTime); break;
					case 2: m_pEffectSpr[0]->PutTransSprite70_NoColorKey(ix, iy, 1, dwTime); break;
					}
					break;

				case DEF_DYNAMICOBJECT_FISH:			// 2
					{	char cTmpDOdir, cTmpDOframe;
						cTmpDOdir   = m_Misc.cCalcDirection(cDynamicObjectData1, cDynamicObjectData2, cDynamicObjectData1 + cDynamicObjectData3, cDynamicObjectData2 + cDynamicObjectData4);
						cTmpDOframe = ((cTmpDOdir-1) * 4) + (rand() % 4);
						m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+0]->PutTransSprite2(ix + cDynamicObjectData1, iy + cDynamicObjectData2, cTmpDOframe, dwTime);
					}
					break;

				case DEF_DYNAMICOBJECT_MINERAL1:		// 4
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->PutShadowSprite(ix, iy, 0, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->PutSpriteFast(ix, iy, 0, dwTime);
					if (    (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.top != -1)
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.top < msY) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.bottom > msY) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.left < msX) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.right > msX) )
					{	m_sMCX = indexX;
						m_sMCY = indexY;
						iFocuiStatus = NULL;
						//bIsBehindOtherBug = TRUE;
						ZeroMemory(cFocusName, sizeof(cFocusName));
						ZeroMemory(m_cMCName, sizeof(m_cMCName));
					}
					break;

				case DEF_DYNAMICOBJECT_MINERAL2:		// 5
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->PutShadowSprite(ix, iy, 1, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->PutSpriteFast(ix, iy, 1, dwTime);
					if (   (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.top != -1) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.top < msY) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.bottom > msY) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.left < msX) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+1]->m_rcBound.right > msX) )
					{	m_sMCX = indexX;
						m_sMCY = indexY;
						iFocuiStatus = NULL;
						//bIsBehindOtherBug = TRUE;
						ZeroMemory(cFocusName, sizeof(cFocusName));
						ZeroMemory(m_cMCName, sizeof(m_cMCName));
					}
					break;

#ifdef DEF_EQUILIBRIUM_PROJECT  // Dynamic items, statues DEF_DYNAMICOBJECT_STATUE1
				case DEF_DYNAMICOBJECT_STATUE1:		//  Dragon - violet
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+3]->PutShadowSprite(ix, iy, 0, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+3]->PutTransSpriteRGB(ix, iy, 0, m_iDrawFlag/4, 0, m_iDrawFlag/2, dwTime);
					bAddNewEffect(54, m_sViewPointX +ix +(rand()%90) -30
									, m_sViewPointY +iy -(rand()%190)+30 , NULL, NULL, -(rand()%8), 0);
					break;
				case DEF_DYNAMICOBJECT_STATUE2:		//  Demon - red
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+4]->PutShadowSprite(ix, iy, 2, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+4]->PutTransSpriteRGB(ix, iy, 2, m_iDrawFlag/2, 0, 0, dwTime);
					bAddNewEffect(54, m_sViewPointX +ix +(rand()%95) -40
									, m_sViewPointY +iy -(rand()%150)+30 , NULL, NULL, -(rand()%8), 0);
					break;
				case DEF_DYNAMICOBJECT_STATUE3:		// Centaure - green
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+3]->PutShadowSprite(ix, iy, 2, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+3]->PutTransSpriteRGB(ix, iy, 2, 0, m_iDrawFlag/2, 0, dwTime);
					bAddNewEffect(54, m_sViewPointX +ix +(rand()%80) -30
									, m_sViewPointY +iy -(rand()%160)+30 , NULL, NULL, -(rand()%8), 0);
					break;
				case DEF_DYNAMICOBJECT_STATUE4:		//  Allien - Orange
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+3]->PutShadowSprite(ix, iy, 5, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+3]->PutTransSpriteRGB(ix, iy, 5, m_iDrawFlag/2, m_iDrawFlag/4, 0, dwTime);
					bAddNewEffect(54, m_sViewPointX +ix +(rand()%95) -45
									, m_sViewPointY +iy -(rand()%175)+30 , NULL, NULL, -(rand()%8), 0);
					break;
				case DEF_DYNAMICOBJECT_STATUE5:		//  Precheur - Jaune
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+4]->PutShadowSprite(ix-15, iy-30, 6, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+4]->PutTransSpriteRGB(ix-15, iy-30, 6, m_iDrawFlag/2, m_iDrawFlag/2, 0, dwTime);
					bAddNewEffect(54, m_sViewPointX +ix +(rand()%70) -20
									, m_sViewPointY +iy -(rand()%160)+30 , NULL, NULL, -(rand()%8), 0);
					break;
				case DEF_DYNAMICOBJECT_STATUE6:		//  War - Red
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+4]->PutShadowSprite(ix-15, iy-30, 12, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+4]->PutTransSpriteRGB(ix-15, iy-30, 12, m_iDrawFlag, 0, 0, dwTime);
					bAddNewEffect(54, m_sViewPointX +ix +(rand()%80) -25
									, m_sViewPointY +iy -(rand()%200)+30 , NULL, NULL, -(rand()%8), 0);
					break;
				case DEF_DYNAMICOBJECT_STATUE7:		// Femme - Blue
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+4]->PutShadowSprite(ix-15, iy-30, 14, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+4]->PutTransSpriteRGB(ix-15, iy-30, 14, 0, 0, m_iDrawFlag, dwTime);
					bAddNewEffect(54, m_sViewPointX +ix +(rand()%70) -15
									, m_sViewPointY +iy -(rand()%150)+25 , NULL, NULL, -(rand()%8), 0);
					break;

				case DEF_DYNAMICOBJECT_CHEST1:
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+5]->PutSpriteFast(ix, iy, 4, dwTime);
					break;

				case DEF_DYNAMICOBJECT_CHEST2:
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+5]->PutSpriteFast(ix, iy, 5, dwTime);
					break;

				case DEF_DYNAMICOBJECT_BARREL:
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+5]->PutSpriteFast(ix, iy, 10, dwTime);
					break;

				case DEF_DYNAMICOBJECT_OBELISK1:
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+7]->PutShadowSprite(ix-15, iy-30, 0, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->PutTransSpriteRGB(ix-15, iy-30, 0, 0, 0, m_iDrawFlag, dwTime);
					if (   (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.top != -1) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.top < msY) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.bottom > msY) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.left < msX) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.right > msX) )
					{	m_sMCX = indexX;
						m_sMCY = indexY;
						iFocuiStatus = NULL;
						//bIsBehindOtherBug = TRUE;
						ZeroMemory(cFocusName, sizeof(cFocusName));
						ZeroMemory(m_cMCName, sizeof(m_cMCName));
					}
					break;

				case DEF_DYNAMICOBJECT_OBELISK2:
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+7]->PutShadowSprite(ix-15, iy-30, 1, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->PutTransSpriteRGB(ix-15, iy-30, 1, 0, 0, m_iDrawFlag, dwTime);
					if (   (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.top != -1) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.top < msY) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.bottom > msY) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.left < msX) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.right > msX) )
					{	m_sMCX = indexX;
						m_sMCY = indexY;
						iFocuiStatus = NULL;
						//bIsBehindOtherBug = TRUE;
						ZeroMemory(cFocusName, sizeof(cFocusName));
						ZeroMemory(m_cMCName, sizeof(m_cMCName));
					}
					break;

				case DEF_DYNAMICOBJECT_OBELISK3:
					if (m_cDetailLevel != 0) m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+7]->PutShadowSprite(ix-15, iy-30, 2, dwTime);
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->PutTransSpriteRGB(ix-15, iy-30, 2, 0, 0, m_iDrawFlag, dwTime);
					if (   (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.top != -1) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.top < msY) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.bottom > msY) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.left < msX) 
						&& (m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6]->m_rcBound.right > msX) )
					{	m_sMCX = indexX;
						m_sMCY = indexY;
						iFocuiStatus = NULL;
						//bIsBehindOtherBug = TRUE;
						ZeroMemory(cFocusName, sizeof(cFocusName));
						ZeroMemory(m_cMCName, sizeof(m_cMCName));
					}
					break;
#endif

				case DEF_DYNAMICOBJECT_SPIKE:			// 9
					m_pEffectSpr[17]->PutTransSprite70_NoColorKey(ix, iy, sDynamicObjectFrame, dwTime);
					break;

				case DEF_DYNAMICOBJECT_ARESDENFLAG1:  // 6
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+2]->PutSpriteFast(ix, iy, sDynamicObjectFrame, dwTime);
					break;

				case DEF_DYNAMICOBJECT_ELVINEFLAG1: // 7
					m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+2]->PutSpriteFast(ix, iy, sDynamicObjectFrame, dwTime);
					break;
			}	}
			indexX++;
		}
		indexY++;
	}

	if ((dwTime - m_dwEnvEffectTime) > 400) m_dwEnvEffectTime = dwTime;

	if ((m_sMCX != NULL) && (bIsBehindOtherBug == FALSE))		// CLEROTH - STATUS
	{	if( _iGetFOE(iFocuiStatus) < 0 ) m_stMCursor.sCursorFrame = 3;
		else m_stMCursor.sCursorFrame = 6;

		_tmp_wObjectID  = wFocusObjectID;
		_tmp_sOwnerType = sFocusOwnerType;
		_tmp_cAction    = cFocusAction;
		_tmp_cFrame     = cFocusFrame;
		_tmp_cDir       = cFocusDir;
		_tmp_sAppr1     = sFocusAppr1;
		_tmp_sAppr2     = sFocusAppr2;
		_tmp_sAppr3     = sFocusAppr3;
		_tmp_sAppr4     = sFocusAppr4;
		_tmp_iApprColor = iFocusApprColor; // v1.4
		_tmp_iStatus    = iFocuiStatus;
		strcpy(_tmp_cName, cFocusName);
		_tmp_dX = sFocus_dX; // v2.171
		_tmp_dY = sFocus_dY; // v2.171

		if ( (_tmp_cAction != DEF_OBJECTDEAD) && (_tmp_cFrame < 0) ) return;
		switch (_tmp_cAction) {
		case DEF_OBJECTSTOP:
			DrawObject_OnStop(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;
		case DEF_OBJECTMOVE:
			switch (_tmp_sOwnerType) {
			case 1:
			case 2:
			case 3: // Human M
			case 4:
			case 5:
			case 6: // Human F

			case 28: // Troll.
			case 29: // Ogre
			case 30: // Liche
			case 31: // DD
			case 32: // Uni
			case 33: // WW
			case 43: // LWB
			case 44: // GHK
			case 45: // GHKABS
			case 46: // TK
			case 47: // BG
			case 48: // SK
			case 49: // HC
			case 50: // TW
			case 51: // CP
			case 52: // GG
			case 53: // BB
			case 54: // DE
			case 55: // Rabbit
			case 56: // Cat
			case 57: // Frog
			case 58: // MG
			case 59: // Ettin
			case 60: // Plant
			case 61: // Rudolph
			case 62: // DireBoar
			case 63: // Frost
			case 65: // Ice-Golem
			case 66: // Wyvern
			case 70: // Dragon..........Ajouts par Snoopy
			case 71: // Centaur
			case 72: // ClawTurtle
			case 73: // FireWyvern
			case 74: // GiantCrayfish
			case 75: // Gi Lizard
			case 76: // Gi Tree
			case 77: // Master Orc
			case 78: // Minaus
			case 79: // Nizie
			case 80: // Tentocle
			case 81: // Abaddon
			case 82: // Sorceress
			case 83: // ATK
			case 84: // MasterElf
			case 85: // DSK
			case 86: // HBT
			case 87: // CT
			case 88: // Barbarian
			case 89: // AGC
			case 91: // Gate

		/*	case 15: // ShopKeeper // Ils ont 8 sprites Stop
			case 19: // Gandalf
			case 20: // Howard
			case 24: // Tom
			case 25: // William
			case 26: // Kenedy
			case 90: // Gail*/
				break;

			default: // 10..27
				_tmp_cFrame = _tmp_cFrame * 2; //
				break;
			}

			DrawObject_OnMove(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTDAMAGEMOVE:
			DrawObject_OnDamageMove(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTRUN:
			DrawObject_OnRun(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTATTACK:
			DrawObject_OnAttack(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTATTACKMOVE:
			DrawObject_OnAttackMove(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTMAGIC:
			DrawObject_OnMagic(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTDAMAGE:
			DrawObject_OnDamage(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTDYING: //10
			DrawObject_OnDying(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;

		case DEF_OBJECTDEAD: //101
			DrawObject_OnDead(m_sMCX, m_sMCY, sFocusX, sFocusY, TRUE, dwTime, msX, msY);
			break;
	}	}

	if (m_bIsGetPointingMode == TRUE)
	{	if ( (m_iPointCommandType >= 100) && (m_iPointCommandType < 200) ) // spell
		{	if (m_bCommandAvailable == TRUE)
			{	if( m_sMCX != NULL )
				{	if( _iGetFOE(iFocuiStatus) < 0 )
						m_stMCursor.sCursorFrame = 5;   // Red enemi for spell
					else m_stMCursor.sCursorFrame = 4;  // Blue friend for spell
				}else m_stMCursor.sCursorFrame = 4;     // Blue friend for spell
			}else m_stMCursor.sCursorFrame = 8;
		}else if ( (m_iPointCommandType >= 0) && (m_iPointCommandType < 50) ) // item
		{	m_stMCursor.sCursorFrame = 10;				// hand to grap item
	}	}
}


void CGame::GameRecvMsgHandler(DWORD dwMsgSize, char * pData)
{ DWORD * dwpMsgID;
	dwpMsgID = (DWORD *)(pData + DEF_INDEX4_MSGID);
	switch (*dwpMsgID) {
	case MSGID_RESPONSE_CHARGED_TELEPORT:
		ResponseChargedTeleport(pData);
		break;

	case MSGID_RESPONSE_TELEPORT_LIST:
		ResponseTeleportList(pData);
		break;

	case MSGID_RESPONSE_HELDENIAN_TP_LIST: // Snoopy Heldenian TP
		ResponseHeldenianTeleportList(pData);
		break;

	case MSGID_RESPONSE_NOTICEMENT:
		NoticementHandler(pData);
		break;

	case MSGID_DYNAMICOBJECT:
		DynamicObjectHandler(pData);
		break;

	case MSGID_RESPONSE_INITPLAYER:
		InitPlayerResponseHandler(pData);
		break;

	case MSGID_RESPONSE_INITDATA:
		InitDataResponseHandler(pData);
		break;

	case MSGID_RESPONSE_MOTION:
		MotionResponseHandler(pData);
		break;

	case MSGID_EVENT_COMMON:
		CommonEventHandler(pData);
		break;

	case MSGID_EVENT_MOTION:
		MotionEventHandler(pData);
		break;

	case MSGID_EVENT_LOG:
		LogEventHandler(pData);
		break;

	case MSGID_COMMAND_CHATMSG:
		ChatMsgHandler(pData);
		break;

	case MSGID_PLAYERITEMLISTCONTENTS:
		InitItemList(pData);
		break;

	case MSGID_NOTIFY:
		NotifyMsgHandler(pData);
		break;

	case MSGID_RESPONSE_CREATENEWGUILD:
		CreateNewGuildResponseHandler(pData);
		break;

	case MSGID_RESPONSE_DISBANDGUILD:
		DisbandGuildResponseHandler(pData);
		break;

	case MSGID_PLAYERCHARACTERCONTENTS:
		InitPlayerCharacteristics(pData);
		break;

	case MSGID_RESPONSE_CIVILRIGHT:
		CivilRightAdmissionHandler(pData);
		break;

	case MSGID_RESPONSE_RETRIEVEITEM:
		RetrieveItemHandler(pData);
		break;

	case MSGID_RESPONSE_PANNING:
		ResponsePanningHandler(pData);
		break;

	case MSGID_RESPONSE_FIGHTZONE_RESERVE:
		ReserveFightzoneResponseHandler(pData);
		break;
	}
}


void CGame::ConnectionEstablishHandler(char cWhere)
{
	ChangeGameMode(DEF_GAMEMODE_ONWAITINGRESPONSE);

	switch (cWhere) {
	case DEF_SERVERTYPE_GAME:
		bSendCommand(MSGID_REQUEST_INITPLAYER, NULL, NULL, NULL, NULL, NULL, NULL);
		break;

	case DEF_SERVERTYPE_LOG:
		switch (m_dwConnectMode) {
		case MSGID_REQUEST_LOGIN:
			bSendCommand(MSGID_REQUEST_LOGIN, NULL, NULL, NULL, NULL, NULL, NULL);
			break;
		case MSGID_REQUEST_CREATENEWACCOUNT:
			bSendCommand(MSGID_REQUEST_CREATENEWACCOUNT, NULL, NULL, NULL, NULL, NULL, NULL);
			break;
		case MSGID_REQUEST_CREATENEWCHARACTER:
			bSendCommand(MSGID_REQUEST_CREATENEWCHARACTER, NULL, NULL, NULL, NULL, NULL, NULL);
			break;
		case MSGID_REQUEST_ENTERGAME:
			bSendCommand(MSGID_REQUEST_ENTERGAME, NULL, NULL, NULL, NULL, NULL, NULL);
			break;
		case MSGID_REQUEST_DELETECHARACTER:
			bSendCommand(MSGID_REQUEST_DELETECHARACTER, NULL, NULL, NULL, NULL, NULL, NULL);
			break;
		case MSGID_REQUEST_CHANGEPASSWORD:
			bSendCommand(MSGID_REQUEST_CHANGEPASSWORD, NULL, NULL, NULL, NULL, NULL, NULL);
			break;
		case MSGID_REQUEST_INPUTKEYCODE:
			bSendCommand(MSGID_REQUEST_INPUTKEYCODE, NULL, NULL, NULL, NULL, NULL, NULL);
			break;
		}
		break;
	}
}

void CGame::InitPlayerResponseHandler(char * pData)
{WORD * wp;
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	switch (*wp) {
	case DEF_MSGTYPE_CONFIRM:
		bSendCommand(MSGID_REQUEST_INITDATA, NULL, NULL, NULL, NULL, NULL, NULL);
		ChangeGameMode(DEF_GAMEMODE_ONWAITINGINITDATA);
		break;

	case DEF_MSGTYPE_REJECT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "3J");
		break;
	}
}

void CGame::UpdateScreen_OnMainMenu()
{ short msX, msY, msZ;
 char cLB, cRB, cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI;
 DWORD dwTime = G_dwGlobalTime;

 m_iItemDropCnt = 0;
 m_bItemDrop = FALSE;

	if (m_cGameModeCount == 0)
	{	if (G_pCalcSocket != NULL)
		{	delete G_pCalcSocket;
			G_pCalcSocket = NULL;
		}
		if ( m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] != NULL )
		{	delete m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING];
			m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING] = NULL;
		}
		EndInputString();
		pMI = new class CMouseInterface;

		// CLEROTH - INTERFACE
		pMI->AddRect(384,177,548,198);
		pMI->AddRect(384,215,548,236);
		pMI->AddRect(384,254,548,275);
		m_DInput.m_sX = 400;
		m_DInput.m_sY = 240;

		m_cCurFocus = 1;
		m_cMaxFocus = 3;

		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	m_DDraw.ClearBackB4();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_MAINMENU, -1, -1, 0, TRUE);

	// CLEROTH
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);

	if ((msX >= 384) && (msY >= 177) && (msX <= 548) && (msY <= 198)) m_cCurFocus = 1;
	if ((msX >= 384) && (msY >= 215) && (msX <= 548) && (msY <= 236)) m_cCurFocus = 2;
	if ((msX >= 384) && (msY >= 254) && (msX <= 548) && (msY <= 275)) m_cCurFocus = 3;

	switch (m_cCurFocus) {

	case 1:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(384 , 177, 1, dwTime);
		break;
	case 2:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(384, 215, 2, dwTime);
		break;

	case 3:
		m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->PutSpriteFast(384, 254, 3, dwTime);
		break;
	}

	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	//m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(msX, msY, 1, 0, 0, 0, dwTime);

	if (m_cArrowPressed != 0) {
	   	switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE) {
		// Enter
		PlaySound('E', 14, 5);
		m_bEnterPressed = FALSE;
		switch (m_cCurFocus) {
		case 1:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			return;
		case 2:
	#ifdef DEF_MAKE_ACCOUNT
			ClearContents_OnSelectCharacter();
			delete pMI;
			//ChangeGameMode(DEF_GAMEMODE_ONAGREEMENT);
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
	#else
			GoHomepage();
	#endif
			return;
		case 3:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			return;
		}
	}

	DrawVersion(TRUE);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);
		m_cCurFocus = iMIbuttonNum;
		switch (iMIbuttonNum)
		{
		case 1:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
			delete pMI;
			break;

		case 2:
	#ifdef DEF_MAKE_ACCOUNT
			ClearContents_OnSelectCharacter();
			delete pMI;
			//ChangeGameMode(DEF_GAMEMODE_ONAGREEMENT);
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
	#else
			GoHomepage();
	#endif
			return;
		case 3:
			delete pMI;
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			return;
		}
	}
//	if ((msX >= 112) && (msY >= 150) && (msX <= 247) && (msY <= 191)) m_cCurFocus = 1;
//	if ((msX >= 73) && (msY >= 192) && (msX <= 281) && (msY <= 230)) m_cCurFocus = 2;
//	if ((msX >= 120) && (msY >= 231) && (msX <= 239) && (msY <= 262)) m_cCurFocus = 3;

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::MakeSprite( char* FileName, short sStart, short sCount, bool bAlphaEffect )
{int iTotalimage;
 DWORD nCount;
 char PathName[28];
	wsprintf( PathName, "sprites\\%s.pak", FileName );
	HANDLE m_hPakFile = CreateFile(PathName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if( m_hPakFile == INVALID_HANDLE_VALUE ) return;
	SetFilePointer(m_hPakFile, 20, NULL, FILE_BEGIN);
	ReadFile(m_hPakFile, (char *)&iTotalimage, 4, &nCount, NULL);
	for( short i=0 ; i < sCount ; i++ )
	{	if( i < iTotalimage ) m_pSprite[i+sStart] = new class CSprite(m_hPakFile, &m_DDraw, FileName, i, bAlphaEffect);
	}
	CloseHandle(m_hPakFile);
}

void CGame::MakeTileSpr( char* FileName, short sStart, short sCount, bool bAlphaEffect )
{int iTotalimage;
 DWORD nCount;
 char PathName[28];
	wsprintf( PathName, "sprites\\%s.pak", FileName );
	HANDLE m_hPakFile = CreateFile(PathName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if( m_hPakFile == INVALID_HANDLE_VALUE ) return;
	SetFilePointer(m_hPakFile, 20, NULL, FILE_BEGIN);
	ReadFile(m_hPakFile, (char *)&iTotalimage, 4, &nCount, NULL);
	for( short i=0 ; i < sCount ; i++ )
	{	if( i < iTotalimage ) m_pTileSpr[i+sStart] = new class CSprite(m_hPakFile, &m_DDraw, FileName, i, bAlphaEffect);
	}
	CloseHandle(m_hPakFile);
}

void CGame::MakeEffectSpr( char* FileName, short sStart, short sCount, bool bAlphaEffect )
{int iTotalimage;
 DWORD nCount;
 char PathName[28];
	wsprintf( PathName, "sprites\\%s.pak", FileName );
	HANDLE m_hPakFile = CreateFile(PathName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if( m_hPakFile == INVALID_HANDLE_VALUE ) return;
	SetFilePointer(m_hPakFile, 20, NULL, FILE_BEGIN);
	ReadFile(m_hPakFile, (char *)&iTotalimage, 4, &nCount, NULL);
	for( short i=0 ; i < sCount ; i++ )
	{	if( i < iTotalimage ) m_pEffectSpr[i+sStart] = new class CSprite(m_hPakFile, &m_DDraw, FileName, i, bAlphaEffect);
	}
	CloseHandle(m_hPakFile);
}

void CGame::UpdateScreen_OnLoading(bool bActive)
{
	int i;
	if( bActive ) UpdateScreen_OnLoading_Progress();

	switch( m_cLoading ) {
	case 0:
		{	m_hPakFile = CreateFile("sprites\\interface.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_MOUSECURSOR] = new class CSprite(m_hPakFile, &m_DDraw, "interface", 0, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS] = new class CSprite(m_hPakFile, &m_DDraw, "interface", 1, FALSE);
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\Newmaps.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS1] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 0, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS2] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 1, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS3] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 2, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS4] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 3, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS5] = new class CSprite(m_hPakFile, &m_DDraw, "Newmaps", 4, FALSE);
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\LoginDialog.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN] = new class CSprite(m_hPakFile, &m_DDraw, "LoginDialog", 0, FALSE);
#ifdef DEF_MAKE_ACCOUNT
				m_pSprite[DEF_SPRID_INTERFACE_ND_NEWACCOUNT] = new class CSprite(m_hPakFile, &m_DDraw, "LoginDialog", 1, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_AGREEMENT] = new class CSprite(m_hPakFile, &m_DDraw, "LoginDialog", 2, FALSE);
#endif
				CloseHandle(m_hPakFile);
			}
#ifdef DEF_MAKE_ACCOUNT			// CLEROTH - ACC - Snoopy: fixed to use without special pak
			m_hPakFile = CreateFile("sprites\\CreateNewAcc.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_ND_NEWACCOUNT] = new class CSprite(m_hPakFile, &m_DDraw, "CreateNewAcc", 0, FALSE);
				CloseHandle(m_hPakFile);
			}else
			{	m_hPakFile = CreateFile("sprites\\New-Dialog.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
				m_pSprite[DEF_SPRID_INTERFACE_ND_NEWACCOUNT] = new class CSprite(m_hPakFile, &m_DDraw, "New-Dialog", 2, FALSE);
				CloseHandle(m_hPakFile);
			}
#endif
			m_hPakFile = CreateFile("sprites\\New-Dialog.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU] = new class CSprite(m_hPakFile, &m_DDraw, "New-Dialog", 1, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_QUIT] = new class CSprite(m_hPakFile, &m_DDraw, "New-Dialog", 2, FALSE);
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\GameDialog.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_ND_GAME1] =      new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 0, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2] =      new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 1, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_GAME3] =      new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 2, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4] =      new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 3, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE] =    new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 4, FALSE);
				//m_pSprite[DEF_SPRID_INTERFACE_GUIDEMAP] =      new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 5, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 6, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_INVENTORY] =  new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 7, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_SELECTCHAR] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 8, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_NEWCHAR] =    new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 9, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_NEWEXCHANGE] = new class CSprite(m_hPakFile, &m_DDraw, "GameDialog", 10, FALSE);
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\DialogText.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_INTERFACE_ND_TEXT] = new class CSprite(m_hPakFile, &m_DDraw, "DialogText", 0, FALSE);
				m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON] = new class CSprite(m_hPakFile, &m_DDraw, "DialogText", 1, FALSE);
				CloseHandle(m_hPakFile);
			}
			MakeSprite( "Telescope", DEF_SPRID_INTERFACE_GUIDEMAP    , 32, FALSE);	  // Snoopy: 20->32

#ifdef DEF_EQUILIBRIUM_PROJECT	// telescope2 
			MakeSprite( "Telescope2", DEF_SPRID_INTERFACE_GUIDEMAP+35, 9 , FALSE); // Snoopy: Ajout.351 (heldenian maps)
#else
			MakeSprite( "Telescope2", DEF_SPRID_INTERFACE_GUIDEMAP+35, 4 , FALSE); // Snoopy: Ajout.351 (heldenian maps)
#endif

			MakeSprite( "monster", DEF_SPRID_INTERFACE_MONSTER, 1, FALSE);
			m_cLoading = 4;
		}
		break;
	case 4:
		{	MakeTileSpr( "maptiles1", 0, 32, TRUE);

#ifdef DEF_EQUILIBRIUM_PROJECT	// Structures1
			MakeTileSpr( "structures1", 50, 20, TRUE);
#else
			m_hPakFile = CreateFile("sprites\\structures1.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); //¾È¾²´Â Å¸ÀÏ ·Îµù ¾ÈÇÑ´Ù.2002.09.06»óÇÏ
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pTileSpr[1 + 50] = new class CSprite(m_hPakFile, &m_DDraw, "structures1",  1, TRUE);
				m_pTileSpr[5 + 50] = new class CSprite(m_hPakFile, &m_DDraw, "structures1",  5, TRUE);
				CloseHandle(m_hPakFile);
			}
#endif
			MakeTileSpr( "Sinside1", 70, 27, FALSE);
			MakeTileSpr( "Trees1", 100, 46, TRUE);
			MakeTileSpr( "TreeShadows", 150, 46, TRUE);
			MakeTileSpr( "objects1", 200, 10, TRUE); // snoopy: 8->10
			MakeTileSpr( "objects2", 211, 5, TRUE);
			MakeTileSpr( "objects3", 216, 4, TRUE);
			MakeTileSpr( "objects4", 220, 2, TRUE); //snoopy: 1->2
			m_cLoading = 8;
		}
		break;
	case 8:
		{	MakeTileSpr( "Tile223-225", 223, 3, TRUE);
			MakeTileSpr( "Tile226-229", 226, 4, TRUE);
			MakeTileSpr( "objects5", 230, 9, TRUE);	// Snoopy
			MakeTileSpr( "objects6", 238, 4, TRUE);	// Snoopy
			MakeTileSpr( "objects7", 242, 7, TRUE);	// Snoopy
			MakeTileSpr( "maptiles2", 300, 15, TRUE);//- Index 300
#ifdef DEF_EQUILIBRIUM_PROJECT	// maptiles3
			MakeTileSpr( "maptiles3", 315, 5, TRUE); // Add by Snoopy
#endif
			MakeTileSpr( "maptiles4", 320, 10, TRUE);
			MakeTileSpr( "maptiles5", 330, 19, TRUE);
			MakeTileSpr( "maptiles6", 349, 4, TRUE);
			MakeTileSpr( "maptiles353-361", 353, 9, TRUE);
			MakeTileSpr( "Tile363-366", 363, 4, TRUE);
			MakeTileSpr( "Tile367-367", 367, 1, TRUE); // Add by Snoopy (fountains)
			MakeTileSpr( "Tile370-381", 370, 12, TRUE);// Tile370~381
			MakeTileSpr( "Tile382-387", 382, 6, TRUE);
			MakeTileSpr( "Tile388-402", 388, 15, TRUE);
			m_cLoading = 12;
		}
		break;
	case 12:
		{
			MakeTileSpr( "Tile403-405", 403, 3, TRUE);
			MakeTileSpr( "Tile406-421", 406, 16, TRUE);
			MakeTileSpr( "Tile422-429", 422, 8, TRUE);
			MakeTileSpr( "Tile430-443", 430, 14, TRUE);
			MakeTileSpr( "Tile444-444", 444, 1, TRUE);
			MakeTileSpr( "Tile445-461",	445, 17, TRUE);
			MakeTileSpr( "Tile462-473",	462, 12, TRUE);	// Diuuude
			MakeTileSpr( "Tile474-478",	474, 5, TRUE);	// Diuuude
			MakeTileSpr( "Tile479-488",	479, 10, TRUE);	// Diuuude
			MakeTileSpr( "Tile489-522",	489, 34, TRUE);	// Diuuude Drunken City
			MakeTileSpr( "Tile523-530",	523, 8, TRUE);	// Diuuude Rampart
			MakeTileSpr( "Tile531-540",	531, 10, TRUE);	// Diuuude GodH + Pont
			MakeTileSpr( "Tile541-545",	541, 5, TRUE);	// Diuuude GodH

			// DEF_SPRID_ITEMPACK_PIVOTPOINT+0
			MakeSprite( "item-pack", DEF_SPRID_ITEMPACK_PIVOTPOINT+1, 27, FALSE);
			m_hPakFile = CreateFile("sprites\\item-pack.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT+20] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 17, FALSE); //
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT+21] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 18, FALSE); //
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT+22] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 19, FALSE); // Angels
				CloseHandle(m_hPakFile);
			}

			// DEF_SPRID_ITEMGROUND_PIVOTPOINT+1
			MakeSprite( "item-ground", DEF_SPRID_ITEMGROUND_PIVOTPOINT+1, 19, FALSE);
			m_hPakFile = CreateFile("sprites\\item-ground.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE )
			{	m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT+20] = new class CSprite(m_hPakFile, &m_DDraw, "item-ground", 17, FALSE);
				m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT+21] = new class CSprite(m_hPakFile, &m_DDraw, "item-ground", 18, FALSE);
				m_pSprite[DEF_SPRID_ITEMGROUND_PIVOTPOINT+22] = new class CSprite(m_hPakFile, &m_DDraw, "item-ground", 19, FALSE);//Angels
				CloseHandle(m_hPakFile);
			}
			MakeSprite( "item-dynamic", DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT, 3, FALSE);// Snoopy 2-> 3 (flags)

#ifdef DEF_EQUILIBRIUM_PROJECT  // Dynamic items, statues DEF_DYNAMICOBJECT_STATUE1
			m_hPakFile = CreateFile("sprites\\Objects6.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) 
			{	m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+3] = new class CSprite(m_hPakFile, &m_DDraw, "Objects6", 0, FALSE);
				m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+4] = new class CSprite(m_hPakFile, &m_DDraw, "Objects6", 2, FALSE);
				CloseHandle(m_hPakFile);
			}
			m_hPakFile = CreateFile("sprites\\Objects1.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) 
			{	m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+5] = new class CSprite(m_hPakFile, &m_DDraw, "Objects1", 5, FALSE);
				CloseHandle(m_hPakFile);
			}
			m_hPakFile = CreateFile("sprites\\Objects2.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) 
			{	m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+6] = new class CSprite(m_hPakFile, &m_DDraw, "Objects2", 1, FALSE);
				m_pSprite[DEF_SPRID_ITEMDYNAMIC_PIVOTPOINT+7] = new class CSprite(m_hPakFile, &m_DDraw, "Objects2", 4, FALSE);
				CloseHandle(m_hPakFile);
			}
#endif
			m_cLoading = 16;
		}
		break;
	case 16:
		{
			m_hPakFile = CreateFile("sprites\\item-equipM.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 0] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 0, FALSE);	// body
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 1] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 1, FALSE);	// 1-swords
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 2] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 2, FALSE);	// 2-bows
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 3] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 3, FALSE);	// 3-shields
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 4] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 4, FALSE);	// 4-tunics
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 5] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 5, FALSE);	// 5-shoes
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 7] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 6, FALSE);	// 6-berk
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 8] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 7, FALSE);	// 7-hoses
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 9] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 8, FALSE);	// 8-bodyarmor
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 15] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 11, FALSE); // Axe hammer
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 17] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 12, FALSE); // Wands
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 9, FALSE);  // hair
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 10, FALSE); // undies
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 20] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 13, FALSE); // capes
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 21] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipM", 14, FALSE); // helm
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\item-pack.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) 
			{	m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 16] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 15); // Necks
				//Snoopy: Angels pandents
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 22] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 19); // Angels
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\item-equipW.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 40] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 0, FALSE); // body
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 41] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 1, FALSE); // 1-swords
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 42] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 2, FALSE); // 2-bows
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 43] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 3, FALSE); // 3-shields
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 45] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 4, FALSE); // 4-shoes
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 50] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 5, FALSE); // 5-Soustif
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 51] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 6, FALSE); // 6 berk
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 52] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 7, FALSE); // 7 hose
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 53] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 8, FALSE); // 8-hoses
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 55] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 11, FALSE); // Axe hammer
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 57] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 12, FALSE); // Wands
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 58] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 9, FALSE); // hair
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 59] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 10, FALSE);// undies
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 60] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 13, FALSE);// capes
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 61] = new class CSprite(m_hPakFile, &m_DDraw, "item-equipW", 14, FALSE);// helm
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\item-pack.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 56] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 15);// necks
				//Snoopy: Angels pandents
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 62] = new class CSprite(m_hPakFile, &m_DDraw, "item-pack", 19); // Angels
				CloseHandle(m_hPakFile);
			}
			MakeSprite( "Bm", 500 + 15*8*0, 96, TRUE);// Black Man (Type: 1)
			MakeSprite( "Wm", 500 + 15*8*1, 96, TRUE);// White Man (Type: 2)
			MakeSprite( "Ym", 500 + 15*8*2, 96, TRUE);// Yellow Man (Type: 3)
			m_cLoading = 20;
		}
		break;
	case 20:
		{	MakeSprite( "TutelarAngel1", DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + 50*0, 48, FALSE);//(STR)
			MakeSprite( "TutelarAngel2", DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + 50*1, 48, FALSE);//(DEX)
			MakeSprite( "TutelarAngel3", DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + 50*2, 48, FALSE);//(INT)
			MakeSprite( "TutelarAngel4", DEF_SPRID_TUTELARYANGELS_PIVOTPOINT + 50*3, 48, FALSE);//(MAG)
			MakeSprite( "Bw", 500 + 15*8*3, 96, TRUE);// Black Woman (Type: 4)
			MakeSprite( "Ww", 500 + 15*8*4, 96, TRUE);// White Woman (Type: 5)
			MakeSprite( "Yw", 500 + 15*8*5, 96, TRUE);// Yellow Woman (Type: 6)
			m_cLoading = 24;
		}
		break;
	case 24:
		{	MakeSprite( "slm",		  DEF_SPRID_MOB   + 7*8*0, 40, TRUE);// Slime (Type: 10)
			MakeSprite( "ske",		  DEF_SPRID_MOB   + 7*8*1, 40, TRUE);// Skeleton (Type: 11)
			MakeSprite( "Gol",		  DEF_SPRID_MOB   + 7*8*2, 40, TRUE);// Stone-Golem (Type: 12)
			MakeSprite( "Cyc",		  DEF_SPRID_MOB   + 7*8*3, 40, TRUE);// Cyclops (Type: 13)
			MakeSprite( "Orc",		  DEF_SPRID_MOB   + 7*8*4, 40, TRUE);// Orc (Type: 14)
			MakeSprite( "Shopkpr",	  DEF_SPRID_MOB   + 7*8*5,  8);		// ShopKeeper-Woman (Type: 15)
			MakeSprite( "Ant",		  DEF_SPRID_MOB   + 7*8*6, 40, TRUE);//  Giant-Ant (Type: 16)
			MakeSprite( "Scp",		  DEF_SPRID_MOB   + 7*8*7, 40, TRUE);//  Scorpion (Type: 17)
			MakeSprite( "Zom",		  DEF_SPRID_MOB   + 7*8*8, 40, TRUE);//  Zombie (Type: 18)
			MakeSprite( "Gandlf",	  DEF_SPRID_MOB   + 7*8*9,  8, TRUE);// Gandalf ¸ (Type: 19)
			MakeSprite( "Howard",	  DEF_SPRID_MOB   + 7*8*10, 8, TRUE);// Howard º¸°ü¼Ò ÁÖÀÎ (Type: 20)
			MakeSprite( "Guard",	  DEF_SPRID_MOB   + 7*8*11, 40, TRUE);// Guard (Type: 21)
			MakeSprite( "Amp",		  DEF_SPRID_MOB   + 7*8*12, 40, TRUE);// Amphis (Type: 22)
			MakeSprite( "Cla",		  DEF_SPRID_MOB   + 7*8*13, 40, TRUE);// Clay-Golem (Type: 23)
			MakeSprite( "tom",		  DEF_SPRID_MOB   + 7*8*14,  8, TRUE);// Tom (Type: 24)
			MakeSprite( "William",	  DEF_SPRID_MOB   + 7*8*15,  8, TRUE);// William (Type: 25)
			m_cLoading = 28;
		}
		break;
	case 28:
		{	MakeSprite( "Kennedy",	  DEF_SPRID_MOB   + 7*8*16,  8, TRUE);// Kennedy (Type: 26)
			MakeSprite( "Helb",		  DEF_SPRID_MOB   + 7*8*17, 40, TRUE);// Hellbound (Type: 27)
			MakeSprite( "Troll",	  DEF_SPRID_MOB   + 7*8*18, 40, TRUE);// Troll (Type: 28)
			MakeSprite( "Orge",		  DEF_SPRID_MOB   + 7*8*19, 40, TRUE);// Orge (Type: 29)
			MakeSprite( "Liche",	  DEF_SPRID_MOB   + 7*8*20, 40, TRUE);// Liche (Type: 30)
			MakeSprite( "Demon",	  DEF_SPRID_MOB   + 7*8*21, 40, TRUE);// Demon (Type: 31)
			MakeSprite( "Unicorn",	  DEF_SPRID_MOB   + 7*8*22, 40, TRUE);// Unicorn (Type: 32)
			MakeSprite( "WereWolf",	  DEF_SPRID_MOB   + 7*8*23, 40, TRUE);// WereWolf (Type: 33)
			MakeSprite( "Dummy",	  DEF_SPRID_MOB   + 7*8*24, 40, TRUE);// Dummy (Type: 34)
			m_hPakFile = CreateFile("sprites\\Effect5.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); // Energy-Ball (Type: 35)
			if( m_hPakFile != INVALID_HANDLE_VALUE )
			{	for (i = 0; i < 40; i++)
					m_pSprite[  DEF_SPRID_MOB + i + 7*8*25] = new class CSprite(m_hPakFile, &m_DDraw, "Effect5", 0, TRUE);

				CloseHandle(m_hPakFile);
			}
			m_cLoading = 32;
		}
		break;
	case 32:
		{MakeSprite( "GT-Arrow",		  DEF_SPRID_MOB   + 7*8*26, 40, TRUE);// Arrow-GuardTower (Type: 36)
			MakeSprite( "GT-Cannon",	  DEF_SPRID_MOB   + 7*8*27, 40, TRUE);// Cannon-GuardTower (Type: 37)
			MakeSprite( "ManaCollector",  DEF_SPRID_MOB   + 7*8*28, 40, TRUE);// Mana Collector (Type: 38)
			MakeSprite( "Detector",		  DEF_SPRID_MOB   + 7*8*29, 40, TRUE);// Detector (Type: 39)
			MakeSprite( "ESG",			  DEF_SPRID_MOB   + 7*8*30, 40, TRUE);// ESG (Type: 40)
			MakeSprite( "GMG",			  DEF_SPRID_MOB   + 7*8*31, 40, TRUE);// GMG (Type: 41)
			MakeSprite( "ManaStone",	  DEF_SPRID_MOB   + 7*8*32, 40, TRUE);// ManaStone (Type: 42)
			MakeSprite( "LWB",			  DEF_SPRID_MOB   + 7*8*33, 40, TRUE);// Light War Beetle (Type: 43)
			MakeSprite( "GHK",		  DEF_SPRID_MOB   + 7*8*34, 40, TRUE);// God's Hand Knight (Type: 44)
			MakeSprite( "GHKABS",	  DEF_SPRID_MOB   + 7*8*35, 40, TRUE);// God's Hand Knight with Armored Battle Steed (Type: 45)
			MakeSprite( "TK",		  DEF_SPRID_MOB   + 7*8*36, 40, TRUE);// Temple Knight (Type: 46)
			MakeSprite( "BG",		  DEF_SPRID_MOB   + 7*8*37, 40, TRUE);// Battle Golem (Type: 47)
			m_cLoading = 36;
		}
		break;
	case 36:
		{
			MakeSprite( "Stalker",	  DEF_SPRID_MOB   + 7*8*38, 40, TRUE);// Stalker (Type: 48)
			MakeSprite( "Hellclaw",	  DEF_SPRID_MOB   + 7*8*39, 40, TRUE);// Hellclaw (Type: 49)
			MakeSprite( "Tigerworm",  DEF_SPRID_MOB   + 7*8*40, 40, TRUE);// Tigerworm (Type: 50)
			MakeSprite( "Catapult",	  DEF_SPRID_MOB   + 7*8*41, 40, TRUE);// Catapult (Type: 51)
			MakeSprite( "Gagoyle",	  DEF_SPRID_MOB   + 7*8*42, 40, TRUE);// Gargoyle (Type: 52)
			MakeSprite( "Beholder",	  DEF_SPRID_MOB   + 7*8*43, 40, TRUE);// Beholder (Type: 53)
			MakeSprite( "DarkElf",	  DEF_SPRID_MOB   + 7*8*44, 40, TRUE);// Dark-Elf (Type: 54)
			MakeSprite( "Bunny",	  DEF_SPRID_MOB   + 7*8*45, 40, TRUE);// Bunny (Type: 55)
			MakeSprite( "Cat",		  DEF_SPRID_MOB   + 7*8*46, 40, TRUE);// Cat (Type: 56)
			MakeSprite( "GiantFrog",  DEF_SPRID_MOB   + 7*8*47, 40, TRUE);// GiantFrog (Type: 57)
			MakeSprite( "MTGiant",	  DEF_SPRID_MOB   + 7*8*48, 40, TRUE);// Mountain Giant (Type: 58)
			m_cLoading = 40;
		}
		break;
	case 40:
		{	MakeSprite( "Ettin",	  DEF_SPRID_MOB   + 7*8*49, 40, TRUE);// Ettin (Type: 59)
			MakeSprite( "CanPlant",	  DEF_SPRID_MOB   + 7*8*50, 40, TRUE);// Cannibal Plant (Type: 60)
			MakeSprite( "Rudolph",	  DEF_SPRID_MOB   + 7*8*51, 40, TRUE);// Rudolph (Type: 61)
			MakeSprite( "DireBoar",	  DEF_SPRID_MOB   + 7*8*52, 40, TRUE);// Boar (Type: 62)
			MakeSprite( "frost",	  DEF_SPRID_MOB   + 7*8*53, 40, TRUE);// Frost (Type: 63)
			MakeSprite( "Crop",		  DEF_SPRID_MOB   + 7*8*54, 40, TRUE);// Crop(Type: 64)
			MakeSprite( "IceGolem",	  DEF_SPRID_MOB   + 7*8*55, 40, TRUE);// IceGolem (Type: 65)
			MakeSprite( "Wyvern",	  DEF_SPRID_MOB   + 7*8*56, 24, TRUE);// Wyvern (Type: 66)
			MakeSprite( "McGaffin",	  DEF_SPRID_MOB   + 7*8*57, 16, TRUE);// McGaffin (Type: 67)
			MakeSprite( "Perry",	  DEF_SPRID_MOB   + 7*8*58, 16, TRUE);// Perry (Type: 68)
			MakeSprite( "Devlin",	  DEF_SPRID_MOB   + 7*8*59, 16, TRUE);// Devlin (Type: 69)
			MakeSprite( "Barlog",		  DEF_SPRID_MOB   + 7*8*60, 40, TRUE);// Barlog (Type: 70)
			MakeSprite( "Centaurus",	  DEF_SPRID_MOB   + 7*8*61, 40, TRUE);// Centaurus (Type: 71)
			MakeSprite( "ClawTurtle",	  DEF_SPRID_MOB   + 7*8*62, 40, TRUE);// Claw-Turtle (Type: 72)
			MakeSprite( "FireWyvern",	  DEF_SPRID_MOB   + 7*8*63, 24, TRUE);// Fire-Wyvern (Type: 73)
			MakeSprite( "GiantCrayfish",  DEF_SPRID_MOB   + 7*8*64, 40, TRUE);// Giant-Crayfish (Type: 74)
			MakeSprite( "GiantLizard",	  DEF_SPRID_MOB   + 7*8*65, 40, TRUE);// Giant-Lizard (Type: 75)
			m_cLoading = 44;
		}
		break;
	case 44:
		{	// New NPCs - Diuuude - fixed by Snoopy
			MakeSprite( "GiantPlant",	  DEF_SPRID_MOB   + 7*8*66, 40, TRUE);// Giant-Plant (Type: 76)
			MakeSprite( "MasterMageOrc",  DEF_SPRID_MOB   + 7*8*67, 40, TRUE);// MasterMage-Orc (Type: 77)
			MakeSprite( "Minotaurs",	  DEF_SPRID_MOB   + 7*8*68, 40, TRUE);// Minotaurs (Type: 78)
			MakeSprite( "Nizie",		  DEF_SPRID_MOB   + 7*8*69, 40, TRUE);// Nizie (Type: 79)
			MakeSprite( "Tentocle",		  DEF_SPRID_MOB   + 7*8*70, 40, TRUE);// Tentocle (Type: 80)
			MakeSprite( "yspro",		  DEF_SPRID_MOB   + 7*8*71, 32, TRUE);// Abaddon (Type: 81)
			MakeSprite( "Sorceress",	  DEF_SPRID_MOB   + 7*8*72, 40, TRUE);// Sorceress (Type: 82)
			MakeSprite( "TPKnight",		  DEF_SPRID_MOB   + 7*8*73, 40, TRUE);// TPKnight (Type: 83)
			MakeSprite( "ElfMaster",	  DEF_SPRID_MOB   + 7*8*74, 40, TRUE);// ElfMaster (Type: 84)
			MakeSprite( "DarkKnight",	  DEF_SPRID_MOB   + 7*8*75, 40, TRUE);// DarkKnight (Type: 85)
			MakeSprite( "HBTank",		  DEF_SPRID_MOB   + 7*8*76, 32, TRUE);// HeavyBattleTank (Type: 86)
			MakeSprite( "CBTurret",		  DEF_SPRID_MOB   + 7*8*77, 32, TRUE);// CBTurret (Type: 87)
			MakeSprite( "Babarian",		  DEF_SPRID_MOB   + 7*8*78, 40, TRUE);// Babarian (Type: 88)
			MakeSprite( "ACannon",		  DEF_SPRID_MOB   + 7*8*79, 32, TRUE);// ACannon (Type: 89)
			m_cLoading = 48;
		}
		break;
	case 48:
		{	MakeSprite( "Gail",			  DEF_SPRID_MOB   + 7*8*80, 8, TRUE); // Gail (Type: 90)
			MakeSprite( "Gate",			  DEF_SPRID_MOB   + 7*8*81, 24, TRUE);// Heldenian Gate (Type: 91)/**/

			m_hPakFile = CreateFile("sprites\\Effect14.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); // Willowisp (Type: 95)
			if( m_hPakFile != INVALID_HANDLE_VALUE )
			{	for (i = 0; i < 32; i++)
					m_pSprite[  DEF_SPRID_MOB + i + 7*8*85] = new class CSprite(m_hPakFile, &m_DDraw, "Effect14", 4, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_hPakFile = CreateFile("sprites\\Effect14.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); // Willowisp dying(Type: 95)
			if( m_hPakFile != INVALID_HANDLE_VALUE )
			{	for (i = 32; i < 40; i++)
					m_pSprite[  DEF_SPRID_MOB + i + 7*8*85] = new class CSprite(m_hPakFile, &m_DDraw, "Effect14", 3, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_hPakFile = CreateFile("sprites\\Effect13.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); // Air Elemental (Type: 96)
			if( m_hPakFile != INVALID_HANDLE_VALUE )
			{	for (i = 0; i < 40; i++)
					m_pSprite[  DEF_SPRID_MOB + i + 7*8*86] = new class CSprite(m_hPakFile, &m_DDraw, "Effect13", 2, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_hPakFile = CreateFile("sprites\\Effect.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); // Fire Elemental (Type: 97)
			if( m_hPakFile != INVALID_HANDLE_VALUE )
			{	for (i = 0; i < 40; i++)
					m_pSprite[  DEF_SPRID_MOB + i + 7*8*87] = new class CSprite(m_hPakFile, &m_DDraw, "Effect", 9, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_hPakFile = CreateFile("sprites\\Effect3.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); // Ice Elemental (Type: 99)
			if( m_hPakFile != INVALID_HANDLE_VALUE )
			{	for (i = 0; i < 40; i++)
					m_pSprite[  DEF_SPRID_MOB + i + 7*8*89] = new class CSprite(m_hPakFile, &m_DDraw, "Effect3", 0, TRUE);
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\Mpt.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE )
			{	for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15*0] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*0, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15*1] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*1, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15*2] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*2, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15*3] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*3, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15*4] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*4, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15*5] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*5, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15*6] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*6, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_M + i + 15*7] = new class CSprite(m_hPakFile, &m_DDraw, "Mpt", i + 12*7, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_cLoading = 52;
		}
		break;

	case 52:
		{	m_hPakFile = CreateFile("sprites\\Mhr.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE )
			{	for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15*0] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*0, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15*1] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*1, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15*2] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*2, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15*3] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*3, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15*4] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*4, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15*5] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*5, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15*6] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*6, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_M + i + 15*7] = new class CSprite(m_hPakFile, &m_DDraw, "Mhr", i + 12*7, TRUE);
				CloseHandle(m_hPakFile);
			}
			MakeSprite( "MLArmor",	DEF_SPRID_BODYARMOR_M + 15*1, 12, TRUE);
			MakeSprite( "MCMail",	DEF_SPRID_BODYARMOR_M + 15*2, 12, TRUE);
			MakeSprite( "MSMail",	DEF_SPRID_BODYARMOR_M + 15*3, 12, TRUE);
			MakeSprite( "MPMail",	DEF_SPRID_BODYARMOR_M + 15*4, 12, TRUE);
			MakeSprite( "Mtunic",	DEF_SPRID_BODYARMOR_M + 15*5, 12, TRUE);
			MakeSprite( "MRobe1",	DEF_SPRID_BODYARMOR_M + 15*6, 12, TRUE);
			MakeSprite( "MSanta",	DEF_SPRID_BODYARMOR_M + 15*7, 12, TRUE);
			MakeSprite( "MHRobe1",	DEF_SPRID_BODYARMOR_M + 15*10, 12, TRUE); //hero
			MakeSprite( "MHRobe2",	DEF_SPRID_BODYARMOR_M + 15*11, 12, TRUE); //hero
			MakeSprite( "MHPMail1",	DEF_SPRID_BODYARMOR_M + 15*8, 12, TRUE);  //hero
			MakeSprite( "MHPMail2",	DEF_SPRID_BODYARMOR_M + 15*9, 12, TRUE);  //hero

#ifdef DEF_EQUILIBRIUM_PROJECT // armures executor
			MakeSprite( "MHRobe3",	  DEF_SPRID_BODYARMOR_M + 15*13, 12, TRUE); //executor
			MakeSprite( "WHRobe3",	  DEF_SPRID_BODYARMOR_W + 15*13, 12, TRUE); //executor
			MakeSprite( "WHPMail3",	  DEF_SPRID_BODYARMOR_W + 15*14, 12, TRUE); //executor
			MakeSprite( "MHPMail3",	  DEF_SPRID_BODYARMOR_M + 15*14, 12, TRUE); //executor

			MakeSprite( "MHHelm3",    DEF_SPRID_HEAD_M + 15*13, 12, TRUE);		//executor
			MakeSprite( "WHHelm3",	  DEF_SPRID_HEAD_W + 15*13, 12, TRUE);		//executor

			MakeSprite( "MHHauberk3", DEF_SPRID_BERK_M + 15*6, 12, TRUE);		//executor			
			MakeSprite( "WHHauberk3", DEF_SPRID_BERK_W + 15*6, 12, TRUE);		//executor

			MakeSprite( "MHLeggings3",DEF_SPRID_LEGG_M + 15*8, 12, TRUE);		//executor
			MakeSprite( "WHLeggings3",DEF_SPRID_LEGG_W + 15*8, 12, TRUE);		//executor
#endif

			MakeSprite( "MShirt",	  DEF_SPRID_BERK_M + 15*1, 12, TRUE);
			MakeSprite( "MHauberk",	  DEF_SPRID_BERK_M + 15*2, 12, TRUE);
			MakeSprite( "MHHauberk1", DEF_SPRID_BERK_M + 15*3, 12, TRUE);
			MakeSprite( "MHHauberk2", DEF_SPRID_BERK_M + 15*4, 12, TRUE);
			m_cLoading = 56;
		}
		break;
	case 56:
		{	MakeSprite( "MTrouser",	DEF_SPRID_LEGG_M + 15*1, 12, TRUE);
			MakeSprite( "MHTrouser",DEF_SPRID_LEGG_M + 15*2, 12, TRUE);
			MakeSprite( "MCHoses",	DEF_SPRID_LEGG_M + 15*3, 12, TRUE);
			MakeSprite( "MLeggings",DEF_SPRID_LEGG_M + 15*4, 12, TRUE);
			MakeSprite( "MHLeggings1",	DEF_SPRID_LEGG_M + 15*5, 12, TRUE); // hero
			MakeSprite( "MHLeggings2",DEF_SPRID_LEGG_M + 15*6, 12, TRUE); // hero
			MakeSprite( "MShoes",	DEF_SPRID_BOOT_M + 15*1, 12, TRUE);
			MakeSprite( "MLBoots",	DEF_SPRID_BOOT_M + 15*2, 12, TRUE);
			m_hPakFile = CreateFile("sprites\\Msw.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) 
			{	for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64*1] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*0, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64*2] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*1, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64*3] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*2, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64*4] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*3, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64*5] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*4, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64*6] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*5, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64*7] = new class CSprite(m_hPakFile, &m_DDraw,  "Msw", i + 56*6, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64*8] = new class CSprite(m_hPakFile, &m_DDraw,  "Msw", i + 56*7, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64*9] = new class CSprite(m_hPakFile, &m_DDraw,  "Msw", i + 56*8, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64*10] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*9, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64*11] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*10, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64*12] = new class CSprite(m_hPakFile, &m_DDraw, "Msw", i + 56*11, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_cLoading = 60;
		}
		break;
	case 60:
#ifdef DEF_EQUILIBRIUM_PROJECT  // men swd paks
		{	MakeSprite( "Mswx",			DEF_SPRID_WEAPON_M + 64*9, 56, TRUE);
#else
		{	MakeSprite( "Mswx",			DEF_SPRID_WEAPON_M + 64*5, 56, TRUE);
#endif
			MakeSprite( "Msw2",			DEF_SPRID_WEAPON_M + 64*13, 56, TRUE);
            MakeSprite( "Msw3",			DEF_SPRID_WEAPON_M + 64*14, 56, TRUE);
			MakeSprite( "MStormBringer",DEF_SPRID_WEAPON_M + 64*15, 56, TRUE);
			MakeSprite( "MDarkExec",	DEF_SPRID_WEAPON_M + 64*16, 56, TRUE);
			MakeSprite( "MKlonessBlade",DEF_SPRID_WEAPON_M + 64*17, 56, TRUE);
			MakeSprite( "MKlonessAstock",DEF_SPRID_WEAPON_M + 64*18, 56, TRUE);
			MakeSprite( "MDebastator",	DEF_SPRID_WEAPON_M + 64*19, 56, TRUE);
			MakeSprite( "MAxe1",		DEF_SPRID_WEAPON_M + 64*20, 56, TRUE);// Axe
			MakeSprite( "MAxe2",		DEF_SPRID_WEAPON_M + 64*21, 56, TRUE);
			MakeSprite( "MAxe3",		DEF_SPRID_WEAPON_M + 64*22, 56, TRUE);
			MakeSprite( "MAxe4",		DEF_SPRID_WEAPON_M + 64*23, 56, TRUE);
			MakeSprite( "MAxe5",		DEF_SPRID_WEAPON_M + 64*24, 56, TRUE);
			MakeSprite( "MPickAxe1",	DEF_SPRID_WEAPON_M + 64*25, 56, TRUE);
			MakeSprite( "MAxe6",		DEF_SPRID_WEAPON_M + 64*26, 56, TRUE);
			MakeSprite( "Mhoe",			DEF_SPRID_WEAPON_M + 64*27, 56, TRUE);
			MakeSprite( "MKlonessAxe",	DEF_SPRID_WEAPON_M + 64*28, 56, TRUE);
			MakeSprite( "MLightBlade",	DEF_SPRID_WEAPON_M + 64*29, 56, TRUE);
			m_cLoading = 64;
		}
		break;
	case 64:
		{	MakeSprite( "MHammer",		DEF_SPRID_WEAPON_M + 64*30, 56, TRUE);
			MakeSprite( "MBHammer",		DEF_SPRID_WEAPON_M + 64*31, 56, TRUE);
			MakeSprite( "MBabHammer",	DEF_SPRID_WEAPON_M + 64*32, 56, TRUE);
			MakeSprite( "MBShadowSword",DEF_SPRID_WEAPON_M + 64*33, 56, TRUE);
			MakeSprite( "MBerserkWand", DEF_SPRID_WEAPON_M + 64*34, 56, TRUE);
			MakeSprite( "Mstaff1",		DEF_SPRID_WEAPON_M + 64*35, 56, TRUE);// Staff
			MakeSprite( "Mstaff2",		DEF_SPRID_WEAPON_M + 64*36, 56, TRUE);
			MakeSprite( "MStaff3",		DEF_SPRID_WEAPON_M + 64*37, 56, TRUE);
			MakeSprite( "MReMagicWand", DEF_SPRID_WEAPON_M + 64*38, 56, TRUE);
			MakeSprite( "MKlonessWand", DEF_SPRID_WEAPON_M + 64*39, 56, TRUE);
			// Bows 40 41 below
			MakeSprite( "MDirectBow",	DEF_SPRID_WEAPON_M + 64*42, 56, TRUE);
			MakeSprite( "MFireBow",		DEF_SPRID_WEAPON_M + 64*43, 56, TRUE);
			m_cLoading = 68;
		}
		break;
	case 68:
		{	MakeSprite( "Mbo", DEF_SPRID_WEAPON_M + 64*40, 56, TRUE);
			m_hPakFile = CreateFile("sprites\\Mbo.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE )
			{	for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_M + i + 64*41] = new class CSprite(m_hPakFile, &m_DDraw, "Mbo", i + 56*1, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_hPakFile = CreateFile("sprites\\Msh.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE )
			{	for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8*1] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*0, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8*2] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*1, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8*3] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*2, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8*4] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*3, TRUE);
				for (i = 0; i < 7; i++)	m_pSprite[DEF_SPRID_SHIELD_M + i + 8*5] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*4, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8*6] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*5, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8*7] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*6, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8*8] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*7, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_M + i + 8*9] = new class CSprite(m_hPakFile, &m_DDraw, "Msh", i + 7*8, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_cLoading = 72;
		}
		break;
	case 72:
		{	MakeSprite( "Mmantle01", DEF_SPRID_MANTLE_M + 15*1, 12, TRUE);
			MakeSprite( "Mmantle02", DEF_SPRID_MANTLE_M + 15*2, 12, TRUE);
			MakeSprite( "Mmantle03", DEF_SPRID_MANTLE_M + 15*3, 12, TRUE);
			MakeSprite( "Mmantle04", DEF_SPRID_MANTLE_M + 15*4, 12, TRUE);
			MakeSprite( "Mmantle05", DEF_SPRID_MANTLE_M + 15*5, 12, TRUE);
			MakeSprite( "Mmantle06", DEF_SPRID_MANTLE_M + 15*6, 12, TRUE);
			MakeSprite( "MHelm1", DEF_SPRID_HEAD_M + 15*1, 12, TRUE);
			MakeSprite( "MHelm2", DEF_SPRID_HEAD_M + 15*2, 12, TRUE);
			MakeSprite( "MHelm3", DEF_SPRID_HEAD_M + 15*3, 12, TRUE);
			MakeSprite( "MHelm4", DEF_SPRID_HEAD_M + 15*4, 12, TRUE);
			MakeSprite( "MHCap1", DEF_SPRID_HEAD_M + 15*11, 12, TRUE);
			MakeSprite( "MHCap2", DEF_SPRID_HEAD_M + 15*12, 12, TRUE);
			MakeSprite( "MHHelm1", DEF_SPRID_HEAD_M + 15*9, 12, TRUE);
			MakeSprite( "MHHelm2", DEF_SPRID_HEAD_M + 15*10, 12, TRUE);
			MakeSprite( "NMHelm1", DEF_SPRID_HEAD_M + 15*5, 12, TRUE);
			MakeSprite( "NMHelm2", DEF_SPRID_HEAD_M + 15*6, 12, TRUE);
			MakeSprite( "NMHelm3", DEF_SPRID_HEAD_M + 15*7, 12, TRUE);
			MakeSprite( "NMHelm4", DEF_SPRID_HEAD_M + 15*8, 12, TRUE);
			m_cLoading = 76;
		}
		break;
	case 76:
		{	m_hPakFile = CreateFile("sprites\\Wpt.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15*0] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15*1] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15*2] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12*2, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15*3] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12*3, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15*4] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12*4, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15*5] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12*5, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15*6] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12*6, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_UNDIES_W + i + 15*7] = new class CSprite(m_hPakFile, &m_DDraw, "Wpt", i + 12*7, TRUE);
				CloseHandle(m_hPakFile);
			}

			m_hPakFile = CreateFile("sprites\\Whr.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15*0] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 0, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15*1] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15*2] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12*2, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15*3] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12*3, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15*4] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12*4, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15*5] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12*5, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15*6] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12*6, TRUE);
				for (i = 0; i < 12; i++) m_pSprite[DEF_SPRID_HAIR_W + i + 15*7] = new class CSprite(m_hPakFile, &m_DDraw, "Whr", i + 12*7, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_cLoading = 80;
		}
		break;
	case 80:
		{
			MakeSprite( "WBodice1", DEF_SPRID_BODYARMOR_W + 15*1, 12, TRUE);
			MakeSprite( "WBodice2", DEF_SPRID_BODYARMOR_W + 15*2, 12, TRUE);
			MakeSprite( "WLArmor",	DEF_SPRID_BODYARMOR_W + 15*3, 12, TRUE);
			MakeSprite( "WCMail",	DEF_SPRID_BODYARMOR_W + 15*4, 12, TRUE);
			MakeSprite( "WSMail",	DEF_SPRID_BODYARMOR_W + 15*5, 12, TRUE);
			MakeSprite( "WPMail",	DEF_SPRID_BODYARMOR_W + 15*6, 12, TRUE);
			MakeSprite( "WRobe1",	DEF_SPRID_BODYARMOR_W + 15*7, 12, TRUE);
			MakeSprite( "WSanta",	DEF_SPRID_BODYARMOR_W + 15*8, 12, TRUE);
			MakeSprite( "WHRobe1",	DEF_SPRID_BODYARMOR_W + 15*11, 12, TRUE); // hero
			MakeSprite( "WHRobe2",	DEF_SPRID_BODYARMOR_W + 15*12, 12, TRUE); // hero
			MakeSprite( "WHPMail1",	DEF_SPRID_BODYARMOR_W + 15*9, 12, TRUE); //hero
			MakeSprite( "WHPMail2",	DEF_SPRID_BODYARMOR_W + 15*10, 12, TRUE); //hero
			MakeSprite( "WChemiss",  DEF_SPRID_BERK_W + 15*1, 12, TRUE);
			MakeSprite( "WShirt",	 DEF_SPRID_BERK_W + 15*2, 12, TRUE);
			MakeSprite( "WHauberk",	 DEF_SPRID_BERK_W + 15*3, 12, TRUE);
			MakeSprite( "WHHauberk1",DEF_SPRID_BERK_W + 15*4, 12, TRUE);
			MakeSprite( "WHHauberk2",DEF_SPRID_BERK_W + 15*5, 12, TRUE);
			MakeSprite( "WSkirt",		DEF_SPRID_LEGG_W + 15*1, 12, TRUE);
			MakeSprite( "WTrouser",		DEF_SPRID_LEGG_W + 15*2, 12, TRUE);
			MakeSprite( "WHTrouser",	DEF_SPRID_LEGG_W + 15*3, 12, TRUE);
			MakeSprite( "WHLeggings1",	DEF_SPRID_LEGG_W + 15*6, 12, TRUE);
			MakeSprite( "WHLeggings2",	DEF_SPRID_LEGG_W + 15*7, 12, TRUE);
			MakeSprite( "WCHoses",		DEF_SPRID_LEGG_W + 15*4, 12, TRUE);
			MakeSprite( "WLeggings",	DEF_SPRID_LEGG_W + 15*5, 12, TRUE);
			MakeSprite( "WShoes",	DEF_SPRID_BOOT_W + 15*1, 12, TRUE);
			MakeSprite( "WLBoots",  DEF_SPRID_BOOT_W + 15*2, 12, TRUE);
			m_cLoading = 84;
		}
		break;
	case 84:
		{	m_hPakFile = CreateFile("sprites\\Wsw.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64*1] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*0, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64*2] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*1, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64*3] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*2, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64*4] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*3, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64*5] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*4, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64*6] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*5, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64*7] = new class CSprite(m_hPakFile, &m_DDraw,  "Wsw", i + 56*6, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64*8] = new class CSprite(m_hPakFile, &m_DDraw,  "Wsw", i + 56*7, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64*9] = new class CSprite(m_hPakFile, &m_DDraw,  "Wsw", i + 56*8, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64*10] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*9, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64*11] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*10, TRUE);
				for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64*12] = new class CSprite(m_hPakFile, &m_DDraw, "Wsw", i + 56*11, TRUE);
				CloseHandle(m_hPakFile);
			}

#ifdef DEF_EQUILIBRIUM_PROJECT // Women sword paks
			MakeSprite( "Wswx",			DEF_SPRID_WEAPON_W + 64*9, 56, TRUE);
#else
			MakeSprite( "Wswx",			DEF_SPRID_WEAPON_W + 64*5, 56, TRUE);
#endif
			MakeSprite( "Wsw2",			DEF_SPRID_WEAPON_W + 64*13, 56, TRUE);
            MakeSprite( "Wsw3",			DEF_SPRID_WEAPON_W + 64*14, 56, TRUE); // TheVampire
			MakeSprite( "WStormBringer",DEF_SPRID_WEAPON_W + 64*15, 56, TRUE);
			MakeSprite( "WDarkExec",	DEF_SPRID_WEAPON_W + 64*16, 56, TRUE);
			MakeSprite( "WKlonessBlade",DEF_SPRID_WEAPON_W + 64*17, 56, TRUE);
			MakeSprite( "WKlonessAstock",DEF_SPRID_WEAPON_W + 64*18, 56, TRUE);
			MakeSprite( "WDebastator",	DEF_SPRID_WEAPON_W + 64*19, 56, TRUE);
			m_cLoading = 88;
		}
		break;
	case 88:
		{	MakeSprite( "WAxe1",		DEF_SPRID_WEAPON_W + 64*20, 56, TRUE);// Axe
			MakeSprite( "WAxe2",		DEF_SPRID_WEAPON_W + 64*21, 56, TRUE);
			MakeSprite( "WAxe3",		DEF_SPRID_WEAPON_W + 64*22, 56, TRUE);
			MakeSprite( "WAxe4",		DEF_SPRID_WEAPON_W + 64*23, 56, TRUE);
			MakeSprite( "WAxe5",		DEF_SPRID_WEAPON_W + 64*24, 56, TRUE);
			MakeSprite( "WpickAxe1",	DEF_SPRID_WEAPON_W + 64*25, 56, TRUE);
			MakeSprite( "WAxe6",		DEF_SPRID_WEAPON_W + 64*26, 56, TRUE);
			MakeSprite( "Whoe",			DEF_SPRID_WEAPON_W + 64*27, 56, TRUE);
			MakeSprite( "WKlonessAxe",	DEF_SPRID_WEAPON_W + 64*28, 56, TRUE);
			MakeSprite( "WLightBlade",  DEF_SPRID_WEAPON_W + 64*29, 56, TRUE);
			MakeSprite( "WHammer",		DEF_SPRID_WEAPON_W + 64*30, 56, TRUE);
			MakeSprite( "WBHammer",		DEF_SPRID_WEAPON_W + 64*31, 56, TRUE);
			MakeSprite( "WBabHammer",	DEF_SPRID_WEAPON_W + 64*32, 56, TRUE);
			MakeSprite( "WBShadowSword",DEF_SPRID_WEAPON_W + 64*33, 56, TRUE);
			MakeSprite( "WBerserkWand", DEF_SPRID_WEAPON_W + 64*34, 56, TRUE);
			MakeSprite( "Wstaff1",		DEF_SPRID_WEAPON_W + 64*35, 56, TRUE);// Staff
			MakeSprite( "Wstaff2",		DEF_SPRID_WEAPON_W + 64*36, 56, TRUE);
			MakeSprite( "WStaff3",		DEF_SPRID_WEAPON_W + 64*37, 56, TRUE);
			MakeSprite( "WKlonessWand", DEF_SPRID_WEAPON_W + 64*39, 56, TRUE);
			MakeSprite( "WReMagicWand", DEF_SPRID_WEAPON_W + 64*38, 56, TRUE);
			// bows 40 41 below
			MakeSprite( "WDirectBow",	DEF_SPRID_WEAPON_W + 64*42, 56, TRUE);
			MakeSprite( "WFireBow",		DEF_SPRID_WEAPON_W + 64*43, 56, TRUE);
			m_cLoading = 92;
		}
		break;
	case 92:
		{	MakeSprite( "Wmantle01", DEF_SPRID_MANTLE_W + 15*1, 12, TRUE);
			MakeSprite( "Wmantle02", DEF_SPRID_MANTLE_W + 15*2, 12, TRUE);
			MakeSprite( "Wmantle03", DEF_SPRID_MANTLE_W + 15*3, 12, TRUE);
			MakeSprite( "Wmantle04", DEF_SPRID_MANTLE_W + 15*4, 12, TRUE);
			MakeSprite( "Wmantle05", DEF_SPRID_MANTLE_W + 15*5, 12, TRUE);
			MakeSprite( "Wmantle06", DEF_SPRID_MANTLE_W + 15*6, 12, TRUE);
			MakeSprite( "WHelm1",	 DEF_SPRID_HEAD_W + 15*1, 12, TRUE);
			MakeSprite( "WHelm4",	 DEF_SPRID_HEAD_W + 15*4, 12, TRUE);
			MakeSprite( "WHHelm1",	 DEF_SPRID_HEAD_W + 15*9, 12, TRUE);
			MakeSprite( "WHHelm2",	 DEF_SPRID_HEAD_W + 15*10, 12, TRUE);
			MakeSprite( "WHCap1",	 DEF_SPRID_HEAD_W + 15*11, 12, TRUE);
			MakeSprite( "WHCap2",	 DEF_SPRID_HEAD_W + 15*12, 12, TRUE);
			MakeSprite( "NWHelm1",	 DEF_SPRID_HEAD_W + 15*5, 12, TRUE);
			MakeSprite( "NWHelm2",	 DEF_SPRID_HEAD_W + 15*6, 12, TRUE);
			MakeSprite( "NWHelm3",	 DEF_SPRID_HEAD_W + 15*7, 12, TRUE);
			MakeSprite( "NWHelm4",	 DEF_SPRID_HEAD_W + 15*8, 12, TRUE);
			m_cLoading = 96;
		}
		break;
	case 96:
		{	MakeSprite( "Wbo", DEF_SPRID_WEAPON_W + 64*40, 56, TRUE);// Bow
			m_hPakFile = CreateFile("sprites\\Wbo.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE )
			{	for (i = 0; i < 56; i++) m_pSprite[DEF_SPRID_WEAPON_W + i + 64*41] = new class CSprite(m_hPakFile, &m_DDraw, "Wbo", i + 56*1, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_hPakFile = CreateFile("sprites\\Wsh.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE ) {
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8*1] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*0, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8*2] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*1, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8*3] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*2, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8*4] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*3, TRUE);
				for (i = 0; i < 7; i++)	m_pSprite[DEF_SPRID_SHIELD_W + i + 8*5] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*4, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8*6] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*5, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8*7] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*6, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8*8] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*7, TRUE);
				for (i = 0; i < 7; i++) m_pSprite[DEF_SPRID_SHIELD_W + i + 8*9] = new class CSprite(m_hPakFile, &m_DDraw, "Wsh", i + 7*8, TRUE);
				CloseHandle(m_hPakFile);
			}
			m_cLoading = 100;
		}
		break;
	case 100:
		{	MakeEffectSpr( "effect", 0, 10, FALSE);
			MakeEffectSpr( "effect2", 10, 3, FALSE);
			MakeEffectSpr( "effect3", 13, 6, FALSE);
			MakeEffectSpr( "effect4", 19, 5, FALSE);
			m_hPakFile = CreateFile("sprites\\effect5.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
			if( m_hPakFile != INVALID_HANDLE_VALUE )
			{	for (i = 0; i <= 6; i++) // Because effectn°0 is EnergySphere
					m_pEffectSpr[i+ 24] = new class CSprite(m_hPakFile, &m_DDraw, "effect5", i+1, FALSE);
				CloseHandle(m_hPakFile);
			}
			MakeEffectSpr( "CruEffect1", 31, 9, FALSE);
			MakeEffectSpr( "effect6", 40, 5, FALSE);
			MakeEffectSpr( "effect7", 45, 12, FALSE);
			MakeEffectSpr( "effect8", 57, 9, FALSE);
			MakeEffectSpr( "effect9", 66, 21, FALSE);

			MakeEffectSpr( "effect10",  87,  2, FALSE); // Effets Hero items
			MakeEffectSpr( "effect11",  89, 14, FALSE); // Cancel, stormBlade, resu, GateHeldenian....etc
			//NB: Charge 15 du client 3.51, mais il n'y a que 14 ds le PAK
			MakeEffectSpr( "effect11s", 104, 1, FALSE); // effet sort mais je ne sais pas lequel

			// Manque des effets ici .....
			// MakeEffectSpr( "effect13", 108, 2, FALSE); // not loaded by client 351 (Heldenian gates death)
			MakeEffectSpr( "effect13", 105, 3, FALSE);	//  Mon PAK effets perso (effect14 de china et AirEl)
			MakeEffectSpr( "effect14", 108, 10, FALSE); //  PAK de HBChina
			
			
			//MakeEffectSpr( "yseffect2", 141, 8, FALSE); // Wrong in 351 client...
			MakeEffectSpr( "yseffect2", 140, 8, FALSE); // Abaddon's death
			MakeEffectSpr( "effect12",  148, 4, FALSE); // Slates auras
			MakeEffectSpr( "yseffect3", 152,16, FALSE); // Fumerolles ou ame qui s'envole
			//MakeEffectSpr( "yseffect4", 167, 7, FALSE); // Wrong in 351 client
			MakeEffectSpr( "yseffect4", 133, 7, FALSE); // Abaddon's map thunder.


			if (m_bSoundFlag) // Attention il y a un autre systeme de chargement ds la v351
			{	for (i = 1; i <= 24; i++)
				{	wsprintf(G_cTxt, "sounds\\C%d.wav", i);
					m_pCSound[i] = new class CSoundBuffer(m_DSound.m_lpDS, m_DSound.m_DSCaps, G_cTxt);
				}

				for (i = 1; i <= 156; i++)
				{	wsprintf(G_cTxt, "sounds\\M%d.wav", i);
					m_pMSound[i] = new class CSoundBuffer(m_DSound.m_lpDS, m_DSound.m_DSCaps, G_cTxt);
				}
				for (i = 1; i <= 53; i++)
				{	wsprintf(G_cTxt, "sounds\\E%d.wav", i);
					m_pESound[i] = new class CSoundBuffer(m_DSound.m_lpDS, m_DSound.m_DSCaps, G_cTxt);
			}	}
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		}
		break;
	}
}
/*********************************************************************************************************************
** 	void CGame::UpdateScreen_OnLoading_Progress()																	**
**  description			:: loading becomes progressbar																**
**********************************************************************************************************************/
void CGame::UpdateScreen_OnLoading_Progress()
{
	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOADING, 0,0,0, TRUE);
	DrawVersion(TRUE);
	int iBarWidth;
	iBarWidth= (int)m_cLoading;
	m_pSprite[DEF_SPRID_INTERFACE_ND_LOADING]->PutSpriteFastWidth(472,442, 1, iBarWidth, G_dwGlobalTime);
	m_DDraw.iFlip();
}

void CGame::OnTimer()
{
	if( m_cGameMode < 0 ) return;
	DWORD dwTime = timeGetTime();

	if (m_cGameMode != DEF_GAMEMODE_ONLOADING) {

#ifdef DEF_ANTI_HACK
		//CheckProcesses(); // Mis a l'envoie du msg, moins simple a trouver.
		if (((dwTime - m_dwCheckSprTime) > DEF_CCM_DELAY) && ( m_dwCheckSprTime != 0))
		{	m_dwCheckSprTime = dwTime;
			if( m_bIsProgramActive ) ReleaseUnusedSprites();			
			if ((m_wCRC16_1 == 0)||((rand()%5) == 2)) DoCRC();
			if (m_Misc.CheckProcesses2() == FALSE) // Vicieux, on blocque le CCm d'ou une detection hack par serveur.
			{	if ((m_pGSock != NULL) && (m_pGSock->m_bIsAvailable == TRUE))
				bSendCommand(MSGID_COMMAND_CHECKCONNECTION, DEF_MSGTYPE_CONFIRM, NULL, dwTime, NULL, NULL, NULL);
	}	}	}
#else
		if ((dwTime - m_dwCheckSprTime) > 8000 )
		{	m_dwCheckSprTime = dwTime;
			if( m_bIsProgramActive ) ReleaseUnusedSprites();
			if ((m_pGSock != NULL) && (m_pGSock->m_bIsAvailable == TRUE))
				bSendCommand(MSGID_COMMAND_CHECKCONNECTION, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL, NULL, NULL);
	}	}
#endif

	if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
	{	if ((dwTime - m_dwCheckConnTime) > 5000)
		{	m_dwCheckConnTime = dwTime;
			if ((m_bIsCrusadeMode) && (m_iCrusadeDuty == NULL)) EnableDialogBox(33, 1, NULL, NULL);
		}

		if ((dwTime - m_dwCheckChatTime) > 2000)
		{	m_dwCheckChatTime = m_dwTime;
			ReleaseTimeoverChatMsg();
			if (m_cCommandCount >= 6)
			{	m_iNetLagCount++;
				if (m_iNetLagCount >= 7)
				{	ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
					delete m_pGSock;
					m_pGSock = NULL;
					return;
				}
			}else m_iNetLagCount = NULL;
		}

		if ((G_bIsCalcSocketConnected == FALSE) && ((dwTime - G_dwCalcSocketTime) > 5000))
		{	delete m_pGSock;
			m_pGSock = NULL;
			ChangeGameMode(DEF_GAMEMODE_ONQUIT);
			m_bEscPressed = FALSE;
			PlaySound('E', 14, 5);
			if (m_bSoundFlag) m_pESound[38]->bStop();
			if ((m_bSoundFlag) && (m_bMusicStat == TRUE))
			{	StopBGM();	// Snoopy: mp3 support
				if (m_pBGM != NULL) m_pBGM->bStop();
			}
			return;
		}

		if ((G_pCalcSocket != NULL) && (G_bIsCalcSocketConnected == TRUE)) {
			if ((dwTime - G_dwCalcSocketSendTime) > 1000*5) {
				if (memcmp(G_cCmdLineTokenA_Lowercase, "wisetop", 7) == 0)
				{}else
				{	char cPacket[120];
					int  iSended;
					WORD * wp;
					ZeroMemory(cPacket, sizeof(cPacket));
					cPacket[0] = 0;					// Key
					wp  = (WORD *)(cPacket +1);
					*wp = 5;
					iSended = G_pCalcSocket->iSendMsgBlockingMode(cPacket, 5);
				}
				G_dwCalcSocketSendTime = dwTime;
	}	}	}
}


BOOL CGame::_bCheckDlgBoxClick(short msX, short msY)
{int i;
 char         cDlgID;
	m_DInput.m_sZ = 0;
	// Snoopy: 41->61
	for (i = 0; i < 61; i++)
	// Snoopy: 40->60
	if (m_cDialogBoxOrder[60 - i] != NULL) {
	// Snoopy: 40->60
		cDlgID = m_cDialogBoxOrder[60 - i];
		if ((m_stDialogBoxInfo[cDlgID].sX < msX) && ((m_stDialogBoxInfo[cDlgID].sX + m_stDialogBoxInfo[cDlgID].sSizeX) > msX) &&
			(m_stDialogBoxInfo[cDlgID].sY < msY) && ((m_stDialogBoxInfo[cDlgID].sY + m_stDialogBoxInfo[cDlgID].sSizeY) > msY) )
		{	switch (cDlgID) {
			case 1:
				DlgBoxClick_Character(msX, msY);
				break;
			case 2:
				DlgBoxClick_Inventory(msX, msY);
				break;
			case 3:
				DlgBoxClick_Magic(msX, msY);
				break;
			case 4:
				DlgBoxClick_ItemDrop(msX, msY);
				break;
			case 5:
				DlgBoxClick_15AgeMsg(msX, msY);
				break;
			case 6:
				DlgBoxClick_WarningMsg(msX, msY);
				break;
			case 7:
				DlgBoxClick_GuildMenu(msX, msY);
				break;
			case 8:
				DlgBoxClick_GuildOp(msX, msY);
				break;
			case 9:
				break;
			case 11:
				DlgBoxClick_Shop(msX, msY);
				break;
			case 12:
				DlgBoxClick_LevelUpSettings(msX, msY);
				break;
			case 13:
				DlgBoxClick_CityhallMenu(msX, msY);
				break;
			case 14:
				DlgBoxClick_Bank(msX, msY);
				break;
			case 15:
				DlgBoxClick_Skill(msX, msY);
				break;
			case 16:
				DlgBoxClick_MagicShop(msX, msY);
				break;
			case 18:
				DlgBoxClick_Text(msX, msY);
				break;
			case 19:
				DlgBoxClick_SysMenu(msX, msY);
				break;
			case 20:
				DlgBoxClick_NpcActionQuery(msX, msY);
				break;
			case 21:
				DlgBoxClick_NpcTalk(msX, msY);
				break;
			case 23:
				DlgBoxClick_ItemSellorRepair(msX, msY);
				break;
			case 24:
				DlgBoxClick_Fish(msX, msY);
				break;
			case 25:
				DlgBoxClick_ShutDownMsg(msX, msY);
				break;
			case 26:
				DlgBoxClick_SkillDlg(msX, msY);
				break;
			case 27:
				DlgBoxClick_Exchange(msX, msY);
				break;
			case 28:
				DlgBoxClick_Quest(msX, msY);
				break;
			case 30:
				DlgBoxClick_IconPannel(msX, msY);
				break;
			case 31:
				DlgBoxClick_SellList(msX, msY);
				break;
			case 32:
				DlgBoxClick_Party(msX, msY);
				break;
			case 33:
				DlgBoxClick_CrusadeJob(msX, msY);
				break;
			case 34:
				DlgBoxClick_ItemUpgrade(msX, msY);
     			break;
			case 35:
				DlgBoxClick_Help(msX, msY);
				break;

			case 36:
				DlgBoxClick_Commander(msX, msY);
				break;

			case 37:
				DlgBoxClick_Constructor(msX, msY);
				break;

			case 38:
				DlgBoxClick_Soldier(msX, msY);
				break;

			case 40:
				DlgBoxClick_Slates(msX, msY);
				break;
// Snoopy: Boite de dialogue de confirmation d'échange
			case 41:
				DlgBoxClick_ConfirmExchange(msX, msY);
				break;
			case 42:
				DlgBoxClick_ChangeStatsMajestic(msX, msY);
				break;
			case 50:
				DlgBoxClick_Resurect(msX, msY);
				break;
			case 51:
				DlgBoxClick_CMDHallMenu(msX, msY);
				break;
			}

			return TRUE;
		}
	}

	return FALSE;
}

BOOL CGame::_bCheckDlgBoxDoubleClick(short msX, short msY)
{
	int i;
	char cDlgID;
//	if (m_iHP <= 0) return FALSE;
	//Snoopy: 41->61
	for (i = 0; i < 61; i++)
	//Snoopy: 40->60
	if (m_cDialogBoxOrder[60 - i] != NULL) {
	//Snoopy: 40->60
		cDlgID = m_cDialogBoxOrder[60 - i];
		if (   (m_stDialogBoxInfo[cDlgID].sX < msX)	&& ((m_stDialogBoxInfo[cDlgID].sX + m_stDialogBoxInfo[cDlgID].sSizeX) > msX) 
			&& (m_stDialogBoxInfo[cDlgID].sY < msY)	&& ((m_stDialogBoxInfo[cDlgID].sY + m_stDialogBoxInfo[cDlgID].sSizeY) > msY) ) 
		{	switch (cDlgID) {
			case 1:
				DlbBoxDoubleClick_Character(msX, msY);
				break;
			case 2:
				DlbBoxDoubleClick_Inventory(msX, msY);
				break;
			case 9:
				DlbBoxDoubleClick_GuideMap(msX, msY);
				break;
			}
			return TRUE;
		}
	}
	return FALSE;
}


BOOL CGame::bDlgBoxPress_Inventory(short msX, short msY)
{int i;
 char  cItemID;
 short sX, sY, x1, x2, y1, y2;

#ifdef _DEBUG
 AddEventList("Press Inventory", 10);
#endif

	if (m_bIsDialogEnabled[2] == FALSE) return FALSE;
	if (m_bIsDialogEnabled[17] == TRUE) return FALSE;
	if (m_bIsDialogEnabled[4] == TRUE) return FALSE;

	sX = m_stDialogBoxInfo[2].sX;
	sY = m_stDialogBoxInfo[2].sY;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_cItemOrder[DEF_MAXITEMS - 1 - i] != -1) {
		cItemID = m_cItemOrder[DEF_MAXITEMS - 1 - i];

		if (m_pItemList[cItemID] != NULL)
		{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + 32 + m_pItemList[cItemID]->m_sX,
			                                                   sY + 44 + m_pItemList[cItemID]->m_sY, m_pItemList[cItemID]->m_sSpriteFrame);
			x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
			y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
			x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
			y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;
			if ( (m_bIsItemDisabled[cItemID] == FALSE) && (m_bIsItemEquipped[cItemID] == FALSE) && (msX > x1) && (msX < x2) && (msY > y1) && (msY < y2) ) {

				if (m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_bCheckCollison(sX + 32 + m_pItemList[cItemID]->m_sX, sY + 44 + m_pItemList[cItemID]->m_sY, m_pItemList[cItemID]->m_sSpriteFrame, msX, msY) == TRUE) 
				{	_SetItemOrder(0, cItemID);
					if (   (m_bIsGetPointingMode == TRUE) && (m_iPointCommandType < 100) && (m_iPointCommandType >= 0 )
						&& (m_pItemList[m_iPointCommandType] != NULL)
						&& (m_pItemList[m_iPointCommandType]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST)
						&& (m_iPointCommandType != cItemID) )
					{	PointCommandHandler(NULL, NULL, cItemID);
						//m_bCommandAvailable  = FALSE;
						m_bIsGetPointingMode = FALSE;
					}else
					{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
						m_stMCursor.sSelectedObjectID   = cItemID;
						m_stMCursor.sDistX = msX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
						m_stMCursor.sDistY = msY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
					}
					return TRUE;
	}	}	}	}
	return FALSE;
}

void CGame::_SetItemOrder(char cWhere, char cItemID)
{
 int i;

	switch (cWhere) {
	case 0:
		for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_cItemOrder[i] == cItemID)
			m_cItemOrder[i] = -1;

		for (i = 1; i < DEF_MAXITEMS; i++)
		if ((m_cItemOrder[i-1] == -1) && (m_cItemOrder[i] != -1)) {
			m_cItemOrder[i-1] = m_cItemOrder[i];
			m_cItemOrder[i]   = -1;
		}

		for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_cItemOrder[i] == -1) {
			m_cItemOrder[i] = cItemID;
			return;
		}
		break;
	}
}

BOOL CGame::_bCheckDraggingItemRelease(short msX, short msY)
{int i;
 char         cDlgID;
	//Snoopy: 41->61
	for (i = 0; i < 61; i++)
	//Snoopy: 40->60
	if (m_cDialogBoxOrder[60 - i] != NULL) {
	//Snoopy: 40->60
		cDlgID = m_cDialogBoxOrder[60 - i];
		if (   (m_stDialogBoxInfo[cDlgID].sX < msX) && ((m_stDialogBoxInfo[cDlgID].sX + m_stDialogBoxInfo[cDlgID].sSizeX) > msX) 
			&& (m_stDialogBoxInfo[cDlgID].sY < msY) && ((m_stDialogBoxInfo[cDlgID].sY + m_stDialogBoxInfo[cDlgID].sSizeY) > msY) ) 
		{	EnableDialogBox(cDlgID, NULL, NULL, NULL);
			switch (cDlgID) {
			case 1:
				bItemDrop_Character();
				break;

			case 2:
				bItemDrop_Inventory(msX, msY);
				break;

			case 14:
				bItemDrop_Bank(msX, msY);
				break;

			case 26: // Alchim / Manuf
				bItemDrop_SkillDialog();
				break;

			case 27:
				bItemDrop_ExchangeDialog(msX, msY);
				break;

			case 30:
				bItemDrop_IconPannel(msX, msY);
				break;

			case 31:
				bItemDrop_SellList(msX, msY);
				break;

			case 34:
				bItemDrop_ItemUpgrade();
				break;

			case 40:
				bItemDrop_Slates();
				break;
			}
			return TRUE;
	}	}
	bItemDrop_ExternalScreen((char)m_stMCursor.sSelectedObjectID, msX, msY);
	return FALSE;
}



void CGame::bItemDrop_ExternalScreen(char cItemID, short msX, short msY)
{char  cName[21];
 short sType, tX, tY;
 int iStatus;
				
	if (bCheckItemOperationEnabled(cItemID) == FALSE) return;

	if ((m_sMCX != 0) && (m_sMCY != 0) && (abs(m_sPlayerX - m_sMCX) <= 8) && (abs(m_sPlayerY - m_sMCY) <= 8))
	{	ZeroMemory(cName, sizeof(cName));
		m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sType, &iStatus, &m_wCommObjectID);
		if (memcmp(m_cPlayerName, cName, 10) == 0)
		{}else
		{	if (   ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW))
				&& (m_pItemList[cItemID]->m_dwCount > 1))
			{	m_stDialogBoxInfo[17].sX  = msX - 140;
				m_stDialogBoxInfo[17].sY  = msY - 70;
				if (m_stDialogBoxInfo[17].sY < 0) m_stDialogBoxInfo[17].sY = 0;
				m_stDialogBoxInfo[17].sV1 = m_sMCX;
				m_stDialogBoxInfo[17].sV2 = m_sMCY;
				m_stDialogBoxInfo[17].sV3 = sType;
				m_stDialogBoxInfo[17].sV4 = m_wCommObjectID;
				ZeroMemory(m_stDialogBoxInfo[17].cStr, sizeof(m_stDialogBoxInfo[17].cStr));
				if (sType < 10)
					memcpy(m_stDialogBoxInfo[17].cStr, cName, 10);
				else
				{	GetNpcName(sType, m_stDialogBoxInfo[17].cStr);
				}
				EnableDialogBox(17, cItemID, m_pItemList[cItemID]->m_dwCount, NULL);
			}else
			{	switch (sType) {
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
					EnableDialogBox(20, 1, cItemID, sType);
					m_stDialogBoxInfo[20].sV3 = 1;
					m_stDialogBoxInfo[20].sV4 = m_wCommObjectID;
					m_stDialogBoxInfo[20].sV5 = m_sMCX;
					m_stDialogBoxInfo[20].sV6 = m_sMCY;

					tX = msX - 117;
					tY = msY - 50;
					if (tX < 0) tX = 0;
					if ((tX + 235) > 639) tX = 639 - 235;
					if (tY < 0) tY = 0;
					if ((tY + 100) > 479) tY = 479 - 100;
					m_stDialogBoxInfo[20].sX  = tX;
					m_stDialogBoxInfo[20].sY  = tY;

					ZeroMemory(m_stDialogBoxInfo[20].cStr, sizeof(m_stDialogBoxInfo[20].cStr));
					strcpy(m_stDialogBoxInfo[20].cStr, cName);
					//bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, cItemID, 1, m_sMCX, m_sMCY, m_pItemList[cItemID]->m_cName); //v1.4
					break;

				case 20: // Howard
					EnableDialogBox(20, 3, cItemID, sType);
					m_stDialogBoxInfo[20].sV3 = 1;
					m_stDialogBoxInfo[20].sV4 = m_wCommObjectID; // v1.4
					m_stDialogBoxInfo[20].sV5 = m_sMCX;
					m_stDialogBoxInfo[20].sV6 = m_sMCY;

					tX = msX - 117;
					tY = msY - 50;
					if (tX < 0) tX = 0;
					if ((tX + 235) > 639) tX = 639 - 235;
					if (tY < 0) tY = 0;
					if ((tY + 100) > 479) tY = 479 - 100;
					m_stDialogBoxInfo[20].sX  = tX;
					m_stDialogBoxInfo[20].sY  = tY;

					ZeroMemory(m_stDialogBoxInfo[20].cStr, sizeof(m_stDialogBoxInfo[20].cStr));
					GetNpcName(sType, m_stDialogBoxInfo[20].cStr);
					//bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, cItemID, 1, m_sMCX, m_sMCY, m_pItemList[cItemID]->m_cName);
					break;

				case 15: // ShopKeeper-W
		  		case 24: // Tom
					EnableDialogBox(20, 2, cItemID, sType);
					m_stDialogBoxInfo[20].sV3 = 1;
					m_stDialogBoxInfo[20].sV4 = m_wCommObjectID; // v1.4
					m_stDialogBoxInfo[20].sV5 = m_sMCX;
					m_stDialogBoxInfo[20].sV6 = m_sMCY;

					tX = msX - 117;
					tY = msY - 50;
					if (tX < 0) tX = 0;
					if ((tX + 235) > 639) tX = 639 - 235;
					if (tY < 0) tY = 0;
					if ((tY + 100) > 479) tY = 479 - 100;
					m_stDialogBoxInfo[20].sX  = tX;
					m_stDialogBoxInfo[20].sY  = tY;

					ZeroMemory(m_stDialogBoxInfo[20].cStr, sizeof(m_stDialogBoxInfo[20].cStr));
					GetNpcName(sType, m_stDialogBoxInfo[20].cStr);
					break;

				default:
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, cItemID, 1, m_sMCX, m_sMCY, m_pItemList[cItemID]->m_cName);
					break;
				}
				//m_bIsItemDisabled[cItemID] = TRUE;
			}
			m_bIsItemDisabled[cItemID] = TRUE;
		}
	}else
	{	if (   ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) 
			&& (m_pItemList[cItemID]->m_dwCount > 1))
		{	m_stDialogBoxInfo[17].sX  = msX - 140;
			m_stDialogBoxInfo[17].sY  = msY - 70;
			if (m_stDialogBoxInfo[17].sY < 0)		m_stDialogBoxInfo[17].sY = 0;
			m_stDialogBoxInfo[17].sV1 = NULL;
			m_stDialogBoxInfo[17].sV2 = NULL;
			m_stDialogBoxInfo[17].sV3 = NULL;
			m_stDialogBoxInfo[17].sV4 = NULL;
			ZeroMemory(m_stDialogBoxInfo[17].cStr, sizeof(m_stDialogBoxInfo[17].cStr));
			EnableDialogBox(17, cItemID, m_pItemList[cItemID]->m_dwCount, NULL);
		}else
		{	if(_ItemDropHistory(m_pItemList[cItemID]->m_cName))
			{	m_stDialogBoxInfo[4].sX  = msX - 140;
				m_stDialogBoxInfo[4].sY  = msY - 70;
				if (m_stDialogBoxInfo[4].sY < 0)	m_stDialogBoxInfo[4].sY = 0;
    			m_stDialogBoxInfo[4].sV1 = NULL;
				m_stDialogBoxInfo[4].sV2 = NULL;
				m_stDialogBoxInfo[4].sV3 = 1;
				m_stDialogBoxInfo[4].sV4 = NULL;
				m_stDialogBoxInfo[4].sV5 = cItemID;
				ZeroMemory(m_stDialogBoxInfo[4].cStr, sizeof(m_stDialogBoxInfo[4].cStr));
				EnableDialogBox(4, cItemID, m_pItemList[cItemID]->m_dwCount, NULL);
			}else
			{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_ITEMDROP, NULL, cItemID, 1, NULL, m_pItemList[cItemID]->m_cName);
		}	}
		m_bIsItemDisabled[cItemID] = TRUE;
	}
}


void CGame::CommonEventHandler(char * pData)
{
 WORD * wp, wEventType;
 short * sp, sX, sY, sV1, sV2, sV3, sV4;
 char * cp;

	wp   = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wEventType = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp  = (short *)cp;
	sX  = *sp;
	cp += 2;

	sp  = (short *)cp;
	sY  = *sp;
	cp += 2;

	sp  = (short *)cp;
	sV1 = *sp;
	cp += 2;

	sp  = (short *)cp;
	sV2 = *sp;
	cp += 2;

	sp  = (short *)cp;
	sV3 = *sp;
	cp += 2;

	sp  = (short *)cp;
	sV4 = *sp;
	cp += 2;

	switch (wEventType) {
	case DEF_COMMONTYPE_ITEMDROP:
		if ((sV1 == 6) && (sV2 == 0)) {
			bAddNewEffect(4, sX, sY, NULL, NULL, 0);
		}
		m_pMapData->bSetItem(sX, sY, sV1, sV2, (char)sV3);
		break;

	case DEF_COMMONTYPE_SETITEM:
		m_pMapData->bSetItem(sX, sY, sV1, sV2, (char)sV3, FALSE); // v1.4 color
		break;

	case DEF_COMMONTYPE_MAGIC:
		bAddNewEffect(sV3, sX, sY, sV1, sV2, 0, sV4);
		break;

	case DEF_COMMONTYPE_CLEARGUILDNAME:
		ClearGuildNameList();
		break;
	}
}

void CGame::ClearGuildNameList()
{
	for (int i = 0; i < DEF_MAXGUILDNAMES; i++) {
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		ZeroMemory(m_stGuildName[i].cCharName, sizeof(m_stGuildName[i].cCharName));
		ZeroMemory(m_stGuildName[i].cGuildName, sizeof(m_stGuildName[i].cGuildName));
	}
}

void CGame::InitGameSettings()
{
 int i;

	m_bForceAttack = FALSE;
	m_dwCommandTime = 0;

	m_bInputStatus = FALSE;
	m_pInputBuffer = NULL;

	m_iPDBGSdivX = 0;
	m_iPDBGSdivY = 0;
	m_bIsRedrawPDBGS = TRUE;

	m_iCameraShakingDegree = 0;

	m_cCommand = DEF_OBJECTSTOP;
	m_cCommandCount = 0;

	m_bIsGetPointingMode = FALSE;
	m_iPointCommandType  = -1; //v2.15 NULL -> -1

	m_bIsCombatMode = FALSE;
	m_bRunningMode = FALSE;

	m_stMCursor.cPrevStatus       = DEF_CURSORSTATUS_NULL;
	m_stMCursor.dwSelectClickTime = NULL;

	m_bSkillUsingStatus = FALSE;
	m_bItemUsingStatus  = FALSE;
	m_bUsingSlate = FALSE;
	m_bHackMoveBlocked = FALSE;

	m_bIsWhetherEffect   = FALSE;
	m_cWhetherEffectType = NULL;

	m_iDownSkillIndex = -1;
	m_stDialogBoxInfo[15].bFlag = FALSE;

	m_bIsConfusion = FALSE;

	m_iIlusionOwnerH = NULL;
	m_cIlusionOwnerType = NULL;

	m_iDrawFlag = 0;
	m_bDrawFlagDir = FALSE;
	m_bIsCrusadeMode = FALSE;
	m_iCrusadeDuty = NULL;
	m_bIsAvatarMode  = FALSE;
	m_bIsAvatarMessenger = FALSE;
	m_bIsHeldenianMode = FALSE;
	m_bIsHeldenianMap = FALSE;

	m_iNetLagCount = NULL;

	// Snoopy: CRC32
	m_dwCRC32 = 0;
	m_wCRC16_1 = 0;
	m_wCRC16_2 = 0;
	m_bUseCRC_2 = FALSE;
	m_iMangler = 0x00125EA4;

	m_dwEnvEffectTime = timeGetTime();	

	for (i = 0; i < DEF_MAXGUILDNAMES; i++) {
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		ZeroMemory(m_stGuildName[i].cCharName, sizeof(m_stGuildName[i].cCharName));
		ZeroMemory(m_stGuildName[i].cGuildName, sizeof(m_stGuildName[i].cGuildName));
	}
	//Snoopy: 61
	for (i = 0; i < 61; i++)
		m_bIsDialogEnabled[i] = FALSE;

	//Snoopy: 58 because 2 last ones alreaddy defined
	for (i = 0; i < 58; i++)
		m_cDialogBoxOrder[i] = NULL;

	for (i = 0; i < DEF_MAXEFFECTS; i++) {
		if (m_pEffectList[i] != NULL) delete m_pEffectList[i];
		m_pEffectList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXCHATMSGS; i++) {
		if (m_pChatMsgList[i] != NULL) delete m_pChatMsgList[i];
		m_pChatMsgList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXCHATSCROLLMSGS; i++) {
		if (m_pChatScrollList[i] != NULL) delete m_pChatScrollList[i];
		m_pChatScrollList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXWHISPERMSG; i++) {
		if (m_pWhisperMsg[i] != NULL) delete m_pWhisperMsg[i];
		m_pWhisperMsg[i] = NULL;
	}

	ZeroMemory(m_cLocation, sizeof(m_cLocation));

	ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
	m_iGuildRank = -1;
	m_iTotalGuildsMan = 0;

	for (i = 0; i < 100; i++) {
		m_stGuildOpList[i].cOpMode = NULL;
		ZeroMemory(m_stGuildOpList[i].cName, sizeof(m_stGuildOpList[i].cName));
	}

	for (i = 0; i < 6; i++) {
		ZeroMemory(m_stEventHistory[i].cTxt, sizeof(m_stEventHistory[i].cTxt));
		m_stEventHistory[i].dwTime = G_dwGlobalTime;

		ZeroMemory(m_stEventHistory2[i].cTxt, sizeof(m_stEventHistory2[i].cTxt));
		m_stEventHistory2[i].dwTime = G_dwGlobalTime;
	}

    for (i = 0; i < DEF_MAXMENUITEMS; i++) {
		if (m_pItemForSaleList[i] != NULL) delete m_pItemForSaleList[i];
		m_pItemForSaleList[i] = NULL;
	}

	for (i = 0; i < 41; i++) {
		m_stDialogBoxInfo[i].bFlag = FALSE;
		m_stDialogBoxInfo[i].sView = 0;
		m_stDialogBoxInfo[i].bIsScrollSelected = FALSE;
	}

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] != NULL) {
		delete m_pItemList[i];
		m_pItemList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXSELLLIST; i++) {
		m_stSellItemList[i].iIndex = -1;
		m_stSellItemList[i].iAmount = 0;
	}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pBankList[i] != NULL) {
		delete m_pBankList[i];
		m_pBankList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_cMagicMastery[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_cSkillMastery[i] = NULL;

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pMsgTextList[i] != NULL)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = NULL;

		if (m_pMsgTextList2[i] != NULL)
			delete m_pMsgTextList2[i];
		m_pMsgTextList2[i] = NULL;

		if (m_pAgreeMsgTextList[i] != NULL)
			delete m_pAgreeMsgTextList[i];
		m_pAgreeMsgTextList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) {
		m_stPartyMember[i].cStatus = 0;
		ZeroMemory(m_stPartyMember[i].cName, sizeof(m_stPartyMember[i].cName));
	}

	m_iLU_Point = 0;
	m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;
	m_bDialogTrans   = FALSE;
	m_cWhetherStatus = NULL;
	m_cLogOutCount = -1;
	m_dwLogOutCountTime = NULL;
	m_iSuperAttackLeft = 0;
	m_bSuperAttackMode = FALSE;
	m_iFightzoneNumber = 0 ;
	ZeroMemory(m_cBGMmapName, sizeof(m_cBGMmapName));
	m_dwWOFtime = 0;
	m_stQuest.sWho          = NULL;
	m_stQuest.sQuestType    = NULL;
	m_stQuest.sContribution = NULL;
	m_stQuest.sTargetType   = NULL;
	m_stQuest.sTargetCount  = NULL;
	m_stQuest.sCurrentCount = NULL;
	m_stQuest.sX            = NULL;
	m_stQuest.sY            = NULL;
	m_stQuest.sRange        = NULL;
	m_stQuest.bIsQuestCompleted = FALSE;
	ZeroMemory(m_stQuest.cTargetName, sizeof(m_stQuest.cTargetName));
	m_bIsObserverMode = FALSE;
	m_bIsObserverCommanded = FALSE;
	m_bIsPoisoned = FALSE;
	m_bIsPrevMoveBlocked = FALSE;
	m_iPrevMoveX = m_iPrevMoveY = -1;
	m_sDamageMove = 0;
	m_sDamageMoveAmount = 0;
	m_bForceDisconn = FALSE;
	m_bIsSpecialAbilityEnabled = FALSE;
	m_iSpecialAbilityType = 0;
	m_dwSpecialAbilitySettingTime = NULL;
	m_iSpecialAbilityTimeLeftSec = NULL;
	m_stMCursor.cSelectedObjectType = NULL;
	m_bIsF1HelpWindowEnabled = FALSE;
	m_bIsTeleportRequested = FALSE;
	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++)
	{	m_stCrusadeStructureInfo[i].cType = NULL;
		m_stCrusadeStructureInfo[i].cSide = NULL;
		m_stCrusadeStructureInfo[i].sX = NULL;
		m_stCrusadeStructureInfo[i].sY = NULL;
	}
	ZeroMemory(m_cStatusMapName, sizeof(m_cStatusMapName));
	m_dwCommanderCommandRequestedTime = NULL;
	ZeroMemory(m_cTopMsg, sizeof(m_cTopMsg));
	m_iTopMsgLastSec = NULL;
	m_dwTopMsgTime   = NULL;
	m_iConstructionPoint = NULL;
	m_iWarContribution   = NULL;
	ZeroMemory(m_cTeleportMapName, sizeof(m_cTeleportMapName));
	m_iTeleportLocX = m_iTeleportLocY = -1;
	ZeroMemory(m_cConstructMapName, sizeof(m_cConstructMapName));
	m_iConstructLocX = m_iConstructLocY = -1;

	//Snoopy: Apocalypse Gate
	ZeroMemory(m_cGateMapName, sizeof(m_cGateMapName));
	m_iGatePositX = m_iGatePositY = -1;
	m_iHeldenianAresdenLeftTower	= -1;
	m_iHeldenianElvineLeftTower		= -1;
	m_iHeldenianAresdenFlags		= -1;
	m_iHeldenianElvineFlags			= -1;
	m_bIsXmas = FALSE;
	m_iTotalPartyMember = 0;
	m_iPartyStatus = 0;
	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));
	m_iGizonItemUpgradeLeft = 0;
	cStateChange1 = 0;
	cStateChange2 = 0;
	cStateChange3 = 0;
	EnableDialogBox(9, 0, 0, 0 );
}

void CGame::_GetHairColorRGB(int iColorType, int * pR, int * pG, int * pB)
{	switch (iColorType) {
	case 0: // rouge foncé
		*pR = 14; *pG = -5; *pB = -5; break;
	case 1: // Orange
		*pR = 20; *pG = 0; *pB = 0; break;
	case 2: // marron tres clair
		*pR = 22; *pG = 13; *pB = -10; break;
	case 3: // vert
		*pR = 0; *pG = 10; *pB = 0; break;
	case 4: // Bleu flashy
		*pR = 0; *pG = 0; *pB = 22; break;
	case 5: // Bleu foncé
		*pR = -5; *pG = -5; *pB = 15; break;
	case 6: //Mauve
		*pR = 15; *pG = -5; *pB = 16; break;
	case 7: // Noir
		*pR = -6; *pG = -6; *pB = -6; break;

#ifdef DEF_EQUILIBRIUM_PROJECT // cheveux
	case 8: // Brun foncé
		*pR = 6; *pG = -2; *pB = -6; break;
	case 9: // Chatain
		*pR = 10; *pG = 3; *pB = -10; break;
	case 10: // chatain clair
		*pR = 14; *pG = 7; *pB = -14; break;
	case 11: // Blond
		*pR = 18; *pG = 20; *pB = 6; break;
	case 12: // Blond or
		*pR = 22; *pG = 24; *pB = -24; break;
	case 13: // Poivre et sel
		*pR = 12; *pG = 12; *pB = 9; break;
	case 14: // Gris clair
		*pR = 15; *pG = 19; *pB = 13; break;
	case 15: // Blanc
		*pR = 18; *pG = 26; *pB = 17; break;
#else
	case 8:
		*pR = 10; *pG = 3; *pB = 10; break;
	case 9:
		*pR = 10; *pG = 3; *pB = -10; break;
	case 10:
		*pR = -10; *pG = 3; *pB = 10; break;
	case 11:
		*pR = 10; *pG = 3; *pB = 20; break;
	case 12:
		*pR = 21; *pG = 3; *pB = 3; break;
	case 13:
		*pR = 3; *pG = 3; *pB = 25; break;
	case 14:
		*pR = 3; *pG = 11; *pB = 3; break;
	case 15:
		*pR = 6; *pG = 8; *pB = 0; break;
#endif

	}
}

void CGame::DlgBoxClick_GuildMenu(short msX, short msY)
{short sX, sY;
 char cTemp[21];
 int iAdjX , iAdjY ;
	sX = m_stDialogBoxInfo[7].sX;
	sY = m_stDialogBoxInfo[7].sY ;

	iAdjX = -13;
	iAdjY = 30;

	switch (m_stDialogBoxInfo[7].cMode) {
	case 0:
		if ((msX > sX + iAdjX + 80) && (msX < sX + iAdjX + 210) && (msY > sY + iAdjY + 63) && (msY < sY + iAdjY + 78))
		{	if (m_iGuildRank != -1) return;
			if (m_iCharisma < 20) return;
			if (m_iLevel < 20) return;
			if (m_bIsCrusadeMode) return;
			EndInputString();
			StartInputString(sX + 75, sY + 140, 21, m_cGuildName);
			m_stDialogBoxInfo[7].cMode = 1;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 72) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 82) && (msY < sY + iAdjY + 99))
		{	if (m_iGuildRank != 0) return;
			if (m_bIsCrusadeMode) return;
			m_stDialogBoxInfo[7].cMode = 5;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 61) && (msX < sX + iAdjX + 226) && (msY > sY + iAdjY + 103) && (msY < sY + iAdjY + 120))
		{	m_stDialogBoxInfo[7].cMode = 9;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 60) && (msX < sX + iAdjX + 227) && (msY > sY + iAdjY + 123) && (msY < sY + iAdjY + 139))
		{	m_stDialogBoxInfo[7].cMode = 11;
			PlaySound('E', 14, 5);
		}
		if( m_iFightzoneNumber < 0 ) break ;
		if ((msX > sX + iAdjX + 72) && (msX < sX + iAdjX + 228) && (msY > sY + iAdjY + 143) && (msY < sY + iAdjY + 169))
		{	if (m_iGuildRank != 0) return;
			if (m_iFightzoneNumber == 0 )	m_stDialogBoxInfo[7].cMode = 13;
			else  m_stDialogBoxInfo[7].cMode = 19;
			PlaySound('E', 14, 5);
		}
		break;
	case 1:
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Submit
			if (strcmp(m_cGuildName, "NONE") == 0) return;
			if (strlen(m_cGuildName) == 0) return;
			bSendCommand(MSGID_REQUEST_CREATENEWGUILD, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL, NULL, NULL);
			m_stDialogBoxInfo[7].cMode = 2;
			EndInputString();
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel
			m_stDialogBoxInfo[7].cMode = 0;
			EndInputString();
			PlaySound('E', 14, 5);
		}
		break;

	case 3:
	case 4:
	case 7:
	case 8:
	case 10:
	case 12:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 9:
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Purchase¹
			ZeroMemory(cTemp, sizeof(cTemp));
			strcpy(cTemp,"GuildAdmissionTicket");
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_PURCHASEITEM, NULL, 1, NULL, NULL, cTemp);
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 11:
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Purchase
			ZeroMemory(cTemp, sizeof(cTemp));
			strcpy(cTemp,"GuildSecessionTicket");
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_PURCHASEITEM, NULL, 1, NULL, NULL, cTemp);
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 5:
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Confirm
			bSendCommand(MSGID_REQUEST_DISBANDGUILD, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL, NULL, NULL);
			m_stDialogBoxInfo[7].cMode = 6;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 13:
		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 168) && (msY < sY + iAdjY + 185))
		{	bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 1, NULL, NULL, NULL);
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 1;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 168) && (msY < sY + iAdjY + 185))
		{	bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 2, NULL, NULL, NULL);
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 2;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 188) && (msY < sY + iAdjY + 205))
		{	bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 3, NULL, NULL, NULL);
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 3;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 188) && (msY < sY + iAdjY + 205))
		{	bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 4, NULL, NULL, NULL);
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 4;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 208) && (msY < sY + iAdjY + 225))
		{	bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 5, NULL, NULL, NULL);
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 5;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 208) && (msY < sY + iAdjY + 225))
		{	bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 6, NULL, NULL, NULL);
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 6;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 65) && (msX < sX + iAdjX + 137) && (msY > sY + iAdjY + 228) && (msY < sY + iAdjY + 245))
		{	bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 7, NULL, NULL, NULL);
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 7;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + iAdjX + 150) && (msX < sX + iAdjX + 222) && (msY > sY + iAdjY + 228) && (msY < sY + iAdjY + 245))
		{ 	bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, NULL, NULL, 8, NULL, NULL, NULL);
			m_stDialogBoxInfo[7].cMode = 18;
			m_iFightzoneNumberTemp = 8;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break ;

	case 14://
	case 15://
	case 16://
	case 17://
	case 21://
	case 22://
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// OK
			m_stDialogBoxInfo[7].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break ;
	}
}

void CGame::CreateNewGuildResponseHandler(char * pData)
{WORD * wpResult;
 	wpResult = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	switch (*wpResult) {
	case DEF_MSGTYPE_CONFIRM:
		m_iGuildRank = 0;
		m_stDialogBoxInfo[7].cMode = 3;
		break;
	case DEF_MSGTYPE_REJECT:
		m_iGuildRank = -1;
		m_stDialogBoxInfo[7].cMode = 4;
		break;
	}
}

void CGame::InitPlayerCharacteristics(char * pData)
{int  * ip;
 char * cp;
 WORD * wp;
	// Snoopy: Angels
	m_iAngelicStr = 0;
	m_iAngelicDex = 0;
	m_iAngelicInt = 0;
	m_iAngelicMag = 0;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ip   = (int *)cp;
	m_iHP = *ip;
	cp += 4;
	ip   = (int *)cp;
	m_iMP = *ip;
	cp += 4;
	ip   = (int *)cp;
	m_iSP = *ip;
	cp += 4;
	ip   = (int *)cp;
	m_iAC = *ip;		//â m_iDefenseRatio
	cp += 4;
	ip   = (int *)cp;
	m_iTHAC0 = *ip;    //» m_iHitRatio
	cp += 4;
	ip   = (int *)cp;
	m_iLevel = *ip;
	cp += 4;
	ip   = (int *)cp;
	m_iStr = *ip;
	cp += 4;
	ip   = (int *)cp;
	m_iInt = *ip;
	cp += 4;
	ip   = (int *)cp;
	m_iVit = *ip;
	cp += 4;
	ip   = (int *)cp;
	m_iDex = *ip;
	cp += 4;
	ip   = (int *)cp;
	m_iMag = *ip;
	cp += 4;
	ip   = (int *)cp;
	m_iCharisma = *ip;
	cp += 4;

	// CLEROTH - LU
	wp = (WORD *)cp;
	m_iLU_Point = *wp - 3;
	cp += 7; // 2 + 5

	/* ORIGINAL
	m_cLU_Str = *cp;
	cp++;
	m_cLU_Vit = *cp;
	cp++;
	m_cLU_Dex = *cp;
	cp++;
	m_cLU_Int = *cp;
	cp++;
	m_cLU_Mag = *cp;
	cp++;
	m_cLU_Char = *cp;
	cp++;

	m_iLU_Point = 3 - (m_cLU_Str + m_cLU_Vit + m_cLU_Dex + m_cLU_Int + m_cLU_Mag + m_cLU_Char);
*/

	ip   = (int *)cp;
	m_iExp = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iEnemyKillCount = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iPKCount = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iRewardGold = *ip;
	cp += 4;

	memcpy(m_cLocation, cp, 10);
	cp += 10;
	if (memcmp(m_cLocation, "aresden", 7) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "arehunter", 9) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter  = TRUE;
	}else if (memcmp(m_cLocation, "elvine", 6) == 0)
	{	m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
	{	m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter  = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // m_bAresden, m_bCitizen, m_bHunter for me ready for later fix
	}else if (memcmp(m_cLocation, "executor", 8) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "evil", 4) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "NONE", 4) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = TRUE;
#endif

	}else
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = TRUE;
	}

	cp = (char *)cp;
	memcpy(m_cGuildName, cp, 20);
	cp += 20;

	if (strcmp(m_cGuildName, "NONE") == 0)
		ZeroMemory(m_cGuildName, sizeof(m_cGuildName));

	m_Misc.ReplaceString(m_cGuildName, '_', ' ');
	ip   = (int *)cp;
	m_iGuildRank = *ip;
	cp += 4;
	m_iSuperAttackLeft = (int)*cp;
	cp++;
	ip   = (int *)cp;
	m_iFightzoneNumber = *ip;
	cp += 4;
}


void CGame::DisbandGuildResponseHandler(char * pData)
{WORD * wpResult;
 	wpResult = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	switch (*wpResult) {
	case DEF_MSGTYPE_CONFIRM:
		ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
		m_iGuildRank = -1;
		m_stDialogBoxInfo[7].cMode = 7;
		break;
	case DEF_MSGTYPE_REJECT:
		m_stDialogBoxInfo[7].cMode = 8;
		break;
	}
}

void CGame::NotifyMsg_BanGuildMan(char * pData)
{ char * cp, cName[24], cLocation[12];
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cLocation, sizeof(cLocation));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 20);
	cp += 20;
	cp += 2;
	memcpy(cLocation, cp, 10);
	cp += 10;
	ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
	m_iGuildRank = -1;
	ZeroMemory(m_cLocation, sizeof(m_cLocation));
	memcpy(m_cLocation, cLocation, 10);
	if (memcmp(m_cLocation, "aresden", 7) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "arehunter", 9) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter  = TRUE;
	}else if (memcmp(m_cLocation, "elvine", 6) == 0)
	{	m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
	{	m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter  = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // m_bAresden, m_bCitizen, m_bHunter for me ready for later fix
	}else if (memcmp(m_cLocation, "executor", 8) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "evil", 4) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "NONE", 4) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = TRUE;
#endif
	}else
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = TRUE;
	}
	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 8);
}

void CGame::_PutGuildOperationList(char * pName, char cOpMode)
{int i;
	for (i = 0; i < 100; i++)
	if (m_stGuildOpList[i].cOpMode == NULL)
	{	m_stGuildOpList[i].cOpMode = cOpMode;
		ZeroMemory(m_stGuildOpList[i].cName, sizeof(m_stGuildOpList[i].cName));
		memcpy(m_stGuildOpList[i].cName, pName, 20);
		return;
	}
}

void CGame::_ShiftGuildOperationList()
{int i;
	ZeroMemory(m_stGuildOpList[0].cName ,sizeof(m_stGuildOpList[0].cName));
	m_stGuildOpList[0].cOpMode = NULL;

	for (i = 1; i < 100; i++)
	if ((m_stGuildOpList[i-1].cOpMode == NULL) && (m_stGuildOpList[i].cOpMode != NULL)) {
		m_stGuildOpList[i-1].cOpMode = m_stGuildOpList[i].cOpMode;
		ZeroMemory(m_stGuildOpList[i-1].cName, sizeof(m_stGuildOpList[i-1].cName));
		memcpy(m_stGuildOpList[i-1].cName, m_stGuildOpList[i].cName, 20);

		ZeroMemory(m_stGuildOpList[i].cName ,sizeof(m_stGuildOpList[i].cName));
		m_stGuildOpList[i].cOpMode = NULL;
	}
}



void CGame::DlgBoxClick_GuildOp(short msX, short msY)
{
 short sX, sY;
 char cName[12], cName20[24];

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cName20, sizeof(cName20));
	sX = m_stDialogBoxInfo[8].sX;
	sY = m_stDialogBoxInfo[8].sY;

	switch (m_stGuildOpList[0].cOpMode) {
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			_ShiftGuildOperationList();
			if (m_stGuildOpList[0].cOpMode == NULL) DisableDialogBox(8);
		}
		return;
	}

	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		// Approve
		PlaySound('E', 14, 5);

		switch (m_stGuildOpList[0].cOpMode) {
		case 1:
			strcpy(cName20, m_stGuildOpList[0].cName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_JOINGUILDAPPROVE, NULL, NULL, NULL, NULL, cName20);
			break;

		case 2:
			strcpy(cName20, m_stGuildOpList[0].cName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL, cName20);
			break;
		}
		_ShiftGuildOperationList();
		if (m_stGuildOpList[0].cOpMode == NULL) DisableDialogBox(8);
	}

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		// Reject
		PlaySound('E', 14, 5);

		switch (m_stGuildOpList[0].cOpMode) {
		case 1:
			strcpy(cName20, m_stGuildOpList[0].cName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_JOINGUILDREJECT, NULL, NULL, NULL, NULL, cName20);
			break;

		case 2:
			strcpy(cName20, m_stGuildOpList[0].cName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_DISMISSGUILDREJECT, NULL, NULL, NULL, NULL, cName20);
			break;
		}

		_ShiftGuildOperationList();
		if (m_stGuildOpList[0].cOpMode == NULL) DisableDialogBox(8);
	}
}

void CGame::SetItemCount(char * pItemName, DWORD dwCount)
{int i;
 char cTmpName[21];
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);
	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pItemList[i] != NULL) && (memcmp(m_pItemList[i]->m_cName, cTmpName, 20) == 0))
	{	m_pItemList[i]->m_dwCount = dwCount;
		return;
	}
}


void CGame::AddEventList(char * pTxt, char cColor, BOOL bDupAllow)
{int i;
	if ((bDupAllow == FALSE) && (strcmp(m_stEventHistory[5].cTxt, pTxt) == 0)) return;
	if (cColor == 10)
	{	for (i = 1; i < 6; i++)
		{	strcpy(m_stEventHistory2[i-1].cTxt, m_stEventHistory2[i].cTxt);
			m_stEventHistory2[i-1].cColor = m_stEventHistory2[i].cColor;
			m_stEventHistory2[i-1].dwTime = m_stEventHistory2[i].dwTime;
		}
		ZeroMemory(m_stEventHistory2[5].cTxt, sizeof(m_stEventHistory2[5].cTxt));
		strcpy(m_stEventHistory2[5].cTxt, pTxt);
		m_stEventHistory2[5].cColor = cColor;
		m_stEventHistory2[5].dwTime = m_dwCurTime;
	}else
	{	for (i = 1; i < 6; i++)
		{	strcpy(m_stEventHistory[i-1].cTxt, m_stEventHistory[i].cTxt);
			m_stEventHistory[i-1].cColor = m_stEventHistory[i].cColor;
			m_stEventHistory[i-1].dwTime = m_stEventHistory[i].dwTime;
		}
		ZeroMemory(m_stEventHistory[5].cTxt, sizeof(m_stEventHistory[5].cTxt));
		strcpy(m_stEventHistory[5].cTxt, pTxt);
		m_stEventHistory[5].cColor = cColor;
		m_stEventHistory[5].dwTime = m_dwCurTime;
	}
}

int _iAttackerHeight[] = {0, 35, 35,35,35,35,35, 0,0,0,
5,  // Slime
35, // Skeleton
40, // Stone-Golem
45, // Cyclops
35,// OrcMage
35,// ShopKeeper
5, // GiantAnt
8, // Scorpion
35,// Zombie
35,// Gandalf
35,// Howard
35,// Guard
10,// Amphis
38,// Clay-Golem
35,// Tom
35,// William
35,// Kennedy
35,// Hellhound
50,// Troll
45,// Orge
55,// Liche
65,// Demon
46,// Unicorn
49,// WereWolf
55,// Dummy
35,// Energysphere
75,// Arrow Guard Tower
75,// Cannon Guard Tower
50,// Mana Collector
50,// Detector
50,// Energy Shield Generator
50,// Grand Magic Generator
50,// ManaStone 42
40,// Light War Beetle
35,// GHK
40,// GHKABS
35,// TK
60,// BG
40,// Stalker
70,// HellClaw
85,// Tigerworm
50,// Catapult
85,// Gargoyle
70,// Beholder
40,// Dark-Elf
20,// Bunny
20,// Cat
40,// Giant-Frog
80,// Mountain-Giant
85,// Ettin
50,// Cannibal-Plant
50, // Rudolph 61 //Snoopy....
80, // Direboar 62
90, // Frost 63
40, // Crops 64
80, // IceGolem 65
190, // Wyvern 66
35, // npc 67
35, // npc 68
35, // npc 69
100, // Dragon 70
90, // Centaur 71
75, // ClawTurtle 72
200, // FireWyvern 73
80, // GiantCrayfish 74
120, // Gi Lizard 75
100, // Gi Tree 76
100, // Master Orc 77
80, // Minaus 78
100, // Nizie 79
25,  // Tentocle 80
200, // Abaddon	 81
60, // Sorceress 82
60, // ATK 83
70, // MasterElf 84
60, // DSK 85
50, // HBT 86
60, // CT 87
60, // Barbarian 88
60, // AGC 89
35, // ncp 90 Gail
35, // Gate 91
35, // 92
35, // 93
35, // 94
45, // 95 Willowisp
80, // 96 Air Elemental
70, // 97 Fire Elemental
60, // 98 Earth Elemental
100, // 99 Ice Elemental
35, // 100
35  // 101

};

void CGame::bAddNewEffect(short sType, int sX, int sY, int dX, int dY, char cStartFrame, int iV1)
{int i;
 short sAbsX, sAbsY, sDist;
 long lPan;
 int  iV2 = 0;
	if (m_cDetailLevel == 0) // Detail Level Low
	{	switch (sType) {
		case 8:
		case 9:
		case 11:
		case 12:
		case 14:
		case 15:
			return;
	}	}
	if( m_bIsProgramActive == FALSE ) return;
  	sAbsX = abs(((m_sViewPointX / 32) + 10) - dX);
	sAbsY = abs(((m_sViewPointY / 32) + 7) - dY);
	if (sAbsX > sAbsY) sDist = sAbsX;
	else sDist = sAbsY;

	for (i = 0; i < DEF_MAXEFFECTS; i++)
	if (m_pEffectList[i] == NULL)
	{	m_pEffectList[i] = new class CEffect;
		m_pEffectList[i]->m_sType  = sType;
		m_pEffectList[i]->m_sX     = sX;
		m_pEffectList[i]->m_sY     = sY;
		m_pEffectList[i]->m_dX     = dX;
		m_pEffectList[i]->m_dY     = dY;
		m_pEffectList[i]->m_iV1    = iV1;
		m_pEffectList[i]->m_cFrame = cStartFrame;
		m_pEffectList[i]->m_dwTime = m_dwCurTime;

		switch (sType) {
		case 1: // coup normal
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - _iAttackerHeight[iV1];
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 2:	// Flêche qui vole
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - _iAttackerHeight[iV1];
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = 0;
			m_pEffectList[i]->m_dwFrameTime = 10;
			m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);
			PlaySound('C', 4, sDist);
			break;

		case 4: // Gold
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32;
			m_pEffectList[i]->m_cMaxFrame   = 12;
			m_pEffectList[i]->m_dwFrameTime = 100;
			sAbsX = abs(((m_sViewPointX / 32) + 10) - sX);
			sAbsY = abs(((m_sViewPointY / 32) + 7)  - sY);
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			lPan = -(((m_sViewPointX / 32) + 10) - sX)*1000;
			PlaySound('E', 12, sDist, lPan);
			break;

		case 5: // FireBall Fire Explosion
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 11;
			m_pEffectList[i]->m_dwFrameTime = 10;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(((m_sViewPointX / 32) + 10) - sX)*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist);
			break;

		case 6:	 // Energy Bolt
		case 10: // Lightning Arrow
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 14;
			m_pEffectList[i]->m_dwFrameTime = 10;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(320 - (sX - m_sViewPointX))*1000;
			PlaySound('E', 2, sDist, lPan);
			SetCameraShakingEffect(sDist);
			break;

		case 7: // Magic Missile Explosion
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 5;
			m_pEffectList[i]->m_dwFrameTime = 50;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(320 - (sX - m_sViewPointX))*1000;
			PlaySound('E', 3, sDist, lPan);
			break;

		case 8: // Burst
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 4;
			m_pEffectList[i]->m_dwFrameTime = 30;
			break;

		case 9: // Burst
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_rX     =  6 - (rand() % 12);
			m_pEffectList[i]->m_rY     = -8 - (rand() % 6);
			m_pEffectList[i]->m_cMaxFrame   = 14;
			m_pEffectList[i]->m_dwFrameTime = 30;
			break;

		case 11:
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_rX     =  6 - (rand() % 12);
			if (iV2 == 0)
				 m_pEffectList[i]->m_rY     = -2 - (rand() % 4);
			else m_pEffectList[i]->m_rY     = -2 - (rand() % 10);
			m_pEffectList[i]->m_cMaxFrame   = 8;
			m_pEffectList[i]->m_dwFrameTime = 30;
			break;

		case 12: // Burst
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_rX    =  8 - (rand() % 16);
			m_pEffectList[i]->m_rY    =  4 - (rand() % 12);
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 30;
			break;

		case 13: // Bulles druncncity
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 18;
			m_pEffectList[i]->m_dwFrameTime = 20;
			break;

		case 14: // Traces de pas ou Tremor (pas en low detail)
			m_pEffectList[i]->m_mX    = sX;
			if (m_pEffectList[i]->m_iV1 > 0) // Case if hit by an arrow
			{	m_pEffectList[i]->m_mY = sY - (_iAttackerHeight[m_pEffectList[i]->m_iV1]/4 + rand()%(_iAttackerHeight[m_pEffectList[i]->m_iV1]/2) );
				m_pEffectList[i]->m_mX = sX + (rand()%5) -2;
			}else m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 4;
			m_pEffectList[i]->m_dwFrameTime = 100;
			m_pEffectList[i]->m_iV1 = iV1;
			break;

		case 15: // feu
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

		case 16: //
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			break;

		case 17: // Ice Storm ?
			m_pEffectList[i]->m_mX     = sX + (rand() % 20) - 40;
			m_pEffectList[i]->m_mY     = sY + (rand() % 20) - 40;
			m_pEffectList[i]->m_rX     =  8 - (rand() % 16);
			m_pEffectList[i]->m_rY     =  4 - (rand() % 12);
			m_pEffectList[i]->m_mX3    = sX;
			m_pEffectList[i]->m_mY3    = sY;
			m_pEffectList[i]->m_iV1    = 0;
			m_pEffectList[i]->m_dwFrameTime = 20;
			break;

		case 18:
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 50;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			SetCameraShakingEffect(sDist);
			break;

		case 20:
		case 21:
		case 22:
		case 23:
		case 24:
		case 25:
		case 26:
		case 27: // Critical strike with a weapon
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = 0;
			m_pEffectList[i]->m_dwFrameTime = 10;
			m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);
			break;

		case 30: // Mass-Fire-Strike (called 1 time)
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 9;
			m_pEffectList[i]->m_dwFrameTime = 40;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(320 - (sX - m_sViewPointX))*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist*2);
			break;

		case 31: // Mass-Fire-Strike (called 3 times)
		case 252: //
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 8;
			m_pEffectList[i]->m_dwFrameTime = 40;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(320 - (sX - m_sViewPointX))*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist);
			break;

		case 32: //
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = 4;
			m_pEffectList[i]->m_dwFrameTime = 100;
			break;

		case 33: //
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 34: //
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			SetCameraShakingEffect(sDist);
			break;

		case 35: // Snoopy: rajout (pour Mass Magic-Missile)
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 18;
			m_pEffectList[i]->m_dwFrameTime = 40;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(320 - (sX - m_sViewPointX))*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist*2);
			break;

		case 36: // Snoopy: Rajout (pour Mass Magic-Missile)
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 40;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(320 - (sX - m_sViewPointX))*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist);
			break;

		case 40: //
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 30;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = ((sX - m_sViewPointX)-320)*30;
			PlaySound('E', 45, sDist, lPan);
			break;

		case 41: // Large Type 1, 2, 3, 4 Ice Strike
		case 42:
		case 43:
		case 44:
		case 45: // Small Type 1, 2
		case 46:			
			if (m_pEffectList[i]->m_iV1 >1) // Ice Elemental
			{	m_pEffectList[i]->m_mX     = sX;
				m_pEffectList[i]->m_mY  = sY - m_pEffectList[i]->m_iV1;
				m_pEffectList[i]->m_cMaxFrame   = 7;
				m_pEffectList[i]->m_dwFrameTime = 20;
				m_pEffectList[i]->m_iV1 = 20;
			}else
			{	m_pEffectList[i]->m_mX     = sX;
				m_pEffectList[i]->m_mY     = sY -220;
				m_pEffectList[i]->m_cMaxFrame   = 14;
				m_pEffectList[i]->m_dwFrameTime = 20;
				m_pEffectList[i]->m_iV1 = 20;
			}
			m_pEffectList[i]->m_iV1 = 20;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = ((sX - m_sViewPointX)-320)*30;
			PlaySound('E', 46, sDist, lPan);
			break;

		case 47: // Blizzard
		case 48: // Blizzard
		case 49: // Blizzard
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY -220;
			m_pEffectList[i]->m_cMaxFrame   = 12;
			m_pEffectList[i]->m_dwFrameTime = 20;
			m_pEffectList[i]->m_iV1 = 20;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = ((sX - m_sViewPointX)-320)*30;
			PlaySound('E', 46, sDist, lPan);
			break;

		case 50: //
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 12;
			m_pEffectList[i]->m_dwFrameTime = 50;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = ((sX - m_sViewPointX)-320)*30;
			if ((rand()%4) == 1) SetCameraShakingEffect(sDist);
			PlaySound('E', 47, sDist, lPan);
			break;

		case 51:
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 9; //15;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

		case 52: // Protect ring
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 80;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = ((sX - m_sViewPointX)-320)*30;
			PlaySound('E', 5, sDist, lPan);
			break;

		case 53: // Hold twist
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 80;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = ((sX - m_sViewPointX)-320)*30;
			PlaySound('E', 5, sDist, lPan);
			break;

		case 54: // star twingkling (effect armes brillantes)
		case 55: // Unused
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 15;
			break;

		case 56: //  Mass-Chill-Wind
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 14;
			m_pEffectList[i]->m_dwFrameTime = 30;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = ((sX - m_sViewPointX)-320)*30;
			PlaySound('E', 45, sDist, lPan);
			break;

		case 57: //
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

		case 60: //
			m_pEffectList[i]->m_mX    = sX +300;
			m_pEffectList[i]->m_mY    = sY -460;
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 50;
			break;

		case 61: //
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 10;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(((m_sViewPointX / 32) + 10) - sX)*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist, 2);
			break;

		case 62: //
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 6;
			m_pEffectList[i]->m_dwFrameTime = 100;
			break;

		case 63: //
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 20;
			break;

		case 64: //
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 20;
			break;

		case 65: // Crusade's MS
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 30;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

		case 66: // Crusade MS explosion
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 14;
			m_pEffectList[i]->m_dwFrameTime = 30;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(((m_sViewPointX / 32) + 10) - sX)*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist, 2);
			break;

		case 67: // Crusade's MS fire + smoke ?
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 27;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 68: // worm-bite
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 17;
			m_pEffectList[i]->m_dwFrameTime = 30;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(((m_sViewPointX / 32) + 10) - sX)*1000;
			PlaySound('E', 4, sDist, lPan);
			m_pEffectList[i]->m_iV1 = sDist;
			//SetCameraShakingEffect(sDist, 2);
			break;

		case 69: // identique au cas 70
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 11;
			m_pEffectList[i]->m_dwFrameTime = 30;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(((m_sViewPointX / 32) + 10) - (sX/32))*1000;
			PlaySound('E', 42, sDist, lPan);
			break;

		case 70: // identtique au cas 69
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 11;
			m_pEffectList[i]->m_dwFrameTime = 30;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(((m_sViewPointX / 32) + 10) - (sX/32))*1000;
			PlaySound('E', 42, sDist, lPan);
			break;

		case 71: //
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			SetCameraShakingEffect(sDist);
			break;

		case 72: // Blizzard
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 20;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = ((sX - m_sViewPointX)-320)*30;
			if ((rand()%4) == 1) SetCameraShakingEffect(sDist);
			PlaySound('E', 47, sDist, lPan);
			break;

		case 73:
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 60;
			break;

		case 74:
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 19;
			m_pEffectList[i]->m_dwFrameTime = 40;
			break;

		case 75: //ice golem
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_dX = dX;
			m_pEffectList[i]->m_dY = dY;
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 40;
			break;

		case 76: //ice golem
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_dX = dX;
			m_pEffectList[i]->m_dY = dY;
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 40;
			break;

		case 77: //ice golem
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_dX = dX;
			m_pEffectList[i]->m_dY = dY;
			m_pEffectList[i]->m_cMaxFrame   = 16;
			m_pEffectList[i]->m_dwFrameTime = 40;
			break;

		case 80: // Snoopy: rajoué, implémenté en dernier ds la v351
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_iV1    = 20;
			m_pEffectList[i]->m_cMaxFrame   = 30;
			m_pEffectList[i]->m_dwFrameTime = 25;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			SetCameraShakingEffect(sDist);
			break;

		case 81: //  Snoopy: Rajout (StormBlade)
			m_pEffectList[i]->m_mX		= sX*32;
			m_pEffectList[i]->m_mY		= sY*32;
			m_pEffectList[i]->m_iErr	= 0;
			m_pEffectList[i]->m_cMaxFrame   = 27;
			m_pEffectList[i]->m_dwFrameTime = 40;
			break;

		case 82: //  Snoopy: Rajout (Gate Apocalypse)
			m_pEffectList[i]->m_cMaxFrame   = 30;
			m_pEffectList[i]->m_dwFrameTime = 40;
			break;


		case 85: // Fire explosion from the ground (effect14.pak)
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 90;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(((m_sViewPointX / 32) + 10) - sX)*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist, 2);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT // EP's Crystal axe hit
		case 109: // EP's Crystal axe hit
#endif
		case 100: // MagicMissile is Flying
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 1, sDist, lPan);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 115: // EP's Staminar-Recovery
		case 148: // Critical heal
		case 168: // Mass heal
		case 186: // Regenerate
#endif
		case 101: // Heal
		case 111: // Staminar-Drain
		case 121: // Great Heal
		case 123: // Staminar-Recovery
		case 128: // Great-Staminar-Recovery
			m_pEffectList[i]->m_cMaxFrame   = 14;
			m_pEffectList[i]->m_dwFrameTime = 80;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;

#ifndef DEF_EQUILIBRIUM_PROJECT
		case 122: // EP's Tremor so remove from here
#endif

		case 102: // CreateFood
		case 126: // Possession
		case 127: // Poison
		case 134: // DetectInvi
		case 136: // Cure
		case 142: // Confuse language
		case 152: // Polymorph
		case 153: // Mass-Poison
		case 162: // Confusion
		case 171: // Mass-Confusion
			m_pEffectList[i]->m_cMaxFrame   = 13;
			m_pEffectList[i]->m_dwFrameTime = 120;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;

		case 110: // Energy-Bolt
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 1, sDist, lPan);
			break;

		case 112: // Recall
		case 131: // Summon
		case 132: // Invi
			m_pEffectList[i]->m_cMaxFrame   = 12;
			m_pEffectList[i]->m_dwFrameTime = 80;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;

		case 113: // Defense-Shield
		case 144: // Great-Defense-Shield
			m_pEffectList[i]->m_cMaxFrame   = 12;
			m_pEffectList[i]->m_dwFrameTime = 120;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;

		case 114: // Celebrating Light
			bAddNewEffect(69 +(rand()%2), dX*32 +20 - (rand() % 40), dY*32 +20 - (rand() % 40), NULL, NULL, -12);
			bAddNewEffect(69 +(rand()%2), dX*32 +20 - (rand() % 40), dY*32 +20 - (rand() % 40), NULL, NULL, -9);
			bAddNewEffect(69 +(rand()%2), dX*32 +20 - (rand() % 40), dY*32 +20 - (rand() % 40), NULL, NULL, -6);
			bAddNewEffect(69 +(rand()%2), dX*32 +20 - (rand() % 40), dY*32 +20 - (rand() % 40), NULL, NULL, -3);
			bAddNewEffect(69 +(rand()%2), dX*32 +20 - (rand() % 40), dY*32 +20 - (rand() % 40), NULL, NULL, 0);
			delete m_pEffectList[i];
			m_pEffectList[i] = NULL;
			break;

		case 120: // Fire Ball
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 1, sDist, lPan);
			break;

		case 124: // Protect form N.M
		case 133: // Protection from Magic
 			bAddNewEffect(52, dX*32, dY*32, NULL, NULL, 0, 0);
			delete m_pEffectList[i];
			m_pEffectList[i] = NULL;
			break;

		case 125: // Hold Person
		case 135: // Paralyze
#ifdef DEF_EQUILIBRIUM_PROJECT
		case 198: // Medusa Kiss
#endif
			bAddNewEffect(53, dX*32, dY*32, NULL, NULL, 0, 0);
			delete m_pEffectList[i];
			m_pEffectList[i] = NULL;
			break;

		case 130: // Fire Strike
		case 137: // Lightning Arrow
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 1, sDist, lPan);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 104: // Abaddon's fury
		case 105: // Ultimate Elixir
		case 122: // EP's Tremor
#else
		case 138: // Tremor.
#endif
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 4, sDist, lPan);
			SetCameraShakingEffect(sDist, 2);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);

			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 143: // Lightning
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 50;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_rX     = 5 - (rand() % 10);
			m_pEffectList[i]->m_rY	   = 5 - (rand() % 10);
			m_pEffectList[i]->m_cMaxFrame   = 7;
			m_pEffectList[i]->m_dwFrameTime = 10;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 40, sDist, lPan);
			break;

		case 145: // ChillWind
			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 147: // Triple-Energy-Bolt
			m_pEffectList[i]->m_cMaxFrame   = NULL ;
			m_pEffectList[i]->m_dwFrameTime = 20;
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 108: // EP's Test spell
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;			
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 60;
			lPan = -(((m_sViewPointX / 32) + 10) - sX)*1000;
			PlaySound('E', 3, sDist, lPan);
			break;

		case 118: // EP's Test spell
		case 107: // EP's Test spell
		case 138: // EP's prayer.
		case 175: // Trance		
		case 117: // EP's Wood Mantle
		case 158: // EP's Bloody Mantle
		case 187: // EP's Magic Mantle
		case 182: // Warrior's spirit
#endif
		case 150: // Berserk : Cirlcle 6 magic
		case 177: // Illusion-Movement
		case 180: // Illusion
		case 183: // Inhibition-Casting
		case 190: // Mass-Illusion
		case 195: // Mass-Illusion-Movement
			m_pEffectList[i]->m_cMaxFrame   = 11;
			m_pEffectList[i]->m_dwFrameTime = 100;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;

		case 151: // LightningBolt
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 50;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_rX     = 5 - (rand() % 10);
			m_pEffectList[i]->m_rY	   = 5 - (rand() % 10);
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 10;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 40, sDist, lPan);
			break;

		case 156: // Mass-Ligtning-Arrow
			m_pEffectList[i]->m_cMaxFrame   = 3;
			m_pEffectList[i]->m_dwFrameTime = 130;
			break;

		case 157: // Ice-Strike
			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 160: // Energy-Strike
			m_pEffectList[i]->m_cMaxFrame   = 7;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 178: // Divine revenge
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 1, sDist, lPan);
			break;

		case 106: // Forge's Breath
#endif

		case 161: // Mass-Fire-Strike
		case 251: //
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 1, sDist, lPan);
			break;

		case 163: // Mass-Chill-Wind
			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 164: // worm-bite
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 4, sDist, lPan);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);

			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			bAddNewEffect(14, dX*32 + (rand() % 120) - 60, dY*32 + (rand() % 80) - 40, NULL, NULL, 0, 0);
			m_pEffectList[i]->m_cMaxFrame   = 1;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 165: // Absolute-Magic-Protection
			m_pEffectList[i]->m_cMaxFrame   = 21;
			m_pEffectList[i]->m_dwFrameTime = 70;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 103: // Abaddon's Terror
		case 192: // Mass armor break
			m_pEffectList[i]->m_cMaxFrame   = 13;
			m_pEffectList[i]->m_dwFrameTime = 80;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist/2, lPan);
			break;
#endif
		case 166: // Armor Break
			m_pEffectList[i]->m_cMaxFrame   = 13;
			m_pEffectList[i]->m_dwFrameTime = 80;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 167: // Scan
			m_pEffectList[i]->m_cMaxFrame   = 12;
			m_pEffectList[i]->m_dwFrameTime = 80;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 50, sDist/2, lPan);
			break;
#endif

		case 170: // Bloody-Shock-Wave
			m_pEffectList[i]->m_cMaxFrame   = 7;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

		case 172: // Mass-Ice-Strike
			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 193: // Mass Lightning-Strike
#endif
		case 174: // Lightning-Strike
			m_pEffectList[i]->m_cMaxFrame   = 5;
			m_pEffectList[i]->m_dwFrameTime = 120;
			break;

		case 176: // Snoopy: Ajout Cancellation
			m_pEffectList[i]->m_cMaxFrame   = 23;
			m_pEffectList[i]->m_dwFrameTime = 60;
			sDist = sDist / 32;
			lPan = -(((m_sViewPointX / 32) + 10) - sX)*1000;
			PlaySound('E', 5, sDist, lPan);
			break;

		case 181: // MS
			m_pEffectList[i]->m_mX    = dX*32 +300;
			m_pEffectList[i]->m_mY    = dY*32 -460;
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 25;
			break;

#ifndef DEF_EQUILIBRIUM_PROJECT
		case 182: // Snoopy: Ajout Mass-Magic-Missile
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 1, sDist, lPan);
			break;
#endif

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 116: // EP's Peace spell
		case 184: // EP's Magic Drain
			m_pEffectList[i]->m_cMaxFrame   = 29;
			m_pEffectList[i]->m_dwFrameTime = 80;
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			break;
#endif
		case 244: // Snoopy: déplacé pour nvx sorts: Aura du casteur de Mass MagicMissile
		//case 184: // effet sur le caster pour MassMM
			m_pEffectList[i]->m_cMaxFrame   = 29;
			m_pEffectList[i]->m_dwFrameTime = 80;
			m_pEffectList[i]->m_mX    = sX;
			m_pEffectList[i]->m_mY    = sY;
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 185: // EP's Blizzard
#endif
		case 191: // Blizzard
			m_pEffectList[i]->m_cMaxFrame   = 7;
			m_pEffectList[i]->m_dwFrameTime = 80;
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 188: // Entangle
#endif
		//case 192: // Hero set Effect
		case 242: // Hero set Effect
			m_pEffectList[i]->m_cMaxFrame   = 30;
			m_pEffectList[i]->m_dwFrameTime = 40;
			break;

		//case 193: // Hero set Effect
		case 243: // Hero set Effect
			m_pEffectList[i]->m_cMaxFrame   = 19;
			m_pEffectList[i]->m_dwFrameTime = 18;
			break;

		case 194: // Resurrection
			m_pEffectList[i]->m_cMaxFrame   = 30;
			m_pEffectList[i]->m_dwFrameTime = 40;
			break;

		case 196: // Snoopy: Ajout de Earth-Shock-Wave
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = 30;
			m_pEffectList[i]->m_dwFrameTime = 25;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			SetCameraShakingEffect(sDist);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 197: // EP's Explosion
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 40;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_cMaxFrame   = NULL;
			m_pEffectList[i]->m_dwFrameTime = 20;
			m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 1, sDist/4, lPan);
			// Add enormous Shacking
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			SetCameraShakingEffect(sDist, 4);
			break;
#endif

		case 200: //
		case 201: //
		case 202: //
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 15;
			m_pEffectList[i]->m_dwFrameTime = 25;
			break;

		case 203: //
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 18;
			m_pEffectList[i]->m_dwFrameTime = 70;
			break;

		case 204: //
		case 205: //
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 12;
			m_pEffectList[i]->m_dwFrameTime = 70;
			break;

		case 206: //
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 3;
			m_pEffectList[i]->m_dwFrameTime = 70;
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT // buts, ZzZz
		case 210: // Effect14.pak, explosion sous les pieds			
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 9;
			m_pEffectList[i]->m_dwFrameTime = 25;
			break;

		case 237: // Air Elemental Attack			
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32 - 50;
			m_pEffectList[i]->m_iErr   = 0;
			m_pEffectList[i]->m_rX     = 5 - (rand() % 10);
			m_pEffectList[i]->m_rY	   = 5 - (rand() % 10);
			m_pEffectList[i]->m_cMaxFrame   = 10;
			m_pEffectList[i]->m_dwFrameTime = 10;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('E', 40, sDist, lPan);
			break;

		case 238: // Ice Elemental Attack
			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		case 239: // Ice Elemental OnMove
			m_pEffectList[i]->m_cMaxFrame   = 2;
			m_pEffectList[i]->m_dwFrameTime = 10;
			m_pEffectList[i]->m_iV1 = 80;
			break;

		case 240: //Air Elemental lightning onMove
			m_pEffectList[i]->m_rX     = 5 - (rand() % 10);
			m_pEffectList[i]->m_rY	   = 5 - (rand() % 10);
			m_pEffectList[i]->m_cMaxFrame   = 7;
			m_pEffectList[i]->m_dwFrameTime = 10;
			PlaySound('E', 40, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY);
			break;

		case 241: // Fire Elemental explosion onMove
			m_pEffectList[i]->m_mX     = sX;
			m_pEffectList[i]->m_mY     = sY;
			m_pEffectList[i]->m_cMaxFrame   = 9;
			m_pEffectList[i]->m_dwFrameTime = 40;
			sAbsX = abs(320 - (sX - m_sViewPointX));
			sAbsY = abs(240 - (sY - m_sViewPointY));
			if (sAbsX > sAbsY) sDist = sAbsX;
			else sDist = sAbsY;
			sDist = sDist / 32;
			lPan = -(320 - (sX - m_sViewPointX))*1000;
			PlaySound('E', 4, sDist +2, lPan);
			break;

		case 245: // But Elvine
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32;
			m_pEffectList[i]->m_cMaxFrame   = 30;
			m_pEffectList[i]->m_dwFrameTime = 121;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('C', 21, sDist, lPan);
			break;

		case 246: // But Ares
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32;
			m_pEffectList[i]->m_cMaxFrame   = 30;
			m_pEffectList[i]->m_dwFrameTime = 120;
			lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			PlaySound('C', 21, sDist, lPan);
			break;

		case 247: // ZzZz
			m_pEffectList[i]->m_mX     = sX*32;
			m_pEffectList[i]->m_mY     = sY*32;
			m_pEffectList[i]->m_cMaxFrame   = 17;
			m_pEffectList[i]->m_dwFrameTime = 200;
			m_pEffectList[i]->m_mX3    = sDist;
			m_pEffectList[i]->m_mY3    = -(((m_sViewPointX / 32) + 10) - dX)*1000;
			m_pEffectList[i]->m_iV1    = rand()%35; // Frame to start sound
			m_pEffectList[i]->m_cFrame = - rand() %12; // Start with delay
			break;
#endif

		case 250: //
			m_pEffectList[i]->m_mX     = sX * 32;
			m_pEffectList[i]->m_mY     = sY * 32 -40;
			m_pEffectList[i]->m_iErr = 0;
			m_pEffectList[i]->m_cMaxFrame   = 0;
			m_pEffectList[i]->m_dwFrameTime = 10;
			break;

		default:
			delete m_pEffectList[i];
			m_pEffectList[i] = NULL;
			break;
		}
		if (m_pEffectList[i] != NULL)
		{	m_pEffectList[i]->m_mX2 = m_pEffectList[i]->m_mX;
			m_pEffectList[i]->m_mY2 = m_pEffectList[i]->m_mY;
		}
		return;
	}
}

void CGame::DrawEffects()
{int i, dX, dY, iDvalue,  tX, tY, rX, rY, rX2, rY2, rX3, rY3, rX4, rY4, rX5, rY5, iErr;
 char  cTempFrame;
 DWORD dwTime = m_dwCurTime;
 short sObjectType;
 char  cName[21];
 int iStatus;

 	for (i = 0;	i < DEF_MAXEFFECTS; i++)
	if ((m_pEffectList[i] != NULL) && (m_pEffectList[i]->m_cFrame >= 0))
	{	switch (m_pEffectList[i]->m_sType) {
		case 1: // Normal hit
			if (m_pEffectList[i]->m_cFrame < 0) break;
			dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
			m_pEffectSpr[8]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 2: // Arrow flying
			dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*2;
			if (cTempFrame < 0) break;
			m_pEffectSpr[7]->PutSpriteFast(dX, dY, cTempFrame, dwTime);
			break;

		case 4: // gold
			/* 1.5
			if (m_pEffectList[i]->m_cFrame < 9) break;
			cTempFrame = m_pEffectList[i]->m_cFrame - 9;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[1]->PutSpriteFast(dX, dY-40, cTempFrame, dwTime);
			*/
			break;

		case 5: // FireBall Fire Explosion
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			iDvalue = (cTempFrame - 8)*(-5);
			if (cTempFrame < 7)
				 m_pEffectSpr[3]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			else m_pEffectSpr[3]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime);
			break;

		case 6:	 // Energy Bolt
		case 10: // Lightning Arrow
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			iDvalue = (cTempFrame - 7)*(-6);
			if (cTempFrame < 6)
				 m_pEffectSpr[6]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			else m_pEffectSpr[6]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

		case 7: // Magic Missile Explosion
			cTempFrame = m_pEffectList[i]->m_cFrame;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			iDvalue = (cTempFrame - 4)*(-3);
			if (cTempFrame < 4)
				 m_pEffectSpr[6]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			else m_pEffectSpr[6]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

		case 8: // Burst
			cTempFrame = m_pEffectList[i]->m_cFrame;
			cTempFrame = 4 - cTempFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 9: // Burst
			cTempFrame = (rand() % 5);
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY) - m_sViewPointY;
			m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 11: // pt grenat
			cTempFrame = (rand() % 5) + 5;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY) - m_sViewPointY;
			m_pEffectSpr[11]->PutTransSprite2(dX, dY, cTempFrame, dwTime);
			break;

		case 12: // Burst
			cTempFrame = (rand() % 6) + 10;
			if (cTempFrame < 0) break;
			iDvalue = (m_pEffectList[i]->m_cFrame - 4)*(-3);
			dX  = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY) - m_sViewPointY;
			if (cTempFrame < 4)
				 m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			else //m_pEffectSpr[11]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			//
			m_pEffectSpr[11]->PutTransSprite(dX, dY, cTempFrame, dwTime);
			break;

		case 13:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY) - m_sViewPointY;
			if (cTempFrame < 13)
			{	m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, 25 + (cTempFrame / 5), dwTime);
			}else
			{	m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, (8 + cTempFrame), dwTime);
			}
			break;

		case 14: // Traces de pas (terrain sec)
			if (m_pEffectList[i]->m_cFrame < 0) break;
			dX  = m_pEffectList[i]->m_mX - m_sViewPointX;
			dY  = m_pEffectList[i]->m_mY - m_sViewPointY;
			m_pEffectSpr[11]->PutTransSprite50_NoColorKey(dX, dY, (28 + m_pEffectList[i]->m_cFrame), dwTime);
			break;

		case 15: // petits nuages rouges
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = m_pEffectList[i]->m_mX - m_sViewPointX;
			dY  = m_pEffectList[i]->m_mY - m_sViewPointY;
			m_pEffectSpr[11]->PutTransSprite50_NoColorKey(dX, dY, (33 + cTempFrame), dwTime);
			break;

		case 16: //
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY, 0, dwTime);
			break;

		case 17: //test
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = 39 + (rand() % 3)*3 + (rand() % 3);
			if (cTempFrame < 0) break;
			m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			dX  = (m_pEffectList[i]->m_mX2)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY2)  - m_sViewPointY;
			m_pEffectSpr[11]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 18: //
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			m_pEffectSpr[18]->PutTransSprite70_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 20: // critical hit
		case 21:
		case 22:
		case 23:
		case 24:
		case 25:
		case 26:
		case 27: // Critical strike with a weapon
			dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
			m_pEffectSpr[8]->PutTransSprite_NoColorKey(dX, dY, 1, dwTime);
			break;

		case 30: // Mass-Fire-Strike
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			m_pEffectSpr[14]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 31: // Mass-Fire-Strike
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			m_pEffectSpr[15]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 32: // Trace de pas  (raining weather)
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame + 20;
			if (cTempFrame < 0) break;
			m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 33: //
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			iDvalue = 0;
			m_pEffectSpr[19]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

		case 34: // absent (220 et 351)
			break;

		case 35: // Snoopy: Ajout
			if (m_pEffectList[i]->m_cFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame;
			m_pEffectSpr[6]->PutTransSprite_NoColorKey(dX-30, dY-18, cTempFrame, dwTime);
			break;

		case 36: // Snoopy: Ajout
			if (m_pEffectList[i]->m_cFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame;
			m_pEffectSpr[97]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 40:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[20]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime); // 20
			break;

		case 41: // Large Type 1, 2, 3, 4
		case 42:
		case 43:
		case 44:
		case 45: // Small Type 1, 2
		case 46:
			dX  = (m_pEffectList[i]->m_sX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_sY)  - m_sViewPointY;
			m_pEffectSpr[21]->PutFadeSprite(dX, dY, 48, dwTime);
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			if ((8*(m_pEffectList[i]->m_sType-41) +cTempFrame) < (8*(m_pEffectList[i]->m_sType-41) +7))
			{	iDvalue = -8*(6 - cTempFrame);
				m_pEffectSpr[21]->PutTransSpriteRGB(dX, dY, 8*(m_pEffectList[i]->m_sType-41) +cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			}else
			{	if ((cTempFrame - 5) >= 8) cTempFrame = ((cTempFrame - 5) - 8) + 5;
				m_pEffectSpr[21]->PutSpriteFast(dX, dY, 8*(m_pEffectList[i]->m_sType-41) + (cTempFrame - 5), dwTime);
			}
			break;

		case 47:
		case 48:
		case 49: // Blizzard
			dX  = (m_pEffectList[i]->m_sX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_sY)  - m_sViewPointY;
			m_pEffectSpr[m_pEffectList[i]->m_sType-1]->PutRevTransSprite(dX, dY, 0, dwTime);
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			//PutString(dX, dY, "*", RGB(255,255,255));
			if (cTempFrame < 7) {
				iDvalue = -8*(6 - cTempFrame);
				m_pEffectSpr[m_pEffectList[i]->m_sType-1]->PutTransSpriteRGB(dX, dY, cTempFrame+1, iDvalue, iDvalue, iDvalue, dwTime);
			}
			else {
				if (cTempFrame >= 8) cTempFrame = cTempFrame % 8;
				m_pEffectSpr[m_pEffectList[i]->m_sType-1]->PutSpriteFast(dX, dY, cTempFrame+1, dwTime);
			}
			break;

		case 50:
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;

			if (cTempFrame <= 6) {
				iDvalue = 0;
				m_pEffectSpr[22]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime);	// RGB2
			}
			else {
				iDvalue = -5*(cTempFrame - 6);
				m_pEffectSpr[22]->PutTransSpriteRGB(dX, dY, 6, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			}
			break;

		case 51: //
			cTempFrame = m_pEffectList[i]->m_cFrame + 11; //15
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[28]->PutTransSprite25(dX, dY, cTempFrame, dwTime); //20
			break;


		case 52: // Protection Ring commente par siementec, a voir
		/*			cTempFrame = m_pEffectList[i]->m_cFrame;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[24]->PutTransSprite(dX, dY, cTempFrame, dwTime);
		*/
			break;


		case 53: // Hold Twist
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			if (cTempFrame < 0) cTempFrame = 0;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[25]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime); //25
			break;

		case 54: //  star twingkling (effect armes brillantes)
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) cTempFrame = 0;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[28]->PutTransSprite(dX, dY, cTempFrame, dwTime);
			break;

		case 55: // star twingkling ???? unused
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) cTempFrame = 0;
			dX  = (m_pEffectList[i]->m_mX);
			dY  = (m_pEffectList[i]->m_mY);
			m_pEffectSpr[28]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 56: // Mass-Chill-Wind
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) cTempFrame = 0;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[29]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 57:  // absent (220 et 351)
			break;

		case 60:  //
		case 181: // MS
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			if (cTempFrame > 4)
			{	cTempFrame = cTempFrame / 4;
			}
			if (cTempFrame >= 0)
			{	dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				m_pEffectSpr[31]->PutSpriteFast(dX, dY, 15 + cTempFrame, dwTime);
				m_pEffectSpr[31]->PutTransSprite(dX, dY, cTempFrame, dwTime);
			}
			break;

		case 61: // Fire aura on ground (crueffect1, 1)
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[32]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 62: // MS strike
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			if (cTempFrame > 0)
			{	cTempFrame = cTempFrame - 1;
				dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				m_pEffectSpr[31]->PutRevTransSprite(dX, dY, 20 + cTempFrame, dwTime, cTempFrame/3);
			}
			break;

		case 63: // Fire explosion (crueffect1, 2)
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[33]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 64: // effet halo blancchatre
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[34]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 65: // 1 nuage de Fumée noire qui monte
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			cTempFrame = cTempFrame / 6;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[31]->PutRevTransSprite(dX, dY, 20 + cTempFrame, dwTime, cTempFrame >> 2);
			break;

		case 66: // MS explodes on the ground
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[39]->PutRevTransSprite(dX, dY, cTempFrame, dwTime);
			m_pEffectSpr[39]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 67: // MS fire with smoke
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			switch (rand() % 3) {
			case 0: m_pEffectSpr[0]->PutTransSprite25_NoColorKey(dX, dY +20, 1, dwTime); break;
			case 1: m_pEffectSpr[0]->PutTransSprite50_NoColorKey(dX, dY +20, 1, dwTime); break;
			case 2: m_pEffectSpr[0]->PutTransSprite70_NoColorKey(dX, dY +20, 1, dwTime); break;
			}
			m_pEffectSpr[35]->PutTransSprite70_NoColorKey(dX, dY, cTempFrame/3, dwTime);
			break;

		case 68: // worm-bite
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			if (cTempFrame <= 11)
			{	m_pEffectSpr[40]->PutSpriteFast(dX, dY, cTempFrame, dwTime);
				m_pEffectSpr[41]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime);
				m_pEffectSpr[44]->PutRevTransSprite(dX-2, dY-3, cTempFrame, dwTime);
				m_pEffectSpr[44]->PutTransSprite_NoColorKey(dX-4, dY-3, cTempFrame, dwTime);
			}else
			{	switch (cTempFrame) {
				case 12:
				case 13:
				case 14: m_pEffectSpr[40]->PutSpriteFast(dX, dY, 11, dwTime); break;
				case 15: m_pEffectSpr[40]->PutTransSprite70_NoColorKey(dX, dY, 11, dwTime); break;
				case 16: m_pEffectSpr[40]->PutTransSprite50_NoColorKey(dX, dY, 11, dwTime); break;
				case 17: m_pEffectSpr[40]->PutTransSprite25_NoColorKey(dX, dY, 11, dwTime); break;
			}	}
			break;

		case 69: // identique au cas 70
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[42]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 70: // identique au cas 69
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[43]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 71: // absent v220 et v351
			break;

		case 72: // Blizzard
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			if (cTempFrame <= 8)
			{	iDvalue = 0;
				m_pEffectSpr[51]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime);
			}else
			{	iDvalue = -1*(cTempFrame - 8);
				m_pEffectSpr[51]->PutTransSpriteRGB(dX, dY, 8, iDvalue, iDvalue, iDvalue, dwTime);	// RGB2
			}
			break;

		case 73: // absent v220 et v351
		case 74: // absent v220 et v351
		case 75: // absent v220 et v351
		case 76: // absent v220 et v351
		case 77: // absent v220 et v351
			break;

		case 80:
		case 196: // Earth-Shock-Wave
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[91]->PutSpriteFast(dX, dY, cTempFrame, dwTime); //Nbe d'arguments modifiés ds la 351....
			m_pEffectSpr[92]->PutTransSprite(dX, dY, cTempFrame, dwTime);
			break;

		case 81: // Snoopy: Ajout StormBlade
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame;
			m_pEffectSpr[100]->PutTransSprite_NoColorKey(dX+70, dY+70, cTempFrame, dwTime);
			break;

		case 82: // Gate (apocalypse)
			cTempFrame = m_pEffectList[i]->m_cFrame;
			m_pEffectSpr[101]->PutTransSprite_NoColorKey(320, 480, cTempFrame, dwTime);
			break;

		case 85: // Fire explosion from the ground (effect14.pak)
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			if (cTempFrame < 10)
				m_pEffectSpr[108]->PutTransSprite_NoColorKey(dX+30, dY+35, cTempFrame, dwTime);
			if (cTempFrame >= 7)
				m_pEffectSpr[109]->PutTransSprite_NoColorKey(dX+5, dY+5, cTempFrame-7, dwTime);	
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 109: // EP's Crystal axe hit
#endif
		case 100: // Magic Missile
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY, 0, dwTime);
			break;


#ifdef DEF_EQUILIBRIUM_PROJECT
		case 148: // Critical heal
		case 168: // Mass heal
		case 186: // Regenerate
#endif

		case 101: // Heal
		case 121: // Great-Heal
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			iDvalue = (cTempFrame - 5)*(-5);
			m_pEffectSpr[50]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 102: // Create Food
		case 124: // Protection from N.M
		case 125: // Hold-Person
		case 126: // Possession
		case 127: // Poison
		case 133: // Protect-From-Magic
		case 134: // Detect-Invisibility
		case 135: // Paralyze
		case 136: // Cure
		case 142: // Confuse Language
		case 152: // Polymorph
		case 153: // Mass-Poison
		case 162: // Confusion
		case 171: // Mass-Confusion

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 198: // Medusa Kiss
#endif
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			iDvalue = (cTempFrame - 5)*(-5);
			if (cTempFrame < 5)
				 m_pEffectSpr[4]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			else m_pEffectSpr[4]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

		case 110: // Energy-Bolt
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY, 2 + (rand() % 4), dwTime);
			break;

		case 111: // Staminar Drain
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			iDvalue = (cTempFrame - 5)*(-5);
			m_pEffectSpr[49]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 112: // Recall
		case 131: // Summon-Creature
		case 132: // Invisibility
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			iDvalue = (cTempFrame - 5)*(-5);
			m_pEffectSpr[52]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 113: // Defense Shield
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			iDvalue = (cTempFrame - 5)*(-5);
			if (cTempFrame < 6)
				 m_pEffectSpr[62]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			else m_pEffectSpr[62]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 178: // Divine revenge			
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[5]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 106: // Forge's Breath
#endif
		case 120: // Fire Ball
		case 130: // Fire Strike
		case 161: // Mass-Fire-Strike
		case 251: //
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[5]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 122: // Absent v220 et 351
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 115: // EP's Staminar-Recovery
#endif
		case 123: // Staminar-Recovery
		case 128: // Great-Staminar-Recovery
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			iDvalue = (cTempFrame - 5)*(-5);
			m_pEffectSpr[56]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 137: // Lightning Arrow
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			tX  = (m_pEffectList[i]->m_mX2)  - m_sViewPointX;
			tY  = (m_pEffectList[i]->m_mY2)  - m_sViewPointY;
			iErr = 0;
			m_Misc.GetPoint(dX, dY, tX, tY, &rX, &rY, &iErr, 15);
			m_Misc.GetPoint(dX, dY, tX, tY, &rX2, &rY2, &iErr, 30);
			m_Misc.GetPoint(dX, dY, tX, tY, &rX3, &rY3, &iErr, 45);
			m_Misc.GetPoint(dX, dY, tX, tY, &rX4, &rY4, &iErr, 60);
			m_Misc.GetPoint(dX, dY, tX, tY, &rX5, &rY5, &iErr, 75);
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[10]->PutTransSprite25_NoColorKey(rX5, rY5, cTempFrame, dwTime);
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[10]->PutTransSprite25_NoColorKey(rX4, rY4, cTempFrame, dwTime);
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[10]->PutTransSprite50_NoColorKey(rX3, rY3, cTempFrame, dwTime);
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[10]->PutTransSprite50_NoColorKey(rX2, rY2, cTempFrame, dwTime);
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[10]->PutTransSprite70_NoColorKey(rX,  rY, cTempFrame, dwTime);
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[10]->PutTransSprite(dX, dY, cTempFrame, dwTime);
			break;

		case 143: // Lightning
			_DrawThunderEffect(m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY - 800,
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY,
								m_pEffectList[i]->m_rX, m_pEffectList[i]->m_rY, 1);
			_DrawThunderEffect(m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY - 800,
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY,
								m_pEffectList[i]->m_rX+4, m_pEffectList[i]->m_rY+2, 2);
			_DrawThunderEffect(m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY - 800,
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY,
								m_pEffectList[i]->m_rX-2, m_pEffectList[i]->m_rY-2, 2);
			break;

		case 144: // Great-Defense-Shield
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			iDvalue = (cTempFrame - 5)*(-5);
			if (cTempFrame < 9)
				 m_pEffectSpr[63]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			else m_pEffectSpr[63]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

		case 151: // Lightning Bolt
			_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY,
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY,
								m_pEffectList[i]->m_rX, m_pEffectList[i]->m_rY, 1);

			_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY,
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY,
								m_pEffectList[i]->m_rX+2, m_pEffectList[i]->m_rY-2, 2);

			_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY,
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY,
								m_pEffectList[i]->m_rX-2, m_pEffectList[i]->m_rY-2, 2);
			break;

		case 165: // Absolute-Magic-Protect
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY; // 53 = APFM buble
			m_pEffectSpr[53]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 103: // Abaddon's Terror
		case 192: // Mass armor break
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[55]->PutRevTransSprite(   dX, dY+35, m_pEffectList[i]->m_cFrame, dwTime);
			m_pEffectSpr[54]->PutTransSprite50(    dX,    dY, m_pEffectList[i]->m_cFrame, dwTime);

			m_pEffectSpr[55]->PutRevTransSprite(   dX,    dY, m_pEffectList[i]->m_cFrame, dwTime);
			m_pEffectSpr[54]->PutTransSprite50(    dX, dY-35, m_pEffectList[i]->m_cFrame, dwTime);

			m_pEffectSpr[55]->PutRevTransSprite(dX-30, dY+20, m_pEffectList[i]->m_cFrame, dwTime);
			m_pEffectSpr[54]->PutTransSprite50( dX-30, dY-15, m_pEffectList[i]->m_cFrame, dwTime);

			m_pEffectSpr[55]->PutRevTransSprite(dX-15, dY+60, m_pEffectList[i]->m_cFrame, dwTime);
			m_pEffectSpr[54]->PutTransSprite50( dX-15, dY+25, m_pEffectList[i]->m_cFrame, dwTime);

			m_pEffectSpr[55]->PutRevTransSprite(dX+15, dY+60, m_pEffectList[i]->m_cFrame, dwTime);
			m_pEffectSpr[54]->PutTransSprite50( dX+15, dY+25, m_pEffectList[i]->m_cFrame, dwTime);

			m_pEffectSpr[55]->PutRevTransSprite(dX+30, dY+20, m_pEffectList[i]->m_cFrame, dwTime);
			m_pEffectSpr[54]->PutTransSprite50( dX+30, dY-15, m_pEffectList[i]->m_cFrame, dwTime);
			break;

#endif
		case 166: // Armor-Break
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[55]->PutRevTransSprite(dX, dY+35, m_pEffectList[i]->m_cFrame, dwTime);
			m_pEffectSpr[54]->PutTransSprite50(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 167: // Scan
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pMapData->bGetOwner(m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY
				, cName, &sObjectType, &iStatus, &m_wCommObjectID);
			m_pEffectSpr[57]->PutTransSprite_NoColorKey(dX+110, dY+110 - _iAttackerHeight[sObjectType], m_pEffectList[i]->m_cFrame, dwTime);
			break;
#endif

		case 176: // Cancellation
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[90]->PutTransSprite_NoColorKey(dX+50, dY+85, cTempFrame, dwTime);
			break;

		case 177: // Illusion-Movement
		case 180: // Illusion
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			iDvalue = (cTempFrame - 5)*(-3);
			if (cTempFrame < 9)	m_pEffectSpr[60]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			else m_pEffectSpr[60]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

#ifndef DEF_EQUILIBRIUM_PROJECT
		case 182: //Mass-Magic-Missile
			cTempFrame = m_pEffectList[i]->m_cFrame;
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[98]->PutTransSprite(dX, dY, cTempFrame, dwTime, 0);
		break;
#endif

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 107: // EP's Test spell		
		case 117: // EP's Wood Mantle
		case 158: // EP's Bloody Mantle
		case 187: // EP's Magic Mantle
		case 118: // EP's Test spell
#endif
		case 183: // Inhibition-Casting
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			iDvalue = (cTempFrame - 5)*(-3);
			if (cTempFrame < 9) m_pEffectSpr[94]->PutTransSprite_NoColorKey(dX, dY + 40, m_pEffectList[i]->m_cFrame, dwTime);
			else m_pEffectSpr[94]->PutTransSpriteRGB(dX, dY + 40, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 116: // EP's Peace spell
		case 184: // EP's Magic Drain
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[96]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;
#endif
		case 244: // Snoopy: déplacé pour nvx sorts: Aura du casteur de Mass MagicMissile
		//case 184: // Aura du casteur de Mass MagicMissile
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = m_pEffectList[i]->m_mX - m_sViewPointX;
			dY  = m_pEffectList[i]->m_mY - m_sViewPointY;
			m_pEffectSpr[96]->PutTransSprite(dX, dY, m_pEffectList[i]->m_cFrame, dwTime, 0);
			break;

		case 190: // Mass-Illusion
		case 195: // Mass-Illusion-Movement
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			iDvalue = (cTempFrame - 5)*(-3);
			if (cTempFrame < 9) m_pEffectSpr[61]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			else m_pEffectSpr[61]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 188: // Entangle
#endif
		//case 192: // Mage Hero set effect
		case 242:
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[87]->PutTransSprite_NoColorKey(dX+50, dY+57, m_pEffectList[i]->m_cFrame, dwTime);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT

		case 108: // EP's Test spell
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			//m_pEffectSpr[111]->PutTransSprite_NoColorKey(dX, dY+10, m_pEffectList[i]->m_cFrame, dwTime);
			m_pEffectSpr[110]->PutTransSprite(dX, dY+20, m_pEffectList[i]->m_cFrame, dwTime, 0);
			break;

		//case 138: // EP's Prayer (added effect in DrawEffectLigths as original Berserk)
		//case 175: // Trance      (added effect in DrawEffectLigths as original Berserk)
		case 182: // Warrior's spirit
#endif
		case 243:
		//case 193: // War Hero set effect
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[88]->PutTransSprite_NoColorKey(dX+65, dY+80, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 194: // Resurrection
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[99]->PutTransSprite(dX, dY, m_pEffectList[i]->m_cFrame, dwTime, 0);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 197: // Explosion
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);
			if (cTempFrame < 0) break;
			m_pEffectSpr[5]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;
#endif


		case 200: // shotstar fall on ground
			dX  = m_pEffectList[i]->m_mX;
			dY  = m_pEffectList[i]->m_mY;
			m_pEffectSpr[133]->PutTransSprite_NoColorKey(dX, dY, (rand() %15), dwTime);
			break;

		case 201: // shotstar fall on ground
			dX  = m_pEffectList[i]->m_mX;
			dY  = m_pEffectList[i]->m_mY;
			m_pEffectSpr[134]->PutTransSprite_NoColorKey(dX, dY, (rand() %15), dwTime);
			break;

		case 202: // shotstar fall on ground
			dX  = m_pEffectList[i]->m_mX;
			dY  = m_pEffectList[i]->m_mY;
			m_pEffectSpr[135]->PutTransSprite_NoColorKey(dX, dY, (rand() %15), dwTime);
			break;

		case 203: // explosion feu apoc
			dX  = m_pEffectList[i]->m_mX;
			dY  = m_pEffectList[i]->m_mY;
			m_pEffectSpr[136]->PutTransSprite_NoColorKey(dX, dY, (rand() %18), dwTime);
			break;

		case 204: // Faille oblique
			dX  = m_pEffectList[i]->m_mX;
			dY  = m_pEffectList[i]->m_mY;
			m_pEffectSpr[137]->PutTransSprite_NoColorKey(dX, dY, (rand() %12), dwTime);
			break;

		case 205: // Faille horizontale
			dX  = m_pEffectList[i]->m_mX;
			dY  = m_pEffectList[i]->m_mY;
			m_pEffectSpr[138]->PutTransSprite_NoColorKey(dX, dY, (rand() %12), dwTime);
			break;

		case 206: // steams
			dX  = m_pEffectList[i]->m_mX;
			dY  = m_pEffectList[i]->m_mY;
			m_pEffectSpr[139]->PutTransSprite_NoColorKey(dX, dY, (rand() %20), dwTime);
			break;
			
#ifdef DEF_EQUILIBRIUM_PROJECT // Buts, ZzZz
		case 210: // Effect14.pak, explosion sous les pieds	
			dX  = m_pEffectList[i]->m_mX;
			dY  = m_pEffectList[i]->m_mY;
			m_pEffectSpr[108]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 237: // Air Elemental Attack
			_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY,
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY,
								m_pEffectList[i]->m_rX, m_pEffectList[i]->m_rY, 1);

			_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY,
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY,
								m_pEffectList[i]->m_rX+2, m_pEffectList[i]->m_rY-2, 2);

			_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY,
				                m_pEffectList[i]->m_dX*32 - m_sViewPointX, m_pEffectList[i]->m_dY*32 - m_sViewPointY,
								m_pEffectList[i]->m_rX-2, m_pEffectList[i]->m_rY-2, 2);
			break;	
			
		case 238: // Ice Elemental OnAttack	
		case 239: // Ice Elemental OnMove			
			break;	

		case 240: // Air Elemental lightning onMove
			_DrawThunderEffect(m_pEffectList[i]->m_dX, 0, m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY
								, m_pEffectList[i]->m_rX, m_pEffectList[i]->m_rY, 1);
			_DrawThunderEffect(m_pEffectList[i]->m_dX, 0, m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY
								, m_pEffectList[i]->m_rX+4, m_pEffectList[i]->m_rY+2, 2);
			_DrawThunderEffect(m_pEffectList[i]->m_dX, 0, m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY
								, m_pEffectList[i]->m_rX-2, m_pEffectList[i]->m_rY-2, 2);
			break;

		case 241: // Fire Elemental explosion onMove
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			cTempFrame = m_pEffectList[i]->m_cFrame;
			if (cTempFrame < 0) break;
			m_pEffectSpr[15]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			break;

		case 245: // But Elvine
			dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
			m_pEffectSpr[64]->PutTransSprite_NoColorKey(dX+50, dY-80, m_pEffectList[i]->m_cFrame %3, dwTime);
			break;

		case 246: // But Ares
			dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
			m_pEffectSpr[65]->PutTransSprite_NoColorKey(dX+50, dY-80, m_pEffectList[i]->m_cFrame %3, dwTime);
			break;

		case 247: // ZzZz
			dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
			dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
			m_pEffectSpr[85]->PutTransSprite_NoColorKey(dX+50, dY+30, m_pEffectList[i]->m_cFrame, dwTime);
			break;
#endif

		case 250: // Gate (round one)
			dX  = m_pEffectList[i]->m_mX - m_sViewPointX;
			dY  = m_pEffectList[i]->m_mY - m_sViewPointY;
			m_pEffectSpr[103]->PutTransSprite_NoColorKey(dX, dY, (rand() %3), dwTime);
			break;

		case 252: // burst (lisgt salmon color)
			dX  = m_pEffectList[i]->m_mX - m_sViewPointX;
			dY  = m_pEffectList[i]->m_mY - m_sViewPointY;
			m_pEffectSpr[104]->PutTransSprite_NoColorKey(dX, dY, (rand() %3), dwTime);
			break;
		}
	}
}

void CGame::bItemDrop_IconPannel(short msX, short msY)
{short sX, sY, sItemIndex;
	sX = m_stDialogBoxInfo[30].sX;	sY = m_stDialogBoxInfo[30].sY;

	sItemIndex = m_stMCursor.sSelectedObjectID;
	if (m_bIsItemDisabled[sItemIndex] == TRUE) return;
	if (m_cCommand < 0) return;
	if ((453 < msX) && (486 > msX) && (440 < msY) && (475 > msY))
	{	bItemDrop_Inventory(m_stDialogBoxInfo[2].sX + (rand() % 148), m_stDialogBoxInfo[2].sY + (rand() % 55));
		return;
	}
	if ((425 < msX)	&& (448 > msX) && (440 < msY) && (475 > msY))
	{	bItemDrop_Character();
		return;
	}
}



void CGame::DrawEffectLights()
{int i, dX, dY, iDvalue;
 DWORD dwTime = m_dwCurTime;
 char  cTempFrame;
	for (i = 0;	i < DEF_MAXEFFECTS; i++)
	if (m_pEffectList[i] != NULL) {
		switch (m_pEffectList[i]->m_sType) {
		case 1:
			break;

		case 2:
			break;

		case 4:
			break;

		case 5:	// Fire Explosion
			if (m_pEffectList[i]->m_cFrame >= 0)
			{	dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				iDvalue = (m_pEffectList[i]->m_cFrame - 7)*(-1);
				if (m_pEffectList[i]->m_cFrame < 6)
					 m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY+30, 1, dwTime);
				else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY+30, 1, iDvalue, iDvalue, iDvalue, dwTime);
			}
			break;

		case 6:	 // Energy Bolt
		case 10: // Lightning Arrow
			if (m_pEffectList[i]->m_cFrame >= 0)
			{	dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				iDvalue = (m_pEffectList[i]->m_cFrame - 9)*(-1);
				if (m_pEffectList[i]->m_cFrame < 8)
					 m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY+30, 1, dwTime);
				else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY+30, 1, iDvalue, iDvalue, iDvalue, dwTime);
			}
			break;
		case 7: // Magic Missile Explosion
			if (m_pEffectList[i]->m_cFrame >= 0)
			{	dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				iDvalue = (m_pEffectList[i]->m_cFrame - 2)*(-1);
				if (m_pEffectList[i]->m_cFrame < 2)
					 m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY+30, 1, dwTime);
				else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY+30, 1, iDvalue, iDvalue, iDvalue, dwTime);
			}
			break;

		case 16:
		case 61:
		case 66:
		case 100:
		case 110:
		case 120:
		case 130:
		case 137: // Lightning arrow
		//case 165: // APFM fixed green light
			// Light on ground below the flying effect
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			iDvalue = -5;
			m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY+30, 1, iDvalue, iDvalue, iDvalue, dwTime);
			break;

		case 69:
		case 70:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[0]->PutTransSprite25(dX, dY+30, 1, dwTime);
			break;

		case 33: //
			/*
			if (m_pEffectList[i]->m_cFrame >= 0) {
				dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				iDvalue = (m_pEffectList[i]->m_cFrame - 9)*(-1);
				if (m_pEffectList[i]->m_cFrame < 8)
					 m_pEffectSpr[0]->PutTransSprite(dX, dY, 1, dwTime);
				else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY, 1, iDvalue, iDvalue, iDvalue, dwTime);
			}
			*/
			break;

		case 40: //
		case 56:
			if (m_pEffectList[i]->m_cFrame >= 0)
			{	dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				iDvalue = (m_pEffectList[i]->m_cFrame - 7)*(-1);
				if (m_pEffectList[i]->m_cFrame < 6)
					 m_pEffectSpr[0]->PutTransSprite(dX, dY, 1, dwTime);
				else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY, 1, iDvalue, iDvalue, iDvalue, dwTime);
			}
			break;

		case 52: // Protection Ring
			if (m_pEffectList[i]->m_cFrame >= 0)
			{				dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				m_pEffectSpr[24]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			}
			break;

		case 57:
			if (m_pEffectList[i]->m_cFrame >= 0) {
				dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
				dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
				m_pEffectSpr[30]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			}
			break;

		case 73:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[74]->PutTransSprite(dX, dY-34, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 74:
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[75]->PutTransSprite(dX, dY+35, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 75: // Icegolem
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[76]->PutTransSprite25(dX+m_pEffectList[i]->m_dX*m_pEffectList[i]->m_cFrame, dY+m_pEffectList[i]->m_dY*m_pEffectList[i]->m_cFrame, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 76:// Icegolem
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[77]->PutTransSprite25(dX+m_pEffectList[i]->m_dX*m_pEffectList[i]->m_cFrame, dY+m_pEffectList[i]->m_dY*m_pEffectList[i]->m_cFrame, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 77:// Icegolem
			dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
			m_pEffectSpr[78]->PutTransSprite25(dX+m_pEffectList[i]->m_dX*m_pEffectList[i]->m_cFrame, dY+m_pEffectList[i]->m_dY*m_pEffectList[i]->m_cFrame, m_pEffectList[i]->m_cFrame, dwTime);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 138: // Prayer
		case 175: // Trance
#endif
		case 150: // Berserk : Cirlcle 6 magic
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[58]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
			break;

		case 180: // Ilusion
		case 190: // Mass Illusion
			cTempFrame = m_pEffectList[i]->m_cFrame;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[59]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
			//if( cTempFrame < 9 ) m_pEffectSpr[59]->PutTransSprite_NoColorKey( dX, dY, cTempFrame, dwTime );
			//else m_pEffectSpr[59]->PutSpriteFast( dX, dY, cTempFrame, dwTime );
			break;

		case 177: // Illusion mvt
		case 195: // Mass Illusion mvt
			cTempFrame = m_pEffectList[i]->m_cFrame;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[102]->PutTransSprite_NoColorKey(dX, dY+30, cTempFrame, dwTime);
			break;

		case 183: // Inhibition casting
			cTempFrame = m_pEffectList[i]->m_cFrame;
			dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
			dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
			m_pEffectSpr[95]->PutTransSprite_NoColorKey(dX, dY+40, cTempFrame, dwTime);
			break;
		}
	}
}

void CGame::_LoadShopMenuContents(char cType)
{
 char cFileName[255], cTemp[255];
 HANDLE hFile;
 FILE * pFile;
 DWORD  dwFileSize;
 char * pBuffer;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));
	wsprintf(cTemp, "contents%d", cType);
	strcat(cFileName, "contents" );
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == NULL) return;
	else {
		pBuffer = new char[dwFileSize+1];
		ZeroMemory(pBuffer, dwFileSize+1);
		fread(pBuffer, dwFileSize, 1, pFile);

		__bDecodeContentsAndBuildItemForSaleList(pBuffer);
		delete[] pBuffer;
	}
	fclose(pFile);
}

BOOL CGame::__bDecodeContentsAndBuildItemForSaleList(char * pBuffer)
{
 char * pContents, * token;
 char seps[] = "= ,\t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iItemForSaleListIndex = 0;
 class CStrTok * pStrTok;

	pContents = pBuffer;

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			//
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					ZeroMemory(m_pItemForSaleList[iItemForSaleListIndex]->m_cName, sizeof(m_pItemForSaleList[iItemForSaleListIndex]->m_cName));
					memcpy(m_pItemForSaleList[iItemForSaleListIndex]->m_cName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:	// m_cItemType
					m_pItemForSaleList[iItemForSaleListIndex]->m_cItemType = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // m_cEquipPos
					m_pItemForSaleList[iItemForSaleListIndex]->m_cEquipPos = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // m_sItemEffectType
					//m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectType = atoi(token);
					cReadModeB = 5;
					break;
				case 5:	// m_sItemEffectValue1
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue1 = atoi(token);
					cReadModeB = 6;
					break;
				case 6: // m_sItemEffectValue2
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue2 = atoi(token);
					cReadModeB = 7;
					break;
				case 7: // m_sItemEffectValue3
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue3 = atoi(token);
					cReadModeB = 8;
					break;
				case 8: // m_sItemEffectValue4
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue4 = atoi(token);
					cReadModeB = 9;
					break;
				case 9: // m_sItemEffectValue5
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue5 = atoi(token);
					cReadModeB = 10;
					break;
				case 10: // m_sItemEffectValue6
					m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue6 = atoi(token);
					cReadModeB = 11;
					break;
				case 11: // m_wMaxLifeSpan
					m_pItemForSaleList[iItemForSaleListIndex]->m_wMaxLifeSpan = (WORD)atoi(token);
					cReadModeB = 12;
					break;
				case 12: // m_sMaxFixCount
					//m_pItemForSaleList[iItemForSaleListIndex]->m_sMaxFixCount = atoi(token);
					cReadModeB = 13;
					break;
				case 13: // m_sSprite
					m_pItemForSaleList[iItemForSaleListIndex]->m_sSprite = atoi(token);
					cReadModeB = 14;
					break;
				case 14: // m_sSpriteFrame
					m_pItemForSaleList[iItemForSaleListIndex]->m_sSpriteFrame = atoi(token);
					cReadModeB = 15;
					break;
				case 15: // m_wPrice
					m_pItemForSaleList[iItemForSaleListIndex]->m_wPrice = atoi(token);
					cReadModeB = 16;
					break;
				case 16: // m_wWeight
					m_pItemForSaleList[iItemForSaleListIndex]->m_wWeight = atoi(token);
					cReadModeB = 17;
					break;
				case 17: // Appr Value
					//m_pItemForSaleList[iItemForSaleListIndex]->m_cApprValue = atoi(token);
					cReadModeB = 18;
					break;
				case 18: // m_cSpeed
					m_pItemForSaleList[iItemForSaleListIndex]->m_cSpeed = atoi(token);
					cReadModeB = 19;
					break;
				case 19: // Level Limit
					m_pItemForSaleList[iItemForSaleListIndex]->m_sLevelLimit = atoi(token);
					m_pItemForSaleList[iItemForSaleListIndex]->m_dwCount = 1;
					cReadModeA = 0;
					cReadModeB = 0;
					iItemForSaleListIndex++;
					break;
				}
				break;

			default:
				break;
			}
		}else
		{	if (memcmp(token, "ItemForSale", 4) == 0)
			{	if (iItemForSaleListIndex >= DEF_MAXMENUITEMS)
				{	delete pStrTok;
					return FALSE;
				}
				cReadModeA = 1;
				cReadModeB = 1;
				m_pItemForSaleList[iItemForSaleListIndex] = new class CItem;
		}	}
		token = pStrTok->pGet();
	}
	delete pStrTok;
	if ((cReadModeA != 0) || (cReadModeB != 0)) return FALSE;
	return TRUE;
}


static char __cSpace[] = {8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8, 8,6,8,7,8,8,9,10,9,7, 8,8,8,8,8, 8,8,
                          15,16,12,17,14,15,14,16,10,13, 19,10,17,17,15,14,15,16,13,17, 16,16,20,17,16,14,
	       			      8,8,8,8,8,8,	8,6,7,8,7,7,7,7,4,7,7,  4,11,7,8,8,7,8,6,5,8,9,14,8,9,8, 8,8,8,8,
				          8,8,8,8,8,8,8};
void CGame::PutString_SprFont(int iX, int iY, char * pStr, short sR, short sG, short sB)
{
 int iXpos;
 DWORD iCnt;
 DWORD dwTime = G_dwGlobalTime;
 char  cTmpStr[100];

	ZeroMemory(cTmpStr, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);
	iXpos = iX;
	for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
		if ((cTmpStr[iCnt] >= 33) && (cTmpStr[iCnt] <= 122)) {
			m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteRGB(iXpos+1, iY, cTmpStr[iCnt] - 33, sR+11, sG+7, sB+6, dwTime);
			if ((sR == 0) && (sG == 0) && (sB == 0))
				 m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteFast(iXpos, iY, cTmpStr[iCnt] - 33, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 33, sR, sG, sB, dwTime);
			 iXpos += __cSpace[cTmpStr[iCnt] - 33];
		}
		else iXpos += 5;
	}
}

void CGame::PutString_SprFont2(int iX, int iY, char * pStr, short sR, short sG, short sB)
{
 int iXpos, iR, iG, iB;
 DWORD iCnt;
 DWORD dwTime = G_dwGlobalTime;
 char  cTmpStr[200];

	m_DDraw.ColorTransferRGB(RGB(sR, sG, sB), &iR, &iG, &iB);

	ZeroMemory(cTmpStr, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);

	iXpos = iX;
	for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
		if ((cTmpStr[iCnt] >= 33) && (cTmpStr[iCnt] <= 122)) {
			m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteFast(iXpos+1, iY, cTmpStr[iCnt] - 33, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteFast(iXpos+1, iY+1, cTmpStr[iCnt] - 33, dwTime);
			if ((sR == 0) && (sG == 0) && (sB == 0))
				 m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteFast(iXpos, iY, cTmpStr[iCnt] - 33, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_FONT1]->PutSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 33, iR, iG, iB, dwTime);
			 iXpos += __cSpace[cTmpStr[iCnt] - 33];
		}
		else iXpos += 5;
	}
}

void CGame::PutString_SprFont3(int iX, int iY, char * pStr, short sR, short sG, short sB, BOOL bTrans, int iType)
{
 int iXpos, iAdd;
 DWORD iCnt;
 DWORD dwTime = G_dwGlobalTime;
 char  cTmpStr[128];

	ZeroMemory(cTmpStr, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);

	if (iType != -1) {
		iAdd = 95*iType;
		iXpos = iX;
		for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
			if ((cTmpStr[iCnt] >= 32) && (cTmpStr[iCnt] <= 126)) {

				if (bTrans == FALSE) {
					m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutSpriteFast(iXpos, iY+1, cTmpStr[iCnt] - 32 +iAdd, dwTime);
					m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutSpriteFast(iXpos+1, iY+1, cTmpStr[iCnt] - 32 +iAdd, dwTime);
					if ((sR == 0) && (sG == 0) && (sB == 0))
						 m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutSpriteFast(iXpos, iY, cTmpStr[iCnt] - 32 +iAdd, dwTime);
					else m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 32 +iAdd, sR, sG, sB, dwTime);

				}
				else m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->PutTransSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 32 +iAdd, sR, sG, sB, dwTime);

				iXpos += (m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS2]->m_stBrush[cTmpStr[iCnt] - 32 +iAdd].szx);
			}
			else iXpos += 5;
		}
	}
	else {
		iAdd = 0;
		iXpos = iX;
		for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++) {
			if ((cTmpStr[iCnt] >= 32) && (cTmpStr[iCnt] <= 126)) {

				if (bTrans == FALSE) {
					m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutSpriteFast(iXpos, iY+1, cTmpStr[iCnt] - 32 +iAdd, dwTime);
					m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutSpriteFast(iXpos+1, iY+1, cTmpStr[iCnt] - 32 +iAdd, dwTime);
					if ((sR == 0) && (sG == 0) && (sB == 0))
						 m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutSpriteFast(iXpos, iY, cTmpStr[iCnt] - 32 +iAdd, dwTime);
					else m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 32 +iAdd, sR, sG, sB, dwTime);

				}
				else m_pSprite[DEF_SPRID_INTERFACE_FONT2]->PutTransSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 32 +iAdd, sR, sG, sB, dwTime);

				iXpos += (m_pSprite[DEF_SPRID_INTERFACE_FONT2]->m_stBrush[cTmpStr[iCnt] - 32 +iAdd].szx);
			}
			else iXpos += 5;
		}
	}
}

static char __cSpace2[] = {6,4,6,6,6,6,6,6,6,6,6}; //{8,6,9,8,8,9,8,8,8,8};
void CGame::PutString_SprNum(int iX, int iY, char * pStr, short sR, short sG, short sB)
{int iXpos;
 unsigned char iCnt;
 DWORD dwTime = G_dwGlobalTime;
 char  cTmpStr[200];
 WORD  wR, wG, wB;
	ZeroMemory(cTmpStr, sizeof(cTmpStr));
	strcpy(cTmpStr, pStr);
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(sR, sG, sB), &wR, &wG, &wB);
	iXpos = iX;
	for (iCnt = 0; iCnt < strlen(cTmpStr); iCnt++)
	{	if ((cTmpStr[iCnt] >= 0x30) && (cTmpStr[iCnt] <= 0x39))
		{	m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSprite(iXpos+2, iY, cTmpStr[iCnt] - 0x30 +6, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSprite(iXpos+1, iY+1, cTmpStr[iCnt] - 0x30 +6, dwTime);
			if ((sR == 0) && (sG == 0) && (sB == 0))
				 m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSprite(iXpos, iY, cTmpStr[iCnt] - 0x30 +6, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(iXpos, iY, cTmpStr[iCnt] - 0x30 +6, wR, wG, wB, dwTime);
			iXpos += __cSpace2[cTmpStr[iCnt] - 0x30];
	}	}
}

void CGame::PutString(int iX, int iY, char * pString, COLORREF color, BOOL bHide, char cBGtype, BOOL bIsPreDC)
{char * pTmp;
 int i;
	if (strlen(pString) == 0) return;
	if (bIsPreDC == FALSE) m_DDraw._GetBackBufferDC();
	if (bHide == FALSE)
	{	switch (cBGtype) {
		case 0:
			m_DDraw.TextOut(iX+1, iY, pString, color);
			break;
		case 1:
			m_DDraw.TextOut(iX, iY+1, pString, RGB(5,5,5));
			m_DDraw.TextOut(iX+1, iY+1, pString, RGB(5,5,5));
			m_DDraw.TextOut(iX+1, iY, pString, RGB(5,5,5));
			break;
		}
		m_DDraw.TextOut(iX, iY, pString, color);
	}else
	{ 	pTmp = new char[strlen(pString)+2];
		ZeroMemory(pTmp, strlen(pString)+2);
		strcpy(pTmp, pString);
		for (i = 0; i < (int)strlen(pString); i++)
			if (pTmp[i] != NULL) pTmp[i] = '*';

		switch (cBGtype) {
		case 0:
			m_DDraw.TextOut(iX+1, iY, pTmp, color);
			break;
		case 1:
			m_DDraw.TextOut(iX, iY+1, pTmp, RGB(5,5,5));
			m_DDraw.TextOut(iX+1, iY+1, pTmp, RGB(5,5,5));
			m_DDraw.TextOut(iX+1, iY, pTmp, RGB(5,5,5));
			break;
		}
		m_DDraw.TextOut(iX, iY, pTmp, color);
		delete[] pTmp;
	}
	if (bIsPreDC == FALSE) m_DDraw._ReleaseBackBufferDC();
}


void CGame::PutString(int iX, int iY, char * pString, COLORREF color)
{
	m_DDraw._GetBackBufferDC();
	m_DDraw.TextOut(iX, iY, pString, color);
	m_DDraw._ReleaseBackBufferDC();
}

void CGame::PutString2(int iX, int iY, char * pString, short sR, short sG, short sB)
{
	m_DDraw._GetBackBufferDC();
	m_DDraw.TextOut(iX+1, iY, pString, RGB(0, 0, 0));
	m_DDraw.TextOut(iX, iY+1, pString, RGB(0, 0, 0));
	m_DDraw.TextOut(iX+1, iY+1, pString, RGB(0, 0, 0));
	m_DDraw.TextOut(iX, iY, pString, RGB(sR, sG, sB));
	m_DDraw._ReleaseBackBufferDC();
}

void CGame::PutAlignedString(int iX1, int iX2, int iY, char * pString, short sR, short sG, short sB)
{
	RECT rt;
	m_DDraw._GetBackBufferDC();
	SetRect(&rt, iX1, iY, iX2, iY+15);
	m_DDraw.DrawText(&rt, pString, RGB(sR, sG, sB));
	m_DDraw._ReleaseBackBufferDC();
}

BOOL CGame::bInitMagicCfgList()
{
 char cFn[255], cTemp[255];
 char * pContents, * token;
 char seps[] = "= ,\t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iMagicCfgListIndex = 0;
 class CStrTok * pStrTok;
 HANDLE hFile;
 FILE * pFile;
 DWORD  dwFileSize;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFn, sizeof(cFn));

	// CLEROTH - MAGIC CFG
	strcpy(cTemp, "magiccfg.txt");

	strcat(cFn, "contents");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, cTemp);

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		pContents = new char[dwFileSize+1];
		ZeroMemory(pContents, dwFileSize+1);
		fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE)
					{	delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					if (m_pMagicCfgList[atoi(token)] != NULL)
					{	delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicCfgList[atoi(token)] = new class CMagic;
					iMagicCfgListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					ZeroMemory(m_pMagicCfgList[iMagicCfgListIndex]->m_cName, sizeof(m_pMagicCfgList[iMagicCfgListIndex]->m_cName));
					memcpy(m_pMagicCfgList[iMagicCfgListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3: // m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 4;
					break;

				case 4: // m_sValue2	// INT
					if (_bGetIsStringIsNumber(token) == FALSE) {
						delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5: // m_sValue3	// COST
					if (_bGetIsStringIsNumber(token) == FALSE) {
						delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 6;
					break;

				// CLEROTH MAGIC CFG
				case 6: // m_sValue4	// STR
					if (_bGetIsStringIsNumber(token) == FALSE)
					{	delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicCfgList[iMagicCfgListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 7;
					break;

				case 7: // m_sValue5
					cReadModeB = 8;
					break;

				case 8: // m_sValue6
					cReadModeB = 9;
					break;

				case 9: // m_bIsVisible
					if (_bGetIsStringIsNumber(token) == FALSE)
					{	delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					if( atoi(token) == 0 ) m_pMagicCfgList[iMagicCfgListIndex]->m_bIsVisible = FALSE;
					else m_pMagicCfgList[iMagicCfgListIndex]->m_bIsVisible = TRUE;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default:
				break;
			}
		}
		else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		return FALSE;
	}

	return TRUE;
}

BOOL CGame::bCheckImportantFile()
{	HANDLE hFile;

#ifndef DEF_EQUILIBRIUM_PROJECT // anti badword.txt
#ifndef _DEBUG
	hFile = CreateFile("CONTENTS\\badword.txt", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if( hFile == INVALID_HANDLE_VALUE ) return FALSE;
	CloseHandle( hFile );
#endif
#endif

	hFile = CreateFile("SPRITES\\TREES1.PAK", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if( hFile == INVALID_HANDLE_VALUE ) return FALSE;

//	// FileSize : 1846406.... Anti Tree1.pak hack....inutile ca peut se modifier sans changer la taille!
//	if( GetFileSize( hFile, NULL ) != 2945524 )
//	{	CloseHandle( hFile );
//		return FALSE;
//	}

	CloseHandle( hFile );
	return TRUE;
}

BOOL CGame::bInitSkillCfgList()
{
 char cFn[255], cTemp[255];
 char * pContents, * token;
 char seps[] = "= ,\t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iSkillCfgListIndex = 0;
 class CStrTok * pStrTok;
 HANDLE hFile;
 FILE * pFile;
 DWORD  dwFileSize;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFn, sizeof(cFn));

	strcpy(cTemp, "Skillcfg.txt");
	strcat(cFn, "contents");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, cTemp);

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		pContents = new char[dwFileSize+1];
		ZeroMemory(pContents, dwFileSize+1);
		fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE)
					{	delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					if (m_pSkillCfgList[atoi(token)] != NULL)
					{	delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillCfgList[atoi(token)] = new class CSkill;
					iSkillCfgListIndex = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					ZeroMemory(m_pSkillCfgList[iSkillCfgListIndex]->m_cName, sizeof(m_pSkillCfgList[iSkillCfgListIndex]->m_cName));
					memcpy(m_pSkillCfgList[iSkillCfgListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3: // m_bIsUseable
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillCfgList[iSkillCfgListIndex]->m_bIsUseable = (BOOL)atoi(token);
					cReadModeB = 4;
					break;

				case 4: // m_cUseMethod
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	delete[] pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillCfgList[iSkillCfgListIndex]->m_cUseMethod = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default:
				break;
			}
		}
		else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		return FALSE;
	}

	return TRUE;
}


BOOL CGame::_bGetIsStringIsNumber(char * pStr)
{
 int i;
	for (i = 0; i < (int)strlen(pStr); i++)
	if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return FALSE;

	return TRUE;
}


void CGame::RequestFullObjectData(WORD wObjectID)
{
 char    cMsg[256];
 int     iRet;
 DWORD * dwp;
 WORD  * wp;

	ZeroMemory(cMsg, sizeof(cMsg));

	dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
	*dwp = MSGID_REQUEST_FULLOBJECTDATA;
	wp  = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
	*wp = wObjectID;

	iRet = m_pGSock->iSendMsg((char *)cMsg, 6);

	switch (iRet) {
	case DEF_XSOCKEVENT_SOCKETCLOSED:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_QUENEFULL:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);

		delete m_pGSock;
		m_pGSock = NULL;
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		delete m_pGSock;
		m_pGSock = NULL;

		if (G_pCalcSocket != NULL) {
			delete G_pCalcSocket;
			G_pCalcSocket = NULL;
		}
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
		break;
	}
}


BOOL   CGame::DrawObject_OnAttack(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
 int iWeaponIndex, iWeapon, iAdd, iShieldIndex, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 81 || _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern
	if(_tmp_sOwnerType == 95 || _tmp_sOwnerType == 96 || _tmp_sOwnerType == 97 || _tmp_sOwnerType == 98 || _tmp_sOwnerType == 99) bInv = TRUE; //Elementals

	if (m_cDetailLevel == 0)
	{	iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}else
	{	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ( (_tmp_iStatus & 0x10) != 0)
	{	if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // invi
		else if((_tmp_iStatus & 0x00040000) != 0 ) bInv = TRUE;
		//		if (bTransparentInvi == TRUE) iTemp = (iTemp | 0x00040000);
#else
		else if( _iGetFOE(_tmp_iStatus) == 1 ) bInv = TRUE;
#endif

		else return FALSE;
	}
	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0) 
		{	iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4);
			if (iWeapon == 0) iAdd = 6;
			if ((iWeapon >= 1)  && (iWeapon <= 39)) iAdd = 6;
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*4 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F)*8 + 4;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd;
		}else // Peace mode
		{	iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (5 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + 5;
			iHairIndex	 = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 5;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 5;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + 5;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 5;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 5;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 5;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 5;
			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{	iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4);
			if (iWeapon == 0) iAdd = 6;
			if ((iWeapon >= 1)  && (iWeapon <= 39)) iAdd = 6;
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*4 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F)*8 + 4;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd;
		}else // Peace mode
		{	iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (5 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + 5;
			iHairIndex	 = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 5;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 5;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + 5;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 5;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 5;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 5;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 5;
			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;

	default:		
		// polymorph bug (OnAttack)
		BOOL bIsPlayer = (_tmp_wObjectID < 10000); 
		if (_tmp_sAppr2 != 0 && !bIsPlayer)
		{	 iBodyIndex = DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			 _tmp_cFrame = _tmp_sAppr2 -1;
		}
		else if (_tmp_sOwnerType == 66) iBodyIndex = DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (1 * 8);
		else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (1 * 8);
		else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (1 * 8);
		else iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
		iUndiesIndex    = -1;
		iHairIndex      = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex  = -1;
		iBootsIndex     = -1;
		iPantsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}
	if (m_bIsCrusadeMode || m_bIsAvatarMode) DrawObjectFOE(sX, sY, _tmp_cFrame);
	if (_tmp_iEffectType != 0)
	{	switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
	}	}

	if (bTrans == FALSE)
	{	CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{	if (iWeaponIndex != -1)
			{	if (iWeaponColor == 0)
				{	m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
				}else
				{	m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY,  _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame -1, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime);
			}
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
            case 60: // Plant
			case 65: // IceGolem
			case 66: // Wyvern
			case 73: // FireWyvern
			case 81: // Abaddon
			case 91: // Gate
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				break;
			default:
				if (m_cDetailLevel != 0)
				{	if (sX < 50)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
				}
				break;
			}
			switch (_tmp_sOwnerType) { // Lumière en dessous
			case 35: // Energy Sphere
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				if (m_cDetailLevel != 0)
				{	m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
				}			
				break;
			default:
				break;
			}

			if (_tmp_sOwnerType == 81) // Abaddon
			{	m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			}else if (bInv == TRUE)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			else
			{	if ((_tmp_iStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				    m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{	if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

			if ((iHairIndex   != -1) && (iHelmIndex == -1))
			{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{	if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iPantsIndex != -1)
			{	if (iPantsColor == 0)
					 m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1)
			{	if (iArmColor == 0)
					 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{	if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1)
			{	if (iArmorColor == 0)
					 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1)
			{	if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{	if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
			{	m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
			}else
			if (iShieldIndex != -1)
			{	if (iShieldColor == 0)
					 m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{	if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
		}else
		{	switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
            case 60: // Plant
			case 65: // IceGolem
			case 66: // Wyvern
			case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				break;
			default:
				if (m_cDetailLevel != 0)
				{	if (sX < 50)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
				}
				break;
			}
			switch (_tmp_sOwnerType) { // Lumière en dessous
			case 35: // Energy Sphere
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				if (m_cDetailLevel != 0)
				{	m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
				}			
				break;
			default:
				break;
			}

			if (_tmp_sOwnerType == 81) // Abaddon
			{	m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			}else if (bInv == TRUE)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			else
			{	if ((_tmp_iStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				    m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{	if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

			if ((iHairIndex   != -1) && (iHelmIndex == -1))
			{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iPantsIndex != -1)
			{	if (iPantsColor == 0)
					 m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1)
			{	if (iArmColor == 0)
					 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{	if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1)
			{	if (iArmorColor == 0)
					 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1)
			{	if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{	if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
			{	m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
			}else
			if (iShieldIndex != -1)
			{	if (iShieldColor == 0)
					 m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{	if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (iWeaponIndex != -1)
			{	if (iWeaponColor == 0)
					 m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY, _tmp_cFrame -1, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime);
		}	}

		if ((_tmp_iStatus & 0x20) != 0) // Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel((_tmp_cDir - 1), sX+20, sY-20, _tmp_cFrame%8, dwTime);
		CheckActiveAura2(sX, sY, dwTime,  _tmp_sOwnerType);

	}else if( strlen(_tmp_cName) > 0 )
	{	if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != NULL)
	{	if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{	m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}else
		{	m_pMapData->ClearChatMsg(indexX, indexY);
	}	}

	// Snoopy: Abaddon effects
	int randFrame;
	switch (_tmp_sOwnerType) {
	case 81: // Abaddon effects	
		randFrame = _tmp_cFrame % 12;
		m_pEffectSpr[154]->PutTransSprite70(sX-50	, sY-50		, randFrame, dwTime);
		m_pEffectSpr[155]->PutTransSprite70(sX-20	, sY-80		, randFrame, dwTime);
		m_pEffectSpr[156]->PutTransSprite70(sX+70	, sY-50		, randFrame, dwTime);
		m_pEffectSpr[157]->PutTransSprite70(sX-30	, sY		, randFrame, dwTime);
		m_pEffectSpr[158]->PutTransSprite70(sX-60	, sY+90		, randFrame, dwTime);
		m_pEffectSpr[159]->PutTransSprite70(sX+65	, sY+85		, randFrame, dwTime);
		switch (_tmp_cDir) {
		case 1:
			m_pEffectSpr[153]->PutTransSprite70(sX		, sY+108 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-50	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 2:
			m_pEffectSpr[153]->PutTransSprite70(sX		, sY+95	, _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-70	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 3:
			m_pEffectSpr[153]->PutTransSprite70(sX		, sY+105 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-90	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 4:
			m_pEffectSpr[153]->PutTransSprite70(sX-35	, sY+100 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-80	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 5:
			m_pEffectSpr[153]->PutTransSprite70(sX		, sY+95	, _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-65	, sY-5	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 6:
			m_pEffectSpr[153]->PutTransSprite70(sX+45	, sY+95	, _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-31	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 7:
			m_pEffectSpr[153]->PutTransSprite70(sX+40	, sY+110 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-30	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 8:
			m_pEffectSpr[153]->PutTransSprite70(sX+20	, sY+110 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-20	, sY+16	, _tmp_iEffectFrame %15, dwTime);
			break;
		}
		break;		

	case 36: // AGT
	case 37: // CGT
	case 38: // MS
	case 39: // DT
	case 40: // ESG
	case 41: // GMG
	case 42: // ManaStone
		// Reduce Sprite width to 40, and Height to 80
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom - 80;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left =
			(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right + m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left)/2 - 20;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left + 40;
		break;

	default:
		if (   (m_bIsGetPointingMode == TRUE) 
			&& (m_bCommandAvailable == TRUE)
			&& (_tmp_sOwnerType >=10)
			&& (m_bShiftPressed == TRUE)
			&& (m_iPointCommandType >= 100) && (m_iPointCommandType < 200) ) // spell
		{	return FALSE;
		}	
		break;
	}

	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;
	return FALSE;
}


BOOL   CGame::DrawObject_OnAttackMove(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
 int iWeaponIndex, iWeapon, iAdd, iShieldIndex, iMantleIndex, dx, dy, dsx, dsy;
 int cFrameMoveDots;
 BOOL bInv = FALSE, bDashDraw = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 81 || _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern
	if(_tmp_sOwnerType == 95 || _tmp_sOwnerType == 96 || _tmp_sOwnerType == 97 || _tmp_sOwnerType == 98 || _tmp_sOwnerType == 99) bInv = TRUE; //Elementals

	if (m_cDetailLevel == 0)
	{	iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}else
	{	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ( (_tmp_iStatus & 0x10) != 0)
	{	if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // invi
		else if((_tmp_iStatus & 0x00040000) != 0 ) bInv = TRUE;
#else
		else if( _iGetFOE(_tmp_iStatus) == 1 ) bInv = TRUE;
#endif

		else return FALSE;
	}

	switch (_tmp_cFrame) {
	case 4:  _tmp_cFrame = 4; break;
	case 5:  _tmp_cFrame = 4; break;
	case 6:  _tmp_cFrame = 4; break;
	case 7:  _tmp_cFrame = 4; break;
	case 8:  _tmp_cFrame = 4; break;
	case 9:  _tmp_cFrame = 4; break;
	case 10: _tmp_cFrame = 5; break;
	case 11: _tmp_cFrame = 6; break;
	case 12: _tmp_cFrame = 7; break;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0) {
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4);
			if (iWeapon == 0) iAdd = 6;
			if ((iWeapon >= 1)  && (iWeapon <= 39)) iAdd = 6;
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*4 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F)*8 + 4;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd;
		}else
		{ 	iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (5 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + 5;
			iHairIndex	 = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 5;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 5;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + 5;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 5;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 5;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 5;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 5;
			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0) {
			iWeapon = ((_tmp_sAppr2 & 0x0FF0) >> 4);
			if (iWeapon == 0) iAdd = 6;
			if ((iWeapon >= 1)  && (iWeapon <= 39)) iAdd = 6;
			if ((iWeapon >= 40) && (iWeapon <= 59)) iAdd = 7;
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*4 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F)*8 + 4;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd;
		}else
		{	iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (5 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + 5;
			iHairIndex	 = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 5;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 5;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + 5;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 5;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 5;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 5;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 5;
			iWeaponIndex = -1;
			iShieldIndex = -1;
		}
		break;
	default:
		iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
		iUndiesIndex    = -1;
		iHairIndex      = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex  = -1;
		iBootsIndex     = -1;
		iPantsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}
	dx = 0;
	dy = 0;
	if ((_tmp_cFrame >= 1) && (_tmp_cFrame <= 3))
	{	switch (_tmp_cFrame) {
		case 1: cFrameMoveDots = 26; break;
		case 2: cFrameMoveDots = 16; break;
		case 3: cFrameMoveDots = 0;  break;
		}
		switch (_tmp_cDir) {
		case 1 : dy =  cFrameMoveDots; break;
		case 2 : dy =  cFrameMoveDots; dx = -cFrameMoveDots; break;
		case 3 : dx = -cFrameMoveDots; break;
		case 4 : dx = -cFrameMoveDots; dy = -cFrameMoveDots; break;
		case 5 : dy = -cFrameMoveDots; break;
		case 6 : dy = -cFrameMoveDots; dx =  cFrameMoveDots; break;
		case 7 : dx =  cFrameMoveDots; break;
		case 8 : dx =  cFrameMoveDots; dy =  cFrameMoveDots; break;
		}
		switch (_tmp_cFrame) {
		case 1: dy++;    break;
		case 2: dy += 2; break;
		case 3: dy++;    break;
		}
		switch (_tmp_cFrame) {
		case 2: bDashDraw = TRUE; cFrameMoveDots = 26; break;
		case 3: bDashDraw = TRUE; cFrameMoveDots = 16; break;
		}
		dsx = 0;
		dsy = 0;
		switch (_tmp_cDir) {
		case 1 : dsy =  cFrameMoveDots; break;
		case 2 : dsy =  cFrameMoveDots; dsx = -cFrameMoveDots; break;
		case 3 : dsx = -cFrameMoveDots; break;
		case 4 : dsx = -cFrameMoveDots; dsy = -cFrameMoveDots; break;
		case 5 : dsy = -cFrameMoveDots; break;
		case 6 : dsy = -cFrameMoveDots; dsx =  cFrameMoveDots; break;
		case 7 : dsx =  cFrameMoveDots; break;
		case 8 : dsx =  cFrameMoveDots; dsy =  cFrameMoveDots; break;
		}
	}else if (_tmp_cFrame > 3)
	{	dx = 0;
		dy = 0;
	}else
	{	switch (_tmp_cDir) {
		case 1: dy = 32; break;
		case 2: dy = 32; dx = -32; break;
		case 3: dx = -32; break;
		case 4: dx = -32; dy = -32; break;
		case 5: dy = -32; break;
		case 6: dy = -32; dx = 32; break;
		case 7: dx = 32; break;
		case 8: dx = 32; dy = 32; break;
	}	}

	if (m_bIsCrusadeMode || m_bIsAvatarMode) DrawObjectFOE(sX+dx, sY+dy, _tmp_cFrame);

	if (_tmp_iEffectType != 0) {
		switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
		}
	}

	if (bTrans == FALSE)
	{	CheckActiveAura(sX+dx, sY+dy, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{	if (iWeaponIndex != -1)
			{	if (iWeaponColor == 0)
					 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy, _tmp_cFrame -1, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime);
			}
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
            case 60: // Plant
			case 65: // IceGolem
			case 66: // Wyvern
			case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				break;
			default:
				if (m_cDetailLevel != 0)
				{	if (sX < 50)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
				break;
			}

			if (bInv == TRUE)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_iStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				    m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iPantsIndex != -1) {
				if (iPantsColor == 0)
					 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1) {
				if (iArmColor == 0)
					 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1) {
				if (iArmorColor == 0)
					 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1) {
				if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
			{	m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
			}else
			if (iShieldIndex != -1) 
			{	if (iShieldColor == 0)
					 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
		}else
		{	switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
            case 60: // Plant
			case 65: // IceGolem
			case 66: // Wyvern
			case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				break;

			default:
				if (m_cDetailLevel != 0) {
					if (sX < 50)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
				break;
			}

			if (bInv == TRUE)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else {
				if ((_tmp_iStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				    m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

			if ((iHairIndex != -1) && (iHelmIndex == -1)) {
				_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
				if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iPantsIndex != -1) {
				if (iPantsColor == 0)
					 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1) {
				if (iArmColor == 0)
					 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1) {
				if (iArmorColor == 0)
					 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1)
			{	if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{	if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
			{	m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
			}else
			if (iShieldIndex != -1) 
			{	if (iShieldColor == 0)
					 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1)) {
				if (iMantleColor == 0)
					 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (iWeaponIndex != -1)
			{	if (iWeaponColor == 0)
					 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}
				if (_tmp_cFrame == 3) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy, _tmp_cFrame -1, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime);
		}	}

		// Berserk
		if ((_tmp_iStatus & 0x20) != 0)
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel(8+(_tmp_cDir - 1), sX+dx+20, sY+dy-20, _tmp_cFrame%8, dwTime);
		CheckActiveAura2(sX+dx, sY+dy, dwTime,  _tmp_sOwnerType);

		if ((bDashDraw == TRUE) && (((_tmp_sAppr2 & 0x000F) != 8) || (iShieldGlare != 1)))
		{	m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX+dsx, sY+dsy, _tmp_cFrame, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime);
			if (iWeaponIndex != -1) m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dsx, sY+dsy, _tmp_cFrame, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime);
			if (iShieldIndex != -1) m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dsx, sY+dsy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[10] -(m_wR[0]/3), m_wG[10] -(m_wG[0]/3), m_wB[10] -(m_wB[0]/3), dwTime);
		}
	}
	else if( strlen(_tmp_cName) > 0 )
	{
		if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX+dx, sY+dy, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX+dx, sY+dy, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != NULL) 
	{	if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX+dx;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY+dy;
		}else
		{	m_pMapData->ClearChatMsg(indexX, indexY);
	}	}
	_tmp_dx = dx;
	_tmp_dy = dy;

	switch (_tmp_sOwnerType) {
	case 36: // AGT
	case 37: // CGT
	case 38: // MS
	case 39: // DT
	case 40: // ESG
	case 41: // GMG
	case 42: // ManaStone
		// Reduce Sprite width to 40, and Height to 80
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom - 80;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left =
			(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right + m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left)/2 - 20;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left + 40;
		break;
		
	default:
		if (   (m_bIsGetPointingMode == TRUE) 
			&& (m_bCommandAvailable == TRUE)
			&& (_tmp_sOwnerType >=10)
			&& (m_bShiftPressed == TRUE)
			&& (m_iPointCommandType >= 100) && (m_iPointCommandType < 200) ) // spell
		{	return FALSE;
		}	
		break;

	}

	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;

	return FALSE;
}


BOOL   CGame::DrawObject_OnMagic(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iHelmIndex, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern
	if(_tmp_sOwnerType == 95 || _tmp_sOwnerType == 96 || _tmp_sOwnerType == 97 || _tmp_sOwnerType == 98 || _tmp_sOwnerType == 99) bInv = TRUE; //Elementals

	if (m_cDetailLevel == 0)
	{	iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}else
	{	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	if ( (_tmp_iStatus & 0x10) != 0)
	{	if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0)
			bInv = TRUE;
		else
		{	if (_tmp_iChatIndex != NULL)
			{	if (m_pChatMsgList[_tmp_iChatIndex] != NULL)
				{	m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
					m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
				}else
				{	m_pMapData->ClearChatMsg(indexX, indexY);
			} 	}
			return FALSE;
	}	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
  		iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (8 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + 8;
		iHairIndex   = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 8;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 8;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + 8;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 8;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 8;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 8;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 8;
		break;
	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;

		iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (8 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + 8;
		iHairIndex   = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 8;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 8;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + 8;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 8;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 8;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 8;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 8;
		break;
	}

	/*
	switch (_tmp_cFrame) {
	case 15:
		_tmp_cFrame = 14;
		break;
	case 16:
		_tmp_cFrame = 14;
		break;
	case 17:
		_tmp_cFrame = 15;
		break;
	case 18:
		_tmp_cFrame = 15;
		break;
	case 19:
		_tmp_cFrame = 15;
		break;
	case 20:
		_tmp_cFrame = 15;
		break;
	case 21:
		_tmp_cFrame = 15;
		break;
	case 22:
		_tmp_cFrame = 15;
		break;
	case 23:
		_tmp_cFrame = 14;
		break;
	}
	*/
	if (m_bIsCrusadeMode || m_bIsAvatarMode) DrawObjectFOE(sX, sY, _tmp_cFrame);

	if (_tmp_iEffectType != 0)
	{	switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
	}	}

	if (bTrans == FALSE)
	{	CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
        case 60: // Plant
		case 65: // IceGolem
		case 66: // Wyvern
		case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
		case 95: // Willowisp
		case 96: // Air Elemental
		case 97: // Fire Elemental
		case 98: // Earth Elemental
		case 99: // Ice Elemental
			break;
		default:
			if (m_cDetailLevel != 0) {
				if (sX < 50)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
			}
			break;
		}

		if (bInv == TRUE)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
		else {
			if ((_tmp_iStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
		}
		SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

		if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, iR, iG, iB, dwTime);
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{	if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}

		if (iPantsIndex != -1)
		{	if (iPantsColor == 0)
				m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
		}

		if (iArmArmorIndex != -1)
		{	if (iArmColor == 0)
				m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{	if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}

		if (iBodyArmorIndex != -1)
		{	if (iArmorColor == 0)
				m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
		}

		if (iHelmIndex != -1)
		{	if (iHelmColor == 0)
				 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
		}

		if (iMantleIndex != -1)
		{	if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 16 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}

		if ((_tmp_iStatus & 0x20) != 0) 	// Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel(32+(_tmp_cDir - 1), sX+20, sY-20, _tmp_cFrame%16, dwTime);
		CheckActiveAura2(sX, sY, dwTime,  _tmp_sOwnerType);

	}else if( strlen(_tmp_cName) > 0 )
	{	if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != NULL)
	{	if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{	m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}else
		{	m_pMapData->ClearChatMsg(indexX, indexY);
	}	}
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;
	return FALSE;
}

BOOL   CGame::DrawObject_OnGetItem(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iHelmIndex, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern
	if(_tmp_sOwnerType == 95 || _tmp_sOwnerType == 96 || _tmp_sOwnerType == 97 || _tmp_sOwnerType == 98 || _tmp_sOwnerType == 99) bInv = TRUE; //Elementals

	if (m_cDetailLevel == 0)
	{	iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}else
	{	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	if ( (_tmp_iStatus & 0x10) != 0)
	{	if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // invi
		else if((_tmp_iStatus & 0x00040000) != 0 ) bInv = TRUE;
#else
		else if( _iGetFOE(_tmp_iStatus) == 1 ) bInv = TRUE;
#endif

		else return FALSE;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (9 * 8);
		iUndiesIndex    = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + 9;
		iHairIndex      = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 9;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 9;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + 9;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 9;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 9;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 9;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 9; 		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (9 * 8);
		iUndiesIndex    = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + 9;
		iHairIndex      = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 9;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 9;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + 9;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 9;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 9;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 9;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 9;
		break;
	default:
		iUndiesIndex    = -1;
		iHairIndex      = -1;
		iArmArmorIndex  = -1;
		iBodyArmorIndex = -1;
		iPantsIndex     = -1;
		iBootsIndex     = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}
	if (m_bIsCrusadeMode || m_bIsAvatarMode) DrawObjectFOE(sX, sY, _tmp_cFrame);

	if (_tmp_iEffectType != 0)
	{	switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
	}	}

	if (bTrans == FALSE)
	{	CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
        case 60: // Plant
		case 65: // IceGolem
		case 66: // Wyvern
		case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
		case 95: // Willowisp
		case 96: // Air Elemental
		case 97: // Fire Elemental
		case 98: // Earth Elemental
		case 99: // Ice Elemental
			break;
		default:
			if (m_cDetailLevel != 0)
			{	if (sX < 50)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
			}
			break;
		}

		if (bInv == TRUE)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite2(sX, sY, _tmp_cFrame, dwTime);
		else {
			if ((_tmp_iStatus & 0x40) != 0)
				 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
		}
		SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
			     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

		if (iUndiesIndex != -1)
		{	if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
		}

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, iR, iG, iB, dwTime);
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{	if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}	}

		if (iPantsIndex != -1)
		{	if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{	if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
		}	}

		if (iArmArmorIndex != -1)
		{	if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{	if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
		}	}

		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{	if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}	}

		if (iBodyArmorIndex != -1)
		{	if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{	if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
		}	}

		if (iHelmIndex != -1)
		{	if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{	if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
		}	}

		if (iMantleIndex != -1)
		{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
			else
			{	if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}	}

		if ((_tmp_iStatus & 0x20) != 0) // Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel(40+(_tmp_cDir - 1), sX+20, sY-20, _tmp_cFrame%4, dwTime);
		CheckActiveAura2(sX, sY, dwTime,  _tmp_sOwnerType);

	}else if( strlen(_tmp_cName) > 0 )
	{	if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != NULL)
	{	if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{	m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}else
		{	m_pMapData->ClearChatMsg(indexX, indexY);
	}	}
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;
	return FALSE;
}

BOOL CGame::DrawObject_OnDamage(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iWeaponIndex, iShieldIndex, iHelmIndex, iR, iG, iB;
 int iAdd, iDrawMode, iMantleIndex;
 char cFrame;
 BOOL bInv = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 81 || _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern
	if(_tmp_sOwnerType == 95 || _tmp_sOwnerType == 96 || _tmp_sOwnerType == 97 || _tmp_sOwnerType == 98 || _tmp_sOwnerType == 99) bInv = TRUE; //Elementals

	if (m_cDetailLevel == 0)
	{	iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}else
	{	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ( (_tmp_iStatus & 0x10) != 0)
	{	if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // invi
		else if((_tmp_iStatus & 0x00040000) != 0 ) bInv = TRUE;
#else
		else if( _iGetFOE(_tmp_iStatus) == 1 ) bInv = TRUE;
#endif

		else return FALSE;
	}	
	cFrame = _tmp_cFrame;
	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if (cFrame < 4)
		{	if ((_tmp_sAppr2 & 0xF000) != 0) iAdd = 1;
			else iAdd = 0;
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd;
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F)*8 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*iAdd + (_tmp_cDir - 1);
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd;
			iDrawMode = 0;
		}else
		{	cFrame -= 4;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (10 * 8);
			iUndiesIndex    = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + 10;
			iHairIndex      = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 10;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 10;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + 10;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 10;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 10;
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F)*8 + 5;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*5 + (_tmp_cDir - 1);
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 10;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 10;
			iDrawMode = 1;
		}
		break;
	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if (cFrame < 4)
		{	if ((_tmp_sAppr2 & 0xF000) != 0) iAdd = 1;
			else iAdd = 0;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex   = DEF_SPRID_HAIR_W	+ ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd;
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F)*8 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*iAdd + (_tmp_cDir - 1);
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd;
			iDrawMode = 0;
		}else
		{	cFrame -= 4;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (10 * 8);
			iUndiesIndex    = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + 10;
			iHairIndex      = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 10;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 10;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + 10;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 10;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 10;
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F)*8 + 5;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*5 + (_tmp_cDir - 1);
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 10;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 10;
			iDrawMode = 1;
		}
		break;

	default:	
		// polymorph bug (OnDamage)
		BOOL bIsPlayer = (_tmp_wObjectID < 10000); 		
		if (cFrame < 4)
		{	if (_tmp_sAppr2 != 0 && !bIsPlayer)
			{	iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
				 cFrame = _tmp_sAppr2 -1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 67) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 68) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 69) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else if (_tmp_sOwnerType == 86) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else if (_tmp_sOwnerType == 87) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else if (_tmp_sOwnerType == 89) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else if (_tmp_sOwnerType == 91) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		}else
		{	cFrame -= 4;
			if (_tmp_sAppr2 != 0 && !bIsPlayer)
			{	iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
				cFrame = _tmp_sAppr2 -1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 67) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 68) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 69) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else if (_tmp_sOwnerType == 86) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else if (_tmp_sOwnerType == 87) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else if (_tmp_sOwnerType == 89) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else if (_tmp_sOwnerType == 91) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (1 * 8);
			else iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (3 * 8);
		}
		iUndiesIndex    = -1;
		iHairIndex      = -1;
		iArmArmorIndex  = -1;
		iBodyArmorIndex = -1;
		iPantsIndex     = -1;
		iBootsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		iDrawMode = 0;
		break;
	}
	if (m_bIsCrusadeMode || m_bIsAvatarMode) DrawObjectFOE(sX, sY, cFrame);

	if (_tmp_iEffectType != 0)
	{	switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
	}	}

	if (bTrans == FALSE)
	{	CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		if (iDrawMode == 1) // Etrange, 1 semble impossible avec des mobs !
		{	if (_cDrawingOrder[_tmp_cDir] == 1)
			{	if (iWeaponIndex != -1)
				{	if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY,  cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
					DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}	}
				switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
				case 10: // Slime
				case 35: // Energy Sphere
				case 50: // TW
				case 51: // CP
		        case 60: // Plant
				case 65: // IceGolem
				case 66: // Wyvern
				case 73: // Fire Wyvern
				case 81: // Abaddon
				case 91: // Gate
				case 95: // Willowisp
				case 96: // Air Elemental
				case 97: // Fire Elemental
				case 98: // Earth Elemental
				case 99: // Ice Elemental
					break;
				default:
					if (m_cDetailLevel != 0) {
						if (sX < 50)
							 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
					}
					break;
				}
				switch (_tmp_sOwnerType) { // Lumière en dessous
				case 35: // Energy Sphere					
				case 95: // Willowisp
				case 96: // Air Elemental
				case 97: // Fire Elemental
				case 98: // Earth Elemental
				case 99: // Ice Elemental
					if (m_cDetailLevel != 0)
					{	m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
					}			
					break;
				default:
					break;
				}

				if (_tmp_sOwnerType == 81) // Abaddon
				{	m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				}else if (bInv == TRUE)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				else
				{	if ((_tmp_iStatus & 0x40) != 0)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime);
				}
				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
				{	if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);

				if ((iHairIndex != -1) && (iHelmIndex == -1))
				{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, iR, iG, iB, dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 1))
				{	if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}

				if (iPantsIndex != -1)
				{	if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}

				if (iArmArmorIndex != -1)
				{	if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 0))
				{	if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}

				if (iBodyArmorIndex != -1)
				{	if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}

				if (iHelmIndex != -1)
				{	if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
				{	if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}

				if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
				{	m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				}else
				if (iShieldIndex != -1)
				{	if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

					switch (iShieldGlare) {
					case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
					case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 4 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 4 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}	}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
				{	if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}else
			{	switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
				case 10: // Slime
				case 35: // Energy Sphere
				case 50: // TW
				case 51: // CP
				case 60: // Plant
				case 65: // IceGolem
				case 66: // Wyvern
				case 73: // Fire Wyvern
				case 81: // Abaddon
				case 91: // Gate
				case 95: // Willowisp
				case 96: // Air Elemental
				case 97: // Fire Elemental
				case 98: // Earth Elemental
				case 99: // Ice Elemental
					break;
				default:
					if (m_cDetailLevel != 0) {
						if (sX < 50)
							 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
					}
					break;
				}
				switch (_tmp_sOwnerType) { // Lumière en dessous
				case 35: // Energy Sphere
				case 95: // Willowisp
				case 96: // Air Elemental
				case 97: // Fire Elemental
				case 98: // Earth Elemental
				case 99: // Ice Elemental
					if (m_cDetailLevel != 0)
					{	m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
					}			
					break;
				default:
					break;
				}

				if (_tmp_sOwnerType == 81) // Abaddon
				{	m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				}else if (bInv == TRUE)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				else
				{	if ((_tmp_iStatus & 0x40) != 0)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime);
				}
				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
				{	if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);

				if ((iHairIndex != -1) && (iHelmIndex == -1))
				{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, iR, iG, iB, dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 1))
				{	if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}

				if (iPantsIndex != -1)
				{	if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}

				if (iArmArmorIndex != -1)
				{	if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 0))
				{	if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}

				if (iBodyArmorIndex != -1)
				{	if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}

				if (iHelmIndex != -1)
				{	if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
				{	if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}

				if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
				{	m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				}else
				if (iShieldIndex != -1)
				{	if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

				switch (iShieldGlare) {
					case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
					case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 4 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 4 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}	}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
				{	if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 4 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}

				if (iWeaponIndex != -1)
				{	if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
					DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}	}

			if ((_tmp_iStatus & 0x20) != 0) 	// Berserk
				m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, cFrame, 0, -5, -5, dwTime);
			DrawAngel(16+(_tmp_cDir - 1), sX+20, sY-20, cFrame%4, dwTime);
			CheckActiveAura2(sX, sY, dwTime,  _tmp_sOwnerType);

		}else // DrawMode != 1
		{	if (_cDrawingOrder[_tmp_cDir] == 1)
			{	if (iWeaponIndex != -1)
				{	if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY,  cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
					DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}	}
				switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
				case 10: // Slime
				case 35: // Energy Sphere
				case 50: // TW
				case 51: // CP
			    case 60: // Plant
				case 65: // IceGolem
				case 66: // Wyvern
				case 73: // Fire Wyvern
				case 81: // Abaddon
				case 91: // Gate
				case 95: // Willowisp
				case 96: // Air Elemental
				case 97: // Fire Elemental
				case 98: // Earth Elemental
				case 99: // Ice Elemental
					break;
				default:
					if (m_cDetailLevel != 0)
					{	if (sX < 50)
							 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
					}
					break;
				}
				switch (_tmp_sOwnerType) { // Lumière en dessous
				case 35: // Energy Sphere
				case 95: // Willowisp
				case 96: // Air Elemental
				case 97: // Fire Elemental
				case 98: // Earth Elemental
				case 99: // Ice Elemental
					if (m_cDetailLevel != 0)
					{	m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
					}			
					break;
				default:
					break;
				}

				if (_tmp_sOwnerType == 81) // Abaddon
				{	m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				}else if (bInv == TRUE)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				else {
					if ((_tmp_iStatus & 0x40) != 0)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime);
				}
				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
				{	if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);

				if ((iHairIndex != -1) && (iHelmIndex == -1))
				{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, iR, iG, iB, dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 1)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}

				if (iPantsIndex != -1)
				{	if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}

				if (iArmArmorIndex != -1)
				{	if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
					if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}

				if (iBodyArmorIndex != -1)
				{	if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}

				if (iHelmIndex != -1)
				{	if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
				{	if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}

				if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
				{	m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				}else
				if (iShieldIndex != -1)
				{	if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

					switch (iShieldGlare) {
					case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
					case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
					}
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
				{	if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}
			}else
			{	switch (_tmp_sOwnerType) {
				case 10: // Slime
				case 35: // Energy Sphere
				case 50: // TW
				case 51: // CP
			    case 60: // Plant
				case 65: // IceGolem
				case 66: // Wyvern
				case 73: // Fire Wyvern
				case 81: // Abaddon
				case 91: // Gate
				case 95: // Willowisp
				case 96: // Air Elemental
				case 97: // Fire Elemental
				case 98: // Earth Elemental
				case 99: // Ice Elemental
					break;
				default:
					if (m_cDetailLevel != 0) {
						if (sX < 50)
							 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
						else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
					}
					break;
				}
				switch (_tmp_sOwnerType) { // Lumière en dessous
				case 35: // Energy Sphere
				case 95: // Willowisp
				case 96: // Air Elemental
				case 97: // Fire Elemental
				case 98: // Earth Elemental
				case 99: // Ice Elemental
					if (m_cDetailLevel != 0)
					{	m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
					}			
					break;
				default:
					break;
				}
				if (_tmp_sOwnerType == 81) // Abaddon
				{	m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				}else if (bInv == TRUE)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
				else {
					if ((_tmp_iStatus & 0x40) != 0)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime);
				}

				SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
					     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
				{	if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}

				if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);

				if ((iHairIndex != -1) && (iHelmIndex == -1))
				{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
					m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, iR, iG, iB, dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 1))
				{	if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}

				if (iPantsIndex != -1)
				{	if (iPantsColor == 0)
						m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
				}

				if (iArmArmorIndex != -1)
				{	if (iArmColor == 0)
						m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
				}

				if ((iBootsIndex != -1) && (iSkirtDraw == 0))
				{	if (iBootsColor == 0)
						m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
				}

				if (iBodyArmorIndex != -1)
				{	if (iArmorColor == 0)
						m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
				}

				if (iHelmIndex != -1)
				{	if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
				}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
				{	if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}

				if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
				{	m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				}else
				if (iShieldIndex != -1)
				{	if (iShieldColor == 0)
						m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

					switch (iShieldGlare) {
					case 0: break;
					//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
					case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
				}	}

				if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
				{	if (iMantleColor == 0)
						m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
				}

				if (iWeaponIndex != -1)
				{	if (iWeaponColor == 0)
						m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
					DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
					switch (iWeaponGlare) {
					case 0: break;
					case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
					case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
					case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}	}

			if ((_tmp_iStatus & 0x20) != 0)	// Berserk
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, cFrame, 0, -5, -5, dwTime);
			DrawAngel(16+(_tmp_cDir - 1), sX+20, sY-20, cFrame%4, dwTime);
			CheckActiveAura2(sX, sY, dwTime,  _tmp_sOwnerType);
		}
	}else if( strlen(_tmp_cName) > 0 )
	{	if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != NULL)
	{	if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{	m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}
		else
		{	m_pMapData->ClearChatMsg(indexX, indexY);
	}	}
	// Snoopy: Abaddon effects
	int randFrame;
	switch (_tmp_sOwnerType) {
	case 81: // Abaddon effects	
		randFrame = _tmp_cFrame % 12;
		m_pEffectSpr[154]->PutTransSprite70(sX-50	, sY-50		, randFrame, dwTime);
		m_pEffectSpr[155]->PutTransSprite70(sX-20	, sY-80		, randFrame, dwTime);
		m_pEffectSpr[156]->PutTransSprite70(sX+70	, sY-50		, randFrame, dwTime);
		m_pEffectSpr[157]->PutTransSprite70(sX-30	, sY		, randFrame, dwTime);
		m_pEffectSpr[158]->PutTransSprite70(sX-60	, sY+90		, randFrame, dwTime);
		m_pEffectSpr[159]->PutTransSprite70(sX+65	, sY+85		, randFrame, dwTime);
		switch (_tmp_cDir) {
		case 1:
			m_pEffectSpr[153]->PutTransSprite70(sX		, sY+108 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-50	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 2:
			m_pEffectSpr[153]->PutTransSprite70(sX		, sY+95	, _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-70	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 3:
			m_pEffectSpr[153]->PutTransSprite70(sX		, sY+105 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-90	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 4:
			m_pEffectSpr[153]->PutTransSprite70(sX-35	, sY+100 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-80	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 5:
			m_pEffectSpr[153]->PutTransSprite70(sX		, sY+95	, _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-65	, sY-5	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 6:
			m_pEffectSpr[153]->PutTransSprite70(sX+45	, sY+95	, _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-31	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 7:
			m_pEffectSpr[153]->PutTransSprite70(sX+40	, sY+110 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-30	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 8:
			m_pEffectSpr[153]->PutTransSprite70(sX+20	, sY+110 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-20	, sY+16	, _tmp_iEffectFrame %15, dwTime);
			break;
		}
		break;	
		
	case 36: // AGT
	case 37: // CGT
	case 38: // MS
	case 39: // DT
	case 40: // ESG
	case 41: // GMG
	case 42: // ManaStone
		// Reduce Sprite width to 40, and Height to 80
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom - 80;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left =
			(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right + m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left)/2 - 20;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left + 40;
		break;
		
	default:
		if (   (m_bIsGetPointingMode == TRUE) 
			&& (m_bCommandAvailable == TRUE)
			&& (_tmp_sOwnerType >=10)
			&& (m_bShiftPressed == TRUE)
			&& (m_iPointCommandType >= 100) && (m_iPointCommandType < 200) ) // spell
		{	return FALSE;
		}	
		break;
	}
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;

	return FALSE;
}

BOOL CGame::DrawObject_OnDying(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB,  iHelmIndex, iMantleIndex;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;
 char cFrame;
 int randFrame;

	if (m_cDetailLevel == 0)
	{	iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}else
	{	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}
	cFrame = _tmp_cFrame;

	 switch (_tmp_sOwnerType) {
	 case 1:
	 case 2:
	 case 3:
		if (cFrame < 6)
		{	iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (0 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15;
			iHairIndex   = DEF_SPRID_HAIR_M	+ ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 0;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 0;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + 0;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 0;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 0;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 0;
		}else
		{	cFrame -= 6;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (11 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + 11;
			iHairIndex   = DEF_SPRID_HAIR_M	+ ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 11;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				     iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 11;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + 11;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 11;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 11;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 11;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 11;
		}
		break;

	 case 4:
	 case 5:
	 case 6:
		 if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		 if (cFrame < 6)
		 {	iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (0 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15;
			iHairIndex   = DEF_SPRID_HAIR_W	+ ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 0;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 0;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + 0;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 0;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 0;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 0;
		}else
		{ 	cFrame -= 6;
			iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (11 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + 11;
			iHairIndex   = DEF_SPRID_HAIR_W	+ ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 11;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				     iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 11;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + 11;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 11;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 11;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 11;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 11;
		}
		break;

	 default:		
		 // polymorph bug (OnDying)
		BOOL bIsPlayer = (_tmp_wObjectID < 10000); 		
		if (cFrame < 4)
		{	if (_tmp_sAppr2 != 0 && !bIsPlayer)
			{	 iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
				 cFrame = _tmp_sAppr2 -1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (3 * 8);
			else if (_tmp_sOwnerType == 86) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (3 * 8);
			else if (_tmp_sOwnerType == 87) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (3 * 8);
			else if (_tmp_sOwnerType == 89) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (3 * 8);
			else if (_tmp_sOwnerType == 91) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
			iUndiesIndex = -1;
			iHairIndex   = -1;
			iArmArmorIndex = -1;
			iBodyArmorIndex = -1;
			iPantsIndex = -1;
			iBootsIndex = -1;
			iMantleIndex = -1;
			iHelmIndex      = -1;
			switch (_tmp_sOwnerType) {
			case 36: // AGT
			case 37: // CGT
			case 38: // MS
			case 39: // DT
			case 40: // ESG
			case 41: // GMG
			case 42: // ManaStone
				if (_tmp_sAppr2 == 0) cFrame = 0;
				break;
			case 51: cFrame = 0; break;
			}
		}else
		{	switch (_tmp_sOwnerType) {
			case 51: cFrame = 0; break;
			default: cFrame -= 4; break;
			}
			if (_tmp_sAppr2 != 0 && !bIsPlayer)
			{	 iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
				 cFrame = _tmp_sAppr2 -1;
			}
			else if (_tmp_sOwnerType == 66) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else if (_tmp_sOwnerType == 73) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else if (_tmp_sOwnerType == 81) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (3 * 8);
			else if (_tmp_sOwnerType == 86) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (3 * 8);
			else if (_tmp_sOwnerType == 87) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (3 * 8);
			else if (_tmp_sOwnerType == 89) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (3 * 8);
			else if (_tmp_sOwnerType == 91) iBodyIndex =  DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			else iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			iUndiesIndex = -1;
			iHairIndex   = -1;
			iArmArmorIndex = -1;
			iBodyArmorIndex = -1;
			iPantsIndex = -1;
			iBootsIndex = -1;
			iMantleIndex = -1;
			iHelmIndex   = -1;
		}
		break;
	}
	if (m_bIsCrusadeMode || m_bIsAvatarMode) DrawObjectFOE(sX, sY, cFrame);

	if (_tmp_iEffectType != 0)
	{	switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
	}	}

	if (bTrans == FALSE)
	{	switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
        case 60: // Plant
		case 65: // IceGolem
		case 66: // Wyvern
		case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
		case 95: // Willowisp
		case 96: // Air Elemental
		case 97: // Fire Elemental
		case 98: // Earth Elemental
		case 99: // Ice Elemental
			break;
		default:
			if (m_cDetailLevel != 0)
			{	if (sX < 50)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, cFrame, dwTime);
			}
			break;
		}
		if (_tmp_sOwnerType == 95) // Will o wisp
		{	m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite70(sX, sY+15, _tmp_cFrame, dwTime);
		}else if (_tmp_sOwnerType == 81)
		{	m_pEffectSpr[152]->PutTransSprite70(sX-80	, sY-15 , _tmp_iEffectFrame %27, dwTime); // Explosion Abaddon
			m_pEffectSpr[152]->PutTransSprite70(sX		, sY-15 , _tmp_iEffectFrame %27, dwTime);
			m_pEffectSpr[152]->PutTransSprite70(sX-40	, sY	, _tmp_iEffectFrame %27, dwTime);
			m_pEffectSpr[163]->PutTransSprite70(sX-90	, sY-80	, _tmp_iEffectFrame %12, dwTime); // Ames qui s'envolent
			m_pEffectSpr[160]->PutTransSprite70(sX-60	, sY-50	, _tmp_iEffectFrame %12, dwTime);
			m_pEffectSpr[161]->PutTransSprite70(sX-30	, sY-20	, _tmp_iEffectFrame %12, dwTime);
			m_pEffectSpr[162]->PutTransSprite70(sX		, sY-100, _tmp_iEffectFrame %12, dwTime);
			m_pEffectSpr[163]->PutTransSprite70(sX+30	, sY-30	, _tmp_iEffectFrame %12, dwTime);
			m_pEffectSpr[162]->PutTransSprite70(sX+60	, sY-90	, _tmp_iEffectFrame %12, dwTime);
			m_pEffectSpr[163]->PutTransSprite70(sX+90	, sY-50	, _tmp_iEffectFrame %12, dwTime);
			switch (_tmp_cDir) {
			case 1: m_pEffectSpr[140]->PutTransSprite70(sX, sY, cFrame, dwTime); break; // Abbadon dying
			case 2: m_pEffectSpr[141]->PutTransSprite70(sX, sY, cFrame, dwTime); break; // fixed sprit IDs
			case 3: m_pEffectSpr[142]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			case 4: m_pEffectSpr[143]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			case 5: m_pEffectSpr[144]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			case 6: m_pEffectSpr[145]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			case 7: m_pEffectSpr[146]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			case 8: m_pEffectSpr[147]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			}
		}else if( _tmp_sOwnerType == 66 ) m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
		else if( _tmp_sOwnerType == 73 )
		{	//m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, cFrame, dwTime);
			m_pSprite[33]->PutTransSprite(sX, sY, cFrame, dwTime);
			switch (_tmp_cDir) {
			case 1: m_pEffectSpr[141]->PutTransSprite70(sX, sY, cFrame+8, dwTime); break; // Abbadon qui meurt
			case 2: m_pEffectSpr[142]->PutTransSprite70(sX, sY, cFrame+8, dwTime); break;
			case 3: m_pEffectSpr[143]->PutTransSprite70(sX, sY, cFrame+8, dwTime); break;
			case 4: m_pEffectSpr[144]->PutTransSprite70(sX, sY, cFrame+8, dwTime); break;
			case 5: m_pEffectSpr[145]->PutTransSprite70(sX, sY, cFrame+8, dwTime); break;
			case 6: m_pEffectSpr[146]->PutTransSprite70(sX, sY, cFrame+8, dwTime); break;
			case 7: m_pEffectSpr[147]->PutTransSprite70(sX, sY, cFrame+8, dwTime); break;
			//case 8: m_pEffectSpr[148]->PutTransSprite70(sX, sY, cFrame, dwTime); break;
			case 8: m_pEffectSpr[141]->PutTransSprite70(sX, sY, cFrame+8, dwTime); break; //due to buggy Sprite nb
			}
		}else
		{	if ((_tmp_iStatus & 0x40) != 0)
				 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, cFrame, dwTime);
		}

		SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
			     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

		if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, iR, iG, iB, dwTime);
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{	if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}

		if (iPantsIndex != -1)
		{	if (iPantsColor == 0)
				m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
		}

		if (iArmArmorIndex != -1)
		{	if (iArmColor == 0)
				m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
		}

		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{	if (iBootsColor == 0)
				m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}

		if (iBodyArmorIndex != -1)
		{	if (iArmorColor == 0)
				m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
		}

		if (iHelmIndex != -1)
		{	if (iHelmColor == 0)
				 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
		}

		if (iMantleIndex != -1)
		{	if (iMantleColor == 0)
				m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}

		if ((_tmp_iStatus & 0x20) != 0) // Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY,  cFrame, 0, -5, -5, dwTime);
		DrawAngel(24+(_tmp_cDir - 1), sX+20, sY-20, _tmp_cFrame, dwTime);
		CheckActiveAura2(sX, sY, dwTime,  _tmp_sOwnerType);

	}else if( strlen(_tmp_cName) > 0 )
	{	if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != NULL)
	{	if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{	m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}else
		{	m_pMapData->ClearChatMsg(indexX, indexY);
	}	}


	switch (_tmp_sOwnerType) {
	case 36: // AGT
	case 37: // CGT
	case 38: // MS
	case 39: // DT
	case 40: // ESG
	case 41: // GMG
	case 42: // ManaStone
		// Reduce Sprite width to 40, and Height to 80
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom - 80;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left =
			(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right + m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left)/2 - 20;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left + 40;
		break;
		
	default:
		if (   (m_bIsGetPointingMode == TRUE) 
			&& (m_bCommandAvailable == TRUE)
			&& (_tmp_sOwnerType >=10)
			&& (m_bShiftPressed == TRUE)
			&& (m_iPointCommandType >= 100) && (m_iPointCommandType < 200) ) // spell
		{	return FALSE;
		}	
		break;
	}
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;
	return FALSE;
}

BOOL   CGame::DrawObject_OnDead(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{int iBodyIndex, iUndiesIndex, iHairIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iR, iG, iB, iFrame, iMantleIndex, iHelmIndex;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	if( _tmp_sOwnerType == 66) return FALSE;

	if (m_cDetailLevel == 0)
	{	iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}else
	{	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iFrame = 7;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (11 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + 11;
		iHairIndex   = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 11;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 11;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + 11;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 11;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 11;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 11;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 11;
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		iFrame = 7;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (11 * 8);
		iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + 11;
		iHairIndex   = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 11;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 11;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + 11;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 11;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 11;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 11;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 11;
		break;
	default:
		switch (_tmp_sOwnerType) {
		case 28: // Troll
		case 29: // Ogre
		case 30: // Liche
		case 31: // DD		// les 2 dernieres sont pas bonnes pour un mort !
		case 63: // Frost	// les 2 dernieres sont pas bonnes pour un mort !
			iFrame = 5;
			iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			break;

		case 32: // Uni
		case 33: // WW
		case 43: // LWB
		case 44: // GHK
		case 45: // GHKABS
		case 46: // TK
		case 47: // BG
		case 48: // SK
		case 49: // HC
		case 50: // TW
		case 53: // BB
		case 54: // DE
		case 55: // Rabbit
		case 56: // Cat
		case 57: // Frog
		case 58: // MG
		case 59: // Ettin
		case 60: // Plant
		case 61: // Rudolph
		case 62: // Direboar
		case 64: // Crops  ----------- Crop ici! etonant, pourtant !
		case 65: // IceGolem
		case 70: // Dragon..........Ajouts par Snoopy
		case 71: // Centaur
		case 72: // ClawTurtle
		case 74: // GiantCrayfish
		case 75: // Gi Lizard
		case 76: // Gi Tree
		case 77: // Master Orc
		case 78: // Minaus
		case 79: // Nizie
		case 80: // Tentocle
		case 82: // Sorceress
		case 83: // ATK
		case 84: // MasterElf
		case 85: // DSK
		case 88: // Barbarian
			iFrame = 7;
			iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			break;

		case 86: // HBT
		case 87: // CT
		case 89: // AGC
			iFrame = 7;
			iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (3 * 8);
			break;

		case 66: // Wyvern
			iFrame = 15;
			iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			break;

		case 73: // FireWyvern
			iFrame = 7;
			iBodyIndex =  DEF_SPRID_MOB  +  (0 )*8*7 + (4 * 8); // Slime's size
			bTrans = TRUE; // Prevents showing hugly corpse
			break;

		case 81: // Abaddon
			iFrame = 0;
			iBodyIndex =  DEF_SPRID_MOB  +  (0 )*8*7 + (4 * 8); // Slime's size
			bTrans = TRUE; // Prevents showing hugly corpse
			break;

		case 51: // CP
			iFrame = 0;
			iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			break;

		case 52: // GG
			iFrame = 11;
			iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			break;

		case 91: // Gate
			iFrame = 5;
			iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
			break;

		case 95: // Willowisp
		case 96:
		case 97:
		case 98:
		case 99: // Elementals
			iBodyIndex =  DEF_SPRID_MOB  +  (0 )*8*7 + (4 * 8); // Slime's size
			bTrans = TRUE; // Prevents showing hugly corpse
			break;

		default: // 40*4 (10...27)
			iFrame = 3;
			iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			break;
		}
		iUndiesIndex = -1;
		iHairIndex   = -1;
		iArmArmorIndex = -1;
		iBodyArmorIndex = -1;
		iPantsIndex = -1;
		iBootsIndex = -1;
		iMantleIndex = -1;
		iHelmIndex      = -1;
		break;
	}
	if (bTrans == FALSE)
	{	if (_tmp_cFrame == -1)
		{	_tmp_cFrame = 7;
			if ((_tmp_iStatus & 0x40) != 0)
				 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, iFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
			else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, iFrame, dwTime);

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{	if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iPantsIndex != -1)
			{	if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1)
			{	if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{	if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1)
			{	if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1)
			{	if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}

			if (iMantleIndex != -1)
			{	if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
		}else if ((_tmp_iStatus & 0x20) != 0)
				 m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, iFrame, -2*_tmp_cFrame +5, -2*_tmp_cFrame -5, -2*_tmp_cFrame -5, dwTime);
			else m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX, sY, iFrame, -2*_tmp_cFrame,-2*_tmp_cFrame,-2*_tmp_cFrame, dwTime);

	}else if( strlen(_tmp_cName) > 0 )
	{	if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != NULL)
	{	if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{	m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}else
		{	m_pMapData->ClearDeadChatMsg(indexX, indexY);
	}	}
	// Snoopy: Abaddon effects
	if (_tmp_sOwnerType == 81)
	{	Abaddon_corpse(sX, sY); // By Snoopy....
	}else if (_tmp_sOwnerType == 73)
	{	//m_pEffectSpr[35]->PutTransSprite70(sX+120, sY+120, rand(), dwTime);
		m_pEffectSpr[35]->PutTransSprite70(sX+20, sY-15,  rand()%10, dwTime);
	}
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;
	return FALSE;
}



BOOL   CGame::DrawObject_OnMove(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{int dx, dy;
 int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
 int iWeaponIndex, iShieldIndex, iAdd, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 66 || _tmp_sOwnerType == 73)	bInv = TRUE; //Energy-Ball, Wyvern
	if(_tmp_sOwnerType == 95 || _tmp_sOwnerType == 96 || _tmp_sOwnerType == 97 || _tmp_sOwnerType == 98 || _tmp_sOwnerType == 99) bInv = TRUE; //Elementals

	if (m_cDetailLevel == 0)
	{	iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}else
	{	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ( (_tmp_iStatus & 0x10) != 0)
	{	if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // invi
		else if((_tmp_iStatus & 0x00040000) != 0 ) bInv = TRUE;
		//		if (bTransparentInvi == TRUE) iTemp = (iTemp | 0x00040000);
#else
		else if( _iGetFOE(_tmp_iStatus) == 1 ) bInv = TRUE;
#endif

		else return FALSE;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{	iAdd = 3;
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*3 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F)*8 + 3;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd;
		}else
		{	iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (2 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + 2;
			iHairIndex	 = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 2;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 2;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + 2;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 2;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 2;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else  iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*2 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F)*8 + 2;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 2;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 2;
		}
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{	iAdd = 3;
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*3 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F)*8 + 3;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd;
		}else
		{	iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (2 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + 2;
			iHairIndex	 = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 2;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 2;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + 2;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 2;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 2;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*2 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F)*8 + 2;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 2;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 2;
		}
		break;

	default:
		if (_tmp_sOwnerType == 86) iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		else iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (1 * 8);
		iUndiesIndex    = -1;
		iHairIndex      = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex  = -1;
		iBootsIndex     = -1;
		iPantsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}
	dx = 0;
	dy = 0;
	switch (_tmp_cDir) {
	case 1 : dy = 28 - (_tmp_cFrame<<2); break;
	case 2 : dy = 28 - (_tmp_cFrame<<2); dx = (_tmp_cFrame<<2) - 28; break;
	case 3 : dx = (_tmp_cFrame<<2) - 28; break;
	case 4 : dx = (_tmp_cFrame<<2) - 28; dy = (_tmp_cFrame<<2) - 28; break;
	case 5 : dy = (_tmp_cFrame<<2) - 28; break;
	case 6 : dy = (_tmp_cFrame<<2) - 28; dx = 28 - (_tmp_cFrame<<2); break;
	case 7 : dx = 28 - (_tmp_cFrame<<2); break;
	case 8 : dx = 28 - (_tmp_cFrame<<2); dy = 28 - (_tmp_cFrame<<2); break;
	}
	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:

	case 28: // Troll.
	case 29: // Orge.
	case 30: // Liche
	case 31: // DD
	case 32: // Uni
	case 33: // ww

	case 43: // LWB
	case 44: // GHK
	case 45: // GHKABS
	case 46: // TK
	case 47: // BG
	case 48: // SK
	case 49: // HC
	case 50: // TW

	case 52: // GG
	case 53: // BB
	case 54: // DE
	case 55: // Rabbit
	case 56: // Cat
	case 57: // Frog
	case 58: // MG
	case 59: // Ettin
	case 60: // Plant
	case 61: // Rudolph
	case 62: // DireBoar
	case 63: // Frost

	case 65: // Ice-Golem
	case 66: // Wyvern

	case 70: // Dragon..........Ajouts par Snoopy
	case 71: // Centaur
	case 72: // ClawTurtle
	case 73: // FireWyvern
	case 74: // GiantCrayfish
	case 75: // Gi Lizard
	case 76: // Gi Tree
	case 77: // Master Orc
	case 78: // Minaus
	case 79: // Nizie
	case 80: // Tentocle
	case 81: // Abaddon
	case 82: // Sorceress
	case 83: // ATK
	case 84: // MasterElf
	case 85: // DSK
	case 86: // HBT
	case 87: // CT
	case 88: // Barbarian
	case 89: // AGC
	case 90: // Gail
		break;

	default:
		_tmp_cFrame = _tmp_cFrame / 2;
		break;
	}
	if (m_bIsCrusadeMode || m_bIsAvatarMode) DrawObjectFOE(sX+dx, sY+dy, _tmp_cFrame);

	if (_tmp_iEffectType != 0)
	{	switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
	}	}

	if( _tmp_sOwnerType == 65 ) // IceGolem
	{	/*m_pEffectSpr[77]->PutTransSprite70(sX+dx, sY+dy, _tmp_cFrame, dwTime);*/
		switch( rand()%3 ) {
		case 0:	m_pEffectSpr[76]->PutTransSprite70(sX+dx, sY+dy, _tmp_cFrame, dwTime); break;
		case 1:	m_pEffectSpr[77]->PutTransSprite70(sX+dx, sY+dy, _tmp_cFrame, dwTime); break;
		case 2:	m_pEffectSpr[78]->PutTransSprite70(sX+dx, sY+dy, _tmp_cFrame, dwTime); break;
		}
	}
	if (bTrans == FALSE)
	{	CheckActiveAura(sX+dx, sY+dy, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{	if (iWeaponIndex != -1)
			{	if(bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else
				{	if (iWeaponColor == 0)
						 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
			case 66: // Wyvern
			case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
			case 96: // Air Elemental
			case 95: // Willowisp
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				break;
						default:
				if (m_cDetailLevel != 0) {
					if (sX < 50)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
				break;
			}			
			switch (_tmp_sOwnerType) { // Lumière en dessous
			case 35: // Energy Sphere
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				if (m_cDetailLevel != 0)
				{	m_pEffectSpr[0]->PutTransSprite(sX+dx, sY+dy, 1, dwTime);	
				}			
				break;
			default:
				break;
			}

			if (_tmp_sOwnerType == 81) // Abaddon
			{	m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			}else if (bInv == TRUE)
				 //m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite2(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else
			{	if ((_tmp_iStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (iUndiesIndex != -1)
			{	if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}	}

			if (iPantsIndex != -1)
			{	if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iPantsColor == 0)
						 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}	}

			if (iArmArmorIndex != -1)
			{	if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iArmColor == 0)
						 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}	}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}	}

			if (iBodyArmorIndex != -1)
			{	if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iArmorColor == 0)
						 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}	}

			if (iHelmIndex != -1)
			{	if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
			{	m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
			}else
			if (iShieldIndex != -1)
			{	if(bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iShieldColor == 0)
						 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

				}
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}
		}else
		{	switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
			case 66: // Wyvern
			case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				break;
			default:
				if (m_cDetailLevel != 0)
				{	if (sX < 50)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
				break;
			}
			switch (_tmp_sOwnerType) { // Lumière en dessous
			case 35: // Energy Sphere
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				if (m_cDetailLevel != 0)
				{	m_pEffectSpr[0]->PutTransSprite(sX+dx, sY+dy, 1, dwTime);
				}			
				break;
			default:
				break;
			}

			if (_tmp_sOwnerType == 81) // Abaddon
			{	m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite70(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			}else if (bInv == TRUE)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else
			{	if ((_tmp_iStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (iUndiesIndex != -1)
			{	if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}	}

			if (iPantsIndex != -1)
			{	if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iPantsColor == 0)
						 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}	}

			if (iArmArmorIndex != -1)
			{	if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iArmColor == 0)
						 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}	}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}	}

			if (iBodyArmorIndex != -1)
			{	if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iArmorColor == 0)
						 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}	}

			if (iHelmIndex != -1)
			{	if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
			{	m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
			}else
			if (iShieldIndex != -1)
			{	if(bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iShieldColor == 0)
						 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

				}
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (iWeaponIndex != -1)
			{	if(bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else
				{	if (iWeaponColor == 0)
						 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
		}	}	}

		// Berserk
		if ((_tmp_iStatus & 0x20) != 0)
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel(40+(_tmp_cDir - 1), sX+dx+20, sY+dy-20, _tmp_cFrame%4, dwTime);
		CheckActiveAura2(sX+dx, sY+dy, dwTime,  _tmp_sOwnerType);

	}else if( strlen(_tmp_cName) > 0 )
	{	if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX+dx, sY+dy, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX+dx, sY+dy, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != NULL)
	{	if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{	m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX+dx;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY+dy;
		}else
		{	m_pMapData->ClearChatMsg(indexX, indexY);
	}	}
	_tmp_dx = dx;
	_tmp_dy = dy;
	// Snoopy: Abaddon effects
	int randFrame;
	switch (_tmp_sOwnerType) {
	case 81: // Abaddon effects		
		randFrame = _tmp_cFrame % 12;
		m_pEffectSpr[154]->PutTransSprite70(sX-50	, sY-50		, randFrame, dwTime);
		m_pEffectSpr[155]->PutTransSprite70(sX-20	, sY-80		, randFrame, dwTime);
		m_pEffectSpr[156]->PutTransSprite70(sX+70	, sY-50		, randFrame, dwTime);
		m_pEffectSpr[157]->PutTransSprite70(sX-30	, sY		, randFrame, dwTime);
		m_pEffectSpr[158]->PutTransSprite70(sX-60	, sY+90		, randFrame, dwTime);
		m_pEffectSpr[159]->PutTransSprite70(sX+65	, sY+85		, randFrame, dwTime);
		switch (_tmp_cDir) {
		case 1:
			m_pEffectSpr[153]->PutTransSprite70(sX+dx		, sY+dy+108 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX+dx-50	, sY+dy+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 2:
			m_pEffectSpr[153]->PutTransSprite70(sX+dx		, sY+dy+95	, _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX+dx-70	, sY+dy+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 3:
			m_pEffectSpr[153]->PutTransSprite70(sX+dx		, sY+dy+105 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX+dx-90	, sY+dy+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 4:
			m_pEffectSpr[153]->PutTransSprite70(sX+dx-35	, sY+dy+100 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX+dx-80	, sY+dy+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 5:
			m_pEffectSpr[153]->PutTransSprite70(sX+dx		, sY+dy+95	, _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX+dx-65	, sY+dy-5	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 6:
			m_pEffectSpr[153]->PutTransSprite70(sX+dx+45	, sY+dy+95	, _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX+dx-31	, sY+dy+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 7:
			m_pEffectSpr[153]->PutTransSprite70(sX+dx+40	, sY+dy+110 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX+dx-30	, sY+dy+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 8:
			m_pEffectSpr[153]->PutTransSprite70(sX+dx+20	, sY+dy+110 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX+dx-20	, sY+dy+16	, _tmp_iEffectFrame %15, dwTime);
			break;
		}	
		break;	
	
	case 36: // AGT
	case 37: // CGT
	case 38: // MS
	case 39: // DT
	case 40: // ESG
	case 41: // GMG
	case 42: // ManaStone
		// Reduce Sprite width to 40, and Height to 80
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom - 80;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left =
			(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right + m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left)/2 - 20;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left + 40;
		break;
		
	default:
		if (   (m_bIsGetPointingMode == TRUE) 
			&& (m_bCommandAvailable == TRUE)
			&& (_tmp_sOwnerType >=10)
			&& (m_bShiftPressed == TRUE)
			&& (m_iPointCommandType >= 100) && (m_iPointCommandType < 200) ) // spell
		{	return FALSE;
		}	
		break;
	}

	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;
	return FALSE;
}

BOOL CGame::DrawObject_OnDamageMove(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{
 int cFrame, cDir;
 int dx, dy;
 int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
 int iWeaponIndex, iShieldIndex, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	if(_tmp_sOwnerType == 67 || _tmp_sOwnerType == 68 || _tmp_sOwnerType == 69 || _tmp_sOwnerType == 81) return FALSE;
	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern
	if(_tmp_sOwnerType == 95 || _tmp_sOwnerType == 96 || _tmp_sOwnerType == 97 || _tmp_sOwnerType == 98 || _tmp_sOwnerType == 99) bInv = TRUE; //Elementals

	if (m_cDetailLevel == 0)
	{	iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}else
	{	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ( (_tmp_iStatus & 0x10) != 0)
	{	if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // invi
		else if((_tmp_iStatus & 0x00040000) != 0 ) bInv = TRUE;
#else
		else if( _iGetFOE(_tmp_iStatus) == 1 ) bInv = TRUE;
#endif

		else return FALSE;
	}
	cDir = _tmp_cDir;
	switch (_tmp_cDir) {
	case 1: _tmp_cDir = 5; break;
	case 2: _tmp_cDir = 6; break;
	case 3: _tmp_cDir = 7; break;
	case 4: _tmp_cDir = 8; break;
	case 5: _tmp_cDir = 1; break;
	case 6: _tmp_cDir = 2; break;
	case 7: _tmp_cDir = 3; break;
	case 8: _tmp_cDir = 4; break;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (10 * 8);
		iUndiesIndex    = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + 10;
		iHairIndex      = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 10;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 10;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + 10;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 10;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 10;
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F)*8 + 5;
		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*5 + (_tmp_cDir - 1);
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 10;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 10;
		break;
	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		iBodyIndex = 500 + (_tmp_sOwnerType - 1 )*8*15 + (10 * 8);
		iUndiesIndex    = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + 10;
		iHairIndex      = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 10;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 10;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + 10;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 10;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 10;
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F)*8 + 5;
		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*5 + (_tmp_cDir - 1);
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 10;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 10;
		break;
	default:
		if (_tmp_sOwnerType == 66)      iBodyIndex = DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		else if (_tmp_sOwnerType == 73) iBodyIndex = DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		else if (_tmp_sOwnerType == 86) iBodyIndex = DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);
		else if (_tmp_sOwnerType == 87) iBodyIndex = DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);// Ne devrait pas arriver!
		else if (_tmp_sOwnerType == 89) iBodyIndex = DEF_SPRID_MOB +  (_tmp_sOwnerType - 10 )*8*7 + (2 * 8);// Ne devrait pas arriver!
		else iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (3 * 8);
		iUndiesIndex    = -1;
		iHairIndex      = -1;
		iArmArmorIndex  = -1;
		iBodyArmorIndex = -1;
		iPantsIndex     = -1;
		iBootsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}
	dx = 0;
	dy = 0;
	switch (_tmp_cDir) {
	case 1 : dy = 28 - (_tmp_cFrame<<2); break;
	case 2 : dy = 28 - (_tmp_cFrame<<2); dx = (_tmp_cFrame<<2) - 28; break;
	case 3 : dx = (_tmp_cFrame<<2) - 28; break;
	case 4 : dx = (_tmp_cFrame<<2) - 28; dy = (_tmp_cFrame<<2) - 28; break;
	case 5 : dy = (_tmp_cFrame<<2) - 28; break;
	case 6 : dy = (_tmp_cFrame<<2) - 28; dx = 28 - (_tmp_cFrame<<2); break;
	case 7 : dx = 28 - (_tmp_cFrame<<2); break;
	case 8 : dx = 28 - (_tmp_cFrame<<2); dy = 28 - (_tmp_cFrame<<2); break;
	}
	cFrame = _tmp_cFrame;
	if (m_bIsCrusadeMode || m_bIsAvatarMode) DrawObjectFOE(sX+dx, sY+dy, cFrame);
	if (_tmp_iEffectType != 0)
	{	switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX+dy, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
	}	}

	if (bTrans == FALSE)
	{	CheckActiveAura(sX+dx, sY+dy, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{	if (iWeaponIndex != -1)
			{	if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy,  cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}
			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
			case 66: // Wyvern
			case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				break;
			default:
				if (m_cDetailLevel != 0)
				{	if (sX < 50)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, cFrame, dwTime);
				}
				break;
			}
			switch (_tmp_sOwnerType) { // Lumière en dessous
			case 35: // Energy Sphere
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				if (m_cDetailLevel != 0)
				{	m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
				}			
				break;
			default:
				break;
			}
			if (bInv == TRUE)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, cFrame, dwTime);
			else {
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{	if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1)
			{	if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{	if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iPantsIndex != -1)
			{	if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1)
			{	if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{	if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1)
			{	if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1) {
				if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{	if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
			{	m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
			}else
			if (iShieldIndex != -1)
			{	if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 4 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 4 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{	if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}
		}else
		{	switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
			case 66: // Wyvern
			case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				break;
			default:
				if (m_cDetailLevel != 0)
				{	if (sX < 50)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, cFrame, dwTime);
				}
				break;
			}
			switch (_tmp_sOwnerType) { // Lumière en dessous
			case 35: // Energy Sphere
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				if (m_cDetailLevel != 0)
				{	m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
				}			
				break;
			default:
				break;
			}

			if (bInv == TRUE)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, cFrame, dwTime);
			else {
				if ((_tmp_iStatus & 0x40) != 0)
					m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{	if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (iUndiesIndex != -1)
			{	if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{	if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iPantsIndex != -1)
			{	if (iPantsColor == 0)
					m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}

			if (iArmArmorIndex != -1)
			{	if (iArmColor == 0)
					m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0)) {
				if (iBootsColor == 0)
					m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}

			if (iBodyArmorIndex != -1)
			{	if (iArmorColor == 0)
					m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}

			if (iHelmIndex != -1)
			{	if (iHelmColor == 0)
					 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{	if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
			{	m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
			}else
			if (iShieldIndex != -1)
			{	if (iShieldColor == 0)
					m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
				else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 4 + cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 4 + cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{	if (iMantleColor == 0)
					m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, dwTime);
				else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 4 + cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}

			if (iWeaponIndex != -1)
			{	if (iWeaponColor == 0)
					m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, cFrame, dwTime);
				else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy, cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
		}	}	}

		if ((_tmp_iStatus & 0x20) != 0) 	// Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX+dx, sY+dy, cFrame, 0, -5, -5, dwTime);
		DrawAngel(16+(_tmp_cDir - 1), sX+dx+20, sY+dy-20, cFrame%4, dwTime);
		CheckActiveAura2(sX+dx, sY+dy, dwTime,  _tmp_sOwnerType);

	}else if( strlen(_tmp_cName) > 0 )
	{	if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX+dx, sY+dy, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX+dx, sY+dy, _tmp_sOwnerType, _tmp_iStatus);
	}
	if (_tmp_iChatIndex != NULL)
	{	if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{	m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX+dx;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY+dy;
		}else
		{	m_pMapData->ClearChatMsg(indexX, indexY);
	}	}
	_tmp_dx = dx;
	_tmp_dy = dy;

	switch (_tmp_sOwnerType) {
	case 36: // AGT
	case 37: // CGT
	case 38: // MS
	case 39: // DT
	case 40: // ESG
	case 41: // GMG
	case 42: // ManaStone
		// Reduce Sprite width to 40, and Height to 80
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom - 80;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left =
			(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right + m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left)/2 - 20;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left + 40;
		break;
		
	default:
		if (   (m_bIsGetPointingMode == TRUE) 
			&& (m_bCommandAvailable == TRUE)
			&& (_tmp_sOwnerType >=10)
			&& (m_bShiftPressed == TRUE)
			&& (m_iPointCommandType >= 100) && (m_iPointCommandType < 200) ) // spell
		{	return FALSE;
		}	
		break;
	}
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;
	return FALSE;
}

BOOL CGame::DrawObject_OnMove_ForMenu(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{short dx, dy;
 int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
 int iWeaponIndex, iShieldIndex, iAdd, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;
 int iShieldGlare = (_tmp_sAppr4 & 0x0003);

	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
	iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
	iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
	iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
	iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
	iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
	iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
	iHelmColor   = (_tmp_iApprColor & 0x0000000F);

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{	iAdd = 3;
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else
				{	iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd;
				}
			}else iBodyArmorIndex = -1;
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd;

			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*3 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F)*8 + 3;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd;
		}else
		{	iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (2 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + 2;
			iHairIndex	 = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 2;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 2;
			}else iBodyArmorIndex = -1;
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + 2;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 2;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 2;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*2 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F)*8 + 2;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 2;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 2;
		}
		break;
	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{	iAdd = 3;
			iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (iAdd * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + iAdd;
			iHairIndex	 = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + iAdd;
			}else  iBodyArmorIndex = -1;
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + iAdd;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + iAdd;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				 iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*3 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F)*8 + 3;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + iAdd;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + iAdd;
		}else
		{	iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (2 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + 2;
			iHairIndex	 = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 2;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 2;
			}else iBodyArmorIndex = -1;
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + 2;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 2;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 2;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*2 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F)*8 + 2;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 2;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 2;
		}
		break;
	default:
		iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (1 * 8);
		iUndiesIndex    = -1;
		iHairIndex      = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex  = -1;
		iBootsIndex     = -1;
		iPantsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iHelmIndex      = -1;
		break;
	}
	dx = 0;
	dy = 0;
	if (_cDrawingOrder[_tmp_cDir] == 1)
	{	if (iWeaponIndex != -1)
		{	if (iWeaponColor == 0)
				 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
		}
		switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
		case 60: // Plant
		case 65: // IceGolem
		case 66: // Wyvern
		case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
		case 95: // Willowisp
		case 96: // Air Elemental
		case 97: // Fire Elemental
		case 98: // Earth Elemental
		case 99: // Ice Elemental
			break;
		default:
			if (m_cDetailLevel != 0)
			{	if (sX < 50)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			}
			break;
		}
		if (bInv == TRUE)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
		else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);


		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
		{	if (iMantleColor == 0)
				 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}
		if (iUndiesIndex != -1)
		{	if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
		}

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
		}
		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{	if (iBootsColor == 0)
				 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}
		if (iPantsIndex != -1)
		{	if (iPantsColor == 0)
				 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
		}
		if (iArmArmorIndex != -1)
		{	if (iArmColor == 0)
				 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
		}
		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{	if (iBootsColor == 0)
				 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}
		if (iBodyArmorIndex != -1)
		{	if (iArmorColor == 0)
				 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
		}
		if (iHelmIndex != -1)
		{	if (iHelmColor == 0)
				 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
		}
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
		{	if (iMantleColor == 0)
				 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}

		if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
		{	m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
		}else
		if (iShieldIndex != -1)
		{	if (iShieldColor == 0)
				 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
			else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
			else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

		}
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
		{	if (iMantleColor == 0)
				 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}
	}else
	{	switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
		case 10: // Slime
		case 35: // Energy Sphere
		case 50: // TW
		case 51: // CP
		case 60: // Plant
		case 65: // IceGolem
		case 66: // Wyvern
		case 73: // Fire Wyvern
		case 81: // Abaddon
		case 91: // Gate
		case 95: // Willowisp
		case 96: // Air Elemental
		case 97: // Fire Elemental
		case 98: // Earth Elemental
		case 99: // Ice Elemental
			break;
		default:
			if (m_cDetailLevel != 0)
			{	if (sX < 50)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			}
			break;
		}

		if (bInv == TRUE)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
		else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);

		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
		{	if (iMantleColor == 0)
				 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}
		if (iUndiesIndex != -1) m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

		if ((iHairIndex != -1) && (iHelmIndex == -1))
		{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
		}
		if ((iBootsIndex != -1) && (iSkirtDraw == 1))
		{	if (iBootsColor == 0)
				 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}
		if (iPantsIndex != -1)
		{	if (iPantsColor == 0)
				 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
		}
		if (iArmArmorIndex != -1)
		{	if (iArmColor == 0)
				 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
		}
		if ((iBootsIndex != -1) && (iSkirtDraw == 0))
		{	if (iBootsColor == 0)
				 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
		}
		if (iBodyArmorIndex != -1)
		{	if (iArmorColor == 0)
				 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
		}
		if (iHelmIndex != -1)
		{	if (iHelmColor == 0)
				 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
		}
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
		{	if (iMantleColor == 0)
				 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}

		
		if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
		{	m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
		}else		
		if (iShieldIndex != -1)
		{	if (iShieldColor == 0)
				 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
			else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
			else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

		}
		if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
		{	if (iMantleColor == 0)
				 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
		}
		if (iWeaponIndex != -1)
		{	if (iWeaponColor == 0)
				 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
	}	}

	if (_tmp_iChatIndex != NULL)
	{	if (m_pChatMsgList[_tmp_iChatIndex] != NULL)
		{	DrawChatMsgBox(sX+dx, sY+dy, _tmp_iChatIndex, FALSE);
		}else
		{	m_pMapData->ClearChatMsg(indexX, indexY);
	}	}
	_tmp_dx = dx;
	_tmp_dy = dy;
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX) ) return TRUE;
	return FALSE;
}


BOOL   CGame::DrawObject_OnStop(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{int iBodyIndex, iUndiesIndex, iHairIndex, iBodyArmorIndex, iArmArmorIndex, iPantsIndex, iBootsIndex, iHelmIndex, iR, iG, iB;
 int iWeaponIndex, iShieldIndex, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66 || _tmp_sOwnerType == 81) bInv = TRUE; //Energy-Ball, Wyvern
	if(_tmp_sOwnerType == 95 || _tmp_sOwnerType == 96 || _tmp_sOwnerType == 97 || _tmp_sOwnerType == 98 || _tmp_sOwnerType == 99) bInv = TRUE; //Elementals
	if (m_cDetailLevel == 0)
	{	iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}else
	{	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}

	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ( (_tmp_iStatus & 0x10) != 0)
	{	if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // invi
		else if((_tmp_iStatus & 0x00040000) != 0 ) bInv = TRUE;
#else
		else if( _iGetFOE(_tmp_iStatus) == 1 ) bInv = TRUE;
#endif

		else return FALSE;
	}

	// CLEROTH - Single-direction monsters
	switch(_tmp_sOwnerType){
/*	case 95: // Willowisp
	case 96: // Air Elemental
	case 97: // Fire Elemental
	case 98: // Earth Elemental
	case 99: // Ice Elemental
		_tmp_cDir = 1; // North
		break;*/
	case 91: // Snoopy: Gate
		if (_tmp_cDir <= 3) _tmp_cDir = 3;
		else  _tmp_cDir = 5;
		break;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		_tmp_cFrame = _tmp_cFrame / 2;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{	iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (1 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + 1;
			iHairIndex	 = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 1;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 1;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + 1;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 1;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 1;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*1 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F)*8 + 1;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 1;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 1;
		}else
		{	iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (0 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15;
			iHairIndex	 = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*0 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F)*8 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 0;
		}
		break;

	case 4:
	case 5:
	case 6:
		_tmp_cFrame = _tmp_cFrame / 2;
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		if ((_tmp_sAppr2 & 0xF000) != 0)
		{	iBodyIndex   = 500 + (_tmp_sOwnerType - 1 )*8*15 + (1 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + 1;
			iHairIndex	 = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 1;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 1;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + 1;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 1;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 1;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*1 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F)*8 + 1;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 1;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 1;
		}else
		{	iBodyIndex   = 500  + (_tmp_sOwnerType - 1 )*8*15 + (0 * 8);
			iUndiesIndex = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15;
			iHairIndex	 = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15;
			if ((_tmp_sAppr4 & 0x80) == 0)
			{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
					 iBodyArmorIndex = -1;
				else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15;
			}
			if ((_tmp_sAppr3 & 0x000F) == 0)
				 iArmArmorIndex = -1;
			else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15;
			if ((_tmp_sAppr3 & 0x0F00) == 0)
				 iPantsIndex = -1;
			else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15;
			if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
				 iBootsIndex = -1;
			else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15;
			if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
				iWeaponIndex = -1;
			else iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*0 + (_tmp_cDir - 1);
			if ((_tmp_sAppr2 & 0x000F) == 0)
				iShieldIndex = -1;
			else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F)*8 + 0;
			if ((_tmp_sAppr4 & 0x0F00) == 0)
				 iMantleIndex = -1;
			else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15;
			if ((_tmp_sAppr3 & 0x00F0) == 0)
				 iHelmIndex = -1;
			else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 0;
		}
		break;
	default:
		// polymorph bug (OnStop)
		BOOL bIsPlayer = (_tmp_wObjectID < 10000); 
		if (_tmp_sAppr2 != 0 && !bIsPlayer)
		{	 iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (4 * 8);
			 _tmp_cFrame = (_tmp_sAppr2 & 0x00FF ) -1;
		}
	/*	else if (_tmp_sOwnerType == 66) iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		else if (_tmp_sOwnerType == 73) iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		else if (_tmp_sOwnerType == 81) iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);*/
		else iBodyIndex =  DEF_SPRID_MOB  +  (_tmp_sOwnerType - 10 )*8*7 + (0 * 8);
		iUndiesIndex    = -1;
		iHairIndex      = -1;
		iBodyArmorIndex = -1;
		iArmArmorIndex  = -1;
		iBootsIndex     = -1;
		iPantsIndex     = -1;
		iWeaponIndex    = -1;
		iShieldIndex    = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}
	if (m_bIsCrusadeMode || m_bIsAvatarMode) DrawObjectFOE(sX, sY, _tmp_cFrame);
	switch (_tmp_sOwnerType) { // hum? la lumiere en dessous ?
	case 15: // ShopKeeper
	case 19: // Gandalf
	case 20: // Howard
	case 24: // Tom
	case 25: // William
	case 26: // Kenedy
	case 51: // CP
	case 86: // HBT
	case 90: // Gail
	case 96:
	case 97:
	case 98:
	case 99: // Elementals
		m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
		break;
	}
	if (_tmp_iEffectType != 0)
	{	switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX, sY, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
	}	}
	if (bTrans == FALSE)
	{	CheckActiveAura(sX, sY, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{	if (iWeaponIndex != -1)
			{	if(bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX, sY, _tmp_cFrame, dwTime);
				else
				{	if (iWeaponColor == 0)
						 m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY,  _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}

			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
			case 66: // Wyvern
			case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				break;
			default:
				if (m_cDetailLevel != 0)
				{	if (sX < 50)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
				}
				break;
			}
			switch (_tmp_sOwnerType) { // Lumière en dessous
			case 35: // Energy Sphere
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				if (m_cDetailLevel != 0)
				{	m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
				}			
				break;
			default:
				break;
			}

			if (_tmp_sOwnerType == 81) // Abaddon
			{	m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);

			}else if (bInv == TRUE)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			else
			{	if ((_tmp_iStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);
			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0)) 
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (iUndiesIndex != -1)
			{	if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}	}

			if (iPantsIndex != -1)
			{	if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iPantsColor == 0)
						 m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}	}

			if (iArmArmorIndex != -1)
			{	if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iArmColor == 0)
						 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}	}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}	}

			if (iBodyArmorIndex != -1)
			{	if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iArmorColor == 0)
						 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}	}

			if (iHelmIndex != -1)
			{	if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
			{	m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
			}else
			if (iShieldIndex != -1)
			{	if(bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iShieldColor == 0)
						 m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

				}
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}
		}else
		{	switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
			case 66: // Wyvern
			case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				break;
			default:
				if (m_cDetailLevel != 0)
				{	if (sX < 50)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX, sY, _tmp_cFrame, dwTime);
				}
				break;
			}
			switch (_tmp_sOwnerType) { // Lumière en dessous
			case 35: // Energy Sphere
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				if (m_cDetailLevel != 0)
				{	m_pEffectSpr[0]->PutTransSprite(sX, sY, 1, dwTime);
				}			
				break;
			default:
				break;
			}
			if (_tmp_sOwnerType == 81) // Abaddon
			{	m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			}else if (bInv == TRUE)
			{	m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX, sY, _tmp_cFrame, dwTime);
			}else
			{	if ((_tmp_iStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 0))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (iUndiesIndex != -1)
			{	if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}	}

			if (iPantsIndex != -1)
			{	if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iPantsColor == 0)
						 m_pSprite[iPantsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}	}

			if (iArmArmorIndex != -1)
			{	if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iArmColor == 0)
						 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}	}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}	}

			if (iBodyArmorIndex != -1)
			{	if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iArmorColor == 0)
						 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}	}

			if (iHelmIndex != -1)
			{	if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 2))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
			{	m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
			}else
			if (iShieldIndex != -1)
			{	if(bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iShieldColor == 0)
						 m_pSprite[iShieldIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

				}
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13, sY -34, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrder[_tmp_cDir] == 1))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX, sY, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (iWeaponIndex != -1)
			{	if(bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX, sY, _tmp_cFrame, dwTime);
				else
				{	if (iWeaponColor == 0)
						 m_pSprite[iWeaponIndex]->PutSpriteFast(sX, sY, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX, sY, _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX, sY,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
		}	}	}
		if (_tmp_sOwnerType == 64) // crop
		{	switch( _tmp_cFrame ) {
			case 0: // color effect for crop
				m_pEffectSpr[84]->PutTransSprite(sX+52, sY+54, (dwTime%3000)/120, dwTime );
				break;
			case 1: // color effect for crop
				m_pEffectSpr[83]->PutTransSprite(sX+53, sY+59, (dwTime%3000)/120, dwTime );
				break;
			case 2: // color effect for crop
				m_pEffectSpr[82]->PutTransSprite(sX+53, sY+65, (dwTime%3000)/120, dwTime );
				break;
		}	}
		// Berserk
		if ((_tmp_iStatus & 0x20) != 0)
			m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSpriteRGB(sX, sY, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel(40+(_tmp_cDir - 1), sX+20, sY-20, _tmp_cFrame%4, dwTime);
		CheckActiveAura2(sX, sY, dwTime,  _tmp_sOwnerType);

	}else if( strlen(_tmp_cName) > 0 )
	{	if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX, sY, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX, sY, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != NULL)
	{	if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID)) {
			m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY;
		}else
		{	m_pMapData->ClearChatMsg(indexX, indexY);
	}	}
	// Snoopy: Abaddon effects
	int randFrame;
	switch (_tmp_sOwnerType) {
	case 81: // Abaddon effects	
		randFrame = _tmp_cFrame % 12;
		m_pEffectSpr[154]->PutTransSprite70(sX-50	, sY-50		, randFrame, dwTime);
		m_pEffectSpr[155]->PutTransSprite70(sX-20	, sY-80		, randFrame, dwTime);
		m_pEffectSpr[156]->PutTransSprite70(sX+70	, sY-50		, randFrame, dwTime);
		m_pEffectSpr[157]->PutTransSprite70(sX-30	, sY		, randFrame, dwTime);
		m_pEffectSpr[158]->PutTransSprite70(sX-60	, sY+90		, randFrame, dwTime);
		m_pEffectSpr[159]->PutTransSprite70(sX+65	, sY+85		, randFrame, dwTime);
		switch (_tmp_cDir) {
		case 1:
			m_pEffectSpr[153]->PutTransSprite70(sX		, sY+108 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-50	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 2:
			m_pEffectSpr[153]->PutTransSprite70(sX		, sY+95	, _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-70	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 3:
			m_pEffectSpr[153]->PutTransSprite70(sX		, sY+105 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-90	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 4:
			m_pEffectSpr[153]->PutTransSprite70(sX-35	, sY+100 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-80	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 5:
			m_pEffectSpr[153]->PutTransSprite70(sX		, sY+95	, _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-65	, sY-5	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 6:
			m_pEffectSpr[153]->PutTransSprite70(sX+45	, sY+95	, _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-31	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 7:
			m_pEffectSpr[153]->PutTransSprite70(sX+40	, sY+110 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-30	, sY+10	, _tmp_iEffectFrame %15, dwTime);
			break;
		case 8:
			m_pEffectSpr[153]->PutTransSprite70(sX+20	, sY+110 , _tmp_iEffectFrame %28, dwTime);
			m_pEffectSpr[164]->PutTransSprite70(sX-20	, sY+16	, _tmp_iEffectFrame %15, dwTime);
			break;
		}
		break;		
	case 36: // AGT
	case 37: // CGT
	case 38: // MS
	case 39: // DT
	case 40: // ESG
	case 41: // GMG
	case 42: // ManaStone
		// Reduce Sprite width to 40, and Height to 80
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom - 80;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left =
			(m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right + m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left)/2 - 20;
		m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right = m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left + 40;
		break;

	default:
		if (   (m_bIsGetPointingMode == TRUE) 
			&& (m_bCommandAvailable == TRUE)
			&& (_tmp_sOwnerType >=10)
			&& (m_bShiftPressed == TRUE)
			&& (m_iPointCommandType >= 100) && (m_iPointCommandType < 200) ) // spell
		{	return FALSE;
		}	
		break;
	}
	if ( (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top != -1) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top < msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom > msY) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left < msX) &&
		 (m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right > msX) ) return TRUE;
	return FALSE;
}

void CGame::_ReadMapData(short sPivotX, short sPivotY, char * pData)
{int i;
 char  * cp, ucHeader, cDir, cName[12], cItemColor;
 short * sp, sTotal, sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4, sItemSpr, sItemSprFrame, sDynamicObjectType;
 int iStatus;
 int   * ip, iApprColor;
 WORD    wObjectID;
 WORD  * wp, wDynamicObjectID;
	cp = pData;
	m_sVDL_X = sPivotX; // Valid Data Loc-X
	m_sVDL_Y = sPivotY;
	sp = (short *)cp;
	sTotal = *sp;
	cp += 2;
	for (i = 1;	i <= sTotal; i++)
	{	sp = (short *)cp;
		sX = *sp;
		cp += 2;
		sp = (short *)cp;
		sY = *sp;
		cp += 2;
		ucHeader = *cp;
		cp++;
		if (ucHeader & 0x01) // object ID
		{	wp  = (WORD *)cp;
			wObjectID = *wp;
			cp += 2;
			sp  = (short *)cp;
			sType = *sp;// object type
			cp += 2;
			// dir
			cDir = *cp;
			cp++;
			if (wObjectID < 10000)
			{	sp  = (short *)cp;
				sAppr1 = *sp;// Appearance1
				cp += 2;
				sp  = (short *)cp;
				sAppr2 = *sp;// Appearance2
				cp += 2;
				sp  = (short *)cp;
				sAppr3 = *sp;// Appearance3
				cp += 2;
				sp  = (short *)cp;
				sAppr4 = *sp;// Appearance4
				cp += 2;
				ip = (int *)cp;
				iApprColor = *ip;// v1.4 ApprColor
				cp += 4;
				// CLEROTH - CRASH BUG ( STATUS )
				// Status
				ip  = (int *)cp;
				iStatus = *ip;
				cp += 4;
				// Name
				ZeroMemory(cName, sizeof(cName));
				memcpy(cName, cp, 10);
				cp    += 10;
			}else // NPC
			{	sAppr1 = sAppr3 = sAppr4 = 0;
				sp  = (short *)cp;
				sAppr2 = *sp;// Appearance2
				cp += 2;
				// CLEROTH - CRASH BUG ( STATUS )
				// Status
				ip  = (int *)cp;
				iStatus = *ip;
				cp += 4;
				// Name
				ZeroMemory(cName, sizeof(cName));
				memcpy(cName, cp, 5);
				cp    += 5;
			}
			m_pMapData->bSetOwner(wObjectID, sPivotX + sX, sPivotY + sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, DEF_OBJECTSTOP, NULL, NULL, NULL);
		}
		if (ucHeader & 0x02) // object ID (Dead)
		{	wp  = (WORD *)cp;
			wObjectID = *wp;
			cp += 2;
			sp  = (short *)cp;
			sType = *sp;	// object type
			cp += 2;
			cDir = *cp;	// dir
			cp++;
			if (wObjectID < 10000)
			{	sp  = (short *)cp;
				sAppr1 = *sp;// Appearance1
				cp += 2;
				sp  = (short *)cp;
				sAppr2 = *sp;// Appearance2
				cp += 2;
				sp  = (short *)cp;
				sAppr3 = *sp;// Appearance3
				cp += 2;
				sp  = (short *)cp;
				sAppr4 = *sp;// Appearance4
				cp += 2;
				ip = (int *)cp;
				iApprColor = *ip;// v1.4 ApprColor
				cp += 4;
				// CLEROTH - CRASH BUG ( STATUS )
				// Status
				ip  = (int *)cp;
				iStatus = *ip;
				cp += 4;
				// Name
				ZeroMemory(cName, sizeof(cName));
				memcpy(cName, cp, 10);
				cp    += 10;
			}else 	// NPC
			{	sAppr1 = sAppr3 = sAppr4 = 0;
				sp  = (short *)cp;
				sAppr2 = *sp;// Appearance2
				cp += 2;
				ip  = (int *)cp;
				iStatus = *ip;// Status
				cp += 4;
				ZeroMemory(cName, sizeof(cName));	// Name
				memcpy(cName, cp, 5);
				cp    += 5;
			}
			m_pMapData->bSetDeadOwner(wObjectID, sPivotX + sX, sPivotY + sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName);
		}
		if (ucHeader & 0x04)
		{	sp  = (short *)cp;
			sItemSpr = *sp;
			cp += 2;
			sp  = (short *)cp;
			sItemSprFrame = *sp;
			cp += 2;
			cItemColor = *cp;
			cp++;
			m_pMapData->bSetItem(sPivotX + sX, sPivotY + sY, sItemSpr, sItemSprFrame, cItemColor, FALSE);
		}
		if (ucHeader & 0x08) // Dynamic object
		{	wp = (WORD *)cp;
			wDynamicObjectID = *wp;
			cp += 2;
			sp  = (short *)cp;
			sDynamicObjectType = *sp;
			cp += 2;
			m_pMapData->bSetDynamicObject(sPivotX + sX, sPivotY + sY, wDynamicObjectID, sDynamicObjectType, FALSE);
	}	}
}

void CGame::LogEventHandler(char * pData)
{WORD * wp, wEventType, wObjectID;
 short * sp, sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4;
 int iStatus;
 char  * cp, cDir, cName[12];
 int   * ip, iApprColor;
	wp   = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wEventType = *wp;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp  = (WORD *)cp;
	wObjectID  = *wp;
	cp += 2;
	sp  = (short *)cp;
	sX  = *sp;
	cp += 2;
	sp  = (short *)cp;
	sY  = *sp;
	cp += 2;
	sp  = (short *)cp;
	sType = *sp;
	cp += 2;
	cDir = *cp;
	cp++;
	ZeroMemory(cName, sizeof(cName));
	if (wObjectID < 10000)
	{	memcpy(cName, cp, 10);
		cp += 10;
		sp  = (short *)cp;
		sAppr1 = *sp;
		cp += 2;
		sp  = (short *)cp;
		sAppr2 = *sp;
		cp += 2;
		sp  = (short *)cp;
		sAppr3 = *sp;
		cp += 2;
		sp  = (short *)cp;
		sAppr4 = *sp;
		cp += 2;
		ip = (int *)cp;
		iApprColor = *ip;
		cp += 4;
		// CLEROTH - CRASH BUG ( STATUS )
		ip  = (int *)cp;
		iStatus = *ip;
		cp += 4;
	}else 	// NPC
	{	memcpy(cName, cp, 5);
		cp += 5;
		sAppr1 = sAppr3 = sAppr4 = 0;
		sp  = (short *)cp;
		sAppr2 = *sp;
		cp += 2;
		ip  = (int *)cp;
		iStatus = *ip;
		cp += 4;
	}

	switch (wEventType) {
	case DEF_MSGTYPE_CONFIRM:
		m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, DEF_OBJECTSTOP, NULL, NULL, NULL);
		switch (sType) {
		case 43: // LWB
		case 44: // GHK
		case 45: // GHKABS
		case 46: // TK
		case 47: // BG
			bAddNewEffect(64, (sX)*32 ,(sY)*32, NULL, NULL, 0);
			break;
		}
		break;

	case DEF_MSGTYPE_REJECT:
		m_pMapData->bSetOwner(wObjectID, -1, -1, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, DEF_OBJECTSTOP, NULL, NULL, NULL);
		break;
	}

	_RemoveChatMsgListByObjectID(wObjectID);
}

void CGame::OnLogSocketEvent(WPARAM wParam, LPARAM lParam)
{int iRet;
 char * pData;
 DWORD  dwMsgSize;
	if (m_pLSock == NULL) return;

	iRet = m_pLSock->iOnSocketEvent(wParam, lParam);
	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		ConnectionEstablishHandler(DEF_SERVERTYPE_LOG);
		break;

	case DEF_XSOCKEVENT_READCOMPLETE:
		pData = m_pLSock->pGetRcvDataPointer(&dwMsgSize);
		LogRecvMsgHandler(pData);
		m_dwTime = G_dwGlobalTime;
		break;

	case DEF_XSOCKEVENT_SOCKETCLOSED:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		delete m_pLSock;
		m_pLSock = NULL;
		break;

	case DEF_XSOCKEVENT_SOCKETERROR:
		ChangeGameMode(DEF_GAMEMODE_ONCONNECTIONLOST);
		delete m_pLSock;
		m_pLSock = NULL;
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		delete m_pLSock;
		m_pLSock = NULL;
		break;
	}
}

void CGame::LogResponseHandler(char * pData)
{
 WORD  * wp, wResponse;
 WORD wServerUpperVersion, wServerLowerVersion;
 DWORD * dwp;
 char  * cp, cCharName[12];
 int   * ip, i;

	dwp = (DWORD *)(pData);
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wResponse = *wp;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	switch (wResponse) {
	case DEF_LOGRESMSGTYPE_CHARACTERDELETED:
		cp = (pData + DEF_INDEX2_MSGTYPE + 2);
		//m_iAccountStatus = (int)*cp;
		cp++;
		m_iTotalChar = (int)*cp;
		cp++;
		for (i = 0; i < 4; i++)
		if (m_pCharList[i] != NULL)
		{	delete m_pCharList[i];
			m_pCharList[i] = NULL;
		}

		for (i = 0; i < m_iTotalChar; i++) {
			m_pCharList[i] = new class CCharInfo;
			memcpy(m_pCharList[i]->m_cName, cp, 10);
			cp += 10;
			if (*cp == 0)
			{	m_pCharList[i]->m_sSex = NULL; // Sex
				cp += 40;
			}else
			{	cp++;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr1 = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr2 = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr3 = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr4 = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sSex = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sSkinCol = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sLevel = *wp;
				cp += 2;
				dwp = (DWORD *)cp;
				m_pCharList[i]->m_iExp = *dwp;
				cp += 4;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sStr = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sVit = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sDex = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sInt = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sMag = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sChr = *wp;
				cp += 2;
				ip = (int *)cp; // v1.4
				m_pCharList[i]->m_iApprColor = *ip;
				cp += 4;
				wp = (WORD *)cp;
				m_pCharList[i]->m_iYear = (int)*wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_iMonth = (int)*wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_iDay = (int)*wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_iHour = (int)*wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_iMinute = (int)*wp;
				cp += 2;
				ZeroMemory(m_pCharList[i]->m_cMapName, sizeof(m_pCharList[i]->m_cMapName));
				memcpy(m_pCharList[i]->m_cMapName, cp, 10);
				cp += 10;
		}	}
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "3A");
		break;

	case DEF_LOGRESMSGTYPE_CONFIRM:
		cp = (pData + DEF_INDEX2_MSGTYPE + 2);
		wp = (WORD *)cp;
		wServerUpperVersion = *wp;
		cp += 2;
		wp = (WORD *)cp;
		wServerLowerVersion = *wp;
		cp += 2;
//		m_iAccountStatus = (int)*cp;
		cp++;
		wp = (WORD *)cp;
		m_iAccntYear = *wp;
		cp += 2;
		wp = (WORD *)cp;
		m_iAccntMonth = *wp;
		cp += 2;
		wp = (WORD *)cp;
		m_iAccntDay = *wp;
		cp += 2;
		wp = (WORD *)cp;
		m_iIpYear = *wp;
		cp += 2;
		wp = (WORD *)cp;
		m_iIpMonth = *wp;
		cp += 2;
		wp = (WORD *)cp;
		m_iIpDay = *wp;
		cp += 2;
		m_iTotalChar = (int)*cp;
		cp++;
		for (i = 0; i < 4; i++)
		if (m_pCharList[i] != NULL)
		{	delete m_pCharList[i];
			m_pCharList[i] = NULL;
		}

		for (i = 0; i < m_iTotalChar; i++)
		{	m_pCharList[i] = new class CCharInfo;
			memcpy(m_pCharList[i]->m_cName, cp, 10);
			cp += 10;
			if (*cp == 0)
			{	m_pCharList[i]->m_sSex = NULL;
				cp += 40;
			}else
			{	cp++;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr1 = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr2 = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr3 = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr4 = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sSex = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sSkinCol = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sLevel = *wp;
				cp += 2;
				dwp = (DWORD *)cp;
				m_pCharList[i]->m_iExp = *dwp;
				cp += 4;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sStr = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sVit = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sDex = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sInt = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sMag = *wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_sChr = *wp;
				cp += 2;
				ip = (int *)cp;
				m_pCharList[i]->m_iApprColor = *ip; // v1.4
				cp += 4;
				wp = (WORD *)cp;
				m_pCharList[i]->m_iYear = (int)*wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_iMonth = (int)*wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_iDay = (int)*wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_iHour = (int)*wp;
				cp += 2;
				wp = (WORD *)cp;
				m_pCharList[i]->m_iMinute = (int)*wp;
				cp += 2;
				ZeroMemory(m_pCharList[i]->m_cMapName, sizeof(m_pCharList[i]->m_cMapName));
				memcpy(m_pCharList[i]->m_cMapName, cp, 10);
				cp += 10;
		}	}
		ip = (int *)cp;
		m_iTimeLeftSecAccount = *ip;
		cp += 4;
		ip = (int *)cp;
		m_iTimeLeftSecIP = *ip;
		cp += 4;
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		ClearContents_OnSelectCharacter();

#ifndef _DEBUG
#ifndef DEF_ANTI_HACK
		if ( (wServerUpperVersion!=DEF_UPPERVERSION) || (wServerLowerVersion!=DEF_LOWERVERSION) )
			ChangeGameMode(DEF_GAMEMODE_ONVERSIONNOTMATCH);
#else
		if ( (wServerUpperVersion!=DEF_HIDDEN_UPPERVERSION) || (wServerLowerVersion!=DEF_HIDDEN_LOWERVERSION) )
			ChangeGameMode(DEF_GAMEMODE_ONVERSIONNOTMATCH);
#endif
#endif
		break;

	case DEF_LOGRESMSGTYPE_REJECT:
		cp = (pData + DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		m_iBlockYear = *ip;
		cp += 4;

		ip = (int *)cp;
		m_iBlockMonth = *ip;
		cp += 4;

		ip = (int *)cp;
		m_iBlockDay = *ip;
		cp += 4;

		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "7H");
		break;

	case DEF_LOGRESMSGTYPE_NOTENOUGHPOINT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "7I");
		break;

	case DEF_LOGRESMSGTYPE_ACCOUNTLOCKED:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "7K");
		break;

	case DEF_LOGRESMSGTYPE_SERVICENOTAVAILABLE:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "7L");
		break;

	case DEF_LOGRESMSGTYPE_PASSWORDCHANGESUCCESS:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "6B");
		break;

	case DEF_LOGRESMSGTYPE_PASSWORDCHANGEFAIL:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "6C");
		break;

	case DEF_LOGRESMSGTYPE_PASSWORDMISMATCH:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "11");
		break;

	case DEF_LOGRESMSGTYPE_NOTEXISTINGACCOUNT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "12");
		break;

	case DEF_LOGRESMSGTYPE_NEWACCOUNTCREATED:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "54");
		break;

	case DEF_LOGRESMSGTYPE_NEWACCOUNTFAILED:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "05");
		break;

	case DEF_LOGRESMSGTYPE_ALREADYEXISTINGACCOUNT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "06");
		break;

	case DEF_LOGRESMSGTYPE_NOTEXISTINGCHARACTER:
		ChangeGameMode(DEF_GAMEMODE_ONMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "Not existing character!");
		break;

	case DEF_LOGRESMSGTYPE_NEWCHARACTERCREATED:
		ZeroMemory(cCharName, sizeof(cCharName));
		memcpy(cCharName, cp, 10);
		cp += 10;

		m_iTotalChar = (int)*cp;
		cp++;

		for (i = 0; i < 4; i++)
		if (m_pCharList[i] != NULL) delete m_pCharList[i];
		//
		for (i = 0; i < m_iTotalChar; i++) {
			m_pCharList[i] = new class CCharInfo;
			memcpy(m_pCharList[i]->m_cName, cp, 10);
			cp += 10;
			if (*cp == 0) {
				m_pCharList[i]->m_sSex = NULL; // Sex
				cp += 40;
			}
			else {
				cp++;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr1 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr2 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr3 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sAppr4 = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sSex = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sSkinCol = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sLevel = *wp;
				cp += 2;

				dwp = (DWORD *)cp;
				m_pCharList[i]->m_iExp = *dwp;
				cp += 4;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sStr = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sVit = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sDex = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sInt = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sMag = *wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_sChr = *wp;
				cp += 2;

				ip = (int *)cp; // v1.4
				m_pCharList[i]->m_iApprColor = *ip;
				cp += 4;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iYear = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iMonth = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iDay = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iHour = (int)*wp;
				cp += 2;

				wp = (WORD *)cp;
				m_pCharList[i]->m_iMinute = (int)*wp;
				cp += 2;

				ZeroMemory(m_pCharList[i]->m_cMapName, sizeof(m_pCharList[i]->m_cMapName));
				memcpy(m_pCharList[i]->m_cMapName, cp, 10);
				cp += 10;
			}
		}
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "47");
		break;

	case DEF_LOGRESMSGTYPE_NEWCHARACTERFAILED:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "28");
		break;

	case DEF_LOGRESMSGTYPE_ALREADYEXISTINGCHARACTER:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "29");
		break;

	case DEF_ENTERGAMERESTYPE_PLAYING:
		ChangeGameMode(DEF_GAMEMODE_ONQUERYFORCELOGIN);
		break;

	case DEF_ENTERGAMERESTYPE_CONFIRM:
		{	int iGameServerPort;
			char cGameServerAddr[16];
			ZeroMemory(cGameServerAddr, sizeof(cGameServerAddr));
			cp = (pData + DEF_INDEX2_MSGTYPE + 2);
			memcpy(cGameServerAddr, cp, 16);
			cp += 16;
			wp = (WORD *)cp;
			iGameServerPort = *wp;
			cp += 2;
			ZeroMemory(m_cGameServerName, sizeof(m_cGameServerName));
			memcpy(m_cGameServerName, cp, 20);
			cp += 20;
			m_pGSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			if (m_iGameServerMode == 1)
			{	m_pGSock->bConnect(m_cLogServerAddr, iGameServerPort, WM_USER_GAMESOCKETEVENT);
			}else
			{	m_pGSock->bConnect(cGameServerAddr, iGameServerPort, WM_USER_GAMESOCKETEVENT);
			}
			m_pGSock->bInitBufferSize(30000);
		}
		break;

	case DEF_ENTERGAMERESTYPE_REJECT:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		switch (*cp) {
		case 1:	strcpy(m_cMsg, "3E"); break;
		case 2:	strcpy(m_cMsg, "3F"); break;
		case 3:	strcpy(m_cMsg, "33"); break;
		case 4: strcpy(m_cMsg, "3D"); break;
		case 5: strcpy(m_cMsg, "3G"); break;
		case 6: strcpy(m_cMsg, "3Z"); break;
		case 7: strcpy(m_cMsg, "3J"); break;
		}
		break;

	case DEF_ENTERGAMERESTYPE_FORCEDISCONN:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "3X");
		break;

	case DEF_LOGRESMSGTYPE_NOTEXISTINGWORLDSERVER:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "1Y");
		break;

	case DEF_LOGRESMSGTYPE_INPUTKEYCODE:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		switch (*cp) {
		case 1:	strcpy(m_cMsg, "8U"); break; //MainMenu, Keycode registration success
		case 2:	strcpy(m_cMsg, "82"); break; //MainMenu, Not existing Account
		case 3:	strcpy(m_cMsg, "81"); break; //MainMenu, Password wrong
		case 4: strcpy(m_cMsg, "8V"); break; //MainMenu, Invalid Keycode
		case 5: strcpy(m_cMsg, "8W"); break; //MainMenu, Already Used Keycode
		}
		break;


	case DEF_LOGRESMSGTYPE_FORCECHANGEPASSWORD:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "6M");
		break;

	case DEF_LOGRESMSGTYPE_INVALIDKOREANSSN:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "1a");
		break;

	case DEF_LOGRESMSGTYPE_LESSTHENFIFTEEN:
		ChangeGameMode(DEF_GAMEMODE_ONLOGRESMSG);
		ZeroMemory(m_cMsg, sizeof(m_cMsg));
		strcpy(m_cMsg, "1b");
		break;

	}
	delete m_pLSock;
	m_pLSock = NULL;
}

void CGame::LogRecvMsgHandler(char * pData)
{
	LogResponseHandler(pData);
}

void CGame::UpdateScreen_OnMsg()
{short msX, msY, msZ;
 char cLB, cRB;
 DWORD dwTime = G_dwGlobalTime;
	m_DDraw.ClearBackB4();
	PutString(10, 10, m_cMsg, RGB(255,155,155), FALSE, 1);
	DrawVersion();
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
	if ((G_dwGlobalTime - m_dwTime) > 1500)
	{	ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
	}
}

void CGame::_InitOnCreateNewCharacter()
{	m_cGender    = rand() % 2 + 1;
	m_cSkinCol   = rand() % 3 + 1;
	m_cHairStyle = rand() % 8;
	m_cHairCol   = rand() % 16;
	m_cUnderCol  = rand() % 8;
	m_ccStr = 10;
	m_ccVit = 10;
	m_ccDex = 10;
	m_ccInt = 10;
	m_ccMag = 10;
	m_ccChr = 10;
}

void CGame::ClearContents_OnCreateNewAccount()
{
	ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
	ZeroMemory(m_cAccountAge, sizeof(m_cAccountAge));
	ZeroMemory(m_cAccountCountry, sizeof(m_cAccountCountry));
	ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
	ZeroMemory(m_cEmailAddr, sizeof(m_cEmailAddr));
	//v1.4334
	ZeroMemory(m_cAccountQuiz, sizeof(m_cAccountQuiz));
	ZeroMemory(m_cAccountAnswer, sizeof(m_cAccountAnswer));
}

void CGame::ChangeGameMode(char cMode)
{
	m_cGameMode = cMode;
	m_cGameModeCount = 0;
	m_dwTime = G_dwGlobalTime;

#ifndef DEF_SELECTSERVER
	if( cMode == DEF_GAMEMODE_ONSELECTSERVER )
	{	ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
		strcpy(m_cWorldServerName, NAME_WORLDNAME1);
		m_cGameMode = DEF_GAMEMODE_ONLOGIN;
	}
#endif
}

BOOL CGame::bReadIp()
{	ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
	strcpy(m_cLogServerAddr, DEF_SERVER_IP);
	m_iLogServerPort = DEF_SERVER_PORT;
	return TRUE;
}

BOOL CGame::bReadLoginConfigFile(char * cFn)
{FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= ,\t\n";
 	cReadMode = 0;
	// Get file size only
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFn, "rt");
	if (pFile == NULL) goto DEFAULT_IP;
	cp = new char[dwFileSize+2];
	ZeroMemory(cp, dwFileSize+2);
	fread(cp, dwFileSize, 1, pFile);
	token = strtok( cp, seps );
	while( token != NULL )
	{	if (cReadMode != 0)
		{	switch (cReadMode) {
			case 1: // log-server-address
				if (strlen(token) > 15)
				{	delete[] cp;
					if (pFile != NULL) fclose(pFile);
					goto DEFAULT_IP;
				}
				ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
				strcpy(m_cLogServerAddr, token);
				cReadMode = 0;
				break;
			case 2: // Main-log-server-port
				m_iLogServerPort = atoi(token);
				if (m_iLogServerPort == 0)
				{	delete[] cp;
					if (pFile != NULL) fclose(pFile);
					goto DEFAULT_IP;
				}
				cReadMode = 0;
				break;
			case 3: // game-server-mode
				if ((memcmp(token, "lan", 3) == 0) || (memcmp(token, "LAN", 3) == 0))
				{	m_iGameServerMode = 1;  // Will no connect multi-hoster HB
											// but will connect from LAN even with bad router
				}
				if ((memcmp(token, "internet", 8) == 0) || (memcmp(token, "INTERNET", 8) == 0))
				{	m_iGameServerMode = 2; // Default HB mode
				}
				cReadMode = 0;
				break;
			}
		}else
		{	if (memcmp(token, "log-server-address",18) == 0) cReadMode = 1;
			if (memcmp(token, "log-server-port",15) == 0)    cReadMode = 2;
			if (memcmp(token, "game-server-mode",16) == 0)   cReadMode = 3;
		}
		token = strtok( NULL, seps );
	}
	delete[] cp;
	if (pFile != NULL) fclose(pFile);
	return TRUE;
DEFAULT_IP:
	ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
	strcpy(m_cLogServerAddr, DEF_SERVER_IP);
	m_iLogServerPort = DEF_SERVER_PORT;
	return TRUE;
}

void CGame::ReleaseUnusedSprites()
{	int i;
	for (i = 0; i < DEF_MAXSPRITES; i++)
	if ((m_pSprite[i] != NULL))
	{	if( (m_pSprite[i]->m_bIsSurfaceEmpty == FALSE) && (m_pSprite[i]->m_bOnCriticalSection == FALSE) )
		{	if ((G_dwGlobalTime - m_pSprite[i]->m_dwRefTime) > 60000 ) m_pSprite[i]->_iCloseSprite();

	}	}
	for (i = 0; i < DEF_MAXTILES; i++)
	if ((m_pTileSpr[i] != NULL))
	{	if( (m_pTileSpr[i]->m_bIsSurfaceEmpty == FALSE) && (m_pTileSpr[i]->m_bOnCriticalSection == FALSE) )
		{	if ((G_dwGlobalTime - m_pTileSpr[i]->m_dwRefTime) > 60000 ) m_pTileSpr[i]->_iCloseSprite();
	}	}
	for (i = 0; i < DEF_MAXEFFECTSPR; i++)
	if ((m_pEffectSpr[i] != NULL))
	{	if( (m_pEffectSpr[i]->m_bIsSurfaceEmpty == FALSE) && (m_pEffectSpr[i]->m_bOnCriticalSection == FALSE) )
		{	if ((G_dwGlobalTime - m_pEffectSpr[i]->m_dwRefTime) > 60000 ) m_pEffectSpr[i]->_iCloseSprite();
	}	}

	for (i = 0; i < DEF_MAXSOUNDEFFECTS; i++)
	{	if (m_pCSound[i] != NULL)
		{	if (((G_dwGlobalTime - m_pCSound[i]->m_dwTime) > 30000) && (m_pCSound[i]->m_bIsLooping == FALSE)) m_pCSound[i]->_ReleaseSoundBuffer();
		}
		if (m_pMSound[i] != NULL)
		{	if (((G_dwGlobalTime - m_pMSound[i]->m_dwTime) > 30000) && (m_pMSound[i]->m_bIsLooping == FALSE)) m_pMSound[i]->_ReleaseSoundBuffer();
		}
		if (m_pESound[i] != NULL)
		{	if (((G_dwGlobalTime - m_pESound[i]->m_dwTime) > 30000) && (m_pESound[i]->m_bIsLooping == FALSE)) m_pESound[i]->_ReleaseSoundBuffer();
	}	}
}

void CGame::PutChatScrollList(char * pMsg, char cType)
{int i;
	if (m_pChatScrollList[DEF_MAXCHATSCROLLMSGS - 1] != NULL)
	{	delete m_pChatScrollList[DEF_MAXCHATSCROLLMSGS - 1];
		m_pChatScrollList[DEF_MAXCHATSCROLLMSGS - 1] = NULL;
	}
	for (i = DEF_MAXCHATSCROLLMSGS - 2; i >= 0; i--)
	{	m_pChatScrollList[i+1] = m_pChatScrollList[i];
		m_pChatScrollList[i] = NULL;
	}
	m_pChatScrollList[0] = new class CMsg(1, pMsg, cType);
}

void CGame::ChatMsgHandler(char * pData)
{
 int i, iObjectID, iLoc;
 short * sp, sX, sY;
 char * cp, cMsgType, cName[21], cTemp[100], cMsg[100], cTxt1[100], cTxt2[100];
 DWORD dwTime;
 WORD * wp;
 BOOL bFlag;

 char cHeadMsg[200];

	dwTime = m_dwCurTime;

	ZeroMemory(cTxt1, sizeof(cTxt1));
	ZeroMemory(cTxt2, sizeof(cTxt2));
	ZeroMemory(cMsg, sizeof(cMsg));

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	iObjectID = (int)*wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, (char *)cp, 10);
	cp += 10;

	cMsgType = *cp;
	cp++;

	if (bCheckExID(cName) == TRUE) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	strcpy(cTemp, cp);

	if( (cMsgType==0) || (cMsgType==2) || (cMsgType==3) )
	{	if( m_Misc.bCheckIMEString(cTemp)==FALSE ) return;
	}
	if( !m_bWhisper )
	{	if( cMsgType == 20 ) return;
	}
	if( !m_bShout )
	{	if( cMsgType == 2 || cMsgType == 3 ) return;
	}

	ZeroMemory(cMsg, sizeof(cMsg));
	wsprintf(cMsg, "%s: %s", cName, cTemp);
	m_DDraw._GetBackBufferDC();
	bFlag = FALSE;
	short sCheckByte = 0;
	while (bFlag == FALSE)
	{	iLoc = m_Misc.iGetTextLengthLoc(m_DDraw.m_hDC, cMsg, 305);
		for( int i=0 ; i<iLoc ; i++ ) if( cMsg[i] < 0 ) sCheckByte ++;
		if (iLoc == 0)
		{	PutChatScrollList(cMsg, cMsgType);
			bFlag = TRUE;
		}else
		{	if ((sCheckByte%2)==0)
			{	ZeroMemory(cTemp, sizeof(cTemp));
				memcpy(cTemp, cMsg, iLoc);
				PutChatScrollList(cTemp, cMsgType);
				ZeroMemory(cTemp, sizeof(cTemp));
				strcpy(cTemp, cMsg +iLoc );
				ZeroMemory(cMsg, sizeof(cMsg));
				strcpy(cMsg, " ");
				strcat(cMsg, cTemp);
			}else
			{	ZeroMemory(cTemp, sizeof(cTemp));
				memcpy(cTemp, cMsg, iLoc+1);
				PutChatScrollList(cTemp, cMsgType);
				ZeroMemory(cTemp, sizeof(cTemp));
				strcpy(cTemp, cMsg +iLoc+1);
				ZeroMemory(cMsg, sizeof(cMsg));
				strcpy(cMsg, " ");
				strcat(cMsg, cTemp);
	}	}	}

	m_DDraw._ReleaseBackBufferDC();

	_RemoveChatMsgListByObjectID(iObjectID);

	for (i = 1; i < DEF_MAXCHATMSGS; i++)
	if (m_pChatMsgList[i] == NULL) {
		m_pChatMsgList[i] = new class CMsg(1, (char *)(cp), dwTime);
		m_pChatMsgList[i]->m_iObjectID = iObjectID;

		if (m_pMapData->bSetChatMsgOwner(iObjectID, sX, sY, i) == FALSE) {
			delete m_pChatMsgList[i];
			m_pChatMsgList[i] = NULL;
		}

		if ( (cMsgType != 0) && (m_bIsDialogEnabled[10] != TRUE) ) {
			ZeroMemory(cHeadMsg, sizeof(cHeadMsg));
			wsprintf(cHeadMsg, "%s:%s", cName, cp);
			AddEventList(cHeadMsg, cMsgType);
		}
		return;
	}
}

void CGame::ReleaseTimeoverChatMsg()
{int i;
 DWORD dwTime;
	dwTime = G_dwGlobalTime;
	for ( i = 1; i < DEF_MAXCHATMSGS; i++)
	if (m_pChatMsgList[i] != NULL) {

		if ((m_pChatMsgList[i]->m_cType >= 1) && (m_pChatMsgList[i]->m_cType <= 20)) {
			if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_A) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
		}
		else
		if ((m_pChatMsgList[i]->m_cType >= 21) && (m_pChatMsgList[i]->m_cType <= 40)) {
			if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_B) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
		}
		else
		if ((m_pChatMsgList[i]->m_cType >= 41) && (m_pChatMsgList[i]->m_cType <= 60)) {
			if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_C) {
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
		}
		else if ((dwTime - m_pChatMsgList[i]->m_dwTime) > DEF_CHATTIMEOUT_A) {
			delete m_pChatMsgList[i];
			m_pChatMsgList[i] = NULL;
		}
	}
}

void CGame::DrawBackground(short sDivX, short sModX, short sDivY, short sModY)
{
 int indexX, indexY, ix, iy;
 short sSpr, sSprFrame;
 	if (sDivX < 0 || sDivY < 0) return ;
	if ((m_bIsRedrawPDBGS == TRUE) || (m_iPDBGSdivX != sDivX) || (m_iPDBGSdivY != sDivY)) {
		// Pre-Draw Background Surface
		m_bIsRedrawPDBGS = FALSE;
		m_iPDBGSdivX = sDivX;
		m_iPDBGSdivY = sDivY;
		SetRect(&m_DDraw.m_rcClipArea, 0,0, 640+32, 480+32);
		indexY = sDivY+m_pMapData->m_sPivotY;
		for (iy = -sModY; iy < 427+48 ; iy += 32)
		{
			indexX = sDivX+m_pMapData->m_sPivotX;
			for (ix = -sModX; ix < 640+48 ; ix += 32)
			{	sSpr      = m_pMapData->m_tile[indexX][indexY].m_sTileSprite;
				sSprFrame = m_pMapData->m_tile[indexX][indexY].m_sTileSpriteFrame;
				m_pTileSpr[sSpr]->PutSpriteFastNoColorKeyDst(m_DDraw.m_lpPDBGS, ix - 16 +sModX, iy - 16 +sModY, sSprFrame, m_dwCurTime);
				indexX++;
			}
			indexY++;
		}
		SetRect(&m_DDraw.m_rcClipArea, 0,0, 640, 480);
	}
	RECT rcRect;
	SetRect(&rcRect, sModX, sModY, 640+sModX, 480+sModY); // our fictitious sprite bitmap is
	m_DDraw.m_lpBackB4->BltFast( 0, 0, m_DDraw.m_lpPDBGS, &rcRect, DDBLTFAST_NOCOLORKEY | DDBLTFAST_WAIT);
	if( m_bIsCrusadeMode )
	{	if(m_iConstructLocX != -1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, m_iConstructLocX*32 - m_sViewPointX, m_iConstructLocY*32 - m_sViewPointY, 41);
		if( m_iTeleportLocX != -1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, m_iTeleportLocX*32 - m_sViewPointX, m_iTeleportLocY*32 - m_sViewPointY, 42);
	}
}


BOOL CGame::bEffectFrameCounter()
{int i, x;
 DWORD dwTime;
 BOOL bRet = FALSE;
 short sAbsX, sAbsY, sDist;
 char  cDir;
 long lPan;
	dwTime = m_dwCurTime;
	dwTime += m_pMapData->m_dwFrameAdjustTime;
	for (i = 0; i < DEF_MAXEFFECTS; i++)
	if (m_pEffectList[i] != NULL) {
		if ((dwTime - m_pEffectList[i]->m_dwTime) > m_pEffectList[i]->m_dwFrameTime)
		{	m_pEffectList[i]->m_dwTime = dwTime;
			m_pEffectList[i]->m_cFrame++;
			bRet = TRUE;
			m_pEffectList[i]->m_mX2 = m_pEffectList[i]->m_mX;
			m_pEffectList[i]->m_mY2 = m_pEffectList[i]->m_mY;
			switch (m_pEffectList[i]->m_sType) {
			case 1: // coup normal
				if (m_pEffectList[i]->m_cFrame == 1)
				{	for (int j = 1; j <= m_pEffectList[i]->m_iV1; j++) bAddNewEffect(11, m_pEffectList[i]->m_mX + 15 - (rand() % 30), m_pEffectList[i]->m_mY + 15 - (rand() % 30), NULL, NULL, -1*(rand() % 2));
				}
				if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 2:	// (Arrow missing target ?)
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY,
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32 - 40,
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
								&m_pEffectList[i]->m_iErr, 70);
				if (   (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2)
					&& (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY*32 - 40)) <= 2) )
				{	//bAddNewEffect(14, m_pEffectList[i]->m_mX +(rand() % 5) - 2, m_pEffectList[i]->m_mY +(rand() % 5) - 2, NULL, NULL, 0, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 4: // Gold Drop ,33,69,70
			case 33: //
			case 69:
			case 70:
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 5:
			case 30:
			case 31: // Fire Explosion
			case 252:
				if (m_pEffectList[i]->m_cFrame == 1)
				{	bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
				}
				if (m_pEffectList[i]->m_cFrame == 7)
				{	bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, NULL, NULL);
					bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, NULL, NULL);
					bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, NULL, NULL);
				}
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 6: // Lightning Bolt Burst
				if (m_pEffectList[i]->m_cFrame == 1)
				{	bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
				}
				if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 7: // Magic Missile Burst
				if (m_pEffectList[i]->m_cFrame == 1)
				{	bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
				}
				if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 9:  // Burst Type 2
			case 11: // Burst Type 3
				m_pEffectList[i]->m_mX += m_pEffectList[i]->m_rX;
				m_pEffectList[i]->m_mY += m_pEffectList[i]->m_rY;
				m_pEffectList[i]->m_rY++;
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 10: // Lightning Arrow Burst
				if (m_pEffectList[i]->m_cFrame == 1)
				{	bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
				}
				if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 12: // Burst Type 4
				m_pEffectList[i]->m_mX += m_pEffectList[i]->m_rX;
				m_pEffectList[i]->m_mY += m_pEffectList[i]->m_rY;
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 13: // Bulles druncncity
				if (m_pEffectList[i]->m_cFrame < 15)
				{	if ((rand() % 2) == 0)
						 m_pEffectList[i]->m_mX++;
					else m_pEffectList[i]->m_mX--;
					m_pEffectList[i]->m_mY--;
				}
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 16: //
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY,
					            m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY,
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
								&m_pEffectList[i]->m_iErr, 40);
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				if (   (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX) <= 2)
					&& (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY)) <= 2))
				{	bAddNewEffect(18, m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, NULL, NULL, 0); // testcode 0111 18
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), NULL, NULL, -1*(rand() % 2));
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 17: // Ice-Storm
				cDir = m_Misc.cGetNextMoveDir(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, m_pEffectList[i]->m_mX3, m_pEffectList[i]->m_mY3);
				switch (cDir) {
				case 1:
					m_pEffectList[i]->m_rY -= 2;
					break;
				case 2:
					m_pEffectList[i]->m_rY -= 2;
					m_pEffectList[i]->m_rX += 2;
					break;
				case 3:
					m_pEffectList[i]->m_rX += 2;
					break;
				case 4:
					m_pEffectList[i]->m_rX += 2;
					m_pEffectList[i]->m_rY += 2;
					break;
				case 5:
					m_pEffectList[i]->m_rY += 2;
					break;
				case 6:
					m_pEffectList[i]->m_rX -= 2;
					m_pEffectList[i]->m_rY += 2;
					break;
				case 7:
					m_pEffectList[i]->m_rX -= 2;
					break;
				case 8:
					m_pEffectList[i]->m_rX -= 2;
					m_pEffectList[i]->m_rY -= 2;
					break;
				}
				if (m_pEffectList[i]->m_rX < -10) m_pEffectList[i]->m_rX = -10;
				if (m_pEffectList[i]->m_rX >  10) m_pEffectList[i]->m_rX =  10;
				if (m_pEffectList[i]->m_rY < -10) m_pEffectList[i]->m_rY = -10;
				if (m_pEffectList[i]->m_rY >  10) m_pEffectList[i]->m_rY =  10;
				m_pEffectList[i]->m_mX += m_pEffectList[i]->m_rX;
				m_pEffectList[i]->m_mY += m_pEffectList[i]->m_rY;
				m_pEffectList[i]->m_mY3--;
				if (m_pEffectList[i]->m_cFrame > 10)
				{	m_pEffectList[i]->m_cFrame = 0;
					if (abs(m_pEffectList[i]->m_sY - m_pEffectList[i]->m_mY3) > 100)
					{	delete m_pEffectList[i];
						m_pEffectList[i] = NULL;
				}	}
				break;

			case 20: // Critical strike with a weapon
			case 21:
			case 22:
			case 23:
			case 24:
			case 25:
			case 26:
			case 27: // Critical strike with a weapon
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY,
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32 - 40,
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
								&m_pEffectList[i]->m_iErr, 50);
				bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), NULL, NULL, 0);//-1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), NULL, NULL, 0);//-1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), NULL, NULL, 0);//-1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), NULL, NULL, 0);//-1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), NULL, NULL, 0);//-1*(rand() % 4));
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY*32 - 40)) <= 2) )
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 34: //
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY,
					            m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY,
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
								&m_pEffectList[i]->m_iErr, 50);
				bAddNewEffect(33, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, NULL, NULL, -1*(rand() % 4));
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY)) <= 2) )
				{	bAddNewEffect(33, m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, NULL, NULL, 0); //7
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;


			case 40:
			case 56:
				if (m_pEffectList[i]->m_cFrame == 9)
				{	bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 100)-50), m_pEffectList[i]->m_mY +((rand() % 70)-35), NULL, NULL, 0, 0);
					bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 100)-50), m_pEffectList[i]->m_mY +((rand() % 70)-35), NULL, NULL, 0, 0);
					bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 100)-50), m_pEffectList[i]->m_mY +((rand() % 70)-35), NULL, NULL, 0, 0);
					bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 100)-50), m_pEffectList[i]->m_mY +((rand() % 70)-35), NULL, NULL, 0, 0);
					bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 100)-50), m_pEffectList[i]->m_mY +((rand() % 70)-35), NULL, NULL, 0, 0);
				}
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 41: //Large Type 1, 2, 3, 4
			case 42:
			case 43:
			case 44:
			case 45: // Small Type 1, 2
			case 46:
				if (m_pEffectList[i]->m_cFrame >= 7)
				{	m_pEffectList[i]->m_mX--;
					m_pEffectList[i]->m_mY += m_pEffectList[i]->m_iV1;
					m_pEffectList[i]->m_iV1++;
				}

				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	if ((m_pEffectList[i]->m_sType != 45) && (m_pEffectList[i]->m_sType != 46))
					{	bAddNewEffect(50, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0);
						bAddNewEffect(14, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
						bAddNewEffect(14, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
						bAddNewEffect(14, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
						bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
						bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
					}
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 47: // Blizzard
			case 48:
			case 49:
				if (m_pEffectList[i]->m_cFrame >= 7)
				{	m_pEffectList[i]->m_mX--;
					m_pEffectList[i]->m_mY += m_pEffectList[i]->m_iV1;
					m_pEffectList[i]->m_iV1 += 4;
				}
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	if (m_pEffectList[i]->m_sType == 49)
						 bAddNewEffect(72, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0);
					else bAddNewEffect(50, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0);
					bAddNewEffect(14, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
					bAddNewEffect(14, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
					bAddNewEffect(14, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);

					bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
					bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 60: //
			case 181: // Meteor-Strike
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	bAddNewEffect(61, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0, 0);
					bAddNewEffect(63, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0, 0);
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else if (m_pEffectList[i]->m_cFrame >= 0)
				{	m_pEffectList[i]->m_mX -= 30;
					m_pEffectList[i]->m_mY += 46;
					bAddNewEffect(62, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0, 0);
				}
				break;

			case 62:
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else if (m_pEffectList[i]->m_cFrame >= 0)
				{	m_pEffectList[i]->m_mX += (rand() % 3) -1;
					m_pEffectList[i]->m_mY += (rand() % 3) -1;
				}
				break;

			case 65: // Building fire after MS (crusade) 65 & 67
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else if (m_pEffectList[i]->m_cFrame >= 0)
				{	m_pEffectList[i]->m_mX += (rand() % 3) -1;
					m_pEffectList[i]->m_mY -= 4 +(rand() % 2);
				}
				break;

			case 66:
			case 203:
			case 204:
			case 205:
			case 206:
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 68:
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else if (m_pEffectList[i]->m_cFrame == 11)
				{	SetCameraShakingEffect(m_pEffectList[i]->m_iV1, 2);
				}
				break;

			case 71:
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY,
					            m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY,
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
								&m_pEffectList[i]->m_iErr, 50);
				bAddNewEffect(48, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, NULL, NULL, 0);
				bAddNewEffect(51, m_pEffectList[i]->m_mX +((rand() % 20)-10), m_pEffectList[i]->m_mY +((rand() % 20)-10), NULL, NULL, 0, 0);
				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY)) <= 2) )
				{	bAddNewEffect(49, m_pEffectList[i]->m_mX/* + (rand() % 30) - 15*/, m_pEffectList[i]->m_mY/* + (rand() % 30) - 15*/, NULL, NULL, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 81: // Snoopy: Ajout StromBlade
				m_Misc.GetPoint(m_pEffectList[i]->m_mX
					, m_pEffectList[i]->m_mY
					, m_pEffectList[i]->m_dX*32
					, m_pEffectList[i]->m_dY*32
					, &m_pEffectList[i]->m_mX
					, &m_pEffectList[i]->m_mY
					, &m_pEffectList[i]->m_iErr
					, 10);
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 85: //	Fire explosion from the ground (effect14.pak)	
				if (m_pEffectList[i]->m_cFrame == 5) 
				{	bAddNewEffect(65, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY  - (rand() % 30), NULL, NULL, -1*(rand() % 2));
				}else if (m_pEffectList[i]->m_cFrame == 11) 
				{	bAddNewEffect(65, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY - (rand() % 30), NULL, NULL, -1*(rand() % 2));
				}else
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

#ifdef DEF_EQUILIBRIUM_PROJECT
		case 109: // EP's Crystal axe hit
#endif
			case 100: // Magic Missile
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY,
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/,
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
								&m_pEffectList[i]->m_iErr, 50);
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));

				if ( (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2) &&
					 (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY*32/* - 40*/)) <= 2) )
				{	bAddNewEffect(7, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 110: // Enegy-Bolt
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY,
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/,
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
								&m_pEffectList[i]->m_iErr, 50);
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				if (    (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2)
					 && (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY*32) <= 2) )
				{	bAddNewEffect(6, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0); // 6 testcode 0111
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 120: // Fire Ball
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY,
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/,
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
								&m_pEffectList[i]->m_iErr, 50);
				if (    (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2)
					 && (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY*32) <= 2) )
				{	bAddNewEffect(5, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 130: // Fire Strike
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY,
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/,
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
								&m_pEffectList[i]->m_iErr, 50);
				if (    (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2)
					 && (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY*32) <= 2) )
				{	bAddNewEffect(5, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
					bAddNewEffect(5, m_pEffectList[i]->m_dX*32 -30, m_pEffectList[i]->m_dY*32 -15, NULL, NULL, -7);
					bAddNewEffect(5, m_pEffectList[i]->m_dX*32 +35, m_pEffectList[i]->m_dY*32 -30, NULL, NULL, -5);
					bAddNewEffect(5, m_pEffectList[i]->m_dX*32 +20, m_pEffectList[i]->m_dY*32 +30, NULL, NULL, -3);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 137: // Lightning Arrow
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY,
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/,
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
								&m_pEffectList[i]->m_iErr, 50);
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				if (   (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2)
					&& (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY*32) <= 2) )
				{	bAddNewEffect(10, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 143: // Lightning
			case 151: // Lightning-Bolt
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	bAddNewEffect(10, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else
				{	m_pEffectList[i]->m_rX = 5 - (rand() % 10);
					m_pEffectList[i]->m_rY = 5 - (rand() % 10);
				}
				break;

			case 145: // Chill-Wind
				bAddNewEffect(40, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
				bAddNewEffect(40, m_pEffectList[i]->m_dX*32 -30, m_pEffectList[i]->m_dY*32 -15, NULL, NULL, -10);
				bAddNewEffect(40, m_pEffectList[i]->m_dX*32 +35, m_pEffectList[i]->m_dY*32 -30, NULL, NULL, -6);
				bAddNewEffect(40, m_pEffectList[i]->m_dX*32 +20, m_pEffectList[i]->m_dY*32 +30, NULL, NULL, -3);
				delete m_pEffectList[i];
				m_pEffectList[i] = NULL;
				break;

			case 147:  // Triple-Energy-Bolt
				bAddNewEffect(110, m_pEffectList[i]->m_sX , m_pEffectList[i]->m_sY ,
						               m_pEffectList[i]->m_dX -1, m_pEffectList[i]->m_dY-1, 0);
				bAddNewEffect(110, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						               m_pEffectList[i]->m_dX +1, m_pEffectList[i]->m_dY -1, 0);
				bAddNewEffect(110, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						               m_pEffectList[i]->m_dX +1, m_pEffectList[i]->m_dY +1, 0);
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX)*1000;
				PlaySound('E', 1, sDist, lPan);
				bAddNewEffect(7, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
				delete m_pEffectList[i];
				m_pEffectList[i] = NULL;
				break ;

			case 156: // Mass-Lightning-Arrow
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else
				{	bAddNewEffect(137, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						               m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, 0);
					sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX)*1000;
					PlaySound('E', 1, sDist, lPan);
				}
				break;

			case 157: // Ice-Strike
				bAddNewEffect(41, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0, 0);
				for (x = 0; x < 14; x++)
				{	bAddNewEffect(41 + (rand() % 3), m_pEffectList[i]->m_dX*32 +(rand() % 100) - 50 +10, m_pEffectList[i]->m_dY*32 + (rand() % 90) - 45, NULL, NULL, -1*x-1, 0);
				}
				for (x = 0; x < 6; x++)
				{	bAddNewEffect(45 + (rand() % 2), m_pEffectList[i]->m_dX*32 +(rand() % 100) - 50 +10, m_pEffectList[i]->m_dY*32 + (rand() % 90) - 45, NULL, NULL, -1*x-1 -10, 0);
				}
				delete m_pEffectList[i];
				m_pEffectList[i] = NULL;
				break;

			case 160: // Energy-Strike
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else
				{	bAddNewEffect(16, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						          m_pEffectList[i]->m_dX*32 + 50 - (rand() % 100), m_pEffectList[i]->m_dY*32 + 50 - (rand() % 100), 0);
					sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					PlaySound('E', 1, sDist, lPan);
				}
				break;

#ifdef DEF_EQUILIBRIUM_PROJECT
			case 178: // Divine revenge
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY,
						m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/,
						&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
						&m_pEffectList[i]->m_iErr, 50);
				if (    (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2)
					 && (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY*32) <= 2) )
				{	bAddNewEffect(85, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 106: // Forge's Breath
#endif
			case 161: // Mass-Fire-Strike
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY,
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/,
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
								&m_pEffectList[i]->m_iErr, 50);
				if (    (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2)
					 && (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY*32) <= 2) )
				{	bAddNewEffect(30, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
					bAddNewEffect(31, m_pEffectList[i]->m_dX*32 -30, m_pEffectList[i]->m_dY*32 -15, NULL, NULL, -7);
					bAddNewEffect(31, m_pEffectList[i]->m_dX*32 +35, m_pEffectList[i]->m_dY*32 -30, NULL, NULL, -5);
					bAddNewEffect(31, m_pEffectList[i]->m_dX*32 +20, m_pEffectList[i]->m_dY*32 +30, NULL, NULL, -3);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 163: // Mass-Chill-Wind Chill-Wind
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 -30, m_pEffectList[i]->m_dY*32 -15, NULL, NULL, -10);
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 +35, m_pEffectList[i]->m_dY*32 -30, NULL, NULL, -6);
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 +20, m_pEffectList[i]->m_dY*32 +30, NULL, NULL, -3);
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 +(rand()%100)-50, m_pEffectList[i]->m_dY*32 +(rand()%70)-35, NULL, NULL, -1*(rand()%10));
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 +(rand()%100)-50, m_pEffectList[i]->m_dY*32 +(rand()%70)-35, NULL, NULL, -1*(rand()%10));
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 +(rand()%100)-50, m_pEffectList[i]->m_dY*32 +(rand()%70)-35, NULL, NULL, -1*(rand()%10));
				bAddNewEffect(56, m_pEffectList[i]->m_dX*32 +(rand()%100)-50, m_pEffectList[i]->m_dY*32 +(rand()%70)-35, NULL, NULL, -1*(rand()%10));
				delete m_pEffectList[i];
				m_pEffectList[i] = NULL;
				break;

			case 164: // worm-bite
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	bAddNewEffect(68, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0); // testcode 0111 18
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 170: // Bloody-Shock-Wave
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else if ((m_pEffectList[i]->m_cFrame % 2) == 0)
				{	bAddNewEffect(34, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						          m_pEffectList[i]->m_dX*32 + 30 - (rand() % 60), m_pEffectList[i]->m_dY*32 + 30 - (rand() % 60), 0);
					sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					PlaySound('E', 1, sDist, lPan);
				}
				break;

			case 172: // Mass-Ice-Strike
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0, 0);
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3), 0);
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3), 0);
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3), 0);
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3), 0);
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3), 0);
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3), 0);
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3), 0);
				bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3), 0);
				for (x = 0; x < 16; x++)
				{	bAddNewEffect(44, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*x-1, 0);
				}
				for (x = 0; x < 8; x++)
				{	bAddNewEffect(45 + (rand() % 2), m_pEffectList[i]->m_dX*32 +(rand() % 100) - 50 +10, m_pEffectList[i]->m_dY*32 + (rand() % 90) - 45, NULL, NULL, -1*x-1 -10, 0);
				}
				delete m_pEffectList[i];
				m_pEffectList[i] = NULL;
				break;

#ifdef DEF_EQUILIBRIUM_PROJECT
			case 193: // Mass Lightning-Strike	// Doublé et élargi l'effêt
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else
				{	bAddNewEffect(151, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						          m_pEffectList[i]->m_dX +(rand()%5) -1, m_pEffectList[i]->m_dY +(rand()%5) -1, 0);
					bAddNewEffect(151, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						          m_pEffectList[i]->m_dX +(rand()%5) -1, m_pEffectList[i]->m_dY +(rand()%5) -1, 0);
					sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					PlaySound('E', 1, sDist/2, lPan);
				}
				break;
#endif
			case 174: // Lightning-Strike
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else
				{	bAddNewEffect(151, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						          m_pEffectList[i]->m_dX +(rand()%3) -1, m_pEffectList[i]->m_dY +(rand()%3) -1, 0);
					sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					PlaySound('E', 1, sDist, lPan);
				}
				break;

#ifndef DEF_EQUILIBRIUM_PROJECT
			case 182: // Mass-Magic-Missile
				m_Misc.GetPoint(m_pEffectList[i]->m_mX
					, m_pEffectList[i]->m_mY
					, m_pEffectList[i]->m_dX*32
					, m_pEffectList[i]->m_dY*32
					, &m_pEffectList[i]->m_mX
					, &m_pEffectList[i]->m_mY
					, &m_pEffectList[i]->m_iErr
					, 50);
				bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, -1*(rand() % 4));
				if (    (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2)
					 && (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY*32) <= 2) )
				{	// JLE 0043132A
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else
				{	bAddNewEffect(35, m_pEffectList[i]->m_dX*32 +22, m_pEffectList[i]->m_dY*32 -15, NULL, NULL, -7, 1);
					bAddNewEffect(36, m_pEffectList[i]->m_dX*32 -22, m_pEffectList[i]->m_dY*32 -7,  NULL, NULL, -7, 1);
					bAddNewEffect(36, m_pEffectList[i]->m_dX*32 +30, m_pEffectList[i]->m_dY*32 -22, NULL, NULL, -5, 1);
					bAddNewEffect(36, m_pEffectList[i]->m_dX*32 +12, m_pEffectList[i]->m_dY*32 +22, NULL, NULL, -3, 1);
				}
				break;
#endif

#ifdef DEF_EQUILIBRIUM_PROJECT
			case 185: // EP's Blizzard = Standard Blizzard
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else /*if (m_pEffectList[i]->m_cFrame == 1)*/
				{	bAddNewEffect(71, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						          m_pEffectList[i]->m_dX*32 +(rand()%120)-60, m_pEffectList[i]->m_dY*32 +(rand()%120)-60, 0);
					sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					PlaySound('E', 1, sDist, lPan);
				}
				break;

			case 191: // EP's Mass Blizzard
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else /*if (m_pEffectList[i]->m_cFrame == 1)*/
				{	bAddNewEffect(71, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						          m_pEffectList[i]->m_dX*32 +(rand()%120)-60, m_pEffectList[i]->m_dY*32 +(rand()%120)-60, 0);
					bAddNewEffect(71, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						          m_pEffectList[i]->m_dX*32 +(rand()%240)-120, m_pEffectList[i]->m_dY*32 +(rand()%240)-120, 0);
					sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					PlaySound('E', 1, sDist/2, lPan);
				}
				break;

#else // Standard Blizzard
			case 191: // Blizzard
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else /*if (m_pEffectList[i]->m_cFrame == 1)*/
				{	bAddNewEffect(71, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
						          m_pEffectList[i]->m_dX*32 +(rand()%120)-60, m_pEffectList[i]->m_dY*32 +(rand()%120)-60, 0);
					sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					PlaySound('E', 1, sDist, lPan);
				}
				break;

#endif

			case 196: // Earth-Shock-Wave
				m_Misc.GetPoint(m_pEffectList[i]->m_mX
					, m_pEffectList[i]->m_mY
					, m_pEffectList[i]->m_dX*32
					, m_pEffectList[i]->m_dY*32
					, &m_pEffectList[i]->m_mX
					, &m_pEffectList[i]->m_mY
					, &m_pEffectList[i]->m_iErr
					, 40);
				bAddNewEffect(80, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, NULL, NULL, 0, 1);
				bAddNewEffect(80, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, 0, 0);
				if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else
				{	sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
					if (sAbsX > sAbsY) sDist = sAbsX -10;
					else sDist = sAbsY -10;
					lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
					PlaySound('E', 1, sDist, lPan);
				}
				break;


#ifdef DEF_EQUILIBRIUM_PROJECT
			case 197: // Explosion
				m_Misc.GetPoint(m_pEffectList[i]->m_mX,    m_pEffectList[i]->m_mY,
					            m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32/* - 40*/,
								&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
								&m_pEffectList[i]->m_iErr, 50);
				if (    (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2)
					 && (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY*32) <= 2) )
				{	bAddNewEffect(30, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
					bAddNewEffect(31, m_pEffectList[i]->m_dX*32 -30, m_pEffectList[i]->m_dY*32 -15, NULL, NULL, -7);
					bAddNewEffect(31, m_pEffectList[i]->m_dX*32 +35, m_pEffectList[i]->m_dY*32 -30, NULL, NULL, -5);
					bAddNewEffect(31, m_pEffectList[i]->m_dX*32 +20, m_pEffectList[i]->m_dY*32 +30, NULL, NULL, -3);

					bAddNewEffect(31, m_pEffectList[i]->m_dX*32 +10, m_pEffectList[i]->m_dY*32 -50, NULL, NULL, -6);
					bAddNewEffect(31, m_pEffectList[i]->m_dX*32 -50, m_pEffectList[i]->m_dY*32 +20, NULL, NULL, -1);


					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;
#endif

			case 200:
				if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else
				{	bAddNewEffect(203, m_pEffectList[i]->m_sX + 40, m_pEffectList[i]->m_sY + 120, NULL, NULL, 0, 0);
					bAddNewEffect(204, m_pEffectList[i]->m_sX -10, m_pEffectList[i]->m_sY +70, NULL, NULL, 0, 0);
					bAddNewEffect(205, m_pEffectList[i]->m_sX -10, m_pEffectList[i]->m_sY +75, NULL, NULL, 0, 0);
					bAddNewEffect(206, m_pEffectList[i]->m_sX -7, m_pEffectList[i]->m_sY +27, NULL, NULL, 0, 0);
					bAddNewEffect(201, (rand() % 160) + 320, (rand() % 120) + 240, NULL, NULL, 0, 1);
					bAddNewEffect(202, (rand() % 160) + 320, (rand() % 120) + 240, NULL, NULL, 0, 1);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 201:
				if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else
				{	bAddNewEffect(203, m_pEffectList[i]->m_sX + 110, m_pEffectList[i]->m_sY + 120, NULL, NULL, 0, 0);
					bAddNewEffect(204, m_pEffectList[i]->m_sX -10, m_pEffectList[i]->m_sY +70, NULL, NULL, 0, 0);
					bAddNewEffect(205, m_pEffectList[i]->m_sX -10, m_pEffectList[i]->m_sY +75, NULL, NULL, 0, 0);
					bAddNewEffect(202, (rand() % 160) + 320, (rand() % 120) + 240, NULL, NULL, 0, 1);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 202:
				if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else
				{	bAddNewEffect(203, m_pEffectList[i]->m_sX + 65, m_pEffectList[i]->m_sY + 120, NULL, NULL, 0, 0);
					bAddNewEffect(204, m_pEffectList[i]->m_sX -10, m_pEffectList[i]->m_sY +70, NULL, NULL, 0, 0);
					bAddNewEffect(205, m_pEffectList[i]->m_sX -10, m_pEffectList[i]->m_sY +75, NULL, NULL, 0, 0);
					bAddNewEffect(206, m_pEffectList[i]->m_sX -7, m_pEffectList[i]->m_sY +27, NULL, NULL, 0, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

#ifdef DEF_EQUILIBRIUM_PROJECT // ZzZz

			case 237: // Air Elemental Attack
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	bAddNewEffect(10, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else
				{	m_pEffectList[i]->m_rX = 5 - (rand() % 10);
					m_pEffectList[i]->m_rY = 5 - (rand() % 10);
				}
				break;

			case 238: // Ice Elemental Attack
				bAddNewEffect(40, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
				//bAddNewEffect(40, m_pEffectList[i]->m_dX*32 -30, m_pEffectList[i]->m_dY*32 -15, NULL, NULL, -10);
				//bAddNewEffect(40, m_pEffectList[i]->m_dX*32 +35, m_pEffectList[i]->m_dY*32 -30, NULL, NULL, -6);
				//bAddNewEffect(40, m_pEffectList[i]->m_dX*32 +20, m_pEffectList[i]->m_dY*32 +30, NULL, NULL, -3);
				delete m_pEffectList[i];
				m_pEffectList[i] = NULL;
				break;

			case 239: // Ice Elemental OnMove
				bAddNewEffect(41, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0,	m_pEffectList[i]->m_iV1);
				for (x = 0; x < 5; x++)
				{	bAddNewEffect(41 + (rand() % 3), m_pEffectList[i]->m_dX*32 +(rand() % 100) - 50 +10, m_pEffectList[i]->m_dY*32 + (rand() % 90) - 45, NULL, NULL, -1*x-1, m_pEffectList[i]->m_iV1);
				}
				for (x = 0; x < 3; x++)
				{	bAddNewEffect(45 + (rand() % 2), m_pEffectList[i]->m_dX*32 +(rand() % 100) - 50 +10, m_pEffectList[i]->m_dY*32 + (rand() % 90) - 45, NULL, NULL, -1*x-1 -10, m_pEffectList[i]->m_iV1);
				}
				delete m_pEffectList[i];
				m_pEffectList[i] = NULL;
				break;
			
			case 240: // Air Elemental lightning onMove
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else
				{	m_pEffectList[i]->m_rX = 5 - (rand() % 10);
					m_pEffectList[i]->m_rY = 5 - (rand() % 10);
				}
				break;

			case 241: // Fire Elemental explosion onMove
				if (m_pEffectList[i]->m_cFrame == 1) // etincelles qui jaillissent
				{	bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
					bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
				}
				if (m_pEffectList[i]->m_cFrame == 7)
				{	bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, NULL, NULL);					
					if (rand()%7 == 3) // parfois + violent!
					{	bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, NULL, NULL);
						bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, NULL, NULL);
				}	}
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 247: // ZzZz
				if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else if (m_pEffectList[i]->m_iV1 == m_pEffectList[i]->m_cFrame)
				{	PlaySound('M', 45, m_pEffectList[i]->m_mX3, m_pEffectList[i]->m_mY3 );
				}
				break;
#endif

			case 250: // Gate round
				m_Misc.GetPoint(m_pEffectList[i]->m_mX
					, m_pEffectList[i]->m_mY
					, m_pEffectList[i]->m_dX*32
					, m_pEffectList[i]->m_dY*32 -40
					, &m_pEffectList[i]->m_mX
					, &m_pEffectList[i]->m_mY
					, &m_pEffectList[i]->m_iErr
					, 10);
				if (    (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2)
					 && (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY*32 - 40)) <= 2) )
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;

			case 251: // Salmon burst (effect11s)
				m_Misc.GetPoint(m_pEffectList[i]->m_mX
					, m_pEffectList[i]->m_mY
					, m_pEffectList[i]->m_dX*32
					, m_pEffectList[i]->m_dY*32
					, &m_pEffectList[i]->m_mX
					, &m_pEffectList[i]->m_mY
					, &m_pEffectList[i]->m_iErr
					, 50);
				if (    (abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX*32) <= 2)
					 && (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY*32 - 40)) <= 2) )
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}else
				{	bAddNewEffect(252, m_pEffectList[i]->m_dX*32     , m_pEffectList[i]->m_dY*32     , 0, 0, 0, 1);
					bAddNewEffect(252, m_pEffectList[i]->m_dX*32 - 30, m_pEffectList[i]->m_dY*32 - 15, 0, 0, -7, 1);
					bAddNewEffect(252, m_pEffectList[i]->m_dX*32 - 35, m_pEffectList[i]->m_dY*32 - 30, 0, 0, -5, 1);
					bAddNewEffect(252, m_pEffectList[i]->m_dX*32 + 20, m_pEffectList[i]->m_dY*32 + 30, 0, 0, -3, 1);
					delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;


#ifdef DEF_EQUILIBRIUM_PROJECT
			case 103: // Abbadon's Terror
			case 107: // Test spell
			case 108: // Test spell
			case 115: // EP's Stamina recovery
			case 116: // EP's Peace spell
			case 117: // EP's Wood Mantle
			case 118: // Test spell
			case 138: // Prayer
			case 148: // Critical heal
			case 158: // EP's Bloody Mantle
			case 167: // Scan
			case 168: // Mass heal
			case 175: // Trance
			case 182: // Warrior's spirit
			case 186: // Regenerate
			case 187: // EP's Magic Mantle
			case 188: // Entangle
			case 192: // Mass armor break
			case 198: // Medusa Kiss
			case 245: // Goal
			case 246: // Goal

#endif

			case 8:
			case 14:
			case 15:
			case 18:
			case 32:
			case 35: //
			case 36: //
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 57:
			case 61:
			case 63:
			case 64:
			case 67:
			case 72:
			case 73:
			case 74:
			case 75:
			case 76:
			case 77:
			case 80: //
			case 82: //

			case 101:
			case 102:
			case 111:
			case 112:
			case 113:
			case 121:
			case 122:
			case 123: // Stamina Rec
			case 124:
			case 125:
			case 126:
			case 127:
			case 128: // Gr Stamina Rec
			case 131:
			case 132:
			case 133:
			case 134:
			case 135:
			case 136:
			case 142:
			case 144:
			case 150: // Berserk : Cirlcle 6 magic
			case 152: // Polymorph
			case 153:
			case 162:
			case 165:
			case 166:
			case 171:
			case 176: //
			case 177: //

			case 180:
			case 183: //
			case 184: // EP's Magic Drain
			case 190:
			case 194:
			case 195:
			case 242: // Mage hero effect
			case 243: // War hero effect
			case 244: // Snoopy: déplacé pour nvx sorts: Aura du casteur de Mass MagicMissile
			default:
				if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
				{	delete m_pEffectList[i];
					m_pEffectList[i] = NULL;
				}
				break;
	}	}	}
	return bRet;
}


BOOL   CGame::DrawObject_OnRun(int indexX, int indexY, int sX, int sY, BOOL bTrans, DWORD dwTime, int msX, int msY)
{int dx, dy;
 int iBodyIndex, iHairIndex, iUndiesIndex, iArmArmorIndex, iBodyArmorIndex, iPantsIndex, iBootsIndex, iWeaponIndex, iShieldIndex, iHelmIndex, iR, iG, iB, iMantleIndex;
 BOOL bInv = FALSE;
 int iWeaponGlare, iShieldGlare;
 int iWeaponColor, iShieldColor, iArmorColor, iMantleColor, iArmColor, iPantsColor, iBootsColor, iHelmColor;
 int iSkirtDraw = 0;

	if(_tmp_sOwnerType == 35 || _tmp_sOwnerType == 73 || _tmp_sOwnerType == 66) bInv = TRUE; //Energy-Ball,Wyvern
	if(_tmp_sOwnerType == 95 || _tmp_sOwnerType == 96 || _tmp_sOwnerType == 97 || _tmp_sOwnerType == 98 || _tmp_sOwnerType == 99) bInv = TRUE; //Elementals

	if (m_cDetailLevel == 0)
	{	iWeaponColor = 0;
		iShieldColor = 0;
		iArmorColor  = 0;
		iMantleColor = 0;
		iArmColor    = 0;
		iPantsColor  = 0;
		iBootsColor  = 0;
		iHelmColor   = 0;
	}else
	{	iWeaponColor = (_tmp_iApprColor & 0xF0000000) >> 28;
		iShieldColor = (_tmp_iApprColor & 0x0F000000) >> 24;
		iArmorColor  = (_tmp_iApprColor & 0x00F00000) >> 20;
		iMantleColor = (_tmp_iApprColor & 0x000F0000) >> 16;
		iArmColor    = (_tmp_iApprColor & 0x0000F000) >> 12;
		iPantsColor  = (_tmp_iApprColor & 0x00000F00) >> 8;
		iBootsColor  = (_tmp_iApprColor & 0x000000F0) >> 4;
		iHelmColor   = (_tmp_iApprColor & 0x0000000F);
	}
	iWeaponGlare = (_tmp_sAppr4 & 0x000C) >> 2;
	iShieldGlare = (_tmp_sAppr4 & 0x0003);
	if ( (_tmp_iStatus & 0x10) != 0)
	{	if (memcmp(m_cPlayerName, _tmp_cName, 10) == 0) bInv = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // invi
		else if((_tmp_iStatus & 0x00040000) != 0 ) bInv = TRUE;
#else
		else if( _iGetFOE(_tmp_iStatus) == 1 ) bInv = TRUE;
#endif

		else return FALSE;
	}

	switch (_tmp_sOwnerType) {
	case 1:
	case 2:
	case 3:
		iBodyIndex  = 500  + (_tmp_sOwnerType - 1 )*8*15 + (4 * 8);
		iUndiesIndex    = DEF_SPRID_UNDIES_M + (_tmp_sAppr1 & 0x000F)*15 + 4;
		iHairIndex	    = DEF_SPRID_HAIR_M + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 4;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_M + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 4;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_M + (_tmp_sAppr3 & 0x000F)*15 + 4;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_M + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 4;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_M + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 4;
		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else
		{	iWeaponIndex = DEF_SPRID_WEAPON_M + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*6 + (_tmp_cDir - 1);
		}
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = DEF_SPRID_SHIELD_M + (_tmp_sAppr2 & 0x000F)*8 + 6;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_M + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 4;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_M + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 4;
		break;

	case 4:
	case 5:
	case 6:
		if (((_tmp_sAppr3 & 0x0F00) >> 8) == 1) iSkirtDraw = 1;
		iBodyIndex  = 500  + (_tmp_sOwnerType - 1 )*8*15 + (4 * 8);
		iUndiesIndex    = DEF_SPRID_UNDIES_W + (_tmp_sAppr1 & 0x000F)*15 + 4;
		iHairIndex	    = DEF_SPRID_HAIR_W + ((_tmp_sAppr1 & 0x0F00) >> 8)*15 + 4;
		if ((_tmp_sAppr4 & 0x80) == 0)
		{	if (((_tmp_sAppr3 & 0xF000) >> 12) == 0)
				 iBodyArmorIndex = -1;
			else iBodyArmorIndex = DEF_SPRID_BODYARMOR_W + ((_tmp_sAppr3 & 0xF000) >> 12)*15 + 4;
		}
		if ((_tmp_sAppr3 & 0x000F) == 0)
			 iArmArmorIndex = -1;
		else iArmArmorIndex = DEF_SPRID_BERK_W + (_tmp_sAppr3 & 0x000F)*15 + 4;
		if ((_tmp_sAppr3 & 0x0F00) == 0)
			 iPantsIndex = -1;
		else iPantsIndex = DEF_SPRID_LEGG_W + ((_tmp_sAppr3 & 0x0F00) >> 8)*15 + 4;
		if (((_tmp_sAppr4 & 0xF000) >> 12) == 0)
			 iBootsIndex = -1;
		else iBootsIndex = DEF_SPRID_BOOT_W + ((_tmp_sAppr4 & 0xF000) >> 12)*15 + 4;
		if (((_tmp_sAppr2 & 0x0FF0) >> 4) == 0)
			iWeaponIndex = -1;
		else
		{	iWeaponIndex = DEF_SPRID_WEAPON_W + ((_tmp_sAppr2 & 0x0FF0) >> 4)*64 + 8*6 + (_tmp_cDir - 1);
		}
		if ((_tmp_sAppr2 & 0x000F) == 0)
			iShieldIndex = -1;
		else iShieldIndex = DEF_SPRID_SHIELD_W + (_tmp_sAppr2 & 0x000F)*8 + 6;
		if ((_tmp_sAppr4 & 0x0F00) == 0)
			 iMantleIndex = -1;
		else iMantleIndex = DEF_SPRID_MANTLE_W + ((_tmp_sAppr4 & 0x0F00) >> 8)*15 + 4;
		if ((_tmp_sAppr3 & 0x00F0) == 0)
			 iHelmIndex = -1;
		else iHelmIndex = DEF_SPRID_HEAD_W + ((_tmp_sAppr3 & 0x00F0) >> 4)*15 + 4;
		break;

	default:
		iUndiesIndex    = -1;
		iHairIndex   	= -1;
		iArmArmorIndex  = -1;
		iBodyArmorIndex = -1;
		iPantsIndex     = -1;
		iBootsIndex     = -1;
		iMantleIndex    = -1;
		iHelmIndex      = -1;
		break;
	}
	dx = 0;
	dy = 0;
	switch (_tmp_cDir) {
	case 1 : dy = 28 - (_tmp_cFrame<<2); break;
	case 2 : dy = 28 - (_tmp_cFrame<<2); dx = (_tmp_cFrame<<2) - 28; break;
	case 3 : dx = (_tmp_cFrame<<2) - 28; break;
	case 4 : dx = (_tmp_cFrame<<2) - 28; dy = (_tmp_cFrame<<2) - 28; break;
	case 5 : dy = (_tmp_cFrame<<2) - 28; break;
	case 6 : dy = (_tmp_cFrame<<2) - 28; dx = 28 - (_tmp_cFrame<<2); break;
	case 7 : dx = 28 - (_tmp_cFrame<<2); break;
	case 8 : dx = 28 - (_tmp_cFrame<<2); dy = 28 - (_tmp_cFrame<<2); break;
	}
	if (m_bIsCrusadeMode || m_bIsAvatarMode) DrawObjectFOE(sX+dx, sY+dy, _tmp_cFrame);

	if (_tmp_iEffectType != 0)
	{	switch (_tmp_iEffectType) {
		case 1: m_pEffectSpr[26]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Attack Effect
		case 2: m_pEffectSpr[27]->PutTransSprite(sX+dx, sY+dy, _tmp_iEffectFrame, dwTime); break; // Special Ability: Protect Effect
	}	}

	if (bTrans == FALSE)
	{	CheckActiveAura(sX+dx, sY+dy, dwTime, _tmp_sOwnerType);
		if (_cDrawingOrder[_tmp_cDir] == 1)
		{	if (iWeaponIndex != -1)
			{	if(bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else
				{	if (iWeaponColor == 0)
						 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}

			switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
			case 66: // Wyvern
			case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				break;
			default:
				if (m_cDetailLevel != 0)
				{	if (sX < 50)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
				break;
			}

			if (bInv == TRUE)
				//m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite2(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else
			{	if ((_tmp_iStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			}
			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 0))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (iUndiesIndex != -1)
			{	if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}	}

			if (iPantsIndex != -1)
			{	if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iPantsColor == 0)
						 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}	}

			if (iArmArmorIndex != -1)
			{	if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iArmColor == 0)
						 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}	}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}	}

			if (iBodyArmorIndex != -1)
			{	if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iArmorColor == 0)
						 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}	}

			if (iHelmIndex != -1)
			{	if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 2))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
			{	m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime); // GM effect
			}else
			if (iShieldIndex != -1)
			{	if(bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iShieldColor == 0)
						 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

				}
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime); // GM effect
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 1))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}
		}else
		{	switch (_tmp_sOwnerType) { // Pas d'ombre pour ces mobs
			case 10: // Slime
			case 35: // Energy Sphere
			case 50: // TW
			case 51: // CP
			case 60: // Plant
			case 65: // IceGolem
			case 66: // Wyvern
			case 73: // Fire Wyvern
			case 81: // Abaddon
			case 91: // Gate
			case 95: // Willowisp
			case 96: // Air Elemental
			case 97: // Fire Elemental
			case 98: // Earth Elemental
			case 99: // Ice Elemental
				break;
			default:
				if (m_cDetailLevel != 0)
				{	if (sX < 50)
						 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSpriteClip(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutShadowSprite(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				}
				break;
			}

			if (bInv == TRUE)
				m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutTransSprite2(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			else
			{	if ((_tmp_iStatus & 0x40) != 0)
					 m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wR[10] -m_wR[0]/2, m_wG[10] -m_wG[0]/2, m_wB[10] -m_wB[0]/2, dwTime);
				else m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
			}

			SetRect(&m_rcBodyRect, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.left, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.top,
				     m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.right, m_pSprite[iBodyIndex + (_tmp_cDir - 1)]->m_rcBound.bottom);


			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 0))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (iUndiesIndex != -1)
			{	if(bInv) m_pSprite[iUndiesIndex]->PutTransSprite2(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				m_pSprite[iUndiesIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
			}

			if ((iHairIndex != -1) && (iHelmIndex == -1))
			{	_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
				m_pSprite[iHairIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, iR, iG, iB, dwTime);
			}

			if ((iBootsIndex != -1) && (iSkirtDraw == 1))
			{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}	}

			if (iPantsIndex != -1)
			{	if(bInv) m_pSprite[iPantsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iPantsColor == 0)
						 m_pSprite[iPantsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iPantsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iPantsColor] -m_wR[0], m_wG[iPantsColor] -m_wG[0], m_wB[iPantsColor] -m_wB[0], dwTime);
			}	}

			if (iArmArmorIndex != -1)
			{	if(bInv) m_pSprite[iArmArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iArmColor == 0)
						 m_pSprite[iArmArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iArmArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmColor] -m_wR[0], m_wG[iArmColor] -m_wG[0], m_wB[iArmColor] -m_wB[0], dwTime);
			}	}

			if ((iBootsIndex != -1) && (iSkirtDraw == 0))
			{	if(bInv) m_pSprite[iBootsIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iBootsColor == 0)
						 m_pSprite[iBootsIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBootsIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iBootsColor] -m_wR[0], m_wG[iBootsColor] -m_wG[0], m_wB[iBootsColor] -m_wB[0], dwTime);
			}	}

			if (iBodyArmorIndex != -1)
			{	if(bInv) m_pSprite[iBodyArmorIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iArmorColor == 0)
						 m_pSprite[iBodyArmorIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iBodyArmorIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iArmorColor] -m_wR[0], m_wG[iArmorColor] -m_wG[0], m_wB[iArmorColor] -m_wB[0], dwTime);
			}	}

			if (iHelmIndex != -1)
			{	if(bInv) m_pSprite[iHelmIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iHelmColor == 0)
						 m_pSprite[iHelmIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iHelmIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iHelmColor] -m_wR[0], m_wG[iHelmColor] -m_wG[0], m_wB[iHelmColor] -m_wB[0], dwTime);
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 2))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (((_tmp_sAppr2 & 0x000F) == 8) && (iShieldGlare == 1))	
			{	m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
			}else
			if (iShieldIndex != -1)
			{	if(bInv) m_pSprite[iShieldIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iShieldColor == 0)
						 m_pSprite[iShieldIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);

#ifdef DEF_EQUILIBRIUM_PROJECT // Couleur shields
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wWR[iShieldColor] -m_wR[0], m_wWG[iShieldColor] -m_wG[0], m_wWB[iShieldColor] -m_wB[0], dwTime);
#else
					else m_pSprite[iShieldIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iShieldColor] -m_wR[0], m_wG[iShieldColor] -m_wG[0], m_wB[iShieldColor] -m_wB[0], dwTime);
#endif

				}
				switch (iShieldGlare) {
				case 0: break;
				//case 1: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX, sY,  (_tmp_cDir-1) * 8 + _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 1: m_pEffectSpr[45]->PutTransSprite(sX -13+dx, sY -34+dy, 0, dwTime);
				case 2: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iShieldIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  (_tmp_cDir-1) * 8 + _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
			}	}

			if ((iMantleIndex != -1) && (_cMantleDrawingOrderOnRun[_tmp_cDir] == 1))
			{	if(bInv) m_pSprite[iMantleIndex]->PutTransSprite25(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
				else
				{	if (iMantleColor == 0)
						 m_pSprite[iMantleIndex]->PutSpriteFast(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, dwTime);
					else m_pSprite[iMantleIndex]->PutSpriteRGB(sX+dx, sY+dy, (_tmp_cDir-1) * 8 + _tmp_cFrame, m_wR[iMantleColor] -m_wR[0], m_wG[iMantleColor] -m_wG[0], m_wB[iMantleColor] -m_wB[0], dwTime);
			}	}

			if (iWeaponIndex != -1)
			{	if(bInv) m_pSprite[iWeaponIndex]->PutTransSprite25(sX+dx, sY+dy, _tmp_cFrame, dwTime);
				else
				{	if (iWeaponColor == 0)
						 m_pSprite[iWeaponIndex]->PutSpriteFast(sX+dx, sY+dy, _tmp_cFrame, dwTime);
					else m_pSprite[iWeaponIndex]->PutSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, m_wWR[iWeaponColor] -m_wR[0], m_wWG[iWeaponColor] -m_wG[0], m_wWB[iWeaponColor] -m_wB[0], dwTime);
				}
				DKGlare(iWeaponColor, iWeaponIndex, &iWeaponGlare);
				switch (iWeaponGlare) {
				case 0: break;
				case 1: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, m_iDrawFlag, 0, 0, dwTime); break; // Red Glare
				case 2: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, m_iDrawFlag, 0, dwTime); break; // Green Glare
				case 3: m_pSprite[iWeaponIndex]->PutTransSpriteRGB(sX+dx, sY+dy,  _tmp_cFrame, 0, 0, m_iDrawFlag, dwTime); break; // Blue Glare
		}	}	}

		if ((_tmp_iStatus & 0x20) != 0) 	// Berserk
			m_pSprite[iBodyIndex + (_tmp_cDir -1)]->PutTransSpriteRGB(sX+dx, sY+dy, _tmp_cFrame, 0, -5, -5, dwTime);
		DrawAngel(40+(_tmp_cDir - 1), sX+dx+20, sY+dy-20, _tmp_cFrame%4, dwTime);
		CheckActiveAura2(sX+dx, sY+dy, dwTime,  _tmp_sOwnerType);

	}else if( strlen(_tmp_cName) > 0 )
	{	if( (_tmp_sOwnerType>=1) && (_tmp_sOwnerType<=6) ) DrawObjectName(sX+dx, sY+dy, _tmp_cName, _tmp_iStatus);
		else DrawNpcName(sX+dx, sY+dy, _tmp_sOwnerType, _tmp_iStatus);
	}

	if (_tmp_iChatIndex != NULL)
	{	if ((m_pChatMsgList[_tmp_iChatIndex] != NULL) && (m_pChatMsgList[_tmp_iChatIndex]->m_iObjectID == _tmp_wObjectID))
		{	m_pChatMsgList[_tmp_iChatIndex]->m_sX = sX+dx;
			m_pChatMsgList[_tmp_iChatIndex]->m_sY = sY+dy;
		}else
		{	m_pMapData->ClearChatMsg(indexX, indexY);
	}	}
	_tmp_dx = dx;
	_tmp_dy = dy;
	if (   (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top != -1)
		&& (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.top < msY)
		&& (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.bottom > msY)
		&& (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.left < msX)
		&& (m_pSprite[iBodyIndex + (_tmp_cDir -1)]->m_rcBound.right > msX)) return TRUE;
	return FALSE;
}

void CGame::GetPlayerTurn()
{
 char cDir;
 short sX, sY, sCnt1, sCnt2;
 int   iError;

	sX = m_sPlayerX;
	sY = m_sPlayerY;
	sCnt1 = 0;
	m_cPlayerTurn = 0;
	iError = 0;
	while (1) {
		cDir = cGetNextMoveDir(sX, sY, m_sCommX, m_sCommY);
		if (cDir == 0) break;
		switch (cDir) {
		case 1: sY--;       break;
		case 2: sX++; sY--; break;
		case 3: sX++;       break;
		case 4: sX++; sY++; break;
		case 5: sY++;       break;
		case 6: sX--; sY++; break;
		case 7: sX--;       break;
		case 8: sX--; sY--; break;
		}
		sCnt1++;
		if (sCnt1 > 30) break;
	}

	sX = m_sPlayerX;
	sY = m_sPlayerY;
	sCnt2 = 0;
	m_cPlayerTurn = 1;
	iError = 0;
	while (1) {
		cDir = cGetNextMoveDir(sX, sY, m_sCommX, m_sCommY);
		if (cDir == 0) break;
		switch (cDir) {
		case 1: sY--;       break;
		case 2: sX++; sY--; break;
		case 3: sX++;       break;
		case 4: sX++; sY++; break;
		case 5: sY++;       break;
		case 6: sX--; sY++; break;
		case 7: sX--;       break;
		case 8: sX--; sY--; break;
		}
		sCnt2++;
		if (sCnt2 > 30) break;
	}

	if (sCnt1 > sCnt2)
		 m_cPlayerTurn = 0;
	else m_cPlayerTurn = 1;
}


int CGame::_iCheckDlgBoxFocus(short msX, short msY, char cButtonSide)
{int i;
 char         cDlgID;
 short        sX, sY;
 DWORD		  dwTime = m_dwCurTime;
	if (cButtonSide == 1) {
		// Snoopy: 41->61
		for (i = 0; i < 61; i++)
		// Snoopy: 40->60
		if (m_cDialogBoxOrder[60 - i] != NULL) 	// Snoopy: 40->60
		{	cDlgID = m_cDialogBoxOrder[60 - i];
			if ((m_stDialogBoxInfo[cDlgID].sX <= msX)	&& ((m_stDialogBoxInfo[cDlgID].sX + m_stDialogBoxInfo[cDlgID].sSizeX) >= msX) &&
				(m_stDialogBoxInfo[cDlgID].sY <= msY)	&& ((m_stDialogBoxInfo[cDlgID].sY + m_stDialogBoxInfo[cDlgID].sSizeY) >= msY) )
			{	EnableDialogBox(cDlgID, NULL, NULL, NULL);

				m_stMCursor.sPrevX = msX;
				m_stMCursor.sPrevY = msY;
				m_stMCursor.sDistX = msX - m_stDialogBoxInfo[cDlgID].sX;
				m_stMCursor.sDistY = msY - m_stDialogBoxInfo[cDlgID].sY;

				switch (cDlgID) {
				case 1:
					if (bDlgBoxPress_Character(msX, msY) == FALSE) {
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;
					}
					break;

				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:

				case 12:
				case 13:
				case 16:
				case 17:
				case 20:
				case 22:
				case 23:
				case 24:
				case 25:
				case 28:
				case 29:
				case 30:
				case 31:
				case 32:
				case 33:
				case 34:
				case 35:
				case 36:
				case 37:
				case 38:
				case 40:
				case 50: // resur
				// NPC
				case 67:
				case 68:
				case 69:
					m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
					m_stMCursor.sSelectedObjectID   = cDlgID;
					break;

				case 2:	// (Sell Item)
					if (bDlgBoxPress_Inventory(msX, msY) == FALSE)
					{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;
					}
					break;

				case 10:
					sX = m_stDialogBoxInfo[10].sX;
					sY = m_stDialogBoxInfo[10].sY;
					if ((msX >= sX + 340) && (msX <= sX + 360) && (msY >= sY + 22) && (msY <= sY + 138)) {
						m_stDialogBoxInfo[10].bIsScrollSelected = TRUE;
						return -1;
					}

					if (m_stDialogBoxInfo[10].bIsScrollSelected == FALSE) {
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;
					}
					else return -1;
					break;

				case 11:
					sX = m_stDialogBoxInfo[11].sX;
					sY = m_stDialogBoxInfo[11].sY;
					if ((m_stDialogBoxInfo[11].cMode == 0) && (msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 20) && (msY <= sY + 330)) {
						m_stDialogBoxInfo[11].bIsScrollSelected = TRUE;
						return -1;
					}

					if ((m_stDialogBoxInfo[11].bIsScrollSelected == FALSE)) {
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;
					}
					else return -1;
					break;

				case 14:
					sX = m_stDialogBoxInfo[14].sX;
					sY = m_stDialogBoxInfo[14].sY;
					if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
						m_stDialogBoxInfo[14].bIsScrollSelected = TRUE;
						return -1;
					}

					if (m_stDialogBoxInfo[14].bIsScrollSelected == FALSE) {
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;
					}
					else return -1;
					break;

				case 15:
					sX = m_stDialogBoxInfo[15].sX;
					sY = m_stDialogBoxInfo[15].sY;
					if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320))
					{	m_stDialogBoxInfo[15].bIsScrollSelected = TRUE;
						return -1;
					}
					if (m_stDialogBoxInfo[15].bIsScrollSelected == FALSE)
					{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;
					}
					else return -1;
					break;

				case 18:
					sX = m_stDialogBoxInfo[18].sX;
					sY = m_stDialogBoxInfo[18].sY;
					if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
						m_stDialogBoxInfo[18].bIsScrollSelected = TRUE;
						return -1;
					}

					if (m_stDialogBoxInfo[18].bIsScrollSelected == FALSE) {
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;
					}
					else return -1;
					break;

				case 19:
					sX = m_stDialogBoxInfo[19].sX;
					sY = m_stDialogBoxInfo[19].sY;
					if ((msX >= sX + 126) && (msX <= sX + 238) && (msY >= sY +122) && (msY <= sY +138)) {
						m_stDialogBoxInfo[19].bIsScrollSelected = TRUE;
						return -1;
					}
					if ((msX >= sX + 126) && (msX <= sX + 238) && (msY >= sY +139) && (msY <= sY +155)) {
						m_stDialogBoxInfo[19].bIsScrollSelected = TRUE;
						return -1;
					}

					if (m_stDialogBoxInfo[19].bIsScrollSelected == FALSE) {
						m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;
					}
					else return -1;
					break;

				case 21:
					sX = m_stDialogBoxInfo[21].sX;
					sY = m_stDialogBoxInfo[21].sY;
					if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) 
					{	m_stDialogBoxInfo[21].bIsScrollSelected = TRUE;
						return -1;
					}

					if (m_stDialogBoxInfo[21].bIsScrollSelected == FALSE) 
					{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;
					}
					else return -1;
					break;

				case 26:
					if (bDlgBoxPress_SkillDlg(msX, msY) == FALSE) 
					{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID   = cDlgID;
					}
					break;

				case 27:
					m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
					m_stMCursor.sSelectedObjectID   = cDlgID;
					break;

				case 41: //Snoopy: Drag exchange confirmation dialog
					m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
					m_stMCursor.sSelectedObjectID   = cDlgID;
					break;

				case 42:  // Snoopy: Drag majestic stats
					m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
					m_stMCursor.sSelectedObjectID   = cDlgID;
					break;

				case 51:  // Snoopy: Drag Gail menu
					m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_DLGBOX;
					m_stMCursor.sSelectedObjectID   = cDlgID;
					break;
				}
				return 1;
		}	}
		return 0;
	}else if (cButtonSide == 2)
	{	if ((dwTime - m_dwDialogCloseTime) < 300) return 0;
		// Snoopy: 40->60
		for (i = 0; i < 61; i++)
		// Snoopy: 40->60
		if (m_cDialogBoxOrder[60 - i] != NULL) {
		// Snoopy: 40->60
			cDlgID = m_cDialogBoxOrder[60 - i];
			if ((m_stDialogBoxInfo[cDlgID].sX < msX) && ((m_stDialogBoxInfo[cDlgID].sX + m_stDialogBoxInfo[cDlgID].sSizeX) > msX) &&
				(m_stDialogBoxInfo[cDlgID].sY < msY) && ((m_stDialogBoxInfo[cDlgID].sY + m_stDialogBoxInfo[cDlgID].sSizeY) > msY) )
			{	if ((cDlgID != 5) && (cDlgID != 6) && (cDlgID != 8) && (cDlgID != 12) && ((cDlgID != 23) || (m_stDialogBoxInfo[23].cMode < 3)) && (cDlgID != 24) && (cDlgID != 27) && (cDlgID != 34) &&
					(cDlgID != 33) && !((cDlgID == 32) && ((m_stDialogBoxInfo[cDlgID].cMode == 1) || (m_stDialogBoxInfo[cDlgID].cMode == 3))))
					DisableDialogBox(cDlgID);
				m_dwDialogCloseTime = dwTime;
				return 1;
	}	}	}
	return 0;
}



void CGame::InitItemList(char * pData)
{char    cTotalItems;
 int     i, iAngelValue;
 short * sp;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;

	for (i = 0; i < DEF_MAXITEMS; i++)
		m_cItemOrder[i] = -1;

	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
		m_sItemEquipmentStatus[i] = -1;

	for (i = 0; i < DEF_MAXITEMS; i++)
		m_bIsItemDisabled[i] = FALSE;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cTotalItems = *cp;
	cp++;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] != NULL) 
	{	delete m_pItemList[i];
		m_pItemList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pBankList[i] != NULL) 
	{	delete m_pBankList[i];
		m_pBankList[i] = NULL;
	}

	for (i = 0; i < cTotalItems; i++)
	{	m_pItemList[i] = new class CItem;
		memcpy(m_pItemList[i]->m_cName, cp, 20);
		cp += 20;
		dwp = (DWORD *)cp;
		m_pItemList[i]->m_dwCount = *dwp;
		m_pItemList[i]->m_sX      =	40;
		m_pItemList[i]->m_sY      =	30;
		cp += 4;
		m_pItemList[i]->m_cItemType = *cp;
		cp++;
		m_pItemList[i]->m_cEquipPos = *cp;
		cp++;
		if( *cp == 0 ) m_bIsItemEquipped[i] = FALSE;
		else m_bIsItemEquipped[i] = TRUE;
		cp++;
		if (m_bIsItemEquipped[i] == TRUE)
		{	m_sItemEquipmentStatus[m_pItemList[i]->m_cEquipPos] = i;
		}
		sp = (short *)cp;
		m_pItemList[i]->m_sLevelLimit = *sp;
		cp += 2;
		m_pItemList[i]->m_cGenderLimit = *cp;
		cp++;
		wp =(WORD *)cp;
		m_pItemList[i]->m_wCurLifeSpan = *wp;
		cp += 2;
		wp =(WORD *)cp;
		m_pItemList[i]->m_wWeight = *wp;
		cp += 2;
		sp = (short *)cp;
		m_pItemList[i]->m_sSprite = *sp;
		cp += 2;
		sp = (short *)cp;
		m_pItemList[i]->m_sSpriteFrame = *sp;
		cp += 2;
		m_pItemList[i]->m_cItemColor = *cp;
		cp++;
		m_pItemList[i]->m_sItemSpecEffectValue2 = (short)*cp; // v1.41
		cp++;
		dwp = (DWORD *)cp;
		m_pItemList[i]->m_dwAttribute = *dwp;
		cp += 4;
		/*
		m_pItemList[i]->m_bIsCustomMade = (BOOL)*cp;
		cp++;
		*/
		m_cItemOrder[i] = i;
		// Snoopy: Add Angelic Stats
		if (   (m_pItemList[i]->m_cItemType == 1)
			&& (m_bIsItemEquipped[i] == TRUE)
			&& (m_pItemList[i]->m_cEquipPos >= 11))
		{	if(memcmp(m_pItemList[i]->m_cName, "AngelicPandent(STR)", 19) == 0)
			{	iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				m_iAngelicStr = iAngelValue;
			}else if(memcmp(m_pItemList[i]->m_cName, "AngelicPandent(DEX)", 19) == 0)
			{	iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				m_iAngelicDex = iAngelValue;
			}else if(memcmp(m_pItemList[i]->m_cName, "AngelicPandent(INT)", 19) == 0)
			{	iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				m_iAngelicInt = iAngelValue;
			}else if(memcmp(m_pItemList[i]->m_cName, "AngelicPandent(MAG)", 19) == 0)
			{	iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				m_iAngelicMag = iAngelValue;
	}	}	}

	cTotalItems = *cp;
	cp++;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pBankList[i] != NULL)
	{	delete m_pBankList[i];
		m_pBankList[i] = NULL;
	}

	for (i = 0; i < cTotalItems; i++)
	{	m_pBankList[i] = new class CItem;
		memcpy(m_pBankList[i]->m_cName, cp, 20);
		cp += 20;

		dwp = (DWORD *)cp;
		m_pBankList[i]->m_dwCount = *dwp;
		cp += 4;

		m_pBankList[i]->m_sX = 40;
		m_pBankList[i]->m_sY = 30;

		m_pBankList[i]->m_cItemType = *cp;
		cp++;

		m_pBankList[i]->m_cEquipPos = *cp;
		cp++;

		sp = (short *)cp;
		m_pBankList[i]->m_sLevelLimit = *sp;
		cp += 2;

		m_pBankList[i]->m_cGenderLimit = *cp;
		cp++;

		wp =(WORD *)cp;
		m_pBankList[i]->m_wCurLifeSpan = *wp;
		cp += 2;

		wp =(WORD *)cp;
		m_pBankList[i]->m_wWeight = *wp;
		cp += 2;

		sp = (short *)cp;
		m_pBankList[i]->m_sSprite = *sp;
		cp += 2;

		sp = (short *)cp;
		m_pBankList[i]->m_sSpriteFrame = *sp;
		cp += 2;

		m_pBankList[i]->m_cItemColor = *cp;
		cp++;

		m_pBankList[i]->m_sItemSpecEffectValue2 = (short)*cp; // v1.41
		cp++;

		dwp = (DWORD *)cp;
		m_pBankList[i]->m_dwAttribute = *dwp;
		cp += 4;
		/*
		m_pBankList[i]->m_bIsCustomMade = (BOOL)*cp;
		cp++;
		*/
	}

	// Magic, Skill Mastery
	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	{	m_cMagicMastery[i] = *cp;
		cp++;
	}

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	{	m_cSkillMastery[i] = (unsigned char)*cp;
		if (m_pSkillCfgList[i] != NULL)
			m_pSkillCfgList[i]->m_iLevel = (int)*cp;
		cp++;
	}
}

void CGame::DrawDialogBox_GuideMap(short msX, short msY, char cLB)
{int  m_iMaxMapIndex   = DEF_SPRID_INTERFACE_GUIDEMAP + m_cMapIndex +1;
 int  m_iMinMapIndex   = DEF_SPRID_INTERFACE_GUIDEMAP;
 int  m_iMinMapSquare  = m_cMapIndex ;
 //telescope.pak:  frames 1..31 <=> DEF_SPRID_INTERFACE_GUIDEMAP +1...+31 <=> m_cMapIndex 0..30
 //telescope1.pak: frames 1..3  <=> DEF_SPRID_INTERFACE_GUIDEMAP +36..+38 <=> m_cMapIndex 35..37 et +
	if( m_cMapIndex < 0 ) return;
	if (m_cMapIndex >= 35)
	{	m_iMaxMapIndex  = DEF_SPRID_INTERFACE_GUIDEMAP + m_cMapIndex +1;
		m_iMinMapIndex  = DEF_SPRID_INTERFACE_GUIDEMAP + 35;
		m_iMinMapSquare = m_cMapIndex - 35;
	}
	short sX, sY, shX, shY, szX, szY;
	sX = m_stDialogBoxInfo[9].sX;
	sY = m_stDialogBoxInfo[9].sY;
	szX = m_stDialogBoxInfo[9].sSizeX;
	szY = m_stDialogBoxInfo[9].sSizeY;
	if( sX < 20 ) sX = 0;
	if( sY < 20 ) sY = 0;
	if( sX > 640-128-20 ) sX = 640-128;
	if( sY > 427-128-20 ) sY = 427-128;
	for( shX=-2 ; shX<130 ; shX++ )
	{
		m_DDraw.PutPixel( sX+shX, sY-2  , 50,50,50);
		m_DDraw.PutPixel( sX+shX, sY-1  , 50,50,50);
		m_DDraw.PutPixel( sX+shX, sY+128, 50,50,50);
		m_DDraw.PutPixel( sX+shX, sY+129, 50,50,50);
	}
	for( shY=-2 ; shY<130 ; shY++ )
	{
		m_DDraw.PutPixel( sX-2  , sY+shY, 50,50,50);
		m_DDraw.PutPixel( sX-1  , sY+shY, 50,50,50);
		m_DDraw.PutPixel( sX+128, sY+shY, 50,50,50);
		m_DDraw.PutPixel( sX+129, sY+shY, 50,50,50);
	}
	if( m_bZoomMap )
	{	shX = m_sPlayerX-64;
		shY = m_sPlayerY-64;
		if( shX < 0 ) shX = 0;
		if( shY < 0 ) shY = 0;
		if( shX > m_pMapData->m_sMapSizeX-128 ) shX = m_pMapData->m_sMapSizeX-128;
		if( shY > m_pMapData->m_sMapSizeY-128 ) shY = m_pMapData->m_sMapSizeY-128;
		if (m_bDialogTrans) m_pSprite[m_iMaxMapIndex]->PutShiftTransSprite2(sX, sY, shX, shY, 0, m_dwCurTime );
		else m_pSprite[m_iMaxMapIndex]->PutShiftSpriteFast(sX, sY, shX, shY, 0, m_dwCurTime );
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX - shX + m_sPlayerX, sY - shY + m_sPlayerY, 37, m_dwCurTime);

		if( (m_dwCurTime - m_dwMonsterEventTime) < 30000 )
		{	if( (m_dwCurTime%500)< 370 )
			{	if( m_sEventX >= shX && m_sEventX <= shX+128 && m_sEventY >= shY && m_sEventY <= shY+128 )
					m_pSprite[DEF_SPRID_INTERFACE_MONSTER]->PutSpriteFast(sX + m_sEventX - shX, sY + m_sEventY -shY, m_sMonsterID, m_dwCurTime);
			}
		}else
		{	m_dwMonsterEventTime = 0;
			m_sMonsterID = 0;
		}
	}else // Sans zoom
	{	if (m_bDialogTrans) m_pSprite[m_iMinMapIndex]->PutTransSprite2(sX, sY, m_iMinMapSquare, m_dwCurTime);
		else m_pSprite[m_iMinMapIndex]->PutSpriteFastNoColorKey(sX, sY, m_iMinMapSquare, m_dwCurTime);
		shX = (m_sPlayerX*128)/(m_pMapData->m_sMapSizeX);
		shY = (m_sPlayerY*128)/(m_pMapData->m_sMapSizeX);
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + shX, sY + shY, 37, m_dwCurTime);

		if( (G_dwGlobalTime - m_dwMonsterEventTime) < 30000 )
		{	if( (m_dwCurTime%500)< 370 )
			{	shX = (m_sEventX*128)/(m_pMapData->m_sMapSizeX);
				shY = (m_sEventY*128)/(m_pMapData->m_sMapSizeX);
				m_pSprite[DEF_SPRID_INTERFACE_MONSTER]->PutSpriteFast(sX + shX, sY + shY, m_sMonsterID, m_dwCurTime);
			}
		}else
		{	m_dwMonsterEventTime = 0;
			m_sMonsterID = 0;
	}	}

	if( cLB != 0 ) return;
	if( msX >= sX && msX < sX+szY && msY >= sY && msY < sY+szY )
	{
		if( sY > 213 ) shY = sY - 17;
		else shY = sY + szY + 4;
		if( m_bZoomMap ) PutString( sX, shY, DEF_MSG_GUIDEMAP_MIN, RGB(200, 200, 120) );//"(-)
		else PutString( sX, shY, DEF_MSG_GUIDEMAP_MAX, RGB(200, 200, 120) );//"(+)

		if( m_bZoomMap )
		{
			shX = m_sPlayerX-64;
			shY = m_sPlayerY-64;
			if( shX < 0 ) shX = 0;
			if( shY < 0 ) shY = 0;
			if( shX > m_pMapData->m_sMapSizeX-128 ) shX = m_pMapData->m_sMapSizeX-128;
			if( shY > m_pMapData->m_sMapSizeY-128 ) shY = m_pMapData->m_sMapSizeY-128;
			shX += msX - sX;
			shY += msY - sY;
		}else
		{	shX = (msX-sX)*m_pMapData->m_sMapSizeX/128;
			shY = (msY-sY)*m_pMapData->m_sMapSizeX/128;
		}
		wsprintf( G_cTxt, "%d, %d", shX, shY );
		if( m_cMapIndex == 11 ) // Aresden: Fixed by Snoopy for v3.51 maps
		{	if( shX >  46 && shX <  66 && shY > 107 && shY < 127 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_MAGICTOWER );
			else if( shX > 103 && shX < 123 && shY > 86 && shY < 116 )  strcpy( G_cTxt, DEF_MSG_MAPNAME_GUILDHALL );
			else if( shX > 176 && shX < 196 && shY >  62 && shY < 82 )  strcpy( G_cTxt, DEF_MSG_MAPNAME_CATH );
			else if( shX > 135 && shX < 155 && shY > 113 && shY < 133 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_CITYHALL );
			else if( shX > 97 && shX < 117  && shY > 175 && shY < 195 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_WAREHOUSE );
			else if( shX > 223 && shX < 243 && shY > 124 && shY < 144 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_WAREHOUSE );
			else if( shX > 118 && shX < 138 && shY > 157 && shY < 177 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_SHOP );
			else if( shX > 148 && shX < 178 && shY > 188 && shY < 208 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_BLACKSMITH );
			else if( shX > 69 && shX < 89   && shY > 199 && shY < 219 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_DUNGEON );
			else if( shX > 21 && shX < 41  && shY > 266  && shY < 286 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_HUNT);
			else if( shX > 20 && shX < 40  && shY > 13   && shY < 33 )  strcpy( G_cTxt, DEF_MSG_MAPNAME_ML );
			else if( shX > 246 && shX < 266 && shY > 16  && shY < 36 )  strcpy( G_cTxt, DEF_MSG_MAPNAME_ML );
			else if( shX > 265 && shX < 285 && shY > 195 && shY < 215 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_FARM);
			else if( shX > 88 && shX < 108 && shY > 150  && shY < 170 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_CMDHALL );
		}else if( m_cMapIndex == 3 ) // Elvine: Fixed by Snoopy for v3.51 maps
		{	if( shX >  170 && shX < 190 && shY >  65 && shY < 85 )      strcpy( G_cTxt, DEF_MSG_MAPNAME_MAGICTOWER );
			else if( shX >  67 && shX < 87 && shY > 130 && shY < 150 )  strcpy( G_cTxt, DEF_MSG_MAPNAME_GUILDHALL );
			else if( shX > 121 && shX < 141 && shY >  66 && shY < 86 )  strcpy( G_cTxt, DEF_MSG_MAPNAME_CATH );
			else if( shX > 135 && shX < 155 && shY > 117 && shY < 137 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_CITYHALL );
			else if( shX > 190 && shX < 213 && shY > 118 && shY < 138 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_WAREHOUSE );
			else if( shX > 73  && shX < 103 && shY > 165 && shY < 185 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_WAREHOUSE );
			else if( shX > 217 && shX < 237 && shY > 142 && shY < 162 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_SHOP );
			else if( shX > 216 && shX < 256 && shY > 99  && shY < 119 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_BLACKSMITH );
			else if( shX > 251 && shX < 271 && shY >  73 && shY < 93 )  strcpy( G_cTxt, DEF_MSG_MAPNAME_DUNGEON );
			else if( shX > 212 && shX < 232 && shY > 13  && shY < 33 )  strcpy( G_cTxt, DEF_MSG_MAPNAME_HUNT);
			else if( shX > 16 && shX < 36   && shY > 262 && shY < 282 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_ML );
			else if( shX > 244 && shX < 264 && shY > 248 && shY < 268 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_ML );
			else if( shX > 264 && shX < 284 && shY > 177 && shY < 207 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_FARM);
			else if( shX > 207 && shX < 227 && shY > 79  && shY < 99 )  strcpy( G_cTxt, DEF_MSG_MAPNAME_CMDHALL );
		}
		else if( m_cMapIndex == 5 ) // Elvine Farm: Fixed by Snoopy for v3.51 maps
		{	if( shX >  62 && shX < 82 && shY >  187 && shY < 207 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_WAREHOUSE );
			else if( shX > 81  && shX < 101 && shY > 169 && shY < 189 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_SHOP );
			else if( shX > 101 && shX < 131 && shY > 180 && shY < 200 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_BLACKSMITH );
			else if( shX > 130 && shX < 150 && shY > 195 && shY < 215 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_DUNGEON );
			else if( shX > 86  && shX < 106 && shY > 139 && shY < 159 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_BARRACK );
		}
		else if( m_cMapIndex == 6 ) // Areden's Farm: Fixed by Snoopy for v3.51 maps
		{	if( shX >  30 && shX < 50 && shY >  80 && shY < 100 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_WAREHOUSE );
			else if( shX > 55 && shX < 85 && shY > 80 && shY < 100 )  strcpy( G_cTxt, DEF_MSG_MAPNAME_BLACKSMITH );
			else if( shX > 52 && shX < 72 && shY > 80 && shY < 100 )  strcpy( G_cTxt, DEF_MSG_MAPNAME_SHOP );
			else if( shX > 70 && shX < 90 && shY > 60 && shY < 80 )   strcpy( G_cTxt, DEF_MSG_MAPNAME_DUNGEON );
			else if( shX > 45 && shX < 65 && shY > 123 && shY < 143 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_BARRACK );
		}
		else if ( m_cMapIndex == 42 ) // Stadium
		{	if     ( shX > 41 && shX < 57  && shY > 63  && shY < 77 )  strcpy( G_cTxt, DEF_MSG_MAPNAME_SIDE_ARESDEN );
			else if( shX > 83 && shX < 99  && shY > 38  && shY < 52 )  strcpy( G_cTxt, DEF_MSG_MAPNAME_SIDE_ELVINE );
			else if( shX > 29 && shX < 40  && shY > 103 && shY < 112 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_DUELGRAVE );
			else if( shX > 80 && shX < 103 && shY > 103 && shY < 120 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_FIELD );
		}
		else if ( m_cMapIndex == 41 ) // lost (Equilibrium city)
		{	if     ( shX > 192 && shX < 202 && shY > 165 && shY < 175 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_WAREHOUSE );
			else if( shX > 145 && shX < 155 && shY > 190 && shY < 200 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_BLACKSMITH );
			else if( shX > 136 && shX < 146 && shY > 162 && shY < 172 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_SHOP );
			else if( shX > 203 && shX < 213 && shY > 140 && shY < 150 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_MAGICTOWER );
			else if( shX > 80  && shX < 100 && shY > 164 && shY < 177 ) strcpy( G_cTxt, "Eldiniel's Church" );
			else if( shX > 92  && shX < 108 && shY > 107 && shY < 120 ) strcpy( G_cTxt, "Aresien's Temple" );
			else if( shX > 55  && shX < 65  && shY > 141 && shY < 151 ) strcpy( G_cTxt, "Mayor's Warehouse");
			else if( shX > 204 && shX < 224 && shY > 18  && shY < 28  ) strcpy( G_cTxt, "Qu's marsh" );
			else if( shX > 223 && shX < 233 && shY > 28  && shY < 33  ) strcpy( G_cTxt, DEF_MSG_MAPNAME_DUNGEON);
			else if( shX > 43  && shX < 63  && shY > 250 && shY < 265 ) strcpy( G_cTxt, DEF_MSG_MAPNAME_HUNT);
		}
		PutString( msX-10, msY-13, G_cTxt, RGB(200, 200, 120) );
	}
}

void CGame::DrawDialogBoxs(short msX, short msY, short msZ, char cLB)
{
 int i;
	if (m_bIsObserverMode == TRUE) return;
	m_DInput.m_sZ = 0;
	//Snoopy: 41->61
	for (i = 0; i < 61; i++)
	if (m_cDialogBoxOrder[i] != NULL)
	{	switch (m_cDialogBoxOrder[i]) {
		case 1:
			//DrawDialogBox_Character(msX, msY); //@@@
			DrawDialogBox_Character(msX, msY);
			break;
		case 2:
			DrawDialogBox_Inventory(msX, msY); //@@@
			break;
		case 3:
			DrawDialogBox_Magic(msX, msY, msZ); //@@@
			break;
		case 4:
			DrawDialogBox_ItemDrop(msX, msY); //@@@
			break;
		case 5:
			DrawDialogBox_15AgeMsg(msX, msY); //@@@
			break;
		case 6:
			DrawDialogBox_WarningMsg(msX, msY); //@@@
			break;
		case 7:
			DrawDialogBox_GuildMenu(msX, msY);
			break;
		case 8:
			DrawDialogBox_GuildOperation(msX, msY);
			break;
		case 9:
			DrawDialogBox_GuideMap(msX, msY, cLB);
			break;
		case 10:
			DrawDialogBox_Chat(msX, msY, msZ, cLB); //@@@
			break;
		case 11:
			DrawDialogBox_Shop(msX, msY, msZ, cLB); //@@@
			break;
		case 12:
			DrawDialogBox_LevelUpSetting(msX, msY); //@@@
			break;
		case 13:
			DrawDialogBox_CityHallMenu(msX, msY);
			break;
		case 14:
			DrawDialogBox_Bank(msX, msY, msZ, cLB); //@@@
			break;
		case 15:
			DrawDialogBox_Skill(msX, msY, msZ, cLB); //@@@
			break;
		case 16:
			DrawDialogBox_MagicShop(msX, msY, msZ); //@@@
			break;
		case 17:
			DrawDialogBox_QueryDropItemAmount();
			break;
		case 18:
			DrawDialogBox_Text(msX, msY, msZ, cLB); //@@@
			break;
		case 19:
			DrawDialogBox_SysMenu(msX, msY, cLB); //@@@
			break;
		case 20:
			DrawDialogBox_NpcActionQuery(msX, msY); //@@@
			break;
		case 21:
			DrawDialogBox_NpcTalk(msX, msY, cLB); //@@@
			break;
		case 22:
			DrawDialogBox_Map();
			break;
		case 23:
			DrawDialogBox_SellorRepairItem(msX, msY); //@@@
			break;
		case 24:
			DrawDialogBox_Fishing(msX, msY);
			break;
		case 25:
			DrawDialogBox_ShutDownMsg(msX, msY); //@@@
			break;
		case 26: // Manuf
			DrawDialogBox_SkillDlg(msX, msY, msZ, cLB);
			break;
		case 27:
			DrawDialogBox_Exchange(msX, msY); //@@@
			break;
		case 28:
			DrawDialogBox_Quest(msX, msY); //@@@
			break;
		case 29:
			DrawDialogBox_GaugePannel(); //@@@
			break;
		case 30:
			DrawDialogBox_IconPannel(msX, msY); //@@@
			break;
		case 31:
			DrawDialogBox_SellList(msX, msY); //@@@
			break;
		case 32:
			DrawDialogBox_Party(msX, msY); //@@@
			break;
		case 33:
			DrawDialogBox_CrusadeJob(msX, msY); //@@@
			break;
		case 34:
			DrawDialogBox_ItemUpgrade(msX, msY);
			break;
		case 35:
			DrawDialogBox_Help(msX, msY); //@@@
			break;
		case 36:
			DrawDialogBox_Commander(msX, msY); //@@@
			break;
		case 37:
			DrawDialogBox_Constructor(msX, msY); //@@@
			break;
		case 38:
			DrawDialogBox_Soldier(msX, msY); //@@@
			break;
		case 40:
			DrawDialogBox_Slates(msX, msY, msZ, cLB);
			break;
		case 41:	//Snoopy: Confirmation Exchange
			DrawDialogBox_ConfirmExchange(msX, msY);
			break;
		case 42:
			DrawDialogBox_ChangeStatsMajestic(msX, msY);
			break;
		case 50: // Snoopy: Resurection?
			DrawDialogBox_Resurect(msX, msY);
			break;
		case 51: // Gail
			DrawDialogBox_CMDHallMenu(msX, msY);
			break;
		}
	}
	if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
	{ 	if (m_iSuperAttackLeft > 0)
		{	if (GetAsyncKeyState(VK_MENU)>>15)
				m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutTransSprite(368, 439, 3, m_dwCurTime);
			wsprintf(G_cTxt, "%d", m_iSuperAttackLeft);
			PutString_SprFont2(380, 454, G_cTxt, 220, 200, 200);
		}
	}else
	{	if (m_iSuperAttackLeft > 0)
		{	wsprintf(G_cTxt, "%d", m_iSuperAttackLeft);
			PutString_SprFont2(380, 454, G_cTxt, 10, 10, 10);
	}	}
}

void CGame::_Draw_CharacterBody(short sX, short sY, short sType)
{
 DWORD dwTime = m_dwCurTime;
 int  iR, iG, iB;

	if (sType <= 3)
	{	m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 0]->PutSpriteFast(sX, sY,  sType-1, dwTime);
		_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18]->PutSpriteRGB(sX, sY, (_tmp_sAppr1 & 0x0F00) >> 8, iR, iG, iB, dwTime);

		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19]->PutSpriteFast(sX, sY, (_tmp_sAppr1 & 0x000F), dwTime);
	}else
	{	m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 40]->PutSpriteFast(sX, sY, sType-4, dwTime);
		_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18 +40]->PutSpriteRGB(sX, sY, (_tmp_sAppr1 & 0x0F00) >> 8, iR, iG, iB, dwTime);
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19 +40]->PutSpriteFast(sX, sY, (_tmp_sAppr1 & 0x000F), dwTime);
	}
}


void CGame::EnableDialogBox(int iBoxID, int cType, int sV1, int sV2, char * pString)
{
 int i;
 short sX, sY;

	switch (iBoxID) {
	case 11:
		if (m_bIsDialogEnabled[11] == FALSE)
		{	switch (cType) {
			case NULL:
				break;
			default:
				_LoadShopMenuContents(cType);
				m_stDialogBoxInfo[11].sV1 = cType;
				m_stDialogBoxInfo[11].cMode	= 0;
				m_stDialogBoxInfo[11].sView = 0;
				m_stDialogBoxInfo[11].bFlag = TRUE;
				m_stDialogBoxInfo[11].sV3   = 1;
				break;
		}	}
		break;

	case 12: // levelup diag
		if (m_bIsDialogEnabled[12] == FALSE)
		{	m_stDialogBoxInfo[12].sX = m_stDialogBoxInfo[1].sX + 20;
			m_stDialogBoxInfo[12].sY = m_stDialogBoxInfo[1].sY + 20;
			m_stDialogBoxInfo[12].sV1 = m_iLU_Point;
		}
		break;

	case 3: // Magic Dialog
		break;

	case 4:
		if (m_bIsDialogEnabled[4] == FALSE) {
			m_stDialogBoxInfo[4].sView = cType;
		}
		break;

	case 5:
		if (m_bIsDialogEnabled[5] == FALSE) {
			m_stDialogBoxInfo[5].sView = cType;
		}
		break;

	case 6:
		if (m_bIsDialogEnabled[6] == FALSE) {
			m_stDialogBoxInfo[6].sView = cType;
		}
		break;

	case 7:
		if (m_stDialogBoxInfo[7].cMode == 1) {
			sX = m_stDialogBoxInfo[7].sX;
			sY = m_stDialogBoxInfo[7].sY;
			EndInputString();
			StartInputString(sX + 75, sY + 140, 21, m_cGuildName);
		}
		break;

	case 17: // demande quantité
		if (m_bIsDialogEnabled[17] == FALSE)
		{	m_stDialogBoxInfo[iBoxID].cMode = 1;
			m_stDialogBoxInfo[17].sView	= cType;
			EndInputString();
			ZeroMemory(m_cAmountString, sizeof(m_cAmountString));
			wsprintf( m_cAmountString, "%d", sV1 );
			sX = m_stDialogBoxInfo[17].sX;
			sY = m_stDialogBoxInfo[17].sY;
			StartInputString(sX + 40, sY + 57, 11, m_cAmountString, FALSE);
		}else
		{	if (m_stDialogBoxInfo[17].cMode == 1)
			{	sX = m_stDialogBoxInfo[17].sX;
				sY = m_stDialogBoxInfo[17].sY;
				EndInputString();
				StartInputString(sX + 40, sY + 57, 11, m_cAmountString, FALSE);
		}	}
		break;

	case 18:
		if (m_bIsDialogEnabled[18] == FALSE)
		{	switch (cType) {
			case NULL:
				m_stDialogBoxInfo[18].cMode	= 0;
				m_stDialogBoxInfo[18].sView = 0;
				break;
			default:
				_LoadTextDlgContents(cType);
				m_stDialogBoxInfo[18].cMode	= 0;
				m_stDialogBoxInfo[18].sView = 0;
				break;
		} 	}
		break;

	case 19:
		break;

	case 20: // Talk to npc or unicorn
		m_bIsItemDisabled[m_stDialogBoxInfo[20].sV1] = FALSE;
		if (m_bIsDialogEnabled[20] == FALSE)
		{	m_stDialogBoxInfo[11].sV1 = m_stDialogBoxInfo[11].sV2 = m_stDialogBoxInfo[11].sV3 =
			m_stDialogBoxInfo[11].sV4 = m_stDialogBoxInfo[11].sV5 = m_stDialogBoxInfo[11].sV6 = NULL;
			m_stDialogBoxInfo[20].cMode	= cType;
			m_stDialogBoxInfo[20].sView = 0;
			m_stDialogBoxInfo[20].sV1 = sV1;
			m_stDialogBoxInfo[20].sV2 = sV2;
		}
		break;

	case 21:
		if (m_bIsDialogEnabled[21] == FALSE)
		{	m_stDialogBoxInfo[21].cMode	= cType;
			m_stDialogBoxInfo[21].sView = 0;
			m_stDialogBoxInfo[21].sV1 = _iLoadTextDlgContents2(sV1+20);
			m_stDialogBoxInfo[21].sV2 = sV1+20;
		}
		break;

	case 22:
		if (m_bIsDialogEnabled[22] == FALSE) {
			m_stDialogBoxInfo[22].sV1 = sV1;
			m_stDialogBoxInfo[22].sV2 = sV2;

			m_stDialogBoxInfo[22].sSizeX = 290;
			m_stDialogBoxInfo[22].sSizeY = 290;
		}
		break;

	case 23:
		if (m_bIsDialogEnabled[23] == FALSE) {
			m_stDialogBoxInfo[23].cMode	= cType;
			m_stDialogBoxInfo[23].sV1   = sV1;		// ItemID
			m_stDialogBoxInfo[23].sV2   = sV2;
			if( cType == 2 )
			{	m_stDialogBoxInfo[23].sX = m_stDialogBoxInfo[11].sX;
				m_stDialogBoxInfo[23].sY = m_stDialogBoxInfo[11].sY;
			}
		}
		break;

	case 15:
		break;

	case 24:
		if (m_bIsDialogEnabled[24] == FALSE)
		{	m_stDialogBoxInfo[24].cMode	= cType;
			m_stDialogBoxInfo[24].sV1   = sV1;
			m_stDialogBoxInfo[24].sV2   = sV2;
			m_bSkillUsingStatus = TRUE;
		}
		break;

	case 25:
		if (m_bIsDialogEnabled[25] == FALSE) {
			m_stDialogBoxInfo[25].cMode	= cType;
			m_stDialogBoxInfo[25].sV1   = sV1;
			m_stDialogBoxInfo[25].sV2   = sV2;
		}
		break;

	case 26:
		switch (cType) {
		case 1:
		case 2: //
			if (m_bIsDialogEnabled[26] == FALSE)
			{	m_stDialogBoxInfo[26].cMode	= cType;
				m_stDialogBoxInfo[26].sV1   = -1;
				m_stDialogBoxInfo[26].sV2   = -1;
				m_stDialogBoxInfo[26].sV3   = -1;
				m_stDialogBoxInfo[26].sV4   = -1;
				m_stDialogBoxInfo[26].sV5   = -1;
				m_stDialogBoxInfo[26].sV6   = -1;
				m_stDialogBoxInfo[26].cStr[0] = 0;
				m_bSkillUsingStatus = TRUE;
				m_stDialogBoxInfo[26].sSizeX = 195;
				m_stDialogBoxInfo[26].sSizeY = 215;
				DisableDialogBox(17);
				DisableDialogBox(20);
				DisableDialogBox(23);
			}
			break;

		case 3:	//
			if (m_bIsDialogEnabled[26] == FALSE) 
			{	m_stDialogBoxInfo[26].sView = 0;
				m_stDialogBoxInfo[26].cMode	= cType;
				m_stDialogBoxInfo[26].sV1   = -1;
				m_stDialogBoxInfo[26].sV2   = -1;
				m_stDialogBoxInfo[26].sV3   = -1;
				m_stDialogBoxInfo[26].sV4   = -1;
				m_stDialogBoxInfo[26].sV5   = -1;
				m_stDialogBoxInfo[26].sV6   = -1;
				m_stDialogBoxInfo[26].cStr[0] = 0;
				m_stDialogBoxInfo[26].cStr[1] = 0;
				m_stDialogBoxInfo[26].cStr[4] = 0;
				m_bSkillUsingStatus = TRUE;
				_bCheckBuildItemStatus();
				//m_stDialogBoxInfo[26].sX = 0;
				//m_stDialogBoxInfo[26].sY = 0;
				m_stDialogBoxInfo[26].sSizeX = 270;
				m_stDialogBoxInfo[26].sSizeY = 381;
				DisableDialogBox(17);
				DisableDialogBox(20);
				DisableDialogBox(23);
			}
			break;

		case 6:
			if (m_bIsDialogEnabled[26] == FALSE)
			{	m_stDialogBoxInfo[26].cMode	= cType;
				m_stDialogBoxInfo[26].cStr[2] = sV1;
				m_stDialogBoxInfo[26].cStr[3] = sV2;
				m_stDialogBoxInfo[26].sSizeX = 270;
				m_stDialogBoxInfo[26].sSizeY = 381;
				m_bSkillUsingStatus = TRUE;
				_bCheckBuildItemStatus();
				DisableDialogBox(17);
				DisableDialogBox(20);
				DisableDialogBox(23);
			}
			break;
		// Crafting
		case 7:
		case 8:
			if (m_bIsDialogEnabled[26] == FALSE)
			{	m_stDialogBoxInfo[26].cMode	= cType;
				m_stDialogBoxInfo[26].sV1   = -1;
				m_stDialogBoxInfo[26].sV2   = -1;
				m_stDialogBoxInfo[26].sV3   = -1;
				m_stDialogBoxInfo[26].sV4   = -1;
				m_stDialogBoxInfo[26].sV5   = -1;
				m_stDialogBoxInfo[26].sV6   = -1;
				m_stDialogBoxInfo[26].cStr[0] = 0;
				m_stDialogBoxInfo[26].cStr[1] = 0;
				m_bSkillUsingStatus = TRUE;
				//_bCheckCraftItemStatus();
				m_stDialogBoxInfo[26].sSizeX = 195;
				m_stDialogBoxInfo[26].sSizeY = 215;
				DisableDialogBox(17);
				DisableDialogBox(20);
				DisableDialogBox(23);
			}
			break;
		}
		break;

	case 27: // Snoopy: 7 mar 06 (multitrade) case rewriten
		if (m_bIsDialogEnabled[27] == FALSE)
		{	m_stDialogBoxInfo[27].cMode = cType;
			for (i=0; i<8;i++)
			{	ZeroMemory(m_stDialogBoxExchangeInfo[i].cStr1, sizeof(m_stDialogBoxExchangeInfo[i].cStr1));
				ZeroMemory(m_stDialogBoxExchangeInfo[i].cStr2, sizeof(m_stDialogBoxExchangeInfo[i].cStr2));
				m_stDialogBoxExchangeInfo[i].sV1 = -1;
				m_stDialogBoxExchangeInfo[i].sV2 = -1;
				m_stDialogBoxExchangeInfo[i].sV3 = -1;
				m_stDialogBoxExchangeInfo[i].sV4 = -1;
				m_stDialogBoxExchangeInfo[i].sV5 = -1;
				m_stDialogBoxExchangeInfo[i].sV6 = -1;
				m_stDialogBoxExchangeInfo[i].sV7 = -1;
				m_stDialogBoxExchangeInfo[i].dwV1 = 0;
			}
			DisableDialogBox(17);
			DisableDialogBox(20);
			DisableDialogBox(23);
			DisableDialogBox(26);
		}
		break;

	case 41: // Snoopy: 7 mar 06 (MultiTrade) Confirmation dialog
		break;

	case 28:
		if (m_bIsDialogEnabled[28] == FALSE) {
			m_stDialogBoxInfo[28].cMode = cType;
			m_stDialogBoxInfo[28].sX = m_stDialogBoxInfo[1].sX + 20;
			m_stDialogBoxInfo[28].sY = m_stDialogBoxInfo[1].sY + 20;
		}
		break;

	case 32:
		if (m_bIsDialogEnabled[32] == FALSE) {
			m_stDialogBoxInfo[32].cMode = cType;
			m_stDialogBoxInfo[32].sX = m_stDialogBoxInfo[1].sX + 20;
			m_stDialogBoxInfo[32].sY = m_stDialogBoxInfo[1].sY + 20;
		}
		break;

	case 33:
		 if ((m_iHP <= 0) || (m_bCitizen==FALSE)) return;
		if (m_bIsDialogEnabled[33] == FALSE)
		{	m_stDialogBoxInfo[33].cMode = cType;
			m_stDialogBoxInfo[33].sX  = 360;
			m_stDialogBoxInfo[33].sY  = 65;
			m_stDialogBoxInfo[33].sV1 = sV1;
		}
		break;


#ifdef DEF_EQUILIBRIUM_PROJECT // Item upgrade
	case 34:
		if (m_bIsDialogEnabled[34] == FALSE)
		{	int iSoX, iSoM, iSoO, iSoE;
			iSoX = iSoM = iSoO = iSoE = 0;
			int iOilIndex, iElixirIndex;
			iOilIndex = iElixirIndex = -1;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pItemList[i] != NULL)
			{	if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 128)) iSoX++;
				if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 129)) iSoM++;
				if (   (m_pItemList[i]->m_cItemType != DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) // Strange stone to enchant Ancient weapon
					&& ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 163)))
				{	iOilIndex = i;
					iSoO++;
				}
				if (   (m_pItemList[i]->m_cItemType != DEF_ITEMTYPE_EAT) // Not a summon potions
					&& (m_pItemList[i]->m_sSprite == 6)
					&& (m_pItemList[i]->m_sSpriteFrame >= 108)
					&& (m_pItemList[i]->m_sSpriteFrame <= 112))
				{	int len = strlen(m_pItemList[i]->m_cName) -6;
					if (len <=0)
					{	iOilIndex = i;
						iSoO++;
					}else
					{	if (strcmp (m_pItemList[i]->m_cName + len, "Elixir") == 0)
						{	iElixirIndex = i;
							iSoE++; // Elixir
						}else
						{	iOilIndex = i;
							iSoO++;
				}	}	}
				if (   (m_pItemList[i]->m_cItemType != DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) // Not Slate
					&& (m_pItemList[i]->m_sSprite == 6)
					&& (m_pItemList[i]->m_sSpriteFrame == 155))
				{	iOilIndex = i;
					iSoO++;
			}	}
			if (   ((iSoX > 0) || (iSoM > 0))
				&& (iSoO == 0))
			{	m_stDialogBoxInfo[34].cMode = 6; // Upgrade with Xelima/Merien
				m_stDialogBoxInfo[34].sV1  = -1;
				m_stDialogBoxInfo[34].sV2  = iSoX;
				m_stDialogBoxInfo[34].sV3  = iSoM;
				m_stDialogBoxInfo[34].sV4  = -1;
				m_stDialogBoxInfo[34].sV5  = -1;
				m_stDialogBoxInfo[34].sV6  = -1;
				m_stDialogBoxInfo[34].sV7  = -1;
				m_stDialogBoxInfo[34].dwV1 = NULL;
			}else if ( (iSoX == 0) && (iSoM == 0)
					&& (iSoO == 1) && (iSoE <= 1))
			{	m_stDialogBoxInfo[34].cMode = 11; // Alchemy Upgrade
				m_stDialogBoxInfo[34].sV1  = -1;
				m_stDialogBoxInfo[34].sV2  = -1;
				m_stDialogBoxInfo[34].sV3  = -1;
				m_stDialogBoxInfo[34].sV4  = iOilIndex;
				m_stDialogBoxInfo[34].sV5  = iElixirIndex;
				m_stDialogBoxInfo[34].sV6  = -1;
				m_stDialogBoxInfo[34].sV7  = -1;
				m_stDialogBoxInfo[34].dwV1 = NULL;
			}else if ( (iSoX == 0) && (iSoM == 0) && (iSoO == 0)
					&& (m_iGizonItemUpgradeLeft >0))
			{	m_stDialogBoxInfo[34].cMode = 1; // gizon upgrade
				m_stDialogBoxInfo[34].sV1  = -1;
				m_stDialogBoxInfo[34].sV2  = -1;
				m_stDialogBoxInfo[34].sV3  = -1;
				m_stDialogBoxInfo[34].sV4  = -1;
				m_stDialogBoxInfo[34].sV5  = -1;
				m_stDialogBoxInfo[34].sV6  = -1;
				m_stDialogBoxInfo[34].sV7  = -1;
				m_stDialogBoxInfo[34].dwV1 = NULL;
			}else
			{	m_stDialogBoxInfo[34].cMode = 5; // Main menu
				m_stDialogBoxInfo[34].sV1  = -1;
				m_stDialogBoxInfo[34].sV2  = iSoX;
				m_stDialogBoxInfo[34].sV3  = iSoM;
				m_stDialogBoxInfo[34].sV4  = iOilIndex;
				m_stDialogBoxInfo[34].sV5  = iElixirIndex;
				m_stDialogBoxInfo[34].sV6  = iSoX + iSoM;
				if      (iSoO == 0) m_stDialogBoxInfo[34].sV7 = 0; // No Oil present
				else if (iSoO > 1)  m_stDialogBoxInfo[34].sV7 = 1; // Too much Oil error
				else if (iSoE > 1)  m_stDialogBoxInfo[34].sV7 = 2; // Too much Elixir error
				else                m_stDialogBoxInfo[34].sV7 = 3; // Correct Ol/Elixir
				m_stDialogBoxInfo[34].dwV1 = NULL;
		}	}
		break;
#else
	case 34:
		if (m_bIsDialogEnabled[34] == FALSE)
		{	int iSoX, iSoM;
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pItemList[i] != NULL)
			{	if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 128)) iSoX++;
				if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 129)) iSoM++;
			}
			if ((iSoX > 0) || (iSoM > 0))
			{	m_stDialogBoxInfo[34].cMode = 6; // Stone upgrade
				m_stDialogBoxInfo[34].sV2 = iSoX;
				m_stDialogBoxInfo[34].sV3 = iSoM;
				m_stDialogBoxInfo[34].sV1  = -1;
				m_stDialogBoxInfo[34].dwV1 = NULL;
			}else if (m_iGizonItemUpgradeLeft >0)
			{	m_stDialogBoxInfo[34].cMode = 1;
				m_stDialogBoxInfo[34].sV2 = -1;
				m_stDialogBoxInfo[34].sV3 = -1;
				m_stDialogBoxInfo[34].sV1  = -1;
				m_stDialogBoxInfo[34].dwV1 = NULL;
			}else
			{	AddEventList(DRAW_DIALOGBOX_ITEMUPGRADE30, 10); // "Stone of Xelima or Merien is not present."
				return;
		}	}
		break;
#endif

	case 16:
		if (m_bIsDialogEnabled[iBoxID]  == FALSE) {
			if (m_cSkillMastery[4] == 0) {
				 DisableDialogBox(16);
				 EnableDialogBox(21, 0, 480, 0);
				 return;
			}
			else {
				m_stDialogBoxInfo[iBoxID].cMode = 0;
				m_stDialogBoxInfo[iBoxID].sView = 0;
			}
		}
		break;

	case 14:
		EndInputString();
		if (m_bIsDialogEnabled[iBoxID]  == FALSE) {
			m_stDialogBoxInfo[iBoxID].cMode	= 0;
			m_stDialogBoxInfo[iBoxID].sView = 0;
			EnableDialogBox(2, NULL, NULL, NULL);
		}
		break;

	case 40: // Slates
		if (m_bIsDialogEnabled[40] == FALSE) {
			m_stDialogBoxInfo[40].sView = 0;
			m_stDialogBoxInfo[40].cMode	= cType;
			m_stDialogBoxInfo[40].sV1   = -1;
			m_stDialogBoxInfo[40].sV2   = -1;
			m_stDialogBoxInfo[40].sV3   = -1;
			m_stDialogBoxInfo[40].sV4   = -1;
			m_stDialogBoxInfo[40].sV5   = -1;
			m_stDialogBoxInfo[40].sV6   = -1;
			m_stDialogBoxInfo[40].cStr[0] = 0;
			m_stDialogBoxInfo[40].cStr[1] = 0;
			m_stDialogBoxInfo[40].cStr[4] = 0;

			m_stDialogBoxInfo[40].sSizeX = 180;
			m_stDialogBoxInfo[40].sSizeY = 183;

			DisableDialogBox(17);
			DisableDialogBox(20);
			DisableDialogBox(23);
			DisableDialogBox(26);
		}
		break;
	case 42: // Diuuude: Change stats window
		if (m_bIsDialogEnabled[42] == FALSE) {
			m_stDialogBoxInfo[42].sX = m_stDialogBoxInfo[12].sX+10;
			m_stDialogBoxInfo[42].sY = m_stDialogBoxInfo[12].sY+10;
			m_stDialogBoxInfo[42].cMode	= 0;
			m_stDialogBoxInfo[42].sView = 0;
			m_bSkillUsingStatus = FALSE;
		}
		break;
	case 50: // Snoopy: Resurection
		if (m_bIsDialogEnabled[50] == FALSE)
		{	m_stDialogBoxInfo[50].sX = 185;
			m_stDialogBoxInfo[50].sY = 100;
			m_stDialogBoxInfo[50].cMode	= 0;
			m_stDialogBoxInfo[50].sView = 0;
			m_bSkillUsingStatus = FALSE;
		}
		break;

	default:
		EndInputString();
		if (m_bIsDialogEnabled[iBoxID]  == FALSE) {
			m_stDialogBoxInfo[iBoxID].cMode	= 0;
			m_stDialogBoxInfo[iBoxID].sView = 0;
		}
		break;
	}
	if( iBoxID != 30 )
	{	if (m_bIsDialogEnabled[iBoxID]  == FALSE)
		{	if( m_stDialogBoxInfo[iBoxID].sY > 400 ) m_stDialogBoxInfo[iBoxID].sY = 410;
			if( m_stDialogBoxInfo[iBoxID].sX > 620 ) m_stDialogBoxInfo[iBoxID].sX = 620;
			if( (m_stDialogBoxInfo[iBoxID].sX+m_stDialogBoxInfo[iBoxID].sSizeX) < 10 ) m_stDialogBoxInfo[iBoxID].sX += 20;
			if( (m_stDialogBoxInfo[iBoxID].sY+m_stDialogBoxInfo[iBoxID].sSizeY) < 10 ) m_stDialogBoxInfo[iBoxID].sY += 20;
	}	}
	m_bIsDialogEnabled[iBoxID] = TRUE;
	if (pString != NULL) strcpy(m_stDialogBoxInfo[iBoxID].cStr, pString);
	//Snoopy: 39->59
	for (i = 0; i < 59; i++)
	if (m_cDialogBoxOrder[i] == iBoxID) m_cDialogBoxOrder[i] = NULL;
	//Snoopy: 39->59
	for (i = 1; i < 59; i++)
	if ((m_cDialogBoxOrder[i-1] == NULL) && (m_cDialogBoxOrder[i] != NULL)) {
		m_cDialogBoxOrder[i-1] = m_cDialogBoxOrder[i];
		m_cDialogBoxOrder[i] = NULL;
	}
	//Snoopy: 39->59
	for (i = 0; i < 59; i++)
	if (m_cDialogBoxOrder[i] == NULL) {
		m_cDialogBoxOrder[i] = iBoxID;
		return;
	}
}

void CGame::DisableDialogBox(int iBoxID)
{
 int i;

	switch (iBoxID) {
	case 4:
		m_bIsItemDisabled[m_stDialogBoxInfo[4].sView] = FALSE;
		break;

	case 5:
		m_bIsItemDisabled[m_stDialogBoxInfo[5].sView] = FALSE;
		break;

	case 6:
		m_bIsItemDisabled[m_stDialogBoxInfo[6].sView] = FALSE;
		break;

	case 7:
		if (m_stDialogBoxInfo[7].cMode == 1)
			EndInputString();
		m_stDialogBoxInfo[7].cMode = 0;
		break;

	case 11:
		for (i = 0; i < DEF_MAXMENUITEMS; i++)
		if (m_pItemForSaleList[i] != NULL) 
		{	delete m_pItemForSaleList[i];
			m_pItemForSaleList[i] = NULL;
		}
		m_stDialogBoxInfo[39].sV3 = 0;
		m_stDialogBoxInfo[39].sV4 = 0; // v1.4
		m_stDialogBoxInfo[39].sV5 = 0;
		m_stDialogBoxInfo[39].sV6 = 0;
		break;

	case 14:
		if (m_stDialogBoxInfo[14].cMode < 0) return;
		break;

	case 17:
		if (m_stDialogBoxInfo[17].cMode == 1) {
			EndInputString();
			m_bIsItemDisabled[m_stDialogBoxInfo[17].sView] = FALSE;
		}
		break;

	case 20: // v1.4
		m_bIsItemDisabled[m_stDialogBoxInfo[20].sV1] = FALSE;
		break;

	case 21:
		if (m_stDialogBoxInfo[21].sV2 == 500)
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GETMAGICABILITY, NULL, NULL, NULL, NULL, NULL);
		}
		break;

	case 24:
		m_bSkillUsingStatus = FALSE;
		break;

	case 26:
		if (m_stDialogBoxInfo[26].sV1 != -1) m_bIsItemDisabled[m_stDialogBoxInfo[26].sV1] = FALSE;
		if (m_stDialogBoxInfo[26].sV2 != -1) m_bIsItemDisabled[m_stDialogBoxInfo[26].sV2] = FALSE;
		if (m_stDialogBoxInfo[26].sV3 != -1) m_bIsItemDisabled[m_stDialogBoxInfo[26].sV3] = FALSE;
		if (m_stDialogBoxInfo[26].sV4 != -1) m_bIsItemDisabled[m_stDialogBoxInfo[26].sV4] = FALSE;
		if (m_stDialogBoxInfo[26].sV5 != -1) m_bIsItemDisabled[m_stDialogBoxInfo[26].sV5] = FALSE;
		if (m_stDialogBoxInfo[26].sV6 != -1) m_bIsItemDisabled[m_stDialogBoxInfo[26].sV6] = FALSE;
		m_bSkillUsingStatus = FALSE;
		break;

	case 27: //Snoopy: 7 mar 06 (multiTrade) case rewriten
		for (i=0; i<8;i++)
		{	ZeroMemory(m_stDialogBoxExchangeInfo[i].cStr1, sizeof(m_stDialogBoxExchangeInfo[i].cStr1));
			ZeroMemory(m_stDialogBoxExchangeInfo[i].cStr2, sizeof(m_stDialogBoxExchangeInfo[i].cStr2));
			m_stDialogBoxExchangeInfo[i].sV1 = -1;
			m_stDialogBoxExchangeInfo[i].sV2 = -1;
			m_stDialogBoxExchangeInfo[i].sV3 = -1;
			m_stDialogBoxExchangeInfo[i].sV4 = -1;
			m_stDialogBoxExchangeInfo[i].sV5 = -1;
			m_stDialogBoxExchangeInfo[i].sV6 = -1;
			m_stDialogBoxExchangeInfo[i].sV7 = -1;
			m_stDialogBoxExchangeInfo[i].dwV1 = 0;
			if (m_bIsItemDisabled[m_stDialogBoxExchangeInfo[i].sItemID] == TRUE)
				m_bIsItemDisabled[m_stDialogBoxExchangeInfo[i].sItemID] = FALSE;
		}
		break;


	case 31:
		for (i = 0; i < DEF_MAXSELLLIST; i++)
		{	if (m_stSellItemList[i].iIndex != -1) m_bIsItemDisabled[m_stSellItemList[i].iIndex] = FALSE;
			m_stSellItemList[i].iIndex = -1;
			m_stSellItemList[i].iAmount = 0;
		}
		break;

	case 34:
		if(m_stDialogBoxInfo[34].sV1 != -1)
		m_bIsItemDisabled[m_stDialogBoxInfo[34].sV1] = FALSE;
		break;

	case 40:
		m_bIsItemDisabled[m_stDialogBoxInfo[40].sV1] = FALSE;
		m_bIsItemDisabled[m_stDialogBoxInfo[40].sV2] = FALSE;
		m_bIsItemDisabled[m_stDialogBoxInfo[40].sV3] = FALSE;
		m_bIsItemDisabled[m_stDialogBoxInfo[40].sV4] = FALSE;

		ZeroMemory(m_stDialogBoxInfo[40].cStr, sizeof(m_stDialogBoxInfo[40].cStr));
		ZeroMemory(m_stDialogBoxInfo[40].cStr2, sizeof(m_stDialogBoxInfo[40].cStr2));
		ZeroMemory(m_stDialogBoxInfo[40].cStr3, sizeof(m_stDialogBoxInfo[40].cStr3));
		ZeroMemory(m_stDialogBoxInfo[40].cStr4, sizeof(m_stDialogBoxInfo[40].cStr4));
		m_stDialogBoxInfo[40].sV1   = -1;
		m_stDialogBoxInfo[40].sV2   = -1;
		m_stDialogBoxInfo[40].sV3   = -1;
		m_stDialogBoxInfo[40].sV4   = -1;
		m_stDialogBoxInfo[40].sV5   = -1;
		m_stDialogBoxInfo[40].sV6   = -1;
		m_stDialogBoxInfo[40].sV9   = -1;
		m_stDialogBoxInfo[40].sV10   = -1;
		m_stDialogBoxInfo[40].sV11   = -1;
		m_stDialogBoxInfo[40].sV12   = -1;
		m_stDialogBoxInfo[40].sV13   = -1;
		m_stDialogBoxInfo[40].sV14   = -1;
		m_stDialogBoxInfo[40].dwV1   = 0;
		m_stDialogBoxInfo[40].dwV2   = 0;
		break;

	case 42:
		cStateChange1 = 0;
		cStateChange2 = 0;
		cStateChange3 = 0;
	/*	m_cLU_Str = 0;
		m_cLU_Vit = 0;
		m_cLU_Dex = 0;
		m_cLU_Int = 0;
		m_cLU_Mag = 0;
		m_cLU_Char = 0;*/
		break;

 	}

	m_bIsDialogEnabled[iBoxID] = FALSE;
	// Snoopy: 39->59
	for (i = 0; i < 59; i++)
	if (m_cDialogBoxOrder[i] == iBoxID)
		m_cDialogBoxOrder[i] = NULL;

	// Snoopy: 39->59
	for (i = 1; i < 59; i++)
	if ((m_cDialogBoxOrder[i-1] == NULL) && (m_cDialogBoxOrder[i] != NULL))
	{	m_cDialogBoxOrder[i-1] = m_cDialogBoxOrder[i];
		m_cDialogBoxOrder[i] = NULL;
	}
}


int CGame::iGetTopDialogBoxIndex()
{
 int i;
	//Snoopy: 38->58
	for (i = 58; i >= 0; i--)
	if (m_cDialogBoxOrder[i] != NULL)
		return m_cDialogBoxOrder[i];

	return NULL;
}

void CGame::DlgBoxClick_IconPannel(short msX, short msY)
{ short sX, sY;
	sX = m_stDialogBoxInfo[30].sX;
	sY = m_stDialogBoxInfo[30].sY;
	// CLEROTH - LU
/*	if ((msX > 322)	&& (msX < 355) && (434 < msY) && (475 > msY))
	{	if (m_iLU_Point <= 0) return;
		if (m_bIsDialogEnabled[12] == TRUE)
			 DisableDialogBox(12);
		else EnableDialogBox(12, NULL, NULL, NULL);
		PlaySound('E', 14, 5);
	}*/
	if ((msX > 322)	&& (msX < 355) && (434 < msY) && (475 > msY)) {
		// Crusade
		if (m_bIsCrusadeMode == FALSE) return;
		switch (m_iCrusadeDuty) {
		case 1: // Fighter
			EnableDialogBox(38, NULL, NULL, NULL);
			break;

		case 2: // Constructor
			EnableDialogBox(37, NULL, NULL, NULL);
			break;

		case 3: // Commander
			EnableDialogBox(36, NULL, NULL, NULL);
			break;

		default: break;
		}
		PlaySound('E', 14, 5);
	}

	if ((362 < msX)	&& (404 > msX) && (434 < msY) && (475 > msY)) {
		// Combat Mode Toggle
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLECOMBATMODE, NULL, NULL, NULL, NULL, NULL);
		PlaySound('E', 14, 5);
	}

	// Character
	if ((413 <= msX) && (446 >= msX) && (434 < msY) && (475 > msY)) {
		if (m_bIsDialogEnabled[1] == TRUE)
			 DisableDialogBox(1);
		else EnableDialogBox(1, NULL, NULL, NULL);
		PlaySound('E', 14, 5);
	}

	// Inventory
	if ((453 <= msX) && (486 >= msX) && (434 < msY) && (475 > msY)) {
		if (m_bIsDialogEnabled[2] == TRUE)
			 DisableDialogBox(2);
		else EnableDialogBox(2, NULL, NULL, NULL);
		PlaySound('E', 14, 5);
	}

	// Magic
	if ((490 <= msX) && (522 >= msX) && (434 < msY) && (475 > msY)) {
		if (m_bIsDialogEnabled[3] == TRUE)
			 DisableDialogBox(3);
		else EnableDialogBox(3, NULL, NULL, NULL);
		PlaySound('E', 14, 5);
	}

	// Skill
	if ((526 <= msX) && (552 >= msX) && (434 < msY) && (475 > msY)) {
		if (m_bIsDialogEnabled[15] == TRUE)
			 DisableDialogBox(15);
		else EnableDialogBox(15, NULL, NULL, NULL);
		PlaySound('E', 14, 5);
	}

	// Chat
	if ((556 <= msX) && (587 >= msX) && (434 < msY) && (475 > msY)) {
		if (m_bIsDialogEnabled[10] == TRUE)
			 DisableDialogBox(10);
		else EnableDialogBox(10, NULL, NULL, NULL);
		PlaySound('E', 14, 5);
	}

	// System Menu
	if ((589 <= msX) && (621 >= msX) && (434 < msY) && (475 > msY)) {
		if (m_bIsDialogEnabled[19] == TRUE)
			 DisableDialogBox(19);
		else EnableDialogBox(19, NULL, NULL, NULL);
		PlaySound('E', 14, 5);
	}
}



void CGame::DrawChatMsgs(short sX, short sY, short dX, short dY)
{
 int i;

	for (i = 0; i < DEF_MAXCHATMSGS; i++)
	if (m_pChatMsgList[i] != NULL)
	if ( (m_pChatMsgList[i]->m_sX >= sX) && (m_pChatMsgList[i]->m_sX <= dX) &&
	     (m_pChatMsgList[i]->m_sY >= sY) && (m_pChatMsgList[i]->m_sY <= dY) ) {

		switch (m_pChatMsgList[i]->m_cType) {
		case 41:
		case 42:
		case 21:
		case 22:
		case 23:
			DrawChatMsgBox(m_pChatMsgList[i]->m_sX, m_pChatMsgList[i]->m_sY, i, FALSE);
			break;
		}
	}

	m_DDraw._GetBackBufferDC();
	for (i = 0; i < DEF_MAXCHATMSGS; i++)
	if (m_pChatMsgList[i] != NULL)
	if ( (m_pChatMsgList[i]->m_sX >= sX) && (m_pChatMsgList[i]->m_sX <= dX) &&
	     (m_pChatMsgList[i]->m_sY >= sY) && (m_pChatMsgList[i]->m_sY <= dY) ) {

		switch (m_pChatMsgList[i]->m_cType) {
		case 41:
		case 42:
		case 21:
		case 22:
		case 23:
			break;

		case 20:
		default:
			DrawChatMsgBox(m_pChatMsgList[i]->m_sX, m_pChatMsgList[i]->m_sY, i, TRUE);
			break;
		}
	}
	m_DDraw._ReleaseBackBufferDC();
}



void CGame::_LoadTextDlgContents(int cType)
{char * pContents, * token, cTemp[120], cFileName[120];
 char   seps[] = "\n";
 int    iIndex = 0, i;
 class  CStrTok * pStrTok;
 DWORD  dwFileSize;
 HANDLE hFile;
 FILE * pFile;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{	if (m_pMsgTextList[i] != NULL)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = NULL;
	}
	// cType
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));

	wsprintf(cTemp, "contents%d", cType);
	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFileName, "rt");
	if (pFile == NULL) return;
	else
	{ 	pContents = new char[dwFileSize+1];
		ZeroMemory(pContents, dwFileSize+1);
		fread(pContents, dwFileSize, 1, pFile);
	}
	fclose(pFile);
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL )
	{	m_pMsgTextList[iIndex] = new class CMsg(NULL, token, NULL);
		token = pStrTok->pGet();
		iIndex++;
	}
	delete pStrTok;
	delete[] pContents;
}



int CGame::_iLoadTextDlgContents2(int iType)
{char * pContents, * token, cTemp[120], cFileName[120];
 char   seps[] = "\n";
 int    iIndex = 0, i;
 class  CStrTok * pStrTok;
 DWORD  dwFileSize;
 HANDLE hFile;
 FILE * pFile;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{	if (m_pMsgTextList2[i] != NULL)
			delete m_pMsgTextList2[i];
		m_pMsgTextList2[i] = NULL;
	}
	// cType
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));

	wsprintf(cTemp, "contents%d", iType);

	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");
	hFile = CreateFile(cFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFileName, "rt");
	if (pFile == NULL) return -1;
	else
	{	pContents = new char[dwFileSize+1];
		if (pContents == NULL) return -1;
		ZeroMemory(pContents, dwFileSize+1);
		fread(pContents, dwFileSize, 1, pFile);
	}
	fclose(pFile);
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL )
	{	m_pMsgTextList2[iIndex] = new class CMsg(NULL, token, NULL);
		token = pStrTok->pGet();
		iIndex++;
	}
	delete pStrTok;
	delete[] pContents;
	return iIndex;
}




void CGame::_LoadGameMsgTextContents()
{
 char * pContents, * token, cTemp[120], cFileName[120];
 char   seps[] = ";\n";
 int    iIndex = 0, i;
 class  CStrTok * pStrTok;
 DWORD  dwFileSize;
 HANDLE hFile;
 FILE * pFile;

	for (i = 0; i < DEF_MAXGAMEMSGS; i++) {
		if (m_pGameMsgList[i] != NULL)
			delete m_pGameMsgList[i];
		m_pGameMsgList[i] = NULL;
	}

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));

	strcpy(cTemp, "GameMsgList");

	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == NULL) return;
	else {
		pContents = new char[dwFileSize+1];
		ZeroMemory(pContents, dwFileSize+1);
		fread(pContents, dwFileSize, 1, pFile);
	}

	fclose(pFile);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		m_pGameMsgList[iIndex] = new class CMsg(NULL, token, NULL);
		token = pStrTok->pGet();
		iIndex++;
	}

	delete pStrTok;
	delete[] pContents;
}

void CGame::DlgBoxClick_Party(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[32].sX;
	sY = m_stDialogBoxInfo[32].sY;

	switch (m_stDialogBoxInfo[32].cMode) {
	case 0:
		if (m_iPartyStatus == 0)
		{	if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 80) && (msY < sY + 100)) 
			{	m_stDialogBoxInfo[32].cMode = 2;
				m_bIsGetPointingMode = TRUE;
				m_iPointCommandType  = 200;
				PlaySound('E', 14, 5);
		}	}

		if (m_iPartyStatus != 0) 
		{	if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 100) && (msY < sY + 120)) 
			{	m_stDialogBoxInfo[32].cMode = 11;
				PlaySound('E', 14, 5);
		}	}

		if (m_iPartyStatus != 0) 
		{	if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 120) && (msY < sY + 140)) 
			{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_JOINPARTY, NULL, 2, NULL, NULL, m_cMCName);
				m_stDialogBoxInfo[32].cMode = 4;
				PlaySound('E', 14, 5);
		}	}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) DisableDialogBox(32);
		break;

	case 1:
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY, NULL, 1, NULL, NULL, m_stDialogBoxInfo[32].cStr);
			DisableDialogBox(32);
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY, NULL, 0, NULL, NULL, m_stDialogBoxInfo[32].cStr);
			DisableDialogBox(32);
			PlaySound('E', 14, 5);
		}
		break;

	case 2:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			m_stDialogBoxInfo[32].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 3:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			m_stDialogBoxInfo[32].cMode = 0;
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY, NULL, 2, NULL, NULL, m_stDialogBoxInfo[32].cStr);
			DisableDialogBox(32);
			PlaySound('E', 14, 5);
		}
		break;

	case 4:
	case 6:
	case 7:
	case 8:
	case 9:
	case 10:
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			m_stDialogBoxInfo[32].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 11:
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_JOINPARTY, NULL, NULL, NULL, NULL, m_cMCName);
			m_stDialogBoxInfo[32].cMode = 5;
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			m_stDialogBoxInfo[32].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;
	}
}


void CGame::DlgBoxClick_CrusadeJob(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[33].sX;
	sY = m_stDialogBoxInfo[33].sY;

	switch (m_stDialogBoxInfo[33].cMode) {
	case 1:
		if( m_bCitizen == FALSE )
		{	DisableDialogBox(33);
			PlaySound('E', 14, 5);
		}else if (m_bAresden == TRUE)
		{	if (m_iGuildRank == 0)
			{	if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165))
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, NULL, 3, NULL, NULL, NULL);
					DisableDialogBox(33);
					PlaySound('E', 14, 5);
				}
 			}else
			{	if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165))
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, NULL, 1, NULL, NULL, NULL);
					DisableDialogBox(33);
				}
				if (m_iGuildRank != -1)
				{	if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 175) && (msY < sY + 190))
					{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, NULL, 2, NULL, NULL, NULL);
						DisableDialogBox(33);
						PlaySound('E', 14, 5);
			}	}	}
		}else if (m_bAresden == FALSE)
		{	if (m_iGuildRank == 0)
			{	if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165))
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, NULL, 3, NULL, NULL, NULL);
					DisableDialogBox(33);
					PlaySound('E', 14, 5);
				}
			}else
			{	if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165))
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, NULL, 1, NULL, NULL, NULL);
					DisableDialogBox(33);
					PlaySound('E', 14, 5);
				}
				if (m_iGuildRank != -1)
				{	if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 175) && (msY < sY + 190))
					{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, NULL, 2, NULL, NULL, NULL);
						DisableDialogBox(33);
						PlaySound('E', 14, 5);
		} 	}	}	}

		if ((msX > sX + 210) && (msX < sX + 260) && (msY >= sY + 296) && (msY <= sY + 316))
		{	DisableDialogBox(18);
			EnableDialogBox(18, 813, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 2:
		if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 160) && (msY < sY + 175))
		{	switch (m_iCrusadeDuty) {
			case 1: EnableDialogBox(18, 803, NULL, NULL); break;
			case 2: EnableDialogBox(18, 805, NULL, NULL); break;
			case 3: EnableDialogBox(18, 808, NULL, NULL); break;
		}	}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			DisableDialogBox(33);
			PlaySound('E', 14, 5);
		}
		break;
	}
}

void CGame::_RequestMapStatus(char * pMapName, int iMode)
{
	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_MAPSTATUS, NULL, iMode, NULL, NULL, pMapName);
}

void CGame::AddMapStatusInfo(char * pData, BOOL bIsLastData)
{
 char * cp, cTotal;
 short * sp, sIndex;
 int i;

	ZeroMemory(m_cStatusMapName, sizeof(m_cStatusMapName));

	cp = (char *)(pData + 6);
	memcpy(m_cStatusMapName, cp, 10);
	cp += 10;

	sp = (short *)cp;
	sIndex = *sp;
	cp += 2;

	cTotal = *cp;
	cp++;

	for (i = 1; i <= cTotal; i++) {
		m_stCrusadeStructureInfo[sIndex].cType = *cp;
		cp++;
		sp = (short *)cp;
		m_stCrusadeStructureInfo[sIndex].sX = *sp;
		cp += 2;
		sp = (short *)cp;
		m_stCrusadeStructureInfo[sIndex].sY = *sp;
		cp += 2;
		m_stCrusadeStructureInfo[sIndex].cSide = *cp;
		cp++;

		sIndex++;
	}

	if (bIsLastData == TRUE) {
		while (sIndex < DEF_MAXCRUSADESTRUCTURES) {
			m_stCrusadeStructureInfo[sIndex].cType = NULL;
			m_stCrusadeStructureInfo[sIndex].sX = NULL;
			m_stCrusadeStructureInfo[sIndex].sY = NULL;
			m_stCrusadeStructureInfo[sIndex].cSide = NULL;
			sIndex++;
		}
	}
}

#ifdef DEF_USING_WIN_IME
bool CGame::GetText(HWND hWnd,UINT msg,WPARAM wparam, LPARAM lparam)
{ 	if( m_pInputBuffer == NULL) return FALSE;
	if( G_hEditWnd == NULL ) return FALSE;
	switch( msg ) {
	case WM_CHAR:
		if( (wparam == 22) || (wparam == 3) || (wparam == 9) || (wparam == 13) ) return TRUE;
		if( strlen(m_pInputBuffer) < m_cInputMaxLen-1 ) SendMessage( G_hEditWnd, msg, wparam, lparam );
		return TRUE;
	case WM_IME_COMPOSITION:
		if( strlen(m_pInputBuffer) < (m_cInputMaxLen -2) ) SendMessage( G_hEditWnd, msg, wparam, lparam );
		return TRUE;
	case WM_IME_CHAR:
	case WM_IME_COMPOSITIONFULL:
	case WM_IME_CONTROL:
	case WM_IME_ENDCOMPOSITION:
	case WM_IME_NOTIFY:
	case WM_IME_STARTCOMPOSITION:
	case WM_IME_SETCONTEXT:
	case WM_IME_KEYDOWN:
	case WM_IME_KEYUP:
	case WM_IME_SELECT:
		SendMessage( G_hEditWnd, msg, wparam, lparam );
		return TRUE;
	case WM_KEYUP:
		SendMessage( G_hEditWnd, msg, wparam, lparam );
		return FALSE;
	case WM_KEYDOWN:
		if( wparam == 8 ) SendMessage( G_hEditWnd, msg, wparam, lparam );
		return FALSE;
	}
	return FALSE;
}

#else // no IME

bool CGame::GetText(HWND hWnd,UINT msg,WPARAM wparam, LPARAM lparam)
{ 	int len;
	HIMC hIMC=NULL;
	if (m_pInputBuffer == NULL) return FALSE;
	switch (msg) {
		case WM_IME_COMPOSITION:
			ZeroMemory(m_cEdit, sizeof(m_cEdit));
			if (lparam & GCS_RESULTSTR)
			{	hIMC = ImmGetContext(hWnd);
				len = ImmGetCompositionString(hIMC, GCS_RESULTSTR, NULL, 0);
				if( len > 4 ) len = 4;
				ImmGetCompositionString(hIMC, GCS_RESULTSTR, m_cEdit, len);
				ImmReleaseContext(hWnd, hIMC);
				len = strlen(m_pInputBuffer) + strlen(m_cEdit);
				if (len < m_cInputMaxLen) strcpy(m_pInputBuffer+strlen(m_pInputBuffer),m_cEdit);
				ZeroMemory(m_cEdit, sizeof(m_cEdit));
			}else if (lparam & GCS_COMPSTR)
			{	hIMC = ImmGetContext(hWnd);
				len = ImmGetCompositionString(hIMC, GCS_COMPSTR, NULL, 0);
				if( len > 4 ) len = 4;
				ImmGetCompositionString(hIMC, GCS_COMPSTR, m_cEdit, len);
				ImmReleaseContext(hWnd, hIMC);
				len = strlen(m_pInputBuffer) + strlen(m_cEdit);
				if (len >= m_cInputMaxLen) ZeroMemory(m_cEdit, sizeof(m_cEdit));
			}
			return TRUE;

		case WM_CHAR:
			if(wparam == 8)
			{	if(strlen(m_pInputBuffer) > 0)
				{	len = strlen(m_pInputBuffer);
					switch (GetCharKind(m_pInputBuffer, len-1)) {
					case 1:
						m_pInputBuffer[len-1] = NULL;
						break;
					case 2:
					case 3:
						m_pInputBuffer[len-2]  = NULL;
						m_pInputBuffer[len-1]  = NULL;
						break;
					}
					ZeroMemory(m_cEdit, sizeof(m_cEdit));
				}
			}else if ((wparam != 9) && (wparam != 13) && (wparam != 27))
			{	len = strlen(m_pInputBuffer);
				if (len >= m_cInputMaxLen-1) return FALSE;
				m_pInputBuffer[len] = wparam & 0xff;
				m_pInputBuffer[len+1] = 0;
			}
			return TRUE;
	}
	return FALSE;
}
#endif


int CGame::GetCharKind(char *str, int index)
{	int kind=1;
    do
	{	if(kind==2) kind=3;
		else
		{	if((unsigned char) *str < 128) kind=1;
	    	else kind=2;
		}
		str++;
		index--;
    }
	while(index>=0);
    return kind;
}

void CGame::ShowReceivedString(BOOL bIsHide)
{
	ZeroMemory(G_cTxt, sizeof(G_cTxt));

#ifdef DEF_USING_WIN_IME
	if( G_hEditWnd != NULL ) GetWindowText(G_hEditWnd, m_pInputBuffer, (int)m_cInputMaxLen);
	strcpy(G_cTxt, m_pInputBuffer);
#else
	strcpy(G_cTxt, m_pInputBuffer);
	if( (m_cEdit[0] != 0) && ( strlen(m_pInputBuffer)+strlen(m_cEdit)+1 <= m_cInputMaxLen ) )
	{	strcpy(G_cTxt + strlen(m_pInputBuffer), m_cEdit);
	}
#endif
	if (bIsHide == TRUE)
	{	for (unsigned char i = 0; i < strlen(G_cTxt); i++)
		if (G_cTxt[i] != NULL) G_cTxt[i] = '*';
	}

	if( (G_dwGlobalTime%400) < 210 ) G_cTxt[strlen(G_cTxt)] = '_';

	PutString(m_iInputX+1, m_iInputY+1, G_cTxt, RGB(0,0,0));
	PutString(m_iInputX, m_iInputY+1, G_cTxt, RGB(0,0,0));
	PutString(m_iInputX+1, m_iInputY, G_cTxt, RGB(0,0,0));
	PutString(m_iInputX, m_iInputY, G_cTxt, RGB(255,255,255));
}

void CGame::ClearInputString()
{
	if (m_pInputBuffer != NULL)	ZeroMemory(m_pInputBuffer, sizeof(m_pInputBuffer));
	ZeroMemory(m_cEdit, sizeof(m_cEdit));
#ifdef DEF_USING_WIN_IME
	if (G_hEditWnd != NULL)	SetWindowText(G_hEditWnd, "");
#endif
}

void CGame::StartInputString(int sX, int sY, unsigned char iLen, char * pBuffer, BOOL bIsHide)
{
	m_bInputStatus = TRUE;
	m_iInputX = sX;
	m_iInputY = sY;
	m_pInputBuffer = pBuffer;
	ZeroMemory(m_cEdit, sizeof(m_cEdit));
	m_cInputMaxLen = iLen;
#ifdef DEF_USING_WIN_IME
	if (bIsHide == FALSE) G_hEditWnd = CreateWindow( RICHEDIT_CLASS, NULL, WS_POPUP | ES_SELFIME, sX-5 , sY -1, iLen*12, 16, G_hWnd, (HMENU)0, G_hInstance, NULL);
	else G_hEditWnd = CreateWindow( RICHEDIT_CLASS, NULL, WS_POPUP | ES_PASSWORD | ES_SELFIME, sX-5 , sY -1, iLen*12, 16, G_hWnd, (HMENU)0, G_hInstance, NULL);
	SetWindowText(G_hEditWnd, m_pInputBuffer);
	SendMessage(G_hEditWnd, EM_EXLIMITTEXT, 0, iLen-1 );
	SendMessage(G_hEditWnd, EM_SETLANGOPTIONS, 0, ~IMF_AUTOFONT);
	COMPOSITIONFORM composform;
	composform.dwStyle = CFS_POINT;
	composform.ptCurrentPos.x = sX;
	composform.ptCurrentPos.y = sY;
	HIMC hImc = ImmGetContext(G_hWnd);
	ImmSetCompositionWindow( hImc, &composform );
	int StrLen = strlen( m_pInputBuffer );
	SendMessage(G_hEditWnd, EM_SETSEL, StrLen, StrLen);
#endif
}

void CGame::EndInputString()
{	m_bInputStatus = FALSE;
#ifdef DEF_USING_WIN_IME
	if (G_hEditWnd != NULL)
	{	GetWindowText(G_hEditWnd, m_pInputBuffer, (int)m_cInputMaxLen);
		CANDIDATEFORM candiform;
		SendMessage(G_hEditWnd, WM_IME_CONTROL, IMC_GETCANDIDATEPOS, (LPARAM)&candiform);
		DestroyWindow(G_hEditWnd);
		G_hEditWnd = NULL;
	}
#else
	int len = strlen(m_cEdit);
	if (len > 0)
	{	m_cEdit[len] = 0;
		strcpy(m_pInputBuffer+strlen(m_pInputBuffer),m_cEdit);
		ZeroMemory( m_cEdit, sizeof(m_cEdit) );
	}
#endif
}

void CGame::ReceiveString(char *pString)
{
	strcpy(pString, m_pInputBuffer);

#ifdef DEF_USING_WIN_IME
	if (G_hEditWnd != NULL) GetWindowText(G_hEditWnd, pString, (int)m_cInputMaxLen);
#endif
}

void CGame::DrawNewDialogBox(char cType, int sX, int sY, int iFrame, BOOL bIsNoColorKey, BOOL bIsTrans)
{
 DWORD dwTime = G_dwGlobalTime;

	if (m_pSprite[cType] == NULL) return;
	if (bIsNoColorKey == FALSE)
	{	if (bIsTrans == TRUE)
			 m_pSprite[cType]->PutTransSprite2(sX, sY, iFrame, dwTime);
		else m_pSprite[cType]->PutSpriteFast(sX, sY, iFrame, dwTime);
	}
	else m_pSprite[cType]->PutSpriteFastNoColorKey(sX, sY, iFrame, dwTime);
}

void CGame::DlgBoxClick_Commander(int msX, int msY) // Snoopy: Fixed for 351
{short sX, sY, tX, tY;
 double d1, d2, d3;
	if (m_bIsCrusadeMode == FALSE) return;
	sX = m_stDialogBoxInfo[36].sX;
	sY = m_stDialogBoxInfo[36].sY;

	switch (m_stDialogBoxInfo[36].cMode) {
	case 0: // Main
		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_stDialogBoxInfo[36].cMode = 1;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	if (m_iTeleportLocX == -1)
			{	SetTopMsg(m_pGameMsgList[15]->m_pMsg, 5);
			}else if (strcmp(m_cMapName, m_cTeleportMapName) == 0)
			{	SetTopMsg(m_pGameMsgList[16]->m_pMsg, 5);
			}else
			{	m_stDialogBoxInfo[36].cMode = 2;
				PlaySound('E', 14, 5);
		}	}
		if ((msX >= sX +20 +100) && (msX <= sX +20 +46 +100) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_stDialogBoxInfo[36].cMode = 3;
			m_stDialogBoxInfo[36].sV1   = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150) && (msX <= sX +20 +46 +150) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_stDialogBoxInfo[36].cMode = 4;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	DisableDialogBox(18);
			EnableDialogBox(18, 808, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 1: // Set TP
		if ((msX >= sX + 15) && (msX <= sX + 15 + 278) && (msY >= sY + 60) && (msY <= sY + 60 + 272))
		{	d1 = (double)(msX - (sX + 15));
			d2 = (double)(524.0f); //(752.0f);
			d3 = (d2*d1)/279.0f;
			tX = (int)d3;
			d1 = (double)(msY - (sY + 60));
			d2 = (double)(524.0f); //(680.0f);
			d3 = (d2*d1)/(280.0f); //253.0f;
			tY = (int)d3;
			if (tX < 30) tX = 30;
			if (tY < 30) tY = 30;
			if (tX > 494) tX = 494;//722;
			if (tY > 494) tY = 494;//650;
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETGUILDTELEPORTLOC, NULL, tX, tY, NULL, "middleland");
			m_stDialogBoxInfo[36].cMode = 0;
			PlaySound('E', 14, 5);
			_RequestMapStatus("middleland", 1);
		}
		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_stDialogBoxInfo[36].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	DisableDialogBox(18);
			EnableDialogBox(18, 809, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 2: // Use TP
		if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GUILDTELEPORT, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(36);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_stDialogBoxInfo[36].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	DisableDialogBox(18);
			EnableDialogBox(18, 810, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 3: // Summon Unit
		if( m_bAresden == TRUE )
		{	if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 3000)
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 47, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
			}	}
			if ((msX >= sX +20 +50) && (msX <= sX +20 +50 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 2000)
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 46, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
			}	}
			if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 1000)
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 43, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
			}	}
			if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 1500)
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 51, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
			}	}
		}else if (m_bAresden == FALSE)
		{	if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 3000)
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 45, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
			} 	}
			if ((msX >= sX +20 +50) && (msX <= sX +20 +50 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 2000)
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 44, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
			} 	}
			if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 1000)
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 43, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
			}	}
			if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 1500)
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 51, 1, m_stDialogBoxInfo[36].sV1, NULL);
					PlaySound('E', 14, 5);
					DisableDialogBox(36);
		}	}	}
		if ((msX >= sX +20) && (msX <= sX +380) && (msY > sY +140) && (msY < sY +160))
		{	m_stDialogBoxInfo[36].sV1   = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20) && (msX <= sX +380) && (msY > sY +160) && (msY < sY +175))
		{	m_stDialogBoxInfo[36].sV1   = 1;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_stDialogBoxInfo[36].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	DisableDialogBox(18);
			EnableDialogBox(18, 811, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 4: // Set constr
		if (   (msX >= sX + 15) && (msX <= sX + 15 + 278)
			&& (msY >= sY + 60) && (msY <= sY + 60 + 272))
		{	d1 = (double)(msX - (sX + 15));
			d2 = (double)(524.0);//(752.0f);
			d3 = (d2*d1)/279.0f;
			tX = (int)d3;
			d1 = (double)(msY - (sY + 60));
			d2 = (double)(524.0);//(680.0f);
			d3 = (d2*d1)/(280.0);//253.0f;
			tY = (int)d3;
			if (tX < 30) tX = 30;
			if (tY < 30) tY = 30;
			if (tX > 494) tX = 494;//722;
			if (tY > 494) tY = 494;//650;
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC, NULL, tX, tY, NULL, "middleland");
			m_stDialogBoxInfo[36].cMode = 0;
			PlaySound('E', 14, 5);
			_RequestMapStatus("middleland", 1);
		}
		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_stDialogBoxInfo[36].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	DisableDialogBox(18);
			EnableDialogBox(18, 812, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;
	}
}


void CGame::DlgBoxClick_Constructor(int msX, int msY)  // Snoopy: Fixed for 351
{ short sX, sY;
	if (m_bIsCrusadeMode == FALSE) return;
	sX = m_stDialogBoxInfo[37].sX;
	sY = m_stDialogBoxInfo[37].sY;

	switch (m_stDialogBoxInfo[37].cMode) {
	case 0: // Main
		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	if (m_iConstructLocX == -1)
			{	SetTopMsg(m_pGameMsgList[14]->m_pMsg, 5);
			}else
			{	m_stDialogBoxInfo[37].cMode = 1;
				PlaySound('E', 14, 5);
		}	}
		if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	if (m_iTeleportLocX == -1)
			{	SetTopMsg(m_pGameMsgList[15]->m_pMsg, 5);
			}else if (strcmp(m_cMapName, m_cTeleportMapName) == 0)
			{	SetTopMsg(m_pGameMsgList[16]->m_pMsg, 5);
			}else
			{	m_stDialogBoxInfo[37].cMode = 2;
				PlaySound('E', 14, 5);
		}	}
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	DisableDialogBox(18);
			EnableDialogBox(18, 805, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 1: // Choose building
		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50))
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 38, 1, m_stDialogBoxInfo[36].sV1, NULL);
			PlaySound('E', 14, 5);
			DisableDialogBox(37);
		}
		if ((msX >= sX +20 +50) && (msX <= sX +20 +50 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 39, 1, m_stDialogBoxInfo[36].sV1, NULL);
			PlaySound('E', 14, 5);
			DisableDialogBox(37);
		}
		if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 36, 1, m_stDialogBoxInfo[36].sV1, NULL);
			PlaySound('E', 14, 5);
			DisableDialogBox(37);
		}
		if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SUMMONWARUNIT, NULL, 37, 1, m_stDialogBoxInfo[36].sV1, NULL);
			PlaySound('E', 14, 5);
			DisableDialogBox(37);
		}

		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{	m_stDialogBoxInfo[37].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{	DisableDialogBox(18);
			EnableDialogBox(18, 806, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 2: // Use TP
		if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GUILDTELEPORT, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(37);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_stDialogBoxInfo[37].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	DisableDialogBox(18);
			EnableDialogBox(18, 807, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;
	}
}


void CGame::DlgBoxClick_Soldier(int msX, int msY) // Snoopy: Fixed for 351
{ short sX, sY;
	if (m_bIsCrusadeMode == FALSE) return;
	sX = m_stDialogBoxInfo[38].sX;
	sY = m_stDialogBoxInfo[38].sY;

	switch (m_stDialogBoxInfo[38].cMode) {
	case 0: // Main dlg
		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	if (m_iTeleportLocX == -1)
			{	SetTopMsg(m_pGameMsgList[15]->m_pMsg, 5);
			}else if (strcmp(m_cMapName, m_cTeleportMapName) == 0)
			{	SetTopMsg(m_pGameMsgList[16]->m_pMsg, 5);
			}else
			{	m_stDialogBoxInfo[38].cMode = 1;
				PlaySound('E', 14, 5);
		}	}
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	DisableDialogBox(18);
			EnableDialogBox(18, 803, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 1: // Use TP
		if ((msX >= sX +20) && (msX <= sX +20 +46+50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GUILDTELEPORT, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(38);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_stDialogBoxInfo[38].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	DisableDialogBox(18);
			EnableDialogBox(18, 804, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;
	}
}

void CGame::SetCameraShakingEffect(short sDist, int iMul)
{
 int iDegree;

	iDegree = 5 - sDist;
	if (iDegree <= 0) iDegree = 0;
	iDegree *= 2;

	if (iMul != 0) iDegree *= iMul;

	if (iDegree <= 2) return;

	m_iCameraShakingDegree = iDegree;
}

void CGame::MeteorStrikeComing(int iCode)
{
	switch (iCode) {
	case 1: //
		SetTopMsg(m_pGameMsgList[0]->m_pMsg, 5);
		break;
	case 2: //
		SetTopMsg(m_pGameMsgList[10]->m_pMsg, 10);
		break;
	case 3: //
		SetTopMsg(m_pGameMsgList[91]->m_pMsg, 5);
		break;
	case 4: //
		SetTopMsg(m_pGameMsgList[11]->m_pMsg, 10);
		break;
	}
}

void CGame::DrawObjectFOE(int ix, int iy, int iFrame)
{	if( _iGetFOE(_tmp_iStatus) < 0 ) // red crusade circle
	{	if (iFrame <= 4 ) m_pEffectSpr[38]->PutTransSprite(ix, iy, iFrame, G_dwGlobalTime);
	}
}

void CGame::SetTopMsg(char *pString, unsigned char iLastSec)
{
	ZeroMemory(m_cTopMsg, sizeof(m_cTopMsg));
	strcpy(m_cTopMsg, pString);

	m_iTopMsgLastSec = iLastSec;
	m_dwTopMsgTime   = G_dwGlobalTime;
}

void CGame::DrawTopMsg()
{
	if (strlen(m_cTopMsg) == 0) return;
	m_DDraw.DrawShadowBox(0, 0, 639, 30);

	if ((((G_dwGlobalTime - m_dwTopMsgTime)/250) % 2) == 0)
		PutAlignedString(0, 639, 10, m_cTopMsg, 255,255,255);

	if ( G_dwGlobalTime > (m_iTopMsgLastSec*1000+m_dwTopMsgTime) ) {
		ZeroMemory(m_cTopMsg, sizeof(m_cTopMsg));
	}
}


void CGame::DrawDialogBox_IconPannel(short msX, short msY)
{
 short sX, sY;
 DWORD dwTime = m_dwCurTime;

	sX = m_stDialogBoxInfo[30].sX;
	sY = m_stDialogBoxInfo[30].sY;

	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(sX, sY, 14, dwTime);

	if ((362 < msX)	&& (404 > msX) && (434 < msY) && (475 > msY)) {
		m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(362, 434, 16, dwTime);
	}

	if (m_bIsCombatMode) {
		if (m_bIsSafeAttackMode)
			 m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(368, 440, 4, dwTime);
		else m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(368, 440, 5, dwTime);
	}

	if ((m_bIsCrusadeMode) && (m_iCrusadeDuty != 0)) {
		if (m_bAresden == TRUE) {
			if ((322 <= msX) && (355 >= msX) && (434 < msY) && (475 > msY))
				 m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(322, 434, 1, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(322, 434, 2, dwTime);
		}
		else if (m_bAresden == FALSE) {
			if ((322 <= msX) && (355 >= msX) && (434 < msY) && (475 > msY))
				 m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(322, 434, 0, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(322, 434, 15, dwTime);
		}
	}

	// CLEROTH - LU
	if ( m_iLU_Point > 0 ) {
			if ((322 <= msX) && (355 >= msX) && (434 < msY) && (475 > msY))
				 m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(322, 434, 17, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(322, 434, 18, dwTime);
	}

	if ((msY > 436) && (msY < 478))
	{
		if ((msX > 410) && (msX < 447))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(412, 434, 6, dwTime);// Character
		}
		if ((msX > 447) && (msX < 484))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(449, 434, 7, dwTime);// Inventory
		}
		if ((msX > 484) && (msX < 521))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(486, 434, 8, dwTime);// Magic
		}
		if ((msX > 521) && (msX < 558))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(523, 434, 9, dwTime);// Skill
		}
		if ((msX > 558) && (msX < 595))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(560, 434, 10, dwTime);// History
		}
		if ((msX > 595) && (msX < 631))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFast(597, 434, 11, dwTime);// System Menu
		}
	}

	if ( ((msX > 144) && (msX < 317) && (msY > 434) && (msY < 477)) || (m_bCtrlPressed) )
	{	int iLev = 0;
		int iCurExp  = iGetLevelExp(m_iLevel);
		int iNextExp = iGetLevelExp(m_iLevel+1);

#ifdef DEF_4XXP_PER_LVL
		if (m_iLevel > 139)
		{	iLev = (m_iLevel-139)*3;
			iNextExp = iGetLevelExp(m_iLevel+iLev);
		}
#endif

#ifdef DEF_EQUILIBRIUM_PROJECT // XP niv 151..153
		if ((m_bCitizen == TRUE) && (m_iLevel > 150))
		{	iCurExp  = iGetLevelExp(150);
			iNextExp = iGetLevelExp(151);
		}
#endif

		if(m_iExp < iNextExp)
		{	iNextExp = iNextExp - iCurExp;
			if( m_iExp > iCurExp ) iCurExp = m_iExp - iCurExp; // curxp: partie faite
			else iCurExp = 0; // below current lvl !
			short sPerc = 0;
			if( iCurExp > 200000 ) sPerc = short( ((iCurExp>>4)*10000)/(iNextExp>>4) );
			else sPerc = (short)( (iCurExp*10000)/iNextExp );
			wsprintf(G_cTxt, "Rest Exp: %d(%d.%02d%%)", iNextExp-iCurExp, sPerc/100, sPerc%100);
		}else
		{	wsprintf(G_cTxt, "Exp: %d(100.00%)", m_iExp); // "Exp: 151000/150000"
		}
	}else wsprintf(G_cTxt, "%s(%d,%d)", m_cMapMessage, m_sPlayerX, m_sPlayerY);
	PutAlignedString(135, 328, 456, G_cTxt, 200,200,120);
}

void CGame::DrawDialogBox_GaugePannel()
{	int iMaxPoint, iBarWidth;
	// HP bar

#ifdef DEF_EQUILIBRIUM_PROJECT // HPs formula
	if (m_iAngelicStr !=0) iMaxPoint = m_iVit*3 + (m_iLevel*3 + (m_iStr + m_iAngelicStr))/2;
	else			       iMaxPoint = m_iVit*3 + (m_iLevel*3 + m_iStr)/2;
#else

	if (m_iAngelicStr !=0) iMaxPoint = m_iVit*3 + m_iLevel*2 + (m_iStr + m_iAngelicStr)/2;
	else				   iMaxPoint = m_iVit*3 + m_iLevel*2 + m_iStr/2;
#endif

	if (m_iHP > iMaxPoint) m_iHP = iMaxPoint;
	iBarWidth = 101 - (m_iHP*101)/iMaxPoint;
	if( iBarWidth < 0 ) iBarWidth = 0;
	if( iBarWidth > 101 ) iBarWidth = 101;
	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFastWidth(23, 437,  12, iBarWidth, m_dwCurTime);

	wsprintf(G_cTxt, "%d", (short) m_iHP);
	if (m_bIsPoisoned)
	{	 PutString_SprNum(85, 441, G_cTxt, m_wR[5]*11, m_wG[5]*11, m_wB[5]*11);
		 PutString_SprFont3(35, 440, "Poisoned", m_wR[5]*8, m_wG[5]*8, m_wB[5]*8, TRUE, 2);
	}else PutString_SprNum(85, 441, G_cTxt, 200, 100, 100);

	//MP bar
	iMaxPoint = (m_iMag + m_iAngelicMag)*2 + m_iLevel*2 + (m_iInt + m_iAngelicInt)/2;
	if (m_iMP > iMaxPoint) m_iMP = iMaxPoint;
	iBarWidth = 101 - (m_iMP*101)/iMaxPoint;
	if( iBarWidth < 0 ) iBarWidth = 0;
	if( iBarWidth > 101 ) iBarWidth = 101;
	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFastWidth(23, 459,  12, iBarWidth, m_dwCurTime);
	wsprintf(G_cTxt, "%d", (short) m_iMP);
	PutString_SprNum(85, 463, G_cTxt, 100, 100, 200);

	// SP bar
	if (m_iAngelicStr !=0) iMaxPoint = m_iLevel*2 + (m_iStr + m_iAngelicStr)*2;
	else				   iMaxPoint = m_iLevel*2 + m_iStr*2;
	if (m_iSP > iMaxPoint) m_iSP = iMaxPoint;
	iBarWidth = 167 - (m_iSP*167)/iMaxPoint;
	if( iBarWidth < 0 ) iBarWidth = 0;
	if( iBarWidth > 167 ) iBarWidth = 167;
	m_pSprite[DEF_SPRID_INTERFACE_ND_ICONPANNEL]->PutSpriteFastWidth(147, 435, 13, iBarWidth, m_dwCurTime);
}

void CGame::DrawDialogBox_Text(short msX, short msY, short msZ, char cLB)
{
 short sX, sY;
 int i, iTotalLines, iPointerLoc;
 double d1,d2,d3;

	sX = m_stDialogBoxInfo[18].sX;
	sY = m_stDialogBoxInfo[18].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);

	iTotalLines = 0;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	if (m_pMsgTextList[i] != NULL) iTotalLines++;

	if( iTotalLines > 17 ) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 1);
	if( iGetTopDialogBoxIndex() == 18 && msZ != 0 )
	{
		m_stDialogBoxInfo[18].sView = m_stDialogBoxInfo[18].sView - msZ/60;
		m_DInput.m_sZ = 0;
	}
	if( m_stDialogBoxInfo[18].sView < 0 ) m_stDialogBoxInfo[18].sView = 0;
	if( iTotalLines>17 && m_stDialogBoxInfo[18].sView > iTotalLines-17 ) m_stDialogBoxInfo[18].sView = iTotalLines-17;

	if (iTotalLines > 17) {
		d1 = (double)m_stDialogBoxInfo[18].sView;
		d2 = (double)(iTotalLines-17);
		d3 = (274.0f * d1)/d2;
		iPointerLoc = (int)(d3+0.5);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 1);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX+242, sY+35+iPointerLoc, 7);
	}
	else iPointerLoc = 0;

	for (i = 0; i < 17; i++)
	if (m_pMsgTextList[i + m_stDialogBoxInfo[18].sView] != NULL) {
		if (m_bDialogTrans == FALSE) { // v2.173
			switch (m_pMsgTextList[i + m_stDialogBoxInfo[18].sView]->m_pMsg[0]) {
			case '_': PutAlignedString(sX +24, sX +236, sY + 50 +i*13, (m_pMsgTextList[i + m_stDialogBoxInfo[18].sView]->m_pMsg+1), 255,255,255); break;
			case ';': PutAlignedString(sX +24, sX +236, sY + 50 +i*13, (m_pMsgTextList[i + m_stDialogBoxInfo[18].sView]->m_pMsg+1), 4, 0, 50); break;
			default: PutAlignedString(sX +24, sX +236, sY + 50 +i*13, m_pMsgTextList[i + m_stDialogBoxInfo[18].sView]->m_pMsg, 45,25,25); break;
			}
		}
		else PutAlignedString(sX +24, sX +236, sY + 50 +i*13, m_pMsgTextList[i + m_stDialogBoxInfo[18].sView]->m_pMsg, 0,0,0);
	}

	if (cLB != 0 && iTotalLines > 17) {
		if ((iGetTopDialogBoxIndex() == 18)) {
			if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
				d1 = (double)(msY -(sY+35));
				d2 = (double)(iTotalLines-17);
				d3 = (d1 * d2)/274.0f;
				iPointerLoc = (int)d3;
				if (iPointerLoc > iTotalLines-17) iPointerLoc = iTotalLines-17;
				m_stDialogBoxInfo[18].sView = iPointerLoc;
			}
		}
	}
	else m_stDialogBoxInfo[18].bIsScrollSelected = FALSE;

	if ((msX > sX + DEF_RBTNPOSX) && (msX < sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
}

void CGame::DrawDialogBox_15AgeMsg(short msX, short msY)
{  return;
// Snoopy: removed FeedbackCard & minus 15 age

}


void CGame::DrawDialogBox_WarningMsg(short msX, short msY)//6
{
    short sX, sY;

	sX = m_stDialogBoxInfo[6].sX;
	sY = m_stDialogBoxInfo[6].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, sX, sY, 2);

    PutString2(sX + 63, sY + 35, DEF_MSG_WARNING1, 200,200,25);//" ** This is a battle area **"
	PutString(sX + 30, sY + 57, DEF_MSG_WARNING2, RGB(220,130,45) );//"This is a dangerous area where you"
	PutString(sX + 30, sY + 74, DEF_MSG_WARNING3, RGB(220,130,45) );//"cannot protected from others' attack."
	PutString(sX + 30, sY + 92, DEF_MSG_WARNING4, RGB(220,130,45) );//"To play the game in safe, go to the"
	PutString(sX + 30, sY +110, DEF_MSG_WARNING5, RGB(220,130,45) );//" cityhall and change to civilian mode."

	if ((msX >= sX + 122 ) && (msX <= sX + 125 + DEF_BTNSZX ) && (msY >= sY + 127 ) && (msY <= sY + 127 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 122 , sY + 127 , 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 122, sY + 127 , 0);

}

void CGame::DrawDialogBox_ItemDrop(short msX, short msY)
{
    short sX, sY;
    char cTxt[120], cStr1[64], cStr2[64], cStr3[64];

	sX = m_stDialogBoxInfo[4].sX;
	sY = m_stDialogBoxInfo[4].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME1, sX, sY, 2);

	GetItemName(m_pItemList[m_stDialogBoxInfo[4].sView]->m_cName, m_pItemList[m_stDialogBoxInfo[4].sView]->m_dwAttribute, cStr1, cStr2, cStr3 );

	if (strlen(m_stDialogBoxInfo[4].cStr) == 0)  wsprintf(cTxt, "%s", cStr1);

	if(m_bIsSpecial)
	{	PutString(sX + 35, sY + 20, cTxt, RGB(0,255,50));
		PutString(sX + 36, sY + 20, cTxt, RGB(0,255,50));
	}else
	{	PutString(sX + 35, sY + 20, cTxt, RGB(4,0,50));
		PutString(sX + 36, sY + 20, cTxt, RGB(4,0,50));
	}
	PutString(sX + 35, sY + 36, DRAW_DIALOGBOX_ITEM_DROP1 , RGB(4,0,50));
	PutString(sX + 36, sY + 36, DRAW_DIALOGBOX_ITEM_DROP1, RGB(4,0,50));

	if(m_bItemDrop)
	{	if ((msX >= sX + 35) && (msX <= sX + 240 ) && (msY >= sY + 80) && (msY <= sY + 90))
		{	PutString(sX + 35, sY + 80, DRAW_DIALOGBOX_ITEM_DROP2, RGB(255,255,255));
			PutString(sX + 36, sY + 80, DRAW_DIALOGBOX_ITEM_DROP2, RGB(255,255,255));
		}else
		{	PutString(sX + 35, sY + 80, DRAW_DIALOGBOX_ITEM_DROP2, RGB(4,0,50));
			PutString(sX + 36, sY + 80, DRAW_DIALOGBOX_ITEM_DROP2, RGB(4,0,50));
		}
	}else
	{	if ((msX >= sX + 35) && (msX <= sX + 240 ) && (msY >= sY + 80) && (msY <= sY + 90))
		{	PutString(sX + 35, sY + 80, DRAW_DIALOGBOX_ITEM_DROP3, RGB(255,255,255));
			PutString(sX + 36, sY + 80, DRAW_DIALOGBOX_ITEM_DROP3, RGB(255,255,255));
		}else
		{	PutString(sX + 35, sY + 80, DRAW_DIALOGBOX_ITEM_DROP3, RGB(4,0,50));
			PutString(sX + 36, sY + 80, DRAW_DIALOGBOX_ITEM_DROP3, RGB(4,0,50));
	}	}

	if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + 55) && (msY <= sY + 55 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 55 ,19);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 55 , 18);

	if ((msX >= sX + 170 ) && (msX <= sX + 170 + DEF_BTNSZX ) && (msY >= sY + 55 ) && (msY <= sY + 55 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 170 , sY + 55 , 3);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 170, sY + 55 , 2);
}

void CGame::DrawDialogBox_NpcTalk(short msX, short msY, char cLB)
{
 short sX, sY;
 int i, iTotalLines, iPointerLoc;
 double d1, d2, d3;
	sX = m_stDialogBoxInfo[21].sX;
	sY = m_stDialogBoxInfo[21].sY;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);

	switch (m_stDialogBoxInfo[21].cMode) {
	case 0: //  OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 1: // Accept / Decline
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 33);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 32);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 41);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 40);
		break;

	case 2: // Next
		if ((msX >= sX + 190) && (msX <= sX + 278) && (msY >= sY + 296) && (msY <= sY + 316))
			 PutString_SprFont(sX + 190, sY + 270, "Next", 6,6,20);
		else PutString_SprFont(sX + 190, sY + 270, "Next", 0,0,7);
		break;
	}

	for (i = 0; i < 17; i++)
	if ((i < DEF_TEXTDLGMAXLINES) && (m_pMsgTextList2[i + m_stDialogBoxInfo[21].sView] != NULL)) {
		PutAlignedString(sX, sX+m_stDialogBoxInfo[21].sSizeX, sY + 57 +i*15, m_pMsgTextList2[i + m_stDialogBoxInfo[21].sView]->m_pMsg, 45,25,25);
	}

	iTotalLines = 0;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	if (m_pMsgTextList2[i] != NULL) iTotalLines++;

	if (iTotalLines > 17) {
		d1 = (double)m_stDialogBoxInfo[21].sView;
		d2 = (double)(iTotalLines-17);
		d3 = (274.0f * d1)/d2;
		iPointerLoc = (int)d3;
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
	}
	else iPointerLoc = 0;

	if (cLB != 0 && iTotalLines > 17) {
		if ((iGetTopDialogBoxIndex() == 21)) {
			if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
				d1 = (double)(msY -(sY+40));
				d2 = (double)(iTotalLines-17);
				d3 = (d1 * d2)/274.0f;
				iPointerLoc = (int)d3;

				if (iPointerLoc > iTotalLines) iPointerLoc = iTotalLines;
				m_stDialogBoxInfo[21].sView = iPointerLoc;
			}
		}
	}
	else m_stDialogBoxInfo[21].bIsScrollSelected = FALSE;
}

void CGame::DrawDialogBox_Slates(short msX, short msY, short msZ, char cLB)
{
 int iAdjX, iAdjY;
 short sX, sY;
 DWORD dwTime = m_dwCurTime;

	iAdjX = 5 ;
	iAdjY = 8 ;

	switch (m_stDialogBoxInfo[40].cMode) {
	// Slates Dialog - Diuuude
	case 1:
		sX = m_stDialogBoxInfo[40].sX;
		sY = m_stDialogBoxInfo[40].sY;
		iAdjX = -1;
		iAdjY = -7;

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX, sY, 4);

		if (m_stDialogBoxInfo[40].sV1 != -1){
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX+20, sY+12, 5);
		}
		if (m_stDialogBoxInfo[40].sV2 != -1){
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX+20, sY+87, 6);
		}
		if (m_stDialogBoxInfo[40].sV3 != -1){
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX+85, sY+32, 7);
		}
		if (m_stDialogBoxInfo[40].sV4 != -1){
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX+70, sY+97, 8);
		}

		if ((m_stDialogBoxInfo[40].sV1 != -1) && (m_stDialogBoxInfo[40].sV2 != -1) && (m_stDialogBoxInfo[40].sV3 != -1) && (m_stDialogBoxInfo[40].sV4 != -1)){
			if ((msX >= sX + 120) && (msX <= sX + 180) && (msY >= sY + 150) && (msY <= sY + 165))
				PutString_SprFont(sX + 120, sY + 150, "Casting", 6,6,20);
			else PutString_SprFont(sX + 120, sY + 150, "Casting", 0, 0, 7);
		}

		break;

	// Slates Dialog - Diuuude
	case 2:
		PlaySound('E', 16, 0);
		if (m_stDialogBoxInfo[40].cStr[0] != 0)
		{	sX = m_stDialogBoxInfo[40].sX + iAdjX + (m_stDialogBoxInfo[40].cStr[0] - (rand() % (m_stDialogBoxInfo[40].cStr[0]*2)));
			sY = m_stDialogBoxInfo[40].sY + iAdjY + (m_stDialogBoxInfo[40].cStr[0] - (rand() % (m_stDialogBoxInfo[40].cStr[0]*2)));
		}else
		{	sX = m_stDialogBoxInfo[40].sX;
			sY = m_stDialogBoxInfo[40].sY;
		}
		m_pSprite[DEF_SPRID_INTERFACE_ND_INVENTORY]->PutSpriteFast(sX, sY, 4, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ND_INVENTORY]->PutSpriteFast(sX+22, sY+14, 3, dwTime);
		//PutString_SprFont(sX + iAdjX + 170, sY + iAdjY + 170, "KURURURURURURURURU!!!", 20,6,6);
		PutAlignedString(199, 438, 201, "KURURURURURURURURU!!!", 220,140,160);
		PutAlignedString(200, 439, 200, "KURURURURURURURURU!!!", 90,220,200);

		if ((dwTime - m_stDialogBoxInfo[40].dwT1) > 1000)
		{	m_stDialogBoxInfo[40].dwT1 = dwTime;
			m_stDialogBoxInfo[40].cStr[0]++;
		}
		if (m_stDialogBoxInfo[40].cStr[0] >= 5)
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_CREATESLATE, NULL, m_stDialogBoxInfo[40].sV1, m_stDialogBoxInfo[40].sV2, m_stDialogBoxInfo[40].sV3, NULL, m_stDialogBoxInfo[40].sV4);
			DisableDialogBox(40);
		}
		break;
	}
}

void CGame::DlgBoxClick_Slates(short msX, short msY)
{
 int iAdjX, iAdjY;
 short sX, sY;

	sX = m_stDialogBoxInfo[40].sX;
	sY = m_stDialogBoxInfo[40].sY;
	iAdjX = 5 ;
	iAdjY = 8 ;
	switch (m_stDialogBoxInfo[40].cMode) {
	// Slates DialogBox - Diuuude
	case 1:
		if ((m_stDialogBoxInfo[40].sV1 != -1) && (m_stDialogBoxInfo[40].sV2 != -1) && (m_stDialogBoxInfo[40].sV3 != -1) && (m_stDialogBoxInfo[40].sV4 != -1)){
			if ((msX >= sX + 120) && (msX <= sX + 180) && (msY >= sY + 150) && (msY <= sY + 165)){
				m_stDialogBoxInfo[40].cMode = 2;
				PlaySound('E', 14, 5);
			}
		}
		break;
	}
}

void CGame::DlgBoxClick_NpcTalk(int msX, int msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[21].sX;
	sY = m_stDialogBoxInfo[21].sY;

	switch (m_stDialogBoxInfo[21].cMode) {
	case 0: //  OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			DisableDialogBox(21);
			PlaySound('E', 14, 5);
		}
		break;

	case 1: // Accept / Decline
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Accept
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_QUESTACCEPTED, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(21);
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel
			DisableDialogBox(21);
			PlaySound('E', 14, 5);
		}
		break;

	case 2:	// Next
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			DisableDialogBox(21);
			PlaySound('E', 14, 5);
		}
		break;
	}
}


void CGame::DrawDialogBox_Chat(short msX, short msY, short msZ, char cLB)
{short sX, sY;
 int i, iPointerLoc;
 double d1, d2, d3;
	sX = m_stDialogBoxInfo[10].sX;
	sY = m_stDialogBoxInfo[10].sY;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 4, FALSE, m_bDialogTrans);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 22, FALSE, m_bDialogTrans);

	if ( msZ != 0 && (iGetTopDialogBoxIndex() == 10)) {
		m_stDialogBoxInfo[10].sView = m_stDialogBoxInfo[10].sView + msZ/30;
		m_DInput.m_sZ = 0;
	}
	if( m_stDialogBoxInfo[10].sView < 0 ) m_stDialogBoxInfo[10].sView = 0;
	if( m_stDialogBoxInfo[10].sView > DEF_MAXCHATSCROLLMSGS-8 ) m_stDialogBoxInfo[10].sView = DEF_MAXCHATSCROLLMSGS-8;

	d1 = (double)m_stDialogBoxInfo[10].sView;
	d2 = (double)(105);
	d3 = (d1*d2)/(DEF_MAXCHATSCROLLMSGS-8);
	iPointerLoc = (int)d3;
	iPointerLoc = 105 - iPointerLoc;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX +346, sY + 33 + iPointerLoc, 7);

	for (i = 0; i < 8; i++)
	if (m_pChatScrollList[i + m_stDialogBoxInfo[10].sView] != NULL) {
		switch ( m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_dwTime ) {
		case 0:  PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 230, 230, 230); break;
		case 1:  PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 130, 200, 130); break;
		case 2:  PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 255, 130, 130); break;
		case 3:  PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 130, 130, 255); break;
		case 4:  PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 230, 230, 130); break;
		case 10: PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 180, 255, 180); break;
		case 20: PutString2(sX + 25, sY + 127 - i*13, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg, 150, 150, 170); break;
		}
	}

	if ( (cLB != 0) && (iGetTopDialogBoxIndex()==10) )
	{ 	if ((msX >= sX + 336) && (msX <= sX + 361) && (msY >= sY + 28) && (msY <= sY + 140)) {
			d1 = (double)(msY - (sY + 28));
			d2 = ((DEF_MAXCHATSCROLLMSGS-8)*d1)/105.0f;
			m_stDialogBoxInfo[10].sView = DEF_MAXCHATSCROLLMSGS - 8 - (int)d2;
		}

		if ((msX >= sX + 336) && (msX <= sX + 361) && (msY > sY + 18) && (msY < sY + 28))
			m_stDialogBoxInfo[10].sView = DEF_MAXCHATSCROLLMSGS - 8;

		if ((msX >= sX + 336) && (msX <= sX + 361) && (msY > sY + 140) && (msY < sY + 163))
			m_stDialogBoxInfo[10].sView = 0;
	}
	else m_stDialogBoxInfo[10].bIsScrollSelected = FALSE;
}


void CGame::DlgBoxClick_ItemUpgrade(int msX, int msY)
{short sX, sY;
 int i, iSoX, iSoM;
	sX = m_stDialogBoxInfo[34].sX;
	sY = m_stDialogBoxInfo[34].sY;
	switch (m_stDialogBoxInfo[34].cMode) {
	case 1:	// Upgrade Majestic, items in the window
		if ((m_stDialogBoxInfo[34].sV1 != -1) && (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	int iValue = (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_dwAttribute & 0xF0000000) >> 28;
			iValue = iValue*(iValue+6)/8 + 2;
			if( m_iGizonItemUpgradeLeft < iValue ) break;
			PlaySound('E', 14, 5);
			PlaySound('E', 44, 0);
			m_stDialogBoxInfo[34].cMode = 2;
			m_stDialogBoxInfo[34].dwV1 = timeGetTime();
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel
			PlaySound('E', 14, 5);
			DisableDialogBox(34);
		}
		break;

	case 3: // sucess
	case 4: // Not possible
	case 7: // Lost item
	case 8: // Failed
	case 9: // Failed
	case 10:// Failed
	case 12:// 12 Need stone!
	case 13:// 13 remove stones!
	case 14:// 14 No Oil present
	case 15:// 15 too much Oil error
	case 16:// 16 too much Elixir error
	case 17:// 17 remove Oils
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// OK
			PlaySound('E', 14, 5);
			DisableDialogBox(34);
		}
		break;



#ifdef DEF_EQUILIBRIUM_PROJECT // Upgrade Main menu click
	case 5: // main menu
			int iSoX, iSoM, iSoO, iSoE;
			iSoX = iSoM = iSoO = iSoE = 0;
			int iOilIndex, iElixirIndex;
			iOilIndex = iElixirIndex = -1;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pItemList[i] != NULL)
			{	if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 128)) iSoX++;
				if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 129)) iSoM++;
				if (   (m_pItemList[i]->m_cItemType != DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) // Strange stone to enchant Ancient weapon
					&& ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 163)))
				{	iOilIndex = i;
					iSoO++;
				}
				if (   (m_pItemList[i]->m_cItemType != DEF_ITEMTYPE_EAT) // Not a summon potions
					&& (m_pItemList[i]->m_sSprite == 6)
					&& (m_pItemList[i]->m_sSpriteFrame >= 108)
					&& (m_pItemList[i]->m_sSpriteFrame <= 112))
				{	int len = strlen(m_pItemList[i]->m_cName) -6;
					if (len <=0)
					{	iOilIndex = i;
						iSoO++;
					}else
					{	if (strcmp (m_pItemList[i]->m_cName + len, "Elixir") == 0)
						{	iElixirIndex = i;
							iSoE++; // Elixir
						}else
						{	iOilIndex = i;
							iSoO++;
				}	}	}
				if (   (m_pItemList[i]->m_cItemType != DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) // Not Slate
					&& (m_pItemList[i]->m_sSprite == 6)
					&& (m_pItemList[i]->m_sSpriteFrame == 155))
				{	iOilIndex = i;
					iSoO++;
			}	}
			m_stDialogBoxInfo[34].sV2 = iSoX;
			m_stDialogBoxInfo[34].sV3 = iSoM;
			m_stDialogBoxInfo[34].sV4 = iOilIndex;
			m_stDialogBoxInfo[34].sV5 = iElixirIndex;
			m_stDialogBoxInfo[34].sV6 = iSoX + iSoM;
			if      (iSoO == 0) m_stDialogBoxInfo[34].sV7 = 0; // No Oil present
			else if (iSoO > 1)  m_stDialogBoxInfo[34].sV7 = 1; // Too much Oil error
			else if (iSoE > 1)  m_stDialogBoxInfo[34].sV7 = 2; // Too much Elixir error
			else                m_stDialogBoxInfo[34].sV7 = 3; // Correct Ol/Elixir

		if ((msX > sX +24) && (msX < sX +248) && (msY > sY +80) && (msY < sY +95))
		{	if (m_stDialogBoxInfo[34].sV6 <= 0)
			{	m_stDialogBoxInfo[34].cMode = 12;		// 12 Need stone!
				PlaySound('E', 14, 5);
			}else
			{	m_stDialogBoxInfo[34].cMode = 6;		// 6 Xelima / Merien upgrade
				PlaySound('E', 14, 5);
			}
		}else if ((msX > sX +24) && (msX < sX +248) && (msY > sY +100) && (msY < sY +115))
		{	if (m_stDialogBoxInfo[34].sV6 != 0)
			{	m_stDialogBoxInfo[34].cMode = 13;		// 13 remove stones!
				PlaySound('E', 14, 5);
			}else if (m_stDialogBoxInfo[34].sV7 == 0)
			{	m_stDialogBoxInfo[34].cMode = 14;		// 14 No Oil present
				PlaySound('E', 14, 5);
			}else if (m_stDialogBoxInfo[34].sV7 == 1)
			{	m_stDialogBoxInfo[34].cMode = 15;		// 15 too much Oil error
				PlaySound('E', 14, 5);
			}else if (m_stDialogBoxInfo[34].sV7 == 2)
			{	m_stDialogBoxInfo[34].cMode = 16;		// 16 too much Elixir error
				PlaySound('E', 14, 5);
			}else
			{	m_stDialogBoxInfo[34].cMode = 11;		// 11  Alchemy enchantement
				PlaySound('E', 14, 5);
			}
		}else if ((msX > sX +24) && (msX < sX +248) && (msY > sY +120) && (msY < sY +135))
		{	if (m_stDialogBoxInfo[34].sV6 != 0)
			{	m_stDialogBoxInfo[34].cMode = 13;		// 13 remove stones!
				PlaySound('E', 14, 5);
			}else if (m_stDialogBoxInfo[34].sV7 > 0)
			{	m_stDialogBoxInfo[34].cMode = 17;		// 17 remove Oils
				PlaySound('E', 14, 5);
			}else
			{	m_stDialogBoxInfo[34].cMode = 1;		// 1  gizon upgrade
				PlaySound('E', 14, 5);
		}	}
		if ((m_stDialogBoxInfo[34].sV1 != -1) && (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Upgrade
			PlaySound('E', 14, 5);
			PlaySound('E', 44, 0);
			m_stDialogBoxInfo[34].cMode = 2;
			m_stDialogBoxInfo[34].dwV1 = timeGetTime();
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel
			PlaySound('E', 14, 5);
			DisableDialogBox(34);
		}
		break;
#else
	case 5: // main menu
		if ((msX > sX +24) && (msX < sX +248) && (msY > sY +100) && (msY < sY +115))
		{	PlaySound('E', 14, 5);
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pItemList[i] != NULL)
			{	if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 128)) iSoX++;
				if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 129)) iSoM++;
			}
			if ((iSoX > 0) || (iSoM > 0))
			{	m_stDialogBoxInfo[34].cMode = 6;
				m_stDialogBoxInfo[34].sV2 = iSoX;
				m_stDialogBoxInfo[34].sV3 = iSoM;
			}
			else AddEventList(DRAW_DIALOGBOX_ITEMUPGRADE30, 10); //"Stone of Xelima or Merien is not present."
		}
		if ((msX > sX +24) && (msX < sX +248) && (msY > sY +120) && (msY < sY +135))
		{	m_stDialogBoxInfo[34].cMode = 1;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel
			PlaySound('E', 14, 5);
			DisableDialogBox(34);
		}
		break;
#endif

	case 6: // Upgrade Xelima / Merien
		if ((m_stDialogBoxInfo[34].sV1 != -1) && (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Upgrade
			PlaySound('E', 14, 5);
			PlaySound('E', 44, 0);
			m_stDialogBoxInfo[34].cMode = 2;
			m_stDialogBoxInfo[34].dwV1 = timeGetTime();
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel
			PlaySound('E', 14, 5);
			DisableDialogBox(34);
		}
		break;


#ifdef DEF_EQUILIBRIUM_PROJECT // Upgrade alchimie click
	case 11: // Alchemy enchantement
		if (   (m_stDialogBoxInfo[34].sV1 != -1)
			&& (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX)
			&& (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Enchant
			PlaySound('E', 14, 5);
			PlaySound('E', 44, 0);
			m_stDialogBoxInfo[34].cMode = 2;
			m_stDialogBoxInfo[34].dwV1 = timeGetTime();
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel
			PlaySound('E', 14, 5);
			DisableDialogBox(34);
		}
		break;
#endif
	}
}


void CGame::DlgBoxClick_SellList(short msX, short msY)
{int i, x;
 short sX, sY;
 	sX = m_stDialogBoxInfo[31].sX;
	sY = m_stDialogBoxInfo[31].sY;
	for (i = 0; i < DEF_MAXSELLLIST; i++)
	if ((msX > sX + 25) && (msX < sX + 250) && (msY >= sY + 55 + i*15) && (msY <= sY + 55 + 14 + i*15))
	{	if (m_pItemList[m_stSellItemList[i].iIndex] != NULL)
		{	m_bIsItemDisabled[m_stSellItemList[i].iIndex] = FALSE;
			m_stSellItemList[i].iIndex = -1;

			PlaySound('E', 14, 5);

			// ÀçÁ¤·Ä
			for (x = 0; x < DEF_MAXSELLLIST-1; x++)
			if (m_stSellItemList[x].iIndex == -1) {
				m_stSellItemList[x].iIndex  = m_stSellItemList[x+1].iIndex;
				m_stSellItemList[x].iAmount = m_stSellItemList[x+1].iAmount;

				m_stSellItemList[x+1].iIndex  = -1;
				m_stSellItemList[x+1].iAmount = 0;
			}
		}
		return;
	}

	if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		// Sell
		bSendCommand(MSGID_REQUEST_SELLITEMLIST, NULL, NULL, NULL, NULL, NULL, NULL);
		PlaySound('E', 14, 5);
		DisableDialogBox(31);
	}

	if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		// Cancel
		PlaySound('E', 14, 5);
		DisableDialogBox(31);
	}
}

// 3.51 LevelUp Box - Diuuude
void CGame::DlgBoxClick_LevelUpSettings(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[12].sX;
	sY = m_stDialogBoxInfo[12].sY;
	// Strength UP - Diuuude
	if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 127) && (msY <= sY + 133) && (m_iStr <= DEF_MAX_STATS) && (m_iLU_Point > 0))
	{	if (m_bCtrlPressed == TRUE)
		{	if ((m_iLU_Point >= 5)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_iLU_Point -= 5;
				m_cLU_Str += 5;
			}
			PlaySound('E', 14, 5);
		}else
		{	if ((m_iLU_Point > 0)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_iLU_Point--;
				m_cLU_Str++;
			}
			PlaySound('E', 14, 5);
	}	}

	// Vitality UP - Diuuude
	if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 146) && (msY <= sY + 152) && (m_iVit <= DEF_MAX_STATS) && (m_iLU_Point > 0))
	{	if (m_bCtrlPressed == TRUE)
		{	if ((m_iLU_Point >= 5)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_iLU_Point -= 5;
				m_cLU_Vit += 5;
			}
			PlaySound('E', 14, 5);
		}else
		{	if ((m_iLU_Point > 0)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_iLU_Point--;
				m_cLU_Vit++;
			}
			PlaySound('E', 14, 5);
	}	}

	// Dexterity UP - Diuuude
	if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 165) && (msY <= sY + 171) && (m_iDex <= DEF_MAX_STATS) && (m_iLU_Point > 0))
	{	if (m_bCtrlPressed == TRUE)
		{	if ((m_iLU_Point >= 5)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_iLU_Point -= 5;
				m_cLU_Dex += 5;
			}
			PlaySound('E', 14, 5);
		}else
		{	if ((m_iLU_Point > 0)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_iLU_Point--;
				m_cLU_Dex++;
			}
			PlaySound('E', 14, 5);
	}	}

	// Intelligence UP - Diuuude
	if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 184) && (msY <= sY + 190) && (m_iInt <= DEF_MAX_STATS) && (m_iLU_Point > 0))
	{	if (m_bCtrlPressed == TRUE)
		{	if ((m_iLU_Point >= 5)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_iLU_Point -= 5;
				m_cLU_Int += 5;
			}
			PlaySound('E', 14, 5);
		}else
		{	if ((m_iLU_Point > 0)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_iLU_Point--;
				m_cLU_Int++;
			}
			PlaySound('E', 14, 5);
	}	}

	// Magic UP - Diuuude
	if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 203) && (msY <= sY + 209) && (m_iMag <= DEF_MAX_STATS) && (m_iLU_Point > 0))
	{	if (m_bCtrlPressed == TRUE)
		{	if ((m_iLU_Point >= 5)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_iLU_Point -= 5;
				m_cLU_Mag += 5;
			}
			PlaySound('E', 14, 5);
		}else
		{	if ((m_iLU_Point > 0)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_iLU_Point--;
				m_cLU_Mag++;
			}
			PlaySound('E', 14, 5);
	}	}

	// Charisma UP - Diuuude
	if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 222) && (msY <= sY + 228) && (m_iCharisma <= DEF_MAX_STATS) && (m_iLU_Point > 0))
	{	if (m_bCtrlPressed == TRUE)
		{	if ((m_iLU_Point >= 5)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_iLU_Point -= 5;
				m_cLU_Char += 5;
			}
			PlaySound('E', 14, 5);
		}else
		{	if ((m_iLU_Point > 0)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_iLU_Point--;
				m_cLU_Char++;
			}
			PlaySound('E', 14, 5);
	}	}

	// Strength DOWN - Diuuude
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 127) && (msY <= sY + 133) && (m_cLU_Str > 0))
	{	if (m_bCtrlPressed == TRUE)
		{	if ((m_cLU_Str >= 5)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_cLU_Str -= 5;
				m_iLU_Point += 5;
			}
			PlaySound('E', 14, 5);
		}else
		{	if ((m_cLU_Str > 0)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_cLU_Str--;
				m_iLU_Point++;
			}
			PlaySound('E', 14, 5);
	}	}

	// Vitality DOWN - Diuuude
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 146) && (msY <= sY + 152) && (m_cLU_Vit > 0))
	{	if (m_bCtrlPressed == TRUE)
		{	if ((m_cLU_Vit >= 5)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_cLU_Vit -= 5;
				m_iLU_Point += 5;
			}
			PlaySound('E', 14, 5);
		}else
		{	if ((m_cLU_Vit > 0)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_cLU_Vit--;
				m_iLU_Point++;
			}
			PlaySound('E', 14, 5);
	}	}

	// Dexterity DOWN - Diuuude
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 165) && (msY <= sY + 171) && (m_cLU_Dex > 0))
	{	if (m_bCtrlPressed == TRUE)
		{	if ((m_cLU_Dex >= 5)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_cLU_Dex -= 5;
				m_iLU_Point += 5;
			}
			PlaySound('E', 14, 5);
		}else
		{	if ((m_cLU_Dex > 0)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_cLU_Dex--;
				m_iLU_Point++;
			}
			PlaySound('E', 14, 5);
	}	}

	// Intelligence DOWN - Diuuude
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 184) && (msY <= sY + 190) && (m_cLU_Int > 0))
	{	if (m_bCtrlPressed == TRUE)
		{	if ((m_cLU_Int >= 5)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_cLU_Int -= 5;
				m_iLU_Point += 5;
			}
			PlaySound('E', 14, 5);
		}else
		{	if ((m_cLU_Int > 0)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_cLU_Int--;
				m_iLU_Point++;
			}
			PlaySound('E', 14, 5);
	}	}

	// Magic DOWN - Diuuude
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 203) && (msY <= sY + 209) && (m_cLU_Mag > 0))
	{	if (m_bCtrlPressed == TRUE)
		{	if ((m_cLU_Mag >= 5)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_cLU_Mag -= 5;
				m_iLU_Point += 5;
			}
			PlaySound('E', 14, 5);
		}else
		{	if ((m_cLU_Mag > 0)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_cLU_Mag--;
				m_iLU_Point++;
			}
			PlaySound('E', 14, 5);
	}	}

	// Charisma DOWN - Diuuude
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 222) && (msY <= sY + 228) && (m_cLU_Char > 0))
	{	if (m_bCtrlPressed == TRUE)
		{	if ((m_cLU_Char >= 5)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_cLU_Char -= 5;
				m_iLU_Point += 5;
			}
			PlaySound('E', 14, 5);
		}else
		{	if ((m_cLU_Char > 0)&&(m_bIsDialogEnabled[42] == FALSE))
			{	m_cLU_Char--;
				m_iLU_Point++;
			}
			PlaySound('E', 14, 5);
	}	}

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
	{	if (m_stDialogBoxInfo[12].sV1 != m_iLU_Point)
		// Send command to HG - Diuuude, Only if changed - Snoopy
		bSendCommand(MSGID_LEVELUPSETTINGS, NULL, NULL, NULL, NULL, NULL, NULL);
		//m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;
		DisableDialogBox(12);
		PlaySound('E', 14, 5);
	}
	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
	{	// Change stats with Majestic
		if (   (m_iGizonItemUpgradeLeft >0) && (m_iLU_Point <= 0)
			&& (m_cLU_Str == 0)&&(m_cLU_Vit == 0)&&(m_cLU_Dex == 0)&&(m_cLU_Int == 0)&&(m_cLU_Mag == 0)&&(m_cLU_Char == 0))
		{	DisableDialogBox(12);
			EnableDialogBox(42, 0, 0, 0);
			//PlaySound('E', 14, 5);
	}	}
}

void CGame::CannotConstruct(int iCode)
{
	switch (iCode) {
	case 1: //
		SetTopMsg(m_pGameMsgList[18]->m_pMsg, 5);
		break;

	case 2: //
		wsprintf(G_cTxt, "%s XY(%d, %d)", m_pGameMsgList[19]->m_pMsg, m_iConstructLocX, m_iConstructLocY);
		SetTopMsg(G_cTxt, 5);
		break;

	case 3: //
		SetTopMsg(m_pGameMsgList[20]->m_pMsg, 5);
		break;
	case 4: //
		SetTopMsg(m_pGameMsgList[20]->m_pMsg, 5);
		break;

	}
}

void CGame::DisplayCommaNumber_G_cTxt(int iGold)
{char cGold[20];
 int iStrLen;
	ZeroMemory(cGold, sizeof(cGold));
	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	itoa(iGold, cGold, 10);
#ifdef DEF_COMMA_GOLD
	iStrLen = strlen(cGold);
	iStrLen--;
	int cnt = 0;
	for (int i = 0 ; i < iStrLen+1 ; i++)
	{	if( (cnt != 0) && ((cnt+1)%4 == 0) )
		{	G_cTxt[cnt] = ',';
			i--;
		}else G_cTxt[cnt] = cGold[iStrLen-i];
		cnt++;
	}
	iStrLen = strlen(G_cTxt);
	G_cTxt[iStrLen] = '\0';
	strrev(G_cTxt);
#else
	strcpy(G_cTxt, cGold);
#endif
}

void CGame::DrawDialogBox_Inventory(int msX, int msY)
{int i;
 short sX, sY;
 DWORD dwTime = m_dwCurTime;
 char cItemColor;
	sX = m_stDialogBoxInfo[2].sX;
	sY = m_stDialogBoxInfo[2].sY;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX, sY, 0);
	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_cItemOrder[i] != -1) && (m_pItemList[m_cItemOrder[i]] != NULL))
	{	if (   ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_ITEM)
			&& (m_stMCursor.sSelectedObjectID   ==	m_cItemOrder[i])) || (m_bIsItemEquipped[m_cItemOrder[i]] == TRUE) )
		{}else
		{	cItemColor = m_pItemList[m_cItemOrder[i]]->m_cItemColor;
			if (m_bIsItemDisabled[ m_cItemOrder[i] ] == TRUE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutTransSprite2(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
					 	                                                sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame, dwTime);
				else
				{	if (   (m_pItemList[m_cItemOrder[i]]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
						|| (m_pItemList[m_cItemOrder[i]]->m_cEquipPos == DEF_EQUIPPOS_RHAND)
						|| (m_pItemList[m_cItemOrder[i]]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
					{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutTransSpriteRGB(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
																			sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame,
																			m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0],
																			dwTime);
					}else
					{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutTransSpriteRGB(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
																			sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame,
																			m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0],
																			dwTime);
				}	}
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutSpriteFast(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
																		sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame, dwTime);
				else
				{	if (   (m_pItemList[m_cItemOrder[i]]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
						|| (m_pItemList[m_cItemOrder[i]]->m_cEquipPos == DEF_EQUIPPOS_RHAND)
						|| (m_pItemList[m_cItemOrder[i]]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
					{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutSpriteRGB(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
																			sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame,
																			m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0],
																			dwTime);
					}else {
						m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutSpriteRGB(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
																			sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame,
																			m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0],
																			dwTime);
			}	}	}
			if (   (m_pItemList[m_cItemOrder[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				|| (m_pItemList[m_cItemOrder[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) )
			{	DisplayCommaNumber_G_cTxt((int)m_pItemList[m_cItemOrder[i]]->m_dwCount); // nbe show, as US: 1,200,000
				PutString2(sX + 29 + m_pItemList[m_cItemOrder[i]]->m_sX +10, sY + 41 + m_pItemList[m_cItemOrder[i]]->m_sY +10
					, G_cTxt, 200,200,200);
	}	}	}
	if ((msX >= sX +23) && (msX <= sX +76) && (msY >= sY +172) && (msY <= sY +184))
	{	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX+23, sY+172, 1);
	}
	if ((msX >= sX +140) && (msX <= sX +212) && (msY >= sY +172) && (msY <= sY +184))
	{	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_INVENTORY, sX+140, sY+172, 2);
	}
}


void CGame::CrusadeContributionResult(int iWarContribution)
{int i;
 char cTemp[120];
	DisableDialogBox(18);
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{	if (m_pMsgTextList[i] != NULL)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = NULL;
	}
	if (iWarContribution > 0)
	{	PlaySound('E', 23, 0, 0);
		PlaySound('C', 21, 0, 0);
		PlaySound('C', 22, 0, 0);
		m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[22]->m_pMsg, NULL); // Congratulations! Your nation
		m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[23]->m_pMsg, NULL); // was victory in the battle!
		m_pMsgTextList[2] = new class CMsg(NULL, " ", NULL);
		m_pMsgTextList[3] = new class CMsg(NULL, m_pGameMsgList[24]->m_pMsg, NULL); // As a victorious citizen
		m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[25]->m_pMsg, NULL); // You will receive
		m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[26]->m_pMsg, NULL); // a prize
		m_pMsgTextList[6] = new class CMsg(NULL, " ", NULL);
		m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[27]->m_pMsg, NULL); // Experience point of the battle contribution:
		ZeroMemory(cTemp, sizeof(cTemp));											//
		wsprintf(cTemp, "+%dExp Points!", iWarContribution);
		m_pMsgTextList[8] = new class CMsg(NULL, cTemp, NULL);
		for (i = 9; i < 18; i++)
		m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);

	}else if (iWarContribution < 0)
	{	PlaySound('E', 24, 0, 0);
		PlaySound('C', 12, 0, 0);
		PlaySound('C', 13, 0, 0);
		m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[28]->m_pMsg, NULL); // Unfortunately! Your country
		m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[29]->m_pMsg, NULL); // have lost the all out war.
		m_pMsgTextList[2] = new class CMsg(NULL, " ", NULL);
		m_pMsgTextList[3] = new class CMsg(NULL, m_pGameMsgList[30]->m_pMsg, NULL); // As a losser citizen;
		m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[31]->m_pMsg, NULL); // the prize that accomplishes
		m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[32]->m_pMsg, NULL); // will not be given.
		m_pMsgTextList[6] = new class CMsg(NULL, " ", NULL);
		m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[33]->m_pMsg, NULL); // I hope you to win
		m_pMsgTextList[8] = new class CMsg(NULL, m_pGameMsgList[34]->m_pMsg, NULL); // in the next battle
		for (i = 9; i < 18; i++)
		m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
	}else if (iWarContribution == 0)
	{	PlaySound('E', 25, 0, 0);
		m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[50]->m_pMsg, NULL); // The battle that you have participated
		m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[51]->m_pMsg, NULL); // is already finished;
		m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[52]->m_pMsg, NULL); //
		m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL);
		m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[53]->m_pMsg, NULL); // You must connect after finishing
		m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[54]->m_pMsg, NULL); // the previous and before starting
		m_pMsgTextList[6] = new class CMsg(NULL, m_pGameMsgList[55]->m_pMsg, NULL); // the next battle so you can receive
		m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[56]->m_pMsg, NULL); // the prize
		for (i = 8; i < 18; i++)
		m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
	}
	EnableDialogBox(18, NULL, NULL, NULL);
}


void CGame::CrusadeWarResult(int iWinnerSide)
{int i, iPlayerSide;
	DisableDialogBox(18);
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{	if (m_pMsgTextList[i] != NULL)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = NULL;
	}
	if( m_bCitizen == FALSE ) iPlayerSide = 0;
	else if (m_bAresden == TRUE) iPlayerSide = 1;
	else if (m_bAresden == FALSE) iPlayerSide = 2;
	if (iPlayerSide == 0)
	{	switch (iWinnerSide) {
		case 0:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // All out war finished!
			m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[36]->m_pMsg, NULL); // There was a draw in the
			m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[37]->m_pMsg, NULL); // battle
			m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL);
			break;
		case 1:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // All out war finished!
			m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[38]->m_pMsg, NULL); // Aresden was victorious
			m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[39]->m_pMsg, NULL); // and put an end to the war
			m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL);
			break;
		case 2:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // All out war finished!
			m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[40]->m_pMsg, NULL); // Elvine was victorious
			m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[41]->m_pMsg, NULL); // and put an end to the war
			m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL);
			break;
		}
		for (i = 4; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
	}else
	{	if (iWinnerSide == 0)
		{	PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // All out war finished!
			m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[36]->m_pMsg, NULL); // There was a draw in the
			m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[37]->m_pMsg, NULL); // battle
			m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL);
			for (i = 4; i < 18; i++)
				m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
		}else
		{ 	if (iWinnerSide == iPlayerSide)
			{	PlaySound('E', 23, 0, 0);
				PlaySound('C', 21, 0, 0);
				PlaySound('C', 22, 0, 0);
				switch (iWinnerSide) {
				case 1:
					m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // All out war finished!;
					m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[38]->m_pMsg, NULL); // Aresden was victorious;
					m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[39]->m_pMsg, NULL); // and put an end to the war
					m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL);
					m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[42]->m_pMsg, NULL); // Congratulations!
					m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[43]->m_pMsg, NULL); // As a victorious citizen
					m_pMsgTextList[6] = new class CMsg(NULL, m_pGameMsgList[44]->m_pMsg, NULL); // You will receive
					m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[45]->m_pMsg, NULL); // a prize
					break;
				case 2:
					m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // All out war finished!
					m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[40]->m_pMsg, NULL); // Elvine was victorious
					m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[41]->m_pMsg, NULL); // and put an end to the war
					m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL);
					m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[42]->m_pMsg, NULL); // Congratulations!
					m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[43]->m_pMsg, NULL); // As a victorious citizen
					m_pMsgTextList[6] = new class CMsg(NULL, m_pGameMsgList[44]->m_pMsg, NULL); // You will receive
					m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[45]->m_pMsg, NULL); // a prize
					break;
				}
				for (i = 8; i < 18; i++)
					m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
			}else if (iWinnerSide != iPlayerSide)
			{	PlaySound('E', 24, 0, 0);
				PlaySound('C', 12, 0, 0);
				PlaySound('C', 13, 0, 0);
				switch (iWinnerSide) {
				case 1:
					m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // All out war finished!
					m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[38]->m_pMsg, NULL); // Aresden was victorious;
					m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[39]->m_pMsg, NULL); // and put an end to the war
					m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL);
					m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[46]->m_pMsg, NULL); // Unfortunately,
					m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[47]->m_pMsg, NULL); // As a losser citizen
					m_pMsgTextList[6] = new class CMsg(NULL, m_pGameMsgList[48]->m_pMsg, NULL); // the prize that accomplishes
					m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[49]->m_pMsg, NULL); // will not be given.
					break;
				case 2:
					m_pMsgTextList[0] = new class CMsg(NULL, m_pGameMsgList[35]->m_pMsg, NULL); // All out war finished!
					m_pMsgTextList[1] = new class CMsg(NULL, m_pGameMsgList[40]->m_pMsg, NULL); // Elvine was victorious
					m_pMsgTextList[2] = new class CMsg(NULL, m_pGameMsgList[41]->m_pMsg, NULL); // and put an end to the war
					m_pMsgTextList[3] = new class CMsg(NULL, " ", NULL);
					m_pMsgTextList[4] = new class CMsg(NULL, m_pGameMsgList[46]->m_pMsg, NULL); // Unfortunately,
					m_pMsgTextList[5] = new class CMsg(NULL, m_pGameMsgList[47]->m_pMsg, NULL); // As a losser citizen
					m_pMsgTextList[6] = new class CMsg(NULL, m_pGameMsgList[48]->m_pMsg, NULL); // the prize that accomplishes
					m_pMsgTextList[7] = new class CMsg(NULL, m_pGameMsgList[49]->m_pMsg, NULL); // will not be given.
					break;
				}
				for (i = 8; i < 18; i++)
					m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
	}	}	}
	EnableDialogBox(18, NULL, NULL, NULL);
	DisableDialogBox(36);
	DisableDialogBox(37);
	DisableDialogBox(38);
}

void CGame::_Draw_UpdateScreen_OnCreateNewAccount()
{
	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWACCOUNT, 0,0,0, TRUE);
	PutString2(329, 110, m_cAccountName, 200,200,200);
	PutString( 329, 125, m_cAccountPassword, RGB(200,200,200), TRUE, 1);
	PutString( 329, 140, m_cAccountPassword, RGB(200,200,200), TRUE, 1);
	PutString2(300, 202, m_cAccountCountry, 200,200,200);
	PutString2(300, 218, m_cAccountSSN, 200,200,200);
	PutString2(194, 257, m_cEmailAddr, 200,200,200);
}

void CGame::DrawChatMsgBox(short sX, short sY, int iChatIndex, BOOL bIsPreDC)
{
 char cMsg[100], cMsgA[22], cMsgB[22], cMsgC[22], * cp;
 int  iRet, iLines, i, iSize, iSize2, iLoc, iFontSize;
 DWORD dwTime;
 COLORREF rgb;
 BOOL bIsTrans;
 RECT rcRect;
 SIZE Size;

	ZeroMemory(cMsg, sizeof(cMsg));
	ZeroMemory(cMsgA, sizeof(cMsgA));
	ZeroMemory(cMsgB, sizeof(cMsgB));
	ZeroMemory(cMsgC, sizeof(cMsgC));

	dwTime = m_pChatMsgList[iChatIndex]->m_dwTime;
	strcpy(cMsg, m_pChatMsgList[iChatIndex]->m_pMsg);
	cp = (char *)cMsg;
	iLines = 0;

	rgb = RGB(255,255,255);
	switch (m_pChatMsgList[iChatIndex]->m_cType) {
	case 1:
		rgb = RGB(255,255,255);
		break;
	case 20:
		rgb = RGB(255,255,20);
		// ¸Þ½ÃÁö Ç¥½Ã¿¡ µô·¹ÀÌ°¡ °É¸°´Ù.
		if ((m_dwCurTime - dwTime) < 650) return;
		else dwTime += 650;
		break;
	case 41:
		rgb = RGB(255,80,80);
		break;

	case 42:
		rgb = RGB(255,80,80);
		if ((m_dwCurTime - dwTime) < 650) return;
		else dwTime += 650;
		break;
	}

	if (strlen(cp) != 0) {
		memcpy(cMsgA, cp, 20);

		iRet = GetCharKind(cMsgA, 19);
		if (iRet == CODE_HAN1) {
			cMsgA[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 1;
	}

	if (strlen(cp) != 0) {
		memcpy(cMsgB, cp, 20);

		iRet = GetCharKind(cMsgB, 19);
		if (iRet == CODE_HAN1) {
			cMsgB[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 2;
	}

	if (strlen(cp) != 0) {
		memcpy(cMsgC, cp, 20);

		iRet = GetCharKind(cMsgC, 19);
		if (iRet == CODE_HAN1) {
			cMsgC[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 3;
	}

	iSize = 0;
	for (i = 0; i < 20; i++)
	if (cMsgA[i] != 0)

	if ((unsigned char)cMsgA[i] >= 128) {
		iSize += 5;	//6
		i++;
	}
	else iSize += 4;

	iLoc = m_dwCurTime - dwTime;
	switch (m_pChatMsgList[iChatIndex]->m_cType) {
	case 21:
	case 22:
	case 23://...
		if( iLoc > 80 ) iLoc = 10;
		else iLoc = iLoc>>3;
		break;
	default://
		if( iLoc > 352 ) iLoc = 9;
		else if( iLoc > 320 ) iLoc = 10;
		else iLoc = iLoc>>5;
		break;
	}

	if (m_cDetailLevel == 0)
		 bIsTrans = FALSE;
	else bIsTrans = TRUE;

	switch (m_pChatMsgList[iChatIndex]->m_cType) {
	case 41:
	case 42:
		iSize2 = 0;
		for (i = 0; i < 100; i++)
		if (cMsg[i] != 0)
		if ((unsigned char)cMsg[i] >= 128) {
			iSize2 += 5;
			i++;
		}
		else iSize2 += 4;
		if( m_Misc.bCheckIMEString(cMsg) == FALSE )
		{
			PutString(sX - iSize2, sY - 65 - iLoc, cMsg, RGB(180, 30, 30));
			PutString(sX - iSize2+1, sY - 65 - iLoc, cMsg, RGB(180, 30, 30));
		}
		else PutString_SprFont3(sX - iSize2, sY - 65 - iLoc, cMsg, m_wR[14]*4, m_wG[14]*4, m_wB[14]*4, FALSE, 0);
		break;

	case 21:
	case 22:
	case 23:
		iFontSize = 23 - (int)m_pChatMsgList[iChatIndex]->m_cType;
		switch (iLines) {
		case 1:
			PutString_SprFont3(sX - iSize, sY - 65 - iLoc, cMsgA, m_wR[13]*2, m_wG[13]*2, m_wB[13]*2, bIsTrans, iFontSize);
			break;
		case 2:
			PutString_SprFont3(sX - iSize, sY - 81 - iLoc,  cMsgA, m_wR[13]*2, m_wG[13]*2, m_wB[13]*2, bIsTrans, iFontSize);
			PutString_SprFont3(sX - iSize, sY - 65 - iLoc,  cMsgB, m_wR[13]*2, m_wG[13]*2, m_wB[13]*2, bIsTrans, iFontSize);
			break;
		case 3:
			PutString_SprFont3(sX - iSize, sY - 97 - iLoc, cMsgA, m_wR[13]*2, m_wG[13]*2, m_wB[13]*2, bIsTrans, iFontSize);
			PutString_SprFont3(sX - iSize, sY - 81 - iLoc, cMsgB, m_wR[13]*2, m_wG[13]*2, m_wB[13]*2, bIsTrans, iFontSize);
			PutString_SprFont3(sX - iSize, sY - 65 - iLoc, cMsgC, m_wR[13]*2, m_wG[13]*2, m_wB[13]*2, bIsTrans, iFontSize);
			break;
		}
		break;

	case 20:
	default:
		if (bIsPreDC == FALSE)
			m_DDraw._GetBackBufferDC();

		GetTextExtentPoint32(m_DDraw.m_hDC, cMsg, strlen(cMsg), &Size);

		switch (Size.cx / 160) {
		case 0:
			SetRect(&rcRect, sX-80 +1, sY-65 -iLoc, sX+80 +1, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));

			SetRect(&rcRect, sX-80, sY-65 -iLoc +1, sX+80, sY -iLoc +1);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));

			SetRect(&rcRect, sX-80, sY-65 -iLoc, sX+80, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, rgb);
			break;

		case 1:
			SetRect(&rcRect, sX-80 +1, sY-83 -iLoc, sX+80 +1, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));

			SetRect(&rcRect, sX-80, sY-83 -iLoc +1, sX+80, sY -iLoc +1);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));

			SetRect(&rcRect, sX-80, sY-83 -iLoc, sX+80, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, rgb);
			break;

		case 2:
			SetRect(&rcRect, sX-80 +1, sY-101 -iLoc, sX+80 +1, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));

			SetRect(&rcRect, sX-80, sY-101 -iLoc +1, sX+80, sY -iLoc +1);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));

			SetRect(&rcRect, sX-80, sY-101 -iLoc, sX+80, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, rgb);
			break;

		case 3:
			SetRect(&rcRect, sX-80 +1, sY-119 -iLoc, sX+80 +1, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));

			SetRect(&rcRect, sX-80, sY-119 -iLoc +1, sX+80, sY -iLoc +1);
			m_DDraw.DrawText(&rcRect, cMsg, RGB(0,0,0));

			SetRect(&rcRect, sX-80, sY-119 -iLoc, sX+80, sY -iLoc);
			m_DDraw.DrawText(&rcRect, cMsg, rgb);
			break;
		}

		if (bIsPreDC == FALSE)
			m_DDraw._ReleaseBackBufferDC();
		break;
	}
}

void CGame::ClearContents_OnSelectCharacter()
{
	m_cCurFocus = 1;
}



void CGame::UpdateScreen_OnSelectCharacter()
{
 short sX, sY, msX, msY, msZ;
 char  cLB, cRB, cTotalChar;
 char  cMIresult;
 static class CMouseInterface * pMI;
 DWORD dwTime;
 static DWORD dwCTime;

 int iMIbuttonNum;

	dwTime = timeGetTime();
	sX = 0;
	sY = 0;
	cTotalChar = 0;

	if (m_cGameModeCount == 0)
	{	G_cSpriteAlphaDegree = 1;
		InitGameSettings();
		pMI = new class CMouseInterface;
		pMI->AddRect(100, 50, 210, 250);
		pMI->AddRect(211, 50, 321, 250);
		pMI->AddRect(322, 50, 431, 250);
		pMI->AddRect(432, 50, 542, 250);

		pMI->AddRect(360,283,545,315);
		pMI->AddRect(360,316,545,345);
		pMI->AddRect(360,346,545,375);
		pMI->AddRect(360,376,545,405);
		pMI->AddRect(360,406,545,435);

		m_cMaxFocus = 4;
		if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
		if (m_cCurFocus < 1)		   m_cCurFocus = 1;

		m_cArrowPressed = 0;
		m_bEnterPressed = FALSE;

		dwCTime = timeGetTime();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{	switch (m_cArrowPressed) {
		case 2:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 4:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEscPressed == TRUE)
	{	ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	if (m_bEnterPressed == TRUE)
	{	m_bEnterPressed = FALSE;
		PlaySound('E', 14, 5);

		if (m_pCharList[m_cCurFocus-1] != NULL)
		{	if (m_pCharList[m_cCurFocus-1]->m_sSex != NULL)
			{	ZeroMemory(m_cPlayerName, sizeof(m_cPlayerName));
				strcpy(m_cPlayerName, m_pCharList[m_cCurFocus-1]->m_cName);
				m_iLevel = (int)m_pCharList[m_cCurFocus-1]->m_sLevel;
				if (m_Misc.bCheckValidString(m_cPlayerName) == TRUE)
				{	m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
					m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
					m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
					m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
					m_pLSock->bInitBufferSize(30000);
					ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
					m_dwConnectMode  = MSGID_REQUEST_ENTERGAME;
					m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
					ZeroMemory(m_cMsg, sizeof(m_cMsg));
					strcpy(m_cMsg,"33");
					ZeroMemory(m_cMapName, sizeof(m_cMapName));
					memcpy(m_cMapName, m_pCharList[m_cCurFocus-1]->m_cMapName, 10);
					delete pMI;
					return;
			}	}
		}else
		{	_InitOnCreateNewCharacter();
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
			delete pMI;
			return;
		}
	}

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	UpdateScreen_OnSelectCharacter(sX, sY, msX, msY);

	if ((dwTime - dwCTime) > 100)
	{	m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{	m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{	m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
		case 2:
		case 3:
		case 4:
			if (m_cCurFocus != iMIbuttonNum)
				m_cCurFocus = iMIbuttonNum;
			else
			{	if (m_pCharList[m_cCurFocus-1] != NULL)
				{	if (m_pCharList[m_cCurFocus-1]->m_sSex != NULL)
					{	ZeroMemory(m_cPlayerName, sizeof(m_cPlayerName));
						strcpy(m_cPlayerName, m_pCharList[m_cCurFocus-1]->m_cName);
						m_iLevel = (int)m_pCharList[m_cCurFocus-1]->m_sLevel;
						if (m_Misc.bCheckValidString(m_cPlayerName) == TRUE)
						{	m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
							m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
							m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
							m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
							m_pLSock->bInitBufferSize(30000);
							ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
							m_dwConnectMode  = MSGID_REQUEST_ENTERGAME;
							m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
							ZeroMemory(m_cMsg, sizeof(m_cMsg));
							strcpy(m_cMsg,"33");
							ZeroMemory(m_cMapName, sizeof(m_cMapName));
							memcpy(m_cMapName, m_pCharList[m_cCurFocus-1]->m_cMapName, 10);
							delete pMI;
							return;
					}	}
				}else
				{	_InitOnCreateNewCharacter();
					ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
					delete pMI;
					return;
				}
			}
			break;

		case 5:
			if (m_pCharList[m_cCurFocus - 1] != NULL)
			{	if (m_pCharList[m_cCurFocus-1]->m_sSex != NULL)
				{	ZeroMemory(m_cPlayerName, sizeof(m_cPlayerName));
					strcpy(m_cPlayerName, m_pCharList[m_cCurFocus-1]->m_cName);
					m_iLevel = (int)m_pCharList[m_cCurFocus-1]->m_sLevel;

					if (m_Misc.bCheckValidString(m_cPlayerName) == TRUE) {
						m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->_iCloseSprite();
						m_pSprite[DEF_SPRID_INTERFACE_ND_MAINMENU]->_iCloseSprite();
						m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
						m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
						m_pLSock->bInitBufferSize(30000);
						ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
						m_dwConnectMode  = MSGID_REQUEST_ENTERGAME;
						m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW;
						ZeroMemory(m_cMsg, sizeof(m_cMsg));
						strcpy(m_cMsg,"33");
						ZeroMemory(m_cMapName, sizeof(m_cMapName));
						memcpy(m_cMapName, m_pCharList[m_cCurFocus-1]->m_cMapName, 10);
						delete pMI;
						return;
			}	}	}
			break;

		case 6:
			if (m_iTotalChar < 4)
			{	_InitOnCreateNewCharacter();
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
				delete pMI;
				return;
			}
			break;

		case 7:
			if ((m_pCharList[m_cCurFocus - 1] != NULL) && (m_pCharList[m_cCurFocus - 1]->m_sLevel < DEF_MAX_DELETE_LEVEL))
			{	ChangeGameMode(DEF_GAMEMODE_ONQUERYDELETECHARACTER);
				m_wEnterGameType = m_cCurFocus;
				delete pMI;
				return;
			}
			break;

		case 8:
			ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD);
			delete pMI;
			return;

		case 9:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

BOOL CGame::bDlgBoxPress_Character(short msX, short msY)
{
	int i;
	short sX, sY, sSprH, sFrame;
	char cEquipPoiStatus[DEF_MAXITEMEQUIPPOS];

	if (m_bIsDialogEnabled[17] == TRUE) return FALSE;

	sX = m_stDialogBoxInfo[1].sX;
	sY = m_stDialogBoxInfo[1].sY;
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) cEquipPoiStatus[i] = -1;
	for (i = 0; i < DEF_MAXITEMS; i++)
	{	if ((m_pItemList[i] != NULL) && (m_bIsItemEquipped[i] == TRUE))	cEquipPoiStatus[ m_pItemList[i]->m_cEquipPos ] = i;
	}

	if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3))
	{	if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 72, sY + 135, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_RFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1) 
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 98, sY + 182, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_LFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;		
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
			}
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1) 
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;		
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1) 
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 90, sY + 170, sFrame, msX, msY ) )
			{
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1) 
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_FULLBODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1) 
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1) 
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_BOOTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1) 
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1) 
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1) 
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison( sX + 41, sY + 137, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
	}else if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6))
	{	if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1) 
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 72, sY + 139, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1) 
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_RFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;		
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1) 
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 98, sY + 182, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_LFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1) 
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1) 
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1) 
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1) 
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 84, sY + 175, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1) 
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1) 
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_FULLBODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if ((cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1)) 
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_BOOTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1) 
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1) 
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
		}	}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1) 
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 45, sY + 143, sFrame, msX, msY ) )
			{	m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return TRUE;
	}	}	}
	return FALSE;
}

void CGame::DlgBoxClick_CityhallMenu(short msX, short msY)
{short sX, sY;
	sX = m_stDialogBoxInfo[13].sX;
	sY = m_stDialogBoxInfo[13].sY;
	switch (m_stDialogBoxInfo[13].cMode) {
	case 0:
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 70) && (msY < sY + 95))
		{	if (m_bCitizen == TRUE) return;
			m_stDialogBoxInfo[13].cMode = 1; // citizenship rq
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 95) && (msY < sY + 120))
		{	if (m_iRewardGold <= 0) return;
			m_stDialogBoxInfo[13].cMode = 5; // rq reward gold
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 120) && (msY < sY + 145))
		{	if (m_iEnemyKillCount < 100) return;
			m_stDialogBoxInfo[13].cMode = 7;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 145) && (msY < sY + 170))
		{	if (m_stQuest.sQuestType == NULL) return;
			m_stDialogBoxInfo[13].cMode = 8;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 170) && (msY < sY + 195))
		{	if (m_bIsCrusadeMode) return;
			if (m_iPKCount != 0) return;
			if (m_bCitizen == FALSE) return;
			if ((m_iLevel > 100) && (m_bHunter==FALSE)) return;
			m_stDialogBoxInfo[13].cMode = 9;
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 195) && (msY < sY + 220))
		{	m_stDialogBoxInfo[13].cMode = 10;
			m_iTeleportMapCount = -1;
			bSendCommand(MSGID_REQUEST_TELEPORT_LIST, NULL, NULL, NULL, NULL, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 220) && (msY < sY + 245)) {
			if (m_bIsCrusadeMode == FALSE) return;
			EnableDialogBox(33, 1, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		break;

	case 1:
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Yes Click
			bSendCommand(MSGID_REQUEST_CIVILRIGHT, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL, NULL, NULL);
			m_stDialogBoxInfo[13].cMode = 2;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// No Click
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 3:	//
	case 4:	// OK°
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// No Click
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 5:
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Yes
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETREWARDMONEY, NULL, NULL, NULL, NULL, NULL);
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);

		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// No
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	// 3.51 Cityhall Menu - Request Hero's Items - Diuuude - fix by Drajwer
	case 7:
 		int iReqHeroItemID;
 		// Hero's Cape
 		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 95) && (msY <= sY + 110))
 		{	if(m_bAresden == TRUE) iReqHeroItemID = 400;
  			else iReqHeroItemID = 401;
			ZeroMemory(m_cTakeHeroItemName,sizeof(m_cTakeHeroItemName));
			memcpy(m_cTakeHeroItemName,DRAW_DIALOGBOX_CITYHALL_MENU47,strlen(DRAW_DIALOGBOX_CITYHALL_MENU47));
  			m_stDialogBoxInfo[13].cMode = 11;
  			m_stDialogBoxInfo[13].sV1=iReqHeroItemID;
  			PlaySound('E', 14, 5);
 		}
 		// Hero's Helm
 		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 125) && (msY <= sY + 140))
 		{	if((m_bAresden == TRUE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 1)) iReqHeroItemID = 403;
  			if((m_bAresden == TRUE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 2)) iReqHeroItemID = 404;
  			if((m_bAresden == FALSE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 1)) iReqHeroItemID = 405;
  			if((m_bAresden == FALSE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 2)) iReqHeroItemID = 406;
 	 		ZeroMemory(m_cTakeHeroItemName,sizeof(m_cTakeHeroItemName));
 	 		memcpy(m_cTakeHeroItemName,DRAW_DIALOGBOX_CITYHALL_MENU48,strlen(DRAW_DIALOGBOX_CITYHALL_MENU48));
 	 		m_stDialogBoxInfo[13].cMode = 11;
 	 		m_stDialogBoxInfo[13].sV1=iReqHeroItemID;
 	 		PlaySound('E', 14, 5);
 		}
 		// Hero's Cap
 		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 155) && (msY <= sY + 170))
 		{	if((m_bAresden == TRUE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 1)) iReqHeroItemID = 407;
  			if((m_bAresden == TRUE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 2)) iReqHeroItemID = 408;
  			if((m_bAresden == FALSE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 1)) iReqHeroItemID = 409;
  			if((m_bAresden == FALSE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 2)) iReqHeroItemID = 410;
  			ZeroMemory(m_cTakeHeroItemName,sizeof(m_cTakeHeroItemName));
  			memcpy(m_cTakeHeroItemName,DRAW_DIALOGBOX_CITYHALL_MENU49,strlen(DRAW_DIALOGBOX_CITYHALL_MENU49));
  			m_stDialogBoxInfo[13].cMode = 11;
  			m_stDialogBoxInfo[13].sV1=iReqHeroItemID;
  			PlaySound('E', 14, 5);
 		}
 		// Hero's Armor
 		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 185) && (msY <= sY + 200))
 		{  	if((m_bAresden == TRUE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 1)) iReqHeroItemID = 411;
  			if((m_bAresden == TRUE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 2)) iReqHeroItemID = 412;
 	 		if((m_bAresden == FALSE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 1)) iReqHeroItemID = 413;
  			if((m_bAresden == FALSE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 2)) iReqHeroItemID = 414;
  			ZeroMemory(m_cTakeHeroItemName,sizeof(m_cTakeHeroItemName));
  			memcpy(m_cTakeHeroItemName,DRAW_DIALOGBOX_CITYHALL_MENU50,strlen(DRAW_DIALOGBOX_CITYHALL_MENU50));
  			m_stDialogBoxInfo[13].cMode = 11;
  			m_stDialogBoxInfo[13].sV1=iReqHeroItemID;
  			PlaySound('E', 14, 5);
 		}
 		// Hero's Robe
 		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 215) && (msY <= sY + 230))
 		{	if((m_bAresden == TRUE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 1)) iReqHeroItemID = 415;
  			if((m_bAresden == TRUE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 2)) iReqHeroItemID = 416;
  			if((m_bAresden == FALSE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 1)) iReqHeroItemID = 417;
  			if((m_bAresden == FALSE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 2)) iReqHeroItemID = 418;
  			ZeroMemory(m_cTakeHeroItemName,sizeof(m_cTakeHeroItemName));
  			memcpy(m_cTakeHeroItemName,DRAW_DIALOGBOX_CITYHALL_MENU51,strlen(DRAW_DIALOGBOX_CITYHALL_MENU51));
  			m_stDialogBoxInfo[13].cMode = 11;
  			m_stDialogBoxInfo[13].sV1=iReqHeroItemID;
  			PlaySound('E', 14, 5);
 		}
 		// Hero's Hauberk
 		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 245) && (msY <= sY + 260))
  		{	if((m_bAresden == TRUE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 1)) iReqHeroItemID = 419;
	  		if((m_bAresden == TRUE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 2)) iReqHeroItemID = 420;
	  		if((m_bAresden == FALSE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 1)) iReqHeroItemID = 421;
  			if((m_bAresden == FALSE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 2)) iReqHeroItemID = 422;
  			ZeroMemory(m_cTakeHeroItemName,sizeof(m_cTakeHeroItemName));
  			memcpy(m_cTakeHeroItemName,DRAW_DIALOGBOX_CITYHALL_MENU52,strlen(DRAW_DIALOGBOX_CITYHALL_MENU52));
  			m_stDialogBoxInfo[13].cMode = 11;
  			m_stDialogBoxInfo[13].sV1=iReqHeroItemID;
  			PlaySound('E', 14, 5);
 		}
 		// Hero's Leggings
 		if ((msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 275) && (msY <= sY + 290))
 		{  	if((m_bAresden == TRUE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 1)) iReqHeroItemID = 423;
  			if((m_bAresden == TRUE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 2)) iReqHeroItemID = 424;
  			if((m_bAresden == FALSE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 1)) iReqHeroItemID = 425;
  			if((m_bAresden == FALSE) && (m_pCharList[m_cCurFocus-1]->m_sSex == 2)) iReqHeroItemID = 426;
  			ZeroMemory(m_cTakeHeroItemName,sizeof(m_cTakeHeroItemName));
  			memcpy(m_cTakeHeroItemName,DRAW_DIALOGBOX_CITYHALL_MENU53,strlen(DRAW_DIALOGBOX_CITYHALL_MENU53));
  			m_stDialogBoxInfo[13].cMode = 11;
  			m_stDialogBoxInfo[13].sV1=iReqHeroItemID;
  			PlaySound('E', 14, 5);
 		}
 		break;

	case 8:
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Yes
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_CANCELQUEST, NULL, NULL, NULL, NULL, NULL);
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// No
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 9:
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Yes
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_HUNTMODE, NULL, NULL, NULL, NULL, NULL);
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// No
			m_stDialogBoxInfo[13].cMode = 0;
			PlaySound('E', 14, 5);
		}
		break;

	case 10:
		if( m_iTeleportMapCount > 0 )
		{	for( int i=0 ; i<m_iTeleportMapCount ; i++ )
			{	if( (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 130 + i*15) && (msY <= sY + 144 + i*15) )
				{	bSendCommand(MSGID_REQUEST_CHARGED_TELEPORT, NULL, NULL, m_stTeleportList[i].iIndex, NULL, NULL, NULL);
					DisableDialogBox(13);
					return;
		}	}	}
		break;

	case 11: // Fix Drawjer
		 if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETHEROMANTLE, NULL, m_stDialogBoxInfo[13].sV1, NULL, NULL, NULL);
		  	m_stDialogBoxInfo[13].cMode = 0;
		  	PlaySound('E', 14, 5);
		}
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	m_stDialogBoxInfo[13].cMode = 7;
		  	PlaySound('E', 14, 5);
		}
 		break;
	}
}

void CGame::CivilRightAdmissionHandler(char *pData)
{WORD * wp, wResult;
 char * cp;

	wp   = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wResult = *wp;

	switch (wResult) {
	case 0:
		m_stDialogBoxInfo[13].cMode = 4;
		break;

	case 1:
		m_stDialogBoxInfo[13].cMode = 3;
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ZeroMemory(m_cLocation, sizeof(m_cLocation));
		memcpy(m_cLocation, cp, 10);
		if (memcmp(m_cLocation, "aresden", 7) == 0)
		{	m_bAresden = TRUE;
			m_bCitizen = TRUE;
			m_bHunter  = FALSE;
		}else if (memcmp(m_cLocation, "arehunter", 9) == 0)
		{	m_bAresden = TRUE;
			m_bCitizen = TRUE;
			m_bHunter  = TRUE;
		}else if (memcmp(m_cLocation, "elvine", 6) == 0)
		{	m_bAresden = FALSE;
			m_bCitizen = TRUE;
			m_bHunter  = FALSE;
		}else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
		{	m_bAresden = FALSE;
			m_bCitizen = TRUE;
			m_bHunter  = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // m_bAresden, m_bCitizen, m_bHunter for me ready for later fix
		}else if (memcmp(m_cLocation, "executor", 8) == 0)
		{	m_bAresden = TRUE;
			m_bCitizen = FALSE;
			m_bHunter  = FALSE;
		}else if (memcmp(m_cLocation, "evil", 4) == 0)
		{	m_bAresden = TRUE;
			m_bCitizen = FALSE;
			m_bHunter  = FALSE;
		}else if (memcmp(m_cLocation, "NONE", 4) == 0)
		{	m_bAresden = TRUE;
			m_bCitizen = FALSE;
			m_bHunter  = TRUE;
#endif

		}else
		{	m_bAresden = TRUE;
			m_bCitizen = FALSE;
			m_bHunter  = TRUE;
		}
		break;
	}
}

void CGame::DlgBoxClick_Text(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[18].sX;
	sY = m_stDialogBoxInfo[18].sY;

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		DisableDialogBox(18);
		PlaySound('E', 14, 5);
	}
}

void CGame::DlgBoxClick_Inventory(short msX, short msY)
{int i, sX, sY;
	sX = m_stDialogBoxInfo[2].sX;
	sY = m_stDialogBoxInfo[2].sY;
	if ((msX >= sX +23) && (msX <= sX +76) && (msY >= sY +172) && (msY <= sY +184))
	{	if( m_iGizonItemUpgradeLeft == NULL )
		{	m_iGizonItemUpgradeLeft = 0;
		}
		EnableDialogBox(34, 5, NULL, NULL);
		PlaySound('E', 14, 5);

	}
	if ((msX >= sX +140) && (msX <= sX +212) && (msY >= sY +172) && (msY <= sY +184))
	{	if (m_cSkillMastery[13] == 0)
		{	AddEventList(DLGBOXCLICK_INVENTORY1, 10);
			AddEventList(DLGBOXCLICK_INVENTORY2, 10);//"The manufacturing manual is purchasable in Blacksmith."
		}else if (m_bSkillUsingStatus == TRUE)
		{	AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY5, 10);//""You are already using another skill."
			return;
		}else if (_bIsItemOnHand() == TRUE)
		{	AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//""Your hands should be free to use this item."
			return;
		}else
		{	for (i = 0; i < DEF_MAXITEMS; i++)
			if (   (m_pItemList[i] != NULL) && (m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) 
				&& (m_pItemList[i]->m_sSpriteFrame == 113) 
				&& (m_pItemList[i]->m_wCurLifeSpan > 0))
			{	EnableDialogBox(26, 3, NULL, NULL, NULL);
				AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY12, 10);//"Using a manufacturing skill..."
				PlaySound('E', 14, 5);
				return;
			}
			AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY14, 10);
		}
		PlaySound('E', 14, 5);
	}
}

void CGame::DlgBoxClick_Character(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[1].sX;
	sY = m_stDialogBoxInfo[1].sY;
/*
	if ((msX >= sX + 100) && (msX <= sX + 150) && (msY >= sY + 90) && (msY <= sY + 110)) {
		MessageBox(NULL,"CRASHED!!!!","JK",MB_OK);
		DisableDialogBox(1);
		PlaySound('E', 14, 5);
	}*/

	if ((msX >= sX + 15) && (msX <= sX + 15 + DEF_BTNSZX) && (msY >= sY + 340) && (msY <= sY + 340 + DEF_BTNSZY)) {
		EnableDialogBox(28, 1, NULL, NULL);
		DisableDialogBox(1);
		PlaySound('E', 14, 5);
	}
	else if ((msX >= sX + 98) && (msX <= sX + 98 + DEF_BTNSZX) && (msY >= sY + 340) && (msY <= sY + 340 + DEF_BTNSZY)) {
		EnableDialogBox(32, NULL, NULL, NULL);
		DisableDialogBox(1);
		PlaySound('E', 14, 5);
	}
	else if ((msX >= sX + 180) && (msX <= sX + 180 + DEF_BTNSZX) && (msY >= sY + 340) && (msY <= sY + 340 + DEF_BTNSZY)) {
		EnableDialogBox(12, NULL, NULL, NULL);
		DisableDialogBox(1);
		PlaySound('E', 14, 5);
	}
}

void CGame::DlgBoxClick_FeedBackCard(short msX, short msY)
{

}

void CGame::DlgBoxClick_MagicShop(short msX, short msY)
{
 int i, iCPivot, iYloc, iAdjX, iAdjY ;
 short sX, sY;

	sX = m_stDialogBoxInfo[16].sX;
	sY = m_stDialogBoxInfo[16].sY;

	iAdjX = -20 ;
	iAdjY = -35 ;

	iCPivot = m_stDialogBoxInfo[16].sView*10;

	iYloc = 0;
	for (i = 0; i < 9; i++) {
		if ((m_pMagicCfgList[iCPivot + i] != NULL) && (m_pMagicCfgList[iCPivot + i]->m_bIsVisible)) {
			if ((msX >= sX + iAdjX + 44) && (msX <= sX + iAdjX + 135 + 44) && (msY >= sY + iAdjY + 70 + iYloc +35) && (msY <= sY + iAdjY + 70 + 14 + iYloc +35)) {
				if (m_cMagicMastery[iCPivot + i] == 0)
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_STUDYMAGIC, NULL, NULL, NULL, NULL, m_pMagicCfgList[iCPivot + i]->m_cName);
					//bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_STUDYMAGIC, NULL, iCPivot + i, NULL, NULL, NULL); //2002.02.07 »óÇÏ º¯°æ ¹è¿ì°í½ÍÀº ¸ÅÁ÷³×ÀÓ¿¡¼­ ¸¶¹ý¹øÈ£·Î º¯°æ..
					PlaySound('E', 14, 5);
				}
				return;
			}
			iYloc += 18;
		}
	}

	if ((msX >= sX + iAdjX + 42 +31) && (msX <= sX + iAdjX + 50 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35))
		m_stDialogBoxInfo[16].sView = 0;
	if ((msX >= sX + iAdjX + 55 +31) && (msX <= sX + iAdjX + 68 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35))
		m_stDialogBoxInfo[16].sView = 1;
	if ((msX >= sX + iAdjX + 73 +31) && (msX <= sX + iAdjX + 93 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35))
		m_stDialogBoxInfo[16].sView = 2;
	if ((msX >= sX + iAdjX + 98 +31) && (msX <= sX + iAdjX + 113 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35))
		m_stDialogBoxInfo[16].sView = 3;
	if ((msX >= sX + iAdjX + 118 +31) && (msX <= sX + iAdjX + 129 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35))
		m_stDialogBoxInfo[16].sView = 4;
	if ((msX >= sX + iAdjX + 133 +31) && (msX <= sX + iAdjX + 150 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35))
		m_stDialogBoxInfo[16].sView = 5;
	if ((msX >= sX + iAdjX + 154 +31) && (msX <= sX + iAdjX + 177 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35))
		m_stDialogBoxInfo[16].sView = 6;
	if ((msX >= sX + iAdjX + 181 +31) && (msX <= sX + iAdjX + 210 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35))
		m_stDialogBoxInfo[16].sView = 7;
	if ((msX >= sX + iAdjX + 214 +31) && (msX <= sX + iAdjX + 230 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35))
		m_stDialogBoxInfo[16].sView = 8;
	if ((msX >= sX + iAdjX + 234 +31) && (msX <= sX + iAdjX + 245 +31) && (msY >= sY + iAdjY + 248 +35) && (msY <= sY + iAdjY + 260 +35))
		m_stDialogBoxInfo[16].sView = 9;
}

void CGame::_RemoveChatMsgListByObjectID(int iObjectID)
{
 int i;

	for (i = 1; i < DEF_MAXCHATMSGS; i++)
	if ((m_pChatMsgList[i] != NULL) && (m_pChatMsgList[i]->m_iObjectID == iObjectID)) {
		delete m_pChatMsgList[i];
		m_pChatMsgList[i] = NULL;
	}
}

void CGame::PlaySound(char cType, int iNum, int iDist, long lPan)
{
 int iVol;

	if (m_bSoundFlag == FALSE) return;
	if (m_bSoundStat == FALSE) return;

	if (iDist > 10) iDist = 10;

	iVol = (m_cSoundVolume - 100)*20;
	iVol += -200 * iDist;

	if (iVol > 0) iVol = 0;
	if (iVol < -10000) iVol = -10000;

	if (iVol > -2000) {

		switch (cType) {
		case 'C':
			if (m_pCSound[iNum] == NULL) return;
			m_pCSound[iNum]->Play(FALSE, lPan, iVol);
			break;

		case 'M':
			if (m_pMSound[iNum] == NULL) return;
			m_pMSound[iNum]->Play(FALSE, lPan, iVol);
			break;

		case 'E':
			if (m_pESound[iNum] == NULL) return;
			m_pESound[iNum]->Play(FALSE, lPan, iVol);
			break;
		}
	}
}

void CGame::_DrawBlackRect(int iSize)
{
 int ix, iy, sx, sy, dcx, dcy;
 DWORD dwTime;

	dwTime = timeGetTime();

	dcx = 40 - iSize*2;
	dcy = 30 - iSize*2;

	sx = iSize*16;
	sy = iSize*16;

	for (ix = 0; ix < dcx; ix++) {
		m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(ix*16 + sx, iSize*16,       12, dwTime);
		m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(ix*16 + sx, 464 - iSize*16, 12, dwTime);
	}

	for (iy = 0; iy < dcy; iy++) {
		m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(iSize*16,       iy*16 + sy, 12, dwTime);
		m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(624 - iSize*16, iy*16 + sy, 12, dwTime);
	}
}

BOOL CGame::_bCheckItemByType(char cType)
{
 int i;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ( (m_pItemList[i] != NULL) && (m_pItemList[i]->m_cItemType == cType) ) return TRUE;

	return FALSE;
}


void CGame::DynamicObjectHandler(char * pData)
{
 WORD * wp;
 char * cp;
 short * sp, sX, sY, sV1, sV2, sV3;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE);
	wp = (WORD *)cp;
	cp += 2;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	sp = (short *)cp;
	sV1 = *sp;
	cp += 2;

	sp = (short *)cp;
	sV2 = *sp;		   // Dyamic Object Index
	cp += 2;

	sp = (short *)cp;
	sV3 = *sp;
	cp += 2;

	switch (*wp) {
	case DEF_MSGTYPE_CONFIRM:// Dynamic Object
		m_pMapData->bSetDynamicObject(sX, sY, sV2, sV1, TRUE);
		break;

	case DEF_MSGTYPE_REJECT:// Dynamic object
		m_pMapData->bSetDynamicObject(sX, sY, sV2, NULL, TRUE);
		break;
	}
}

BOOL CGame::_bIsItemOnHand() // Snoopy: Fixed to remove ShieldCast
{int i;
 WORD wWeaponType;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pItemList[i] != NULL) && (m_bIsItemEquipped[i] == TRUE))
	{	if (   (m_pItemList[i]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
			&& (strcmp(m_pItemList[i]->m_cName, "GMShield")==0))
			return FALSE;
		else if (   (m_pItemList[i]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
			|| (m_pItemList[i]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
			return TRUE;
	}
	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pItemList[i] != NULL) && (m_bIsItemEquipped[i] == TRUE))
	{	if (m_pItemList[i]->m_cEquipPos == DEF_EQUIPPOS_RHAND)
		{	wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);
			// Snoopy 34 for all wands.
			if ((wWeaponType >= 34) && (wWeaponType < 40)) return FALSE;
			//else if( wWeaponType == 27 ) return FALSE; // Farming's hoe !
			else return TRUE;
	}	}
	return FALSE;
}

int CGame::_iCalcTotalWeight()
{
 int i, iWeight, iCnt, iTemp;
	iCnt = 0;
	iWeight = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] != NULL)
	{	if (   (m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_CONSUME)
			|| (m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_ARROW) )
		{	iTemp = m_pItemList[i]->m_wWeight * m_pItemList[i]->m_dwCount;
			if (strcmp(m_pItemList[i]->m_cName, "Gold") == 0) iTemp = iTemp / 20;
			iWeight += iTemp;
		}else iWeight += m_pItemList[i]->m_wWeight;
		iCnt++;
	}

	return iWeight;
}

void CGame::DlgBoxClick_15AgeMsg(short msX, short msY)
{	// Snoopy: removed feedback card
	short sX, sY;
	sX = m_stDialogBoxInfo[5].sX;
	sY = m_stDialogBoxInfo[5].sY;
    if ((msX >= sX + 120 ) && (msX <= sX + 120 + DEF_BTNSZX ) && (msY >= sY + 127 ) && (msY <= sY + 127 + DEF_BTNSZY))
	   DisableDialogBox(5);
}


void CGame::DlgBoxClick_WarningMsg(short msX, short msY)// Á¤Áø±¤.
{	short sX, sY;
	sX = m_stDialogBoxInfo[6].sX;
	sY = m_stDialogBoxInfo[6].sY;

    if ((msX >= sX + 120 ) && (msX <= sX + 120 + DEF_BTNSZX ) && (msY >= sY + 127 ) && (msY <= sY + 127 + DEF_BTNSZY))
	   DisableDialogBox(6);
}

void CGame::DlgBoxClick_ItemDrop(short msX, short msY)
{	short sX, sY;
	if (m_cCommand < 0) return;

	sX = m_stDialogBoxInfo[4].sX;
	sY = m_stDialogBoxInfo[4].sY;

	if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + 55) && (msY <= sY + 55 + DEF_BTNSZY))
	{
	    m_stDialogBoxInfo[4].cMode = 3;
        bSendCommand(MSGID_COMMAND_COMMON,
                     DEF_COMMONTYPE_ITEMDROP,
                     NULL,
                     m_stDialogBoxInfo[4].sView,
                     1,
                     NULL,
                     m_pItemList[m_stDialogBoxInfo[4].sView]->m_cName);
		//m_stDialogBoxInfo[40].sView ;
		DisableDialogBox(4);
	}

	else if ((msX >= sX + 170 ) && (msX <= sX + 170 + DEF_BTNSZX ) && (msY >= sY + 55 ) && (msY <= sY + 55 + DEF_BTNSZY))
	{

		for (int i = 0; i < DEF_MAXSELLLIST; i++)
	         m_bIsItemDisabled[i] = FALSE;

		DisableDialogBox(4);
	}
    else if ((msX >= sX + 35) && (msX <= sX + 240 ) && (msY >= sY + 80) && (msY <= sY + 90))
	{
	   m_bItemDrop = !m_bItemDrop;
	}
}

void CGame::DlgBoxClick_ItemSellorRepair(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[23].sX;
	sY = m_stDialogBoxInfo[23].sY;

	switch (m_stDialogBoxInfo[23].cMode) {
	case 1:
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Sell
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_SELLITEMCONFIRM, NULL, m_stDialogBoxInfo[23].sV1, m_stDialogBoxInfo[23].sV4, m_stDialogBoxInfo[23].sV3, m_pItemList[m_stDialogBoxInfo[23].sV1]->m_cName); //v1.2
			m_stDialogBoxInfo[23].cMode = 3;
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel
			m_bIsItemDisabled[ m_stDialogBoxInfo[23].sV1 ] = FALSE;
			DisableDialogBox(23);
		}
		break;

	case 2:
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Repair
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM, NULL, m_stDialogBoxInfo[23].sV1, NULL, NULL, m_pItemList[m_stDialogBoxInfo[23].sV1]->m_cName);
			m_stDialogBoxInfo[23].cMode = 4;
		}
		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			// Cancel
			m_bIsItemDisabled[ m_stDialogBoxInfo[23].sV1 ] = FALSE;
			DisableDialogBox(23);
		}
		break;
	}
}


int CGame::iGetLevelExp(int iLevel)
{int iRet;
	if (iLevel == 0) return 0;
	iRet = iGetLevelExp(iLevel - 1) + iLevel * ( 50 + (iLevel * (iLevel / 17) * (iLevel / 17) ) );
	return iRet;
}

int CGame::_iGetTotalItemNum()
{ int i, iCnt;
	iCnt = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] != NULL) iCnt++;
	return iCnt;
}

BOOL CGame::bCheckExID(char * pName)
{	if (m_pExID == NULL) return FALSE;
	if (memcmp(m_cPlayerName, pName, 10) == 0) return FALSE;
	char cTxt[12];
	ZeroMemory(cTxt, sizeof(cTxt));
	memcpy(cTxt, m_pExID->m_pMsg, strlen(m_pExID->m_pMsg));
	if (memcmp(cTxt, pName, 10) == 0) return TRUE;
	else return FALSE;
}

void CGame::DrawWhetherEffects()
{
#define MAXNUM 1000
 static int ix1[MAXNUM];
 static int iy2[MAXNUM];
 static int iFrame[MAXNUM];
 static int iNum = 0;
 int i;
 short dX, dY, sCnt;
 char cTempFrame;
 DWORD dwTime = m_dwCurTime;

	switch (m_cWhetherEffectType) {
	case 1:
	case 2:
	case 3: // rain
		switch (m_cWhetherEffectType) {
		case 1: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 2:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 3:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}

		for (i = 0; i < sCnt; i++)
		{	if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 20) && (m_stWhetherObject[i].sX != 0))
			{	dX = m_stWhetherObject[i].sX - m_sViewPointX;
				dY = m_stWhetherObject[i].sY - m_sViewPointY;
				cTempFrame = 16 + (m_stWhetherObject[i].cStep / 6);
				m_pEffectSpr[11]->PutTransSprite(dX, dY, cTempFrame, dwTime);
 			}else if ((m_stWhetherObject[i].cStep >= 20) && (m_stWhetherObject[i].cStep < 25) && (m_stWhetherObject[i].sX != 0))
			{	dX = m_stWhetherObject[i].sX - m_sViewPointX;
				dY = m_stWhetherObject[i].sY - m_sViewPointY;
				m_pEffectSpr[11]->PutTransSprite(dX, dY, m_stWhetherObject[i].cStep, dwTime);
		}	}
		break;

	case 4:
	case 5:
	case 6: // Snow
		switch (m_cWhetherEffectType) {
		case 4: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 5:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 6:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}
		for (i = 0; i < sCnt; i++)
		{	if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 80))
			{	dX = m_stWhetherObject[i].sX - m_sViewPointX;
				dY = m_stWhetherObject[i].sY - m_sViewPointY;

				// Snoopy: Snow on lower bar
				if (dY >= 460)
				{	cTempFrame = 39 + (m_stWhetherObject[i].cStep / 20)*3;
					dX = m_stWhetherObject[i].sBX;
					dY = DEF_SNOW_POSITION_Y;// 426
				}else cTempFrame = 39 + (m_stWhetherObject[i].cStep / 20)*3 + (rand() % 3);

				m_pEffectSpr[11]->PutTransSprite(dX, dY, cTempFrame, dwTime);

				if (m_bIsXmas == TRUE)
				{	if( dY == 478 - 53 )
					{	ix1[iNum] = dX;
						iy2[iNum] = dY + (rand()%5);
						iFrame[iNum] = cTempFrame;
						iNum++;
					}
					if( iNum >= MAXNUM ) iNum = 0;
		}	}	}
		if (m_bIsXmas == TRUE)
		{	for (i = 0; i <= MAXNUM; i++)
			{	if( iy2[i] > 10 ) m_pEffectSpr[11]->PutTransSprite(ix1[i], iy2[i], iFrame[i], dwTime);
		}	}
		break;
	}
}

void CGame::WhetherObjectFrameCounter()
{
 int i;
 short sCnt;
 char  cAdd;
 DWORD dwTime = m_dwCurTime;

	if ((dwTime - m_dwWOFtime) < 30) return;
	m_dwWOFtime = dwTime;

	switch (m_cWhetherEffectType) {
	case 1:
	case 2:
	case 3: // Rain
		switch (m_cWhetherEffectType) {
		case 1: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 2:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 3:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}
		for (i = 0; i < sCnt; i++)
		{	m_stWhetherObject[i].cStep++;
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 20))
			{	cAdd = (40 - m_stWhetherObject[i].cStep);
				if (cAdd < 0) cAdd = 0;
				m_stWhetherObject[i].sY = m_stWhetherObject[i].sY + cAdd;
				if (cAdd != 0)
					m_stWhetherObject[i].sX = m_stWhetherObject[i].sX - 1;
			}else if (m_stWhetherObject[i].cStep >= 25)
			{	if (m_bIsWhetherEffect == FALSE)
				{	m_stWhetherObject[i].sX    = 0;
					m_stWhetherObject[i].sY    = 0;
					m_stWhetherObject[i].cStep = 30;
				}else
				{	m_stWhetherObject[i].sX    = (m_pMapData->m_sPivotX*32) + ((rand() % 940) - 200) + 300;
					m_stWhetherObject[i].sY    = (m_pMapData->m_sPivotY*32) + ((rand() % 800) - 600) + 240;
					m_stWhetherObject[i].cStep = -1*(rand() % 10);
		}	}	}
		break;

	case 4:
	case 5:
	case 6:
		switch (m_cWhetherEffectType) {
		case 4: sCnt = DEF_MAXWHETHEROBJECTS / 5; break;
		case 5:	sCnt = DEF_MAXWHETHEROBJECTS / 2; break;
		case 6:	sCnt = DEF_MAXWHETHEROBJECTS;     break;
		}
		for (i = 0; i < sCnt; i++)
		{	m_stWhetherObject[i].cStep++;
			if ((m_stWhetherObject[i].cStep >= 0) && (m_stWhetherObject[i].cStep < 80))
			{	cAdd = (80 - m_stWhetherObject[i].cStep)/10;
				if (cAdd < 0) cAdd = 0;
				m_stWhetherObject[i].sY = m_stWhetherObject[i].sY + cAdd;

				//Snoopy: Snow on lower bar
				if (m_stWhetherObject[i].sY > (426 + m_sViewPointY))
				{	m_stWhetherObject[i].sY = 470 + m_sViewPointY;
					if ((rand() % 10) !=2) m_stWhetherObject[i].cStep--;
					if (m_stWhetherObject[i].sBX == 0) m_stWhetherObject[i].sBX = m_stWhetherObject[i].sX - m_sViewPointX;


				}else m_stWhetherObject[i].sX += 1 - (rand() % 3);
			}else if (m_stWhetherObject[i].cStep >= 80)
			{	if (m_bIsWhetherEffect == FALSE)
				{	m_stWhetherObject[i].sX    = 0;
					m_stWhetherObject[i].sY    = 0;
					m_stWhetherObject[i].sBX   = 0;
					m_stWhetherObject[i].cStep = 80;
				}else
				{	m_stWhetherObject[i].sX    = (m_pMapData->m_sPivotX*32) + ((rand() % 940) - 200) + 300;
					m_stWhetherObject[i].sY    = (m_pMapData->m_sPivotY*32) + ((rand() % 800) - 600) + 600;
					m_stWhetherObject[i].cStep = -1*(rand() % 10);
					m_stWhetherObject[i].sBX   = 0;
		}	}	}
		break;
	}
}

void CGame::SetWhetherStatus(BOOL bStart, char cType)
{SYSTEMTIME SysTime;
	GetLocalTime(&SysTime);
	if (bStart == TRUE)
	{	m_bIsWhetherEffect   = TRUE;
		m_cWhetherEffectType = cType;
		if ((m_bSoundStat == TRUE) && (m_bSoundFlag) && (cType >= 1) && (cType <= 3)) m_pESound[38]->Play(TRUE);

		for (int i = 0; i < DEF_MAXWHETHEROBJECTS; i++)
		{	m_stWhetherObject[i].sX    = 1;
			m_stWhetherObject[i].sBX    = 1;
			m_stWhetherObject[i].sY    = 1;
			m_stWhetherObject[i].cStep = -1*(rand() % 40);
		}
		if( cType >= 4 && cType <= 6 )
		{	if( m_bMusicStat ) StartBGM();
		}
	}else
	{	m_bIsWhetherEffect = FALSE;
		m_cWhetherEffectType = NULL;
		if ((m_bSoundStat == TRUE) && (m_bSoundFlag)) m_pESound[38]->bStop();
	}
}

void CGame::DlgBoxClick_ShutDownMsg(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[25].sX;
	sY = m_stDialogBoxInfo[25].sY;
	if ((msX >= sX + 210) && (msX <= sX + 210 + DEF_BTNSZX) && (msY > sY + 127) && (msY < sY + 127 + DEF_BTNSZY)) {
		DisableDialogBox(25);
		PlaySound('E', 14, 5);
	}
}

void CGame::DrawLine(int x0, int y0, int x1, int y1, int iR, int iG, int iB)
{
 int dx, dy, x_inc, y_inc, error, index, dstR, dstG, dstB;
 int iResultX, iResultY;
 WORD * pDst;

	if ((x0 == x1) && (y0 == y1)) return;
	error = 0;
	iResultX = x0;
	iResultY = y0;
	dx = x1-x0;
	dy = y1-y0;
	if(dx>=0)
	{	x_inc = 1;
	}else
	{	x_inc = -1;
		dx = -dx;
	}
	if(dy>=0)
	{	y_inc = 1;
	}else
	{	y_inc = -1;
		dy = -dy;
	}
	if(dx>dy)
	{	for(index = 0; index <= dx; index++)
		{	error += dy;
			if(error > dx)
			{	error -= dx;
				iResultY += y_inc;
			}
			iResultX += x_inc;
			if ((iResultX >= 0) && (iResultX < 640) && (iResultY >= 0) && (iResultY < 480)) {
				pDst = (WORD *)m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*m_DDraw.m_sBackB4Pitch);
				switch (m_DDraw.m_cPixelFormat) {
				case 1:
					dstR = (int)m_DDraw.m_lTransRB100[(pDst[0]&0xF800)>>11][iR];
					dstG = (int)m_DDraw.m_lTransG100[(pDst[0]&0x7E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB100[(pDst[0]&0x1F)][iB];
					*pDst = (WORD)((dstR<<11) | (dstG<<5) | dstB);
					break;

				case 2:
					dstR = (int)m_DDraw.m_lTransRB100[(pDst[0]&0x7C00)>>10][iR];
					dstG = (int)m_DDraw.m_lTransG100[(pDst[0]&0x3E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB100[(pDst[0]&0x1F)][iB];
					*pDst = (WORD)((dstR<<10) | (dstG<<5) | dstB);
					break;
		}	}	}
	}else
	{	for(index = 0; index <= dy; index++)
		{	error += dx;
			if(error > dy)
			{	error -= dy;
				iResultX += x_inc;
			}
			iResultY += y_inc;
			if ((iResultX >= 0) && (iResultX < 640) && (iResultY >= 0) && (iResultY < 480)) {
				pDst = (WORD *)m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*m_DDraw.m_sBackB4Pitch);
				switch (m_DDraw.m_cPixelFormat) {
				case 1:
					dstR = (int)m_DDraw.m_lTransRB100[(pDst[0]&0xF800)>>11][iR];
					dstG = (int)m_DDraw.m_lTransG100[(pDst[0]&0x7E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB100[(pDst[0]&0x1F)][iB];
					*pDst = (WORD)((dstR<<11) | (dstG<<5) | dstB);
					break;

				case 2:
					dstR = (int)m_DDraw.m_lTransRB100[(pDst[0]&0x7C00)>>10][iR];
					dstG = (int)m_DDraw.m_lTransG100[(pDst[0]&0x3E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB100[(pDst[0]&0x1F)][iB];
					*pDst = (WORD)((dstR<<10) | (dstG<<5) | dstB);
					break;
	}	}	}	}
}


void CGame::DrawLine2(int x0, int y0, int x1, int y1, int iR, int iG, int iB)
{int dx, dy, x_inc, y_inc, error, index, dstR, dstG, dstB;
 int iResultX, iResultY;
 WORD * pDst;
	if ((x0 == x1) && (y0 == y1)) return;

	error = 0;
	iResultX = x0;
	iResultY = y0;
	dx = x1-x0;
	dy = y1-y0;
	if(dx>=0)
	{	x_inc = 1;
	}else
	{	x_inc = -1;
		dx = -dx;
	}
	if(dy>=0)
	{	y_inc = 1;
	}else
	{	y_inc = -1;
		dy = -dy;
	}
	if(dx>dy)
	{	for(index = 0; index <= dx; index++)
		{	error += dy;
			if(error > dx)
			{	error -= dx;
				iResultY += y_inc;
			}
			iResultX += x_inc;
			if ((iResultX >= 0) && (iResultX < 640) && (iResultY >= 0) && (iResultY < 480)) {
				pDst = (WORD *)m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*m_DDraw.m_sBackB4Pitch);
				switch (m_DDraw.m_cPixelFormat) {
				case 1:
					dstR = (int)m_DDraw.m_lTransRB50[(pDst[0]&0xF800)>>11][iR];
					dstG = (int)m_DDraw.m_lTransG50[(pDst[0]&0x7E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB50[(pDst[0]&0x1F)][iB];
					*pDst = (WORD)((dstR<<11) | (dstG<<5) | dstB);
					break;

				case 2:
					dstR = (int)m_DDraw.m_lTransRB50[(pDst[0]&0x7C00)>>10][iR];
					dstG = (int)m_DDraw.m_lTransG50[(pDst[0]&0x3E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB50[(pDst[0]&0x1F)][iB];
					*pDst = (WORD)((dstR<<10) | (dstG<<5) | dstB);
					break;
		}	}	}
	}else
	{	for(index = 0; index <= dy; index++)
		{	error += dx;
			if(error > dy)
			{	error -= dy;
				iResultX += x_inc;
			}
			iResultY += y_inc;
			if ((iResultX >= 0) && (iResultX < 640) && (iResultY >= 0) && (iResultY < 480)) {
				pDst = (WORD *)m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*m_DDraw.m_sBackB4Pitch);
				switch (m_DDraw.m_cPixelFormat) {
				case 1:
					dstR = (int)m_DDraw.m_lTransRB50[(pDst[0]&0xF800)>>11][iR];
					dstG = (int)m_DDraw.m_lTransG50[(pDst[0]&0x7E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB50[(pDst[0]&0x1F)][iB];
					*pDst = (WORD)((dstR<<11) | (dstG<<5) | dstB);
					break;

				case 2:
					dstR = (int)m_DDraw.m_lTransRB50[(pDst[0]&0x7C00)>>10][iR];
					dstG = (int)m_DDraw.m_lTransG50[(pDst[0]&0x3E0)>>5][iG];
					dstB = (int)m_DDraw.m_lTransRB50[(pDst[0]&0x1F)][iB];
					*pDst = (WORD)((dstR<<10) | (dstG<<5) | dstB);
					break;
	}	}	}	}
}

void CGame::_DrawThunderEffect(int sX, int sY, int dX, int dY, int rX, int rY, char cType)
{int j, iErr, pX1, pY1, iX1, iY1, tX, tY;
 char cDir;
 DWORD dwTime;
 WORD  wR1, wG1, wB1, wR2, wG2, wB2, wR3, wG3, wB3, wR4, wG4, wB4;
	dwTime = m_dwCurTime;
	sX = pX1 = iX1 = tX = sX;
	sY = pY1 = iY1 = tY = sY;
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(50, 50, 100), &wR1, &wG1, &wB1);
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(30, 30, 100), &wR2, &wG2, &wB2);
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(0, 0, 30), &wR3, &wG3, &wB3);
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(50, 50, 200), &wR4, &wG4, &wB4);

	for (j = 0; j < 100; j++)
	{	switch (cType) {
		case 1: // Ligne epaisse principale
			DrawLine(pX1, pY1, iX1, iY1, 15, 15, 20);
			DrawLine(pX1-1, pY1, iX1-1, iY1, wR1, wG1, wB1);
			DrawLine(pX1+1, pY1, iX1+1, iY1, wR1, wG1, wB1);
			DrawLine(pX1, pY1-1, iX1, iY1-1, wR1, wG1, wB1);
			DrawLine(pX1, pY1+1, iX1, iY1+1, wR1, wG1, wB1);

			DrawLine(pX1-2, pY1, iX1-2, iY1, wR2, wG2, wB2);
			DrawLine(pX1+2, pY1, iX1+2, iY1, wR2, wG2, wB2);
			DrawLine(pX1, pY1-2, iX1, iY1-2, wR2, wG2, wB2);
			DrawLine(pX1, pY1+2, iX1, iY1+2, wR2, wG2, wB2);

			DrawLine(pX1-1, pY1-1, iX1-1, iY1-1, wR3, wG3, wB3);
			DrawLine(pX1+1, pY1-1, iX1+1, iY1-1, wR3, wG3, wB3);
			DrawLine(pX1+1, pY1-1, iX1+1, iY1-1, wR3, wG3, wB3);
			DrawLine(pX1-1, pY1+1, iX1-1, iY1+1, wR3, wG3, wB3);
			break;

		case 2: // traces autour
			DrawLine2(pX1, pY1, iX1, iY1, wR4, wG4, wB4);
			break;
		}
		iErr = 0;
		m_Misc.GetPoint(sX, sY, dX, dY, &tX, &tY, &iErr, j*10);
		pX1 = iX1;
		pY1 = iY1;
		cDir = m_Misc.cGetNextMoveDir(iX1, iY1, tX, tY);
		switch (cDir) {
		case 1:	rY -= 5; break;
		case 2: rY -= 5; rX += 5; break;
		case 3:	rX += 5; break;
		case 4: rX += 5; rY += 5; break;
		case 5: rY += 5; break;
		case 6: rX -= 5; rY += 5; break;
		case 7: rX -= 5; break;
		case 8: rX -= 5; rY -= 5; break;
		}
		if (rX < -20) rX = -20;
		if (rX >  20) rX =  20;
		if (rY < -20) rY = -20;
		if (rY >  20) rY =  20;
		iX1 = iX1 + rX;
		iY1 = iY1 + rY;
		if ((abs(tX - dX) < 5) && (abs(tY - dY) < 5)) break;
	}
	switch (cType) {
	case 1:
		m_pEffectSpr[6]->PutTransSprite(iX1, iY1, (rand() % 2), dwTime);
		break;
	}
}

BOOL CGame::bDlgBoxPress_SkillDlg(short msX, short msY)
{int i , iAdjX, iAdjY ;
 char  cItemID;
 short sX, sY, x1, y1, x2, y2, sArray[10];
	sX = m_stDialogBoxInfo[26].sX;
	sY = m_stDialogBoxInfo[26].sY;
	iAdjX = 5 ;
	iAdjY = 10 ;
	switch (m_stDialogBoxInfo[26].cMode) {
	case 1:
		ZeroMemory(sArray, sizeof(sArray));
		sArray[1] = m_stDialogBoxInfo[26].sV1;
		sArray[2] = m_stDialogBoxInfo[26].sV2;
		sArray[3] = m_stDialogBoxInfo[26].sV3;
		sArray[4] = m_stDialogBoxInfo[26].sV4;
		sArray[5] = m_stDialogBoxInfo[26].sV5;
		sArray[6] = m_stDialogBoxInfo[26].sV6;
		for (i = 1; i <= 6; i++)
		if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != NULL))
		{	cItemID = (char)sArray[i];
			switch (i) {
			case 1: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55, sY + iAdjY + 55,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 2: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*1, sY + iAdjY + 55,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 3: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*2, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 4: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55, sY + iAdjY + 100,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 5: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*1, sY + iAdjY + 100,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 6: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*2, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
			}
			x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
			y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
			x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
			y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;
			if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
			{	switch (i) {
				case 1: m_stDialogBoxInfo[26].sV1 = -1; break;
				case 2: m_stDialogBoxInfo[26].sV2 = -1; break;
				case 3: m_stDialogBoxInfo[26].sV3 = -1; break;
				case 4: m_stDialogBoxInfo[26].sV4 = -1; break;
				case 5: m_stDialogBoxInfo[26].sV5 = -1; break;
				case 6: m_stDialogBoxInfo[26].sV6 = -1; break;
				}
				m_bIsItemDisabled[cItemID] = FALSE;
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = cItemID;
				m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
				m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
				return TRUE;
		}	}
		break;

	case 4:
		ZeroMemory(sArray, sizeof(sArray));
		sArray[1] = m_stDialogBoxInfo[26].sV1;
		sArray[2] = m_stDialogBoxInfo[26].sV2;
		sArray[3] = m_stDialogBoxInfo[26].sV3;
		sArray[4] = m_stDialogBoxInfo[26].sV4;
		sArray[5] = m_stDialogBoxInfo[26].sV5;
		sArray[6] = m_stDialogBoxInfo[26].sV6;
		for (i = 1; i <= 6; i++)
		if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != NULL))
		{	cItemID = (char)sArray[i];
			switch (i) {
			case 1: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 +30 +13, sY + iAdjY + 55 +180,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 2: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*1 +30 +13, sY + iAdjY + 55 +180,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 3: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*2 +30 +13, sY + iAdjY + 55 +180, m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 4: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 +30 +13, sY + iAdjY + 100 +180,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 5: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*1 +30 +13, sY + iAdjY + 100 +180,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 6: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55+45*2 +30 +13, sY + iAdjY + 100 +180, m_pItemList[cItemID]->m_sSpriteFrame); break;
			}
			x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
			y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
			x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
			y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;

			if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
			{	switch (i) {
				case 1: m_stDialogBoxInfo[26].sV1 = -1; break;
				case 2: m_stDialogBoxInfo[26].sV2 = -1; break;
				case 3: m_stDialogBoxInfo[26].sV3 = -1; break;
				case 4: m_stDialogBoxInfo[26].sV4 = -1; break;
				case 5: m_stDialogBoxInfo[26].sV5 = -1; break;
				case 6: m_stDialogBoxInfo[26].sV6 = -1; break;
				}
				m_bIsItemDisabled[cItemID] = FALSE;
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = cItemID;
				m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
				m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
				m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				return TRUE;
		}	}
		break;
	// Crafting
	case 7:
		ZeroMemory(sArray, sizeof(sArray));
		sArray[1] = m_stDialogBoxInfo[26].sV1;
		sArray[2] = m_stDialogBoxInfo[26].sV2;
		sArray[3] = m_stDialogBoxInfo[26].sV3;
		sArray[4] = m_stDialogBoxInfo[26].sV4;
		sArray[5] = m_stDialogBoxInfo[26].sV5;
		sArray[6] = m_stDialogBoxInfo[26].sV6;
		for (i = 1; i <= 6; i++)
		if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != NULL))
		{	cItemID = (char)sArray[i];
			switch (i) {
			case 1: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55, sY + iAdjY + 55,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 2: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 65+45*1, sY + iAdjY + 40,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 3: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 65+45*2, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 4: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 65, sY + iAdjY + 100,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 5: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 65+45*1, sY + iAdjY + 115,  m_pItemList[cItemID]->m_sSpriteFrame); break;
			case 6: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 75+45*2, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
			}
			x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
			y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
			x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
			y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;
			if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
			{	switch (i) {
				case 1: m_stDialogBoxInfo[26].sV1 = -1; break;
				case 2: m_stDialogBoxInfo[26].sV2 = -1; break;
				case 3: m_stDialogBoxInfo[26].sV3 = -1; break;
				case 4: m_stDialogBoxInfo[26].sV4 = -1; break;
				case 5: m_stDialogBoxInfo[26].sV5 = -1; break;
				case 6: m_stDialogBoxInfo[26].sV6 = -1; break;
				}
				m_bIsItemDisabled[cItemID] = FALSE;
				m_stMCursor.cSelectedObjectType	= DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID   = cItemID;
				m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
				m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
				return TRUE;
		}	}
		break;
	}

	return FALSE;
}
// Snoopy: added StormBlade
int CGame::_iGetAttackType()
{WORD wWeaponType;
	wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);
	if (wWeaponType == 0)
	{	if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[5] >= 100)) return 20;
		else return 1;		// Boxe
	}else if ((wWeaponType >= 1) && (wWeaponType <= 2))
	{	if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[7] >= 100)) return 21;
		else return 1;		//Dag, SS
	}else if ((wWeaponType > 2) && (wWeaponType < 20))
	{	if ((wWeaponType == 7)||(wWeaponType == 18)) // Added Kloness Esterk
		{	if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[9] >= 100)) return 22;
			else return 1;  // Esterk
		}else if (wWeaponType == 15)
		{	if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[8] >= 100)) return 30;
			else return 5;  // StormBlade
		}else
		{	if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[8] >= 100)) return 23;
			else return 1;	// LongSwords
		}
	}else if ((wWeaponType >= 20) && (wWeaponType < 29))
	{	if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[10] >= 100)) return 24;
		else return 1;		// Haches
	}else if ((wWeaponType >= 30) && (wWeaponType < 33))
	{	if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[14] >= 100)) return 26;
		else return 1;		// Hammers
	}else if ((wWeaponType >= 34) && (wWeaponType < 40))
	{	if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[21] >= 100)) return 27;
		else return 1;		// Wands
	}else if (wWeaponType >= 40)
	{	if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[6] >= 100)) return 25;
		else return 2;		// Bows
	}else if ((wWeaponType == 29) || (wWeaponType == 33))
	{	if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) && (m_cSkillMastery[8] >= 100)) return 23;
		else return 1;		// LS
	}
	return 0;
}

int CGame::_iGetWeaponSkillType()
{WORD wWeaponType;
	wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);
	if (wWeaponType == 0)
	{	return 5; // Openhand
	}else if ((wWeaponType >= 1) && (wWeaponType < 3))
	{	return 7; // SS
	}else if ((wWeaponType >= 3) && (wWeaponType < 20))
	{	if ((wWeaponType == 7)||(wWeaponType == 18)) // Esterk or KlonessEsterk
			 return 9; // Fencing
		else return 8; // LS
	}else if ((wWeaponType >= 20) && (wWeaponType < 29))
	{	return 10; // Axe (20..28)
	}else if ((wWeaponType >= 30) && (wWeaponType < 33))
	{	return 14; // Hammer (30,31,32)
	}else if ((wWeaponType >= 34) && (wWeaponType < 40))
	{	return 21; // Wand
	}else if (wWeaponType >= 40)
	{	return 6;  // Bow
	}else if ((wWeaponType == 29) || (wWeaponType == 33))
	{	return 8;  // LS LightingBlade || BlackShadow
	}
	return 1; // Fishing !
}

void CGame::NotifyMsg_AdminInfo(char *pData)
{
 char * cp, cStr[256];
 int  * ip, iV1, iV2, iV3, iV4, iV5;

	cp = (char *)(pData + 6);

	ip = (int *)cp;
	iV1 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV2 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV3 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV4 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV5 = *ip;
	cp += 4;

	ZeroMemory(cStr, sizeof(cStr));
	wsprintf(cStr, "%d %d %d %d %d", iV1, iV2, iV3, iV4, iV5);
	AddEventList(cStr);
}

BOOL CGame::_bCheckBadWords(char *pMsg)
{
#ifdef	DEF_EQUILIBRIUM_PROJECT //Checkbadwords
	return FALSE;
#else
 char cStr[500];
 int i, iLen;
	ZeroMemory(cStr, sizeof(cStr));
	strcpy(cStr, pMsg);
	iLen = strlen(cStr);

	for (i = 0; i < iLen; i++) {
		if (m_pCGameMonitor->bCheckBadWord((char *)(cStr + i)) == TRUE) return TRUE;
		if ((unsigned char)cStr[i] >= 128) i++;
	}

	return FALSE;
#endif
}

/*********************************************************************************************************************
**  void CGame::bItemDrop_ExchangeDialog(short msX, short msY)	(snoopy)											**
**  description			:: modifyed for MultiTrade																	**
**********************************************************************************************************************/
void CGame::bItemDrop_ExchangeDialog(short msX, short msY)
{char cItemID;
	if (m_cCommand < 0) return;
	if (m_stDialogBoxExchangeInfo[3].sV1 != -1) return; //Do not accept item's drop if already 4 items.

	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if ( ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
		 (m_pItemList[cItemID]->m_dwCount > 1) )
	{	m_stDialogBoxInfo[17].sX  = msX - 140;
		m_stDialogBoxInfo[17].sY  = msY - 70;
		if (m_stDialogBoxInfo[17].sY < 0) m_stDialogBoxInfo[17].sY = 0;
		m_stDialogBoxInfo[17].sV1 = m_sPlayerX+1;
		m_stDialogBoxInfo[17].sV2 = m_sPlayerY+1;
		m_stDialogBoxInfo[17].sV3 = 1000;
		m_stDialogBoxInfo[17].sV4 = cItemID;
		//m_stDialogBoxInfo[27].sView = cItemID;
		if (m_stDialogBoxExchangeInfo[0].sV1 == -1)			m_stDialogBoxExchangeInfo[0].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[1].sV1 == -1)	m_stDialogBoxExchangeInfo[1].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[2].sV1 == -1)	m_stDialogBoxExchangeInfo[2].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[3].sV1 == -1)	m_stDialogBoxExchangeInfo[3].sItemID = cItemID;
		else return; // Impossible case, tested at function beginning
		ZeroMemory(m_stDialogBoxInfo[17].cStr, sizeof(m_stDialogBoxInfo[17].cStr));
		EnableDialogBox(17, cItemID, m_pItemList[cItemID]->m_dwCount, NULL);
		return;
	}else // hum? déjà on affiche? , bon je désactive, ca devrait plutôt s'afficher lors du retour du serveur.
	{	/*m_stDialogBoxInfo[27].sV1 = m_pItemList[cItemID]->m_sSprite;
		m_stDialogBoxInfo[27].sV2 = m_pItemList[cItemID]->m_sSpriteFrame;
		m_stDialogBoxInfo[27].sV3 = 1;
		m_stDialogBoxInfo[27].sV4 = m_pItemList[cItemID]->m_cItemColor;
		m_stDialogBoxInfo[27].sView = cItemID;*/
		if (m_stDialogBoxExchangeInfo[0].sV1 == -1)			m_stDialogBoxExchangeInfo[0].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[1].sV1 == -1)	m_stDialogBoxExchangeInfo[1].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[2].sV1 == -1)	m_stDialogBoxExchangeInfo[2].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[3].sV1 == -1)	m_stDialogBoxExchangeInfo[3].sItemID = cItemID;
		else return; // Impossible case, tested at function beginning
		m_bIsItemDisabled[cItemID] = TRUE;
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETEXCHANGEITEM, NULL, cItemID, 1, NULL, NULL);
//	   :bSendCommand(DWORD dwMsgID,        WORD wCommand,             char cDir, int iV1, int iV2, int iV3, char * pString, int iV4)
		return;
	}
}
/*********************************************************************************************************************
**  void CGame::DlgBoxClick_Exchange(short msX, short msY)		(snoopy)											**
**  description			:: modifyed for MultiTrade																	**
**********************************************************************************************************************/
void CGame::DlgBoxClick_Exchange(short msX, short msY)
{short sX, sY;
	sX = m_stDialogBoxInfo[27].sX ;
	sY = m_stDialogBoxInfo[27].sY ;
	switch (m_stDialogBoxInfo[27].cMode) {
	case 1: // Not yet confirmed the exchange
		if ((msX >= sX + 220) && (msX <= sX + 220 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY)) // Exchange
		{	if ( (m_stDialogBoxExchangeInfo[0].sV1 != -1) && (m_stDialogBoxExchangeInfo[4].sV1 != -1))
			{	/*bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_CONFIRMEXCHANGEITEM, NULL
					, m_stDialogBoxExchangeInfo[0].sV1 // ItemID; inutilisé par serveur
					, m_stDialogBoxExchangeInfo[0].sV3 // Amount; inutilisé par serveur
					, NULL, NULL);	*/
				PlaySound('E', 14, 5);
				m_stDialogBoxInfo[27].cMode = 2;
				// Show confirmation Diag instead.
				EnableDialogBox(41, NULL, NULL, NULL);
				m_stDialogBoxInfo[41].cMode = 1;
			}
			return;
		}
		if (   (msX >= sX + 450) && (msX <= sX + 450 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY)
			&& (m_bIsDialogEnabled[41] == FALSE)) // Cancel only possible if confirmation is not activated
		{	DisableDialogBox(27);
			DisableDialogBox(22);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL, NULL);
			PlaySound('E', 14, 5);
			return;
		}
		break;

	case 2: // Someone already confirmed the exchange
	/*	if ((msX >= sX + 450) && (msX <= sX + 450 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY))  // Cancel
		{	DisableDialogBox(27);
			DisableDialogBox(22);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL, NULL);
			PlaySound('E', 14, 5);
			return;
		}*/
		break;
	}
}
/*********************************************************************************************************************
**  void CGame::DlgBoxClick_ConfirmExchange(short msX, short msY)		(snoopy)									**
**  description			:: click on confirmation diag																**
**********************************************************************************************************************/
void CGame::DlgBoxClick_ConfirmExchange(short msX, short msY)
{short sX, sY;
	sX = m_stDialogBoxInfo[41].sX ;
	sY = m_stDialogBoxInfo[41].sY ;

	switch (m_stDialogBoxInfo[41].cMode) {
	case 1: // Not yet confirmed the exchange
		// yes
		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + 55) && (msY <= sY + 55 + DEF_BTNSZY))
		{	if ( (m_stDialogBoxExchangeInfo[0].sV1 != -1) && (m_stDialogBoxExchangeInfo[4].sV1 != -1))
			{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_CONFIRMEXCHANGEITEM, NULL
					, m_stDialogBoxExchangeInfo[0].sV1 // ItemID; inutilisé par serveur
					, m_stDialogBoxExchangeInfo[0].sV3 // Amount; inutilisé par serveur
					, NULL, NULL);
				PlaySound('E', 14, 5);
				m_stDialogBoxInfo[27].cMode = 2;
				m_stDialogBoxInfo[41].cMode = 2;
			}
			return;
		}
		// No
		if ((msX >= sX + 170 ) && (msX <= sX + 170 + DEF_BTNSZX ) && (msY >= sY + 55 ) && (msY <= sY + 55 + DEF_BTNSZY))
		{	DisableDialogBox(41);
			DisableDialogBox(27);
			DisableDialogBox(22);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL, NULL);
			PlaySound('E', 14, 5);
			return;
		}
		break;
	case 2: // waiting for other side to confirm
		break;
	}
}

void CGame::DlgBoxClick_Quest(int msX, int msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[28].sX;
	sY = m_stDialogBoxInfo[28].sY;

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		DisableDialogBox(28);
		PlaySound('E', 14, 5);
	}
}

int CGame::_iGetBankItemCount()
{
 int i, iCnt;

	iCnt = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pBankList[i] != NULL) iCnt++;

	return iCnt;
}

BOOL CGame::_bDecodeBuildItemContents()
{char cFileName[255], cTemp[255];
 HANDLE hFile;
 FILE * pFile;
 DWORD  dwFileSize;
 char * pBuffer;
 BOOL   bRet;
 int    i;

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
	if (m_pBuildItemList[i] != NULL) 
	{	delete m_pBuildItemList[i];
		m_pBuildItemList[i] = NULL;
	}

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));

	strcpy(cTemp, "BItemcfg");
	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == NULL) return FALSE;
	else 
	{	pBuffer = new char[dwFileSize+1];
		ZeroMemory(pBuffer, dwFileSize+1);
		fread(pBuffer, dwFileSize, 1, pFile);
		bRet = __bDecodeBuildItemContents(pBuffer);
		delete[] pBuffer;
	}
	fclose(pFile);
	return bRet;
}

BOOL CGame::_bCheckBuildItemStatus()
{int iIndex, i, j, iMatch, iCount;
 char cTempName[21];
 int  iItemCount[DEF_MAXITEMS];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
	if (m_pDispBuildItemList[i] != NULL)
	{	delete m_pDispBuildItemList[i];
		m_pDispBuildItemList[i] = NULL;
	}
	iIndex = 0;
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
	if (m_pBuildItemList[i] != NULL)
	{	// Skill-Limit
		if (m_cSkillMastery[13] >= m_pBuildItemList[i]->m_iSkillLimit)
		{	iMatch = 0;
			m_pDispBuildItemList[iIndex] = new class CBuildItem;
			memcpy(m_pDispBuildItemList[iIndex]->m_cName, m_pBuildItemList[i]->m_cName, 20);

			memcpy(m_pDispBuildItemList[iIndex]->m_cElementName1, m_pBuildItemList[i]->m_cElementName1, 20);
			memcpy(m_pDispBuildItemList[iIndex]->m_cElementName2, m_pBuildItemList[i]->m_cElementName2, 20);
			memcpy(m_pDispBuildItemList[iIndex]->m_cElementName3, m_pBuildItemList[i]->m_cElementName3, 20);
			memcpy(m_pDispBuildItemList[iIndex]->m_cElementName4, m_pBuildItemList[i]->m_cElementName4, 20);
			memcpy(m_pDispBuildItemList[iIndex]->m_cElementName5, m_pBuildItemList[i]->m_cElementName5, 20);
			memcpy(m_pDispBuildItemList[iIndex]->m_cElementName6, m_pBuildItemList[i]->m_cElementName6, 20);

			m_pDispBuildItemList[iIndex]->m_iElementCount[1] = m_pBuildItemList[i]->m_iElementCount[1];
			m_pDispBuildItemList[iIndex]->m_iElementCount[2] = m_pBuildItemList[i]->m_iElementCount[2];
			m_pDispBuildItemList[iIndex]->m_iElementCount[3] = m_pBuildItemList[i]->m_iElementCount[3];
			m_pDispBuildItemList[iIndex]->m_iElementCount[4] = m_pBuildItemList[i]->m_iElementCount[4];
			m_pDispBuildItemList[iIndex]->m_iElementCount[5] = m_pBuildItemList[i]->m_iElementCount[5];
			m_pDispBuildItemList[iIndex]->m_iElementCount[6] = m_pBuildItemList[i]->m_iElementCount[6];

			m_pDispBuildItemList[iIndex]->m_iSprH       = m_pBuildItemList[i]->m_iSprH;
			m_pDispBuildItemList[iIndex]->m_iSprFrame   = m_pBuildItemList[i]->m_iSprFrame;
			m_pDispBuildItemList[iIndex]->m_iMaxSkill   = m_pBuildItemList[i]->m_iMaxSkill;
			m_pDispBuildItemList[iIndex]->m_iSkillLimit = m_pBuildItemList[i]->m_iSkillLimit;

			// ItemCount
			for (j = 0; j < DEF_MAXITEMS; j++)
			if (m_pItemList[j] != NULL)
				 iItemCount[j] = m_pItemList[j]->m_dwCount;
			else iItemCount[j] = 0;

			// Element1
			ZeroMemory(cTempName, sizeof(cTempName));
			memcpy(cTempName, m_pBuildItemList[i]->m_cElementName1, 20);
			iCount = m_pBuildItemList[i]->m_iElementCount[1];
			if (iCount == 0) iMatch++;
			else
			{	for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_pItemList[j] != NULL) {
					if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
						(iItemCount[j] > 0))
					{	iMatch++;
						m_pDispBuildItemList[iIndex]->m_bElementFlag[1] = TRUE;
						iItemCount[j] -= iCount;
						goto CBIS_STEP2;
			}	}	}

CBIS_STEP2:;
			// Element2
			ZeroMemory(cTempName, sizeof(cTempName));
			memcpy(cTempName, m_pBuildItemList[i]->m_cElementName2, 20);
			iCount = m_pBuildItemList[i]->m_iElementCount[2];
			if (iCount == 0) iMatch++;
			else
			{	for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_pItemList[j] != NULL)
				{	if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
						(iItemCount[j] > 0))
					{	iMatch++;
						m_pDispBuildItemList[iIndex]->m_bElementFlag[2] = TRUE;
						iItemCount[j] -= iCount;
						goto CBIS_STEP3;
			}	}	}

CBIS_STEP3:;
			// Element3
			ZeroMemory(cTempName, sizeof(cTempName));
			memcpy(cTempName, m_pBuildItemList[i]->m_cElementName3, 20);
			iCount = m_pBuildItemList[i]->m_iElementCount[3];
			if (iCount == 0) iMatch++;
			else
			{	for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_pItemList[j] != NULL)
				{	if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
						(iItemCount[j] > 0))
					{	iMatch++;
						m_pDispBuildItemList[iIndex]->m_bElementFlag[3] = TRUE;
						iItemCount[j] -= iCount;
						goto CBIS_STEP4;
			}	}	}

CBIS_STEP4:;
		    // Element4 °Ë»ç
			ZeroMemory(cTempName, sizeof(cTempName));
			memcpy(cTempName, m_pBuildItemList[i]->m_cElementName4, 20);
			iCount = m_pBuildItemList[i]->m_iElementCount[4];
			if (iCount == 0) iMatch++;
			else
			{	for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_pItemList[j] != NULL)
				{	if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
						(iItemCount[j] > 0))
					{	iMatch++;
						m_pDispBuildItemList[iIndex]->m_bElementFlag[4] = TRUE;
						iItemCount[j] -= iCount;
						goto CBIS_STEP5;
			}	}	}

CBIS_STEP5:;

			// Element5
			ZeroMemory(cTempName, sizeof(cTempName));
			memcpy(cTempName, m_pBuildItemList[i]->m_cElementName5, 20);
			iCount = m_pBuildItemList[i]->m_iElementCount[5];
			if (iCount == 0) iMatch++;
			else
			{	for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_pItemList[j] != NULL)
				{	if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
						(iItemCount[j] > 0))
					{	iMatch++;
						m_pDispBuildItemList[iIndex]->m_bElementFlag[5] = TRUE;
						iItemCount[j] -= iCount;
						goto CBIS_STEP6;
			}	}	}

CBIS_STEP6:;

			// Element6
			ZeroMemory(cTempName, sizeof(cTempName));
			memcpy(cTempName, m_pBuildItemList[i]->m_cElementName6, 20);
			iCount = m_pBuildItemList[i]->m_iElementCount[6];
			if (iCount == 0) iMatch++;
			else
			{	for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_pItemList[j] != NULL)
				{	if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (DWORD)(iCount)) &&
						(iItemCount[j] > 0))
					{	iMatch++;
						m_pDispBuildItemList[iIndex]->m_bElementFlag[6] = TRUE;
						iItemCount[j] -= iCount;
						goto CBIS_STEP7;
			}	}	}

CBIS_STEP7:;

			if (iMatch == 6) m_pDispBuildItemList[iIndex]->m_bBuildEnabled = TRUE;
			iIndex++;
	}	}
	return TRUE;
}

BOOL CGame::_ItemDropHistory(char * ItemName)
{BOOL bFlag = FALSE;
	if (m_iItemDropCnt == 0 )
	{	strcpy(m_cItemDrop[m_iItemDropCnt], ItemName);
		m_iItemDropCnt++;
		return TRUE;
	}
	if ( (1 <= m_iItemDropCnt) && (20 >= m_iItemDropCnt) )
	{	for (int i = 0; i < m_iItemDropCnt; i++)
		{	if (strcmp(m_cItemDrop[i], ItemName) == 0)
			{	bFlag = TRUE;
	            break;
		}	}
		if (bFlag)
		{	if (m_bItemDrop)
				return FALSE;
			else
				return TRUE;
		}

		if( 20 < m_iItemDropCnt )
		{	for (int i = 0; i < m_iItemDropCnt ; i++)
            strcpy(m_cItemDrop[i-1], ItemName);
			strcpy(m_cItemDrop[20], ItemName);
			m_iItemDropCnt = 21;
		}else
		{	strcpy(m_cItemDrop[m_iItemDropCnt], ItemName);
			m_iItemDropCnt++;
	}	}
	return TRUE;
}


BOOL CGame::__bDecodeBuildItemContents(char *pBuffer)
{char * pContents, * token;
 char seps[] = "= ,\t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iIndex = 0;
 class CStrTok * pStrTok;
	pContents = pBuffer;
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while( token != NULL ) 
	{	if (cReadModeA != 0) 
		{	switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					ZeroMemory(m_pBuildItemList[iIndex]->m_cName, sizeof(m_pBuildItemList[iIndex]->m_cName));
					memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:
					m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // m_cElementName1
					ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName1, sizeof(m_pBuildItemList[iIndex]->m_cElementName1));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName1, token, strlen(token));
					cReadModeB = 4;
					break;
				case 4: // m_iElementCount1
					m_pBuildItemList[iIndex]->m_iElementCount[1] = atoi(token);
					cReadModeB = 5;
					break;
				case 5: // m_cElementName2
					ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName2, sizeof(m_pBuildItemList[iIndex]->m_cElementName2));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName2, token, strlen(token));
					cReadModeB = 6;
					break;
				case 6: // m_iElementCount2
					m_pBuildItemList[iIndex]->m_iElementCount[2] = atoi(token);
					cReadModeB = 7;
					break;
				case 7: // m_cElementName3
					ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName3, sizeof(m_pBuildItemList[iIndex]->m_cElementName3));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName3, token, strlen(token));
					cReadModeB = 8;
					break;
				case 8: // m_iElementCount3
					m_pBuildItemList[iIndex]->m_iElementCount[3] = atoi(token);
					cReadModeB = 9;
					break;
				case 9: // m_cElementName4
					ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName4, sizeof(m_pBuildItemList[iIndex]->m_cElementName4));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName4, token, strlen(token));
					cReadModeB = 10;
					break;
				case 10: // m_iElementCount4
					m_pBuildItemList[iIndex]->m_iElementCount[4] = atoi(token);
					cReadModeB = 11;
					break;
				case 11: // m_cElementName5
					ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName5, sizeof(m_pBuildItemList[iIndex]->m_cElementName5));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName5, token, strlen(token));
					cReadModeB = 12;
					break;
				case 12: // m_iElementCount5
					m_pBuildItemList[iIndex]->m_iElementCount[5] = atoi(token);
					cReadModeB = 13;
					break;
				case 13: // m_cElementName6
					ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName6, sizeof(m_pBuildItemList[iIndex]->m_cElementName6));
					memcpy(m_pBuildItemList[iIndex]->m_cElementName6, token, strlen(token));
					cReadModeB = 14;
					break;
				case 14: // m_iElementCount6
					m_pBuildItemList[iIndex]->m_iElementCount[6] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					m_pBuildItemList[iIndex]->m_iSprH = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					m_pBuildItemList[iIndex]->m_iSprFrame = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					iIndex++;
					break;
				}
				break;

			default:
				break;
			}
		}else 
		{	if (memcmp(token, "BuildItem", 9) == 0) 
			{	cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
		}	}
		token = pStrTok->pGet();
	}
	delete pStrTok;
	if ((cReadModeA != 0) || (cReadModeB != 0)) return FALSE;
	return TRUE;
}


BOOL CGame::_bCheckCurrentBuildItemStatus()
{
 int i, iCount2, iMatch, iIndex, iItemIndex[7];
 int iCount;
 int iItemCount[7];
 char cTempName[21];
 BOOL bItemFlag[7];

	iIndex = m_stDialogBoxInfo[26].cStr[0];

	if (m_pBuildItemList[iIndex] == NULL) return FALSE;

	iItemIndex[1] = m_stDialogBoxInfo[26].sV1;
	iItemIndex[2] = m_stDialogBoxInfo[26].sV2;
	iItemIndex[3] = m_stDialogBoxInfo[26].sV3;
	iItemIndex[4] = m_stDialogBoxInfo[26].sV4;
	iItemIndex[5] = m_stDialogBoxInfo[26].sV5;
	iItemIndex[6] = m_stDialogBoxInfo[26].sV6;

	for (i = 1; i <= 6; i++)
	if (iItemIndex[i] != -1)
		 iItemCount[i] = m_pItemList[iItemIndex[i]]->m_dwCount;
	else iItemCount[i] = 0;
	iMatch = 0;
	for (i = 1; i <= 6; i++) bItemFlag[i] = FALSE;

	// Element1
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName1, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[1];
	if (iCount == 0) iMatch++;
	else
	{	for (i = 1; i <= 6; i++)
		{	if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == FALSE))
			{	iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = TRUE;
				goto CCBIS_STEP2;
	}	}	}

CCBIS_STEP2:;

	// Element2
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName2, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[2];
	if (iCount == 0) iMatch++;
	else
	{	for (i = 1; i <= 6; i++)
		{	if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == FALSE))
			{	iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = TRUE;
				goto CCBIS_STEP3;
	}	}	}

CCBIS_STEP3:;


	// Element3
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName3, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[3];
	if (iCount == 0) iMatch++;
	else
	{	for (i = 1; i <= 6; i++)
		{	if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == FALSE))
			{	iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = TRUE;
				goto CCBIS_STEP4;
	}	}	}

CCBIS_STEP4:;

	// Element4
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName4, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[4];
	if (iCount == 0) iMatch++;
	else
	{	for (i = 1; i <= 6; i++)
		{	if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == FALSE))
			{	iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = TRUE;
				goto CCBIS_STEP5;
	}	}	}

CCBIS_STEP5:;

	// Element5
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName5, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[5];
	if (iCount == 0) iMatch++;
	else
	{	for (i = 1; i <= 6; i++)
		{	if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == FALSE))
			{	iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = TRUE;
				goto CCBIS_STEP6;
	}	}	}

CCBIS_STEP6:;

	// Element6
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName6, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[6];
	if (iCount == 0) iMatch++;
	else
	{	for (i = 1; i <= 6; i++)
		{	if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (DWORD)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == FALSE))
			{	iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = TRUE;
				goto CCBIS_STEP7;
	}	}	}

CCBIS_STEP7:;

	iCount = 0;
	for (i = 1; i <= 6; i++)
	if (m_pDispBuildItemList[iIndex]->m_iElementCount[i] != 0) iCount++;
	iCount2 = 0;
	for (i = 1; i <= 6; i++)
	if (iItemIndex[i] != -1) iCount2++;
	if ((iMatch == 6) && (iCount == iCount2)) return TRUE;
	return FALSE;
}

void CGame::NoticementHandler(char * pData)
{
 char * cp;
 FILE * pFile;
 WORD * wp;
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	switch (*wp) {
	case DEF_MSGTYPE_CONFIRM:
		break;
	case DEF_MSGTYPE_REJECT:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		pFile = fopen("contents\\contents1000.txt", "wt");
		if (pFile == NULL) return;
		fwrite(cp, strlen(cp), 1, pFile);
		fclose(pFile);
		m_stDialogBoxInfo[18].sX  =  20;
		m_stDialogBoxInfo[18].sY  =  65;
		EnableDialogBox(18, 1000, NULL, NULL);
		break;
	}
#ifdef DEF_MULTI_SHORTCUT
	AddEventList("Press Ctrl+H for news and help.", 10);
#else
	AddEventList("Press F1 for news and help.", 10);
#endif
	if (m_iLevel < 42) EnableDialogBox(35, NULL, NULL, NULL);

}

#ifdef DEF_EQUILIBRIUM_PROJECT // _iGetFOE
int CGame::_iGetFOE(int iStatus)
{	BOOL bCitizen, bAresden, bHunter;
	if ( iStatus & 0x00080000 ) return -2; // Boss Mobs

	//I see a traveller: 1 1+0+0+0 bHunter
	//I see an   elvine: 4 0+0+4+0 bCitizen
	//I see an  elv civ: 5 1+0+4+0 bHunter  & bCitizen
	//I see an     ares: 6 0+2+4+0 bCitizen & bAresden
	//I see an  are civ: 7 1+2+4+0 bHunter  & bCitizen & bAresden
	//I see an executor: 6 0+2+0+0 bAresden (NotCitizen but Aresden, and not bHunter)

	if( m_iPKCount != 0 ) return -1;		// I'm crim, everybody is eny
	if( iStatus & 0x80000000 ) return -1;	// He's crim, so he's my eny

	if( iStatus & 0x40000000 ) bCitizen = TRUE;
	else bCitizen = FALSE;
	if( iStatus & 0x20000000 ) bAresden = TRUE;
	else bAresden = FALSE;

	if( iStatus & 0x10000000 ) bHunter = TRUE;
	else bHunter = FALSE;

	if((m_bAresden == bAresden) && (m_bCitizen == bCitizen)) return 1;
											// We are same city (elvine/aresden/executor)=>friend
	if( bCitizen == FALSE ) // I am trav or exec
	{	if (bHunter == TRUE) return 0;		// Trav seen as neutral
			else return -1;					// Exec seen as eny
	}
	if(( m_bIsCrusadeMode == TRUE)||(m_bIsAvatarMode == TRUE))
	{	return -1;
	}else
	{	if( (m_bHunter == FALSE) && (bHunter == FALSE) ) return -1;
	}
	return 0; // Civ see Civ as neutral
}
#else
int CGame::_iGetFOE(int iStatus)
{	BOOL bPK, bCitizen, bAresden, bHunter;
	if( m_iPKCount != 0 ) return -1;
	//	CLEROTH			0x00000000 status is int NOT short ( 3.51 )
	if( iStatus & 0x80000000 ) bPK = TRUE;
	else bPK = FALSE;
	if( iStatus & 0x40000000 ) bCitizen = TRUE;
	else bCitizen = FALSE;
	if( iStatus & 0x20000000 ) bAresden = TRUE;
	else bAresden = FALSE;
	if( iStatus & 0x10000000 ) bHunter = TRUE;
	else bHunter = FALSE;
	if( bPK == TRUE ) return -2;
	if( bCitizen == FALSE ) return 0;
	if( m_bCitizen == FALSE ) return 0;
	if( (m_bAresden == TRUE) && (bAresden == TRUE) ) return 1;
	if( (m_bAresden == FALSE) && (bAresden == FALSE) ) return 1;
	if( m_bIsCrusadeMode == TRUE ) return -1;
	else
	{	if( (m_bHunter == FALSE) && (bHunter == FALSE) ) return -1;
		else return 0;
	}
}
#endif

void CGame::_SetIlusionEffect(int iOwnerH)
{
 char cDir;

	m_iIlusionOwnerH = iOwnerH;

	ZeroMemory(m_cName_IE, sizeof(m_cName_IE));
	m_pMapData->GetOwnerStatusByObjectID(iOwnerH, &m_cIlusionOwnerType, &cDir, &m_sAppr1_IE, &m_sAppr2_IE, &m_sAppr3_IE, &m_sAppr4_IE, &m_iStatus_IE, &m_iApprColor_IE, m_cName_IE);
}

void CGame::ResponsePanningHandler(char *pData)
{
 char * cp, cDir;
 short * sp, sX, sY;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE +2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;

	switch (cDir) {
	case 1: m_sViewDstY -= 32; m_sPlayerY--; break;
	case 2: m_sViewDstY -= 32; m_sPlayerY--; m_sViewDstX += 32; m_sPlayerX++; break;
	case 3: m_sViewDstX += 32; m_sPlayerX++; break;
	case 4: m_sViewDstY += 32; m_sPlayerY++; m_sViewDstX += 32; m_sPlayerX++; break;
	case 5: m_sViewDstY += 32; m_sPlayerY++;break;
	case 6: m_sViewDstY += 32; m_sPlayerY++; m_sViewDstX -= 32; m_sPlayerX--; break;
	case 7: m_sViewDstX -= 32; m_sPlayerX--; break;
	case 8: m_sViewDstY -= 32; m_sPlayerY--; m_sViewDstX -= 32; m_sPlayerX--; break;
	}

	m_pMapData->ShiftMapData(cDir);
	_ReadMapData(sX, sY, cp);

	m_bIsRedrawPDBGS = TRUE;

	m_bIsObserverCommanded = FALSE;
}

BOOL CGame::bReadItemNameConfigFile()
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "=\n";
 int iIndex;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile("contents\\ItemName.cfg", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen("contents\\ItemName.cfg", "rt");
	if (pFile == NULL) return FALSE;
	else {
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		token = strtok( cp, seps );
		while( token != NULL )   {

			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:
						m_pItemNameList[iIndex] = new class CItemName;
						strcpy(m_pItemNameList[iIndex]->m_cOriginName, token);
						cReadModeB = 2;
						break;

					case 2:
						strcpy(m_pItemNameList[iIndex]->m_cName, token);
						cReadModeA = 0;
						cReadModeB = 0;
						iIndex++;
						break;
					}
				}
			}
			else {
				if (memcmp(token, "Item", 4) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = strtok( NULL, seps );
		}
		delete[] cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CGame::DrawDialogBox_Map()
{
 short sX, sY;
 DWORD dwTime = m_dwCurTime;
 double dV1, dV2, dV3;
 int    tX, tY, szX, szY, dX, dY;

	sX = m_stDialogBoxInfo[22].sX;
	sY = m_stDialogBoxInfo[22].sY;

	szX = 0;
	szY = 0;

	switch (m_stDialogBoxInfo[22].sV1) {
	case 1:
		switch (m_stDialogBoxInfo[22].sV2) {
		case 0: // aresden
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS1]->PutTransSprite2(sX, sY, 0, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS1]->PutSpriteFast(sX, sY, 0, dwTime);
			dX = 19;
			dY = 20;
			szX = 260;
			szY = 260;
			break;

		case 1: // elvine
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS1]->PutTransSprite2(sX, sY, 1, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS1]->PutSpriteFast(sX, sY, 1, dwTime);
			dX = 20;
			dY = 18;
			szX = 260;
			szY = 260;
			break;

		case 2: // middleland
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS2]->PutTransSprite2(sX, sY, 0, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS2]->PutSpriteFast(sX, sY, 0, dwTime);
			dX = 11;
			dY = 31;
			szX = 280;
			szY = 253;
			break;

		case 3: // default
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS2]->PutTransSprite2(sX, sY, 1, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS2]->PutSpriteFast(sX, sY, 1, dwTime);
			dX = 52;
			dY = 42;
			szX = 200;
			szY = 200;
			break;

		case 4: // aresden ¸
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS3]->PutTransSprite2(sX, sY, 0, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS3]->PutSpriteFast(sX, sY, 0, dwTime);
			dX = 40;
			dY = 40;
			szX = 220;
			szY = 220;
			break;

		case 5: // elvine ¸
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS3]->PutTransSprite2(sX, sY, 1, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS3]->PutSpriteFast(sX, sY, 1, dwTime);
			dX = 40;
			dY = 40;
			szX = 220;
			szY = 220;
			break;

		case 6: // aresden
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS4]->PutTransSprite2(sX, sY, 0, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS4]->PutSpriteFast(sX, sY, 0, dwTime);
			dX = 40;
			dY = 40;
			szX = 220;
			szY = 220;
			break;

		case 7: // elvine
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS4]->PutTransSprite2(sX, sY, 1, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS4]->PutSpriteFast(sX, sY, 1, dwTime);
			dX = 40;
			dY = 40;
			szX = 220;
			szY = 220;
			break;
		case 8: // aresden
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS5]->PutTransSprite2(sX, sY, 0, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS5]->PutSpriteFast(sX, sY, 0, dwTime);
			dX = 40;
			dY = 32;
			szX = 220;
			szY = 220;
			break;

		case 9: // elvine
			if (m_bDialogTrans)
				 m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS5]->PutTransSprite2(sX, sY, 1, dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_NEWMAPS5]->PutSpriteFast(sX, sY, 1, dwTime);
			dX = 40;
			dY = 38;
			szX = 220;
			szY = 220;
			break;

		}

		dV1 = (double)m_pMapData->m_sMapSizeX;
		dV2 = (double)m_sPlayerX;
		dV3 = (dV2*(double)szX)/dV1;
		tX  = (int)dV3 +dX;

		dV1 = (double)m_pMapData->m_sMapSizeY;
		if( dV1 == 752 ) dV1 = 680;
		dV2 = (double)m_sPlayerY;
		dV3 = (dV2*(double)szY)/dV1;
		tY  = (int)dV3 +dY;


		//m_pSprite[DEF_SPRID_INTERFACE_MAPS1]->PutSpriteFast(sX +tX, sY +tY, 4, dwTime);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, sX +tX, sY +tY, 43);
		wsprintf(G_cTxt, "%d,%d", m_sPlayerX, m_sPlayerY);
		PutString_SprFont3(sX + 10 +tX -5, sY + 10 + tY -6, G_cTxt, m_wR[13]*4, m_wG[13]*4, m_wB[13]*4, FALSE, 2);
		break;
   	}
}
/*********************************************************************************************************************
**  void CGame::NotifyMsg_SetExchangeItem(char *pData)		(snoopy)												**
**  description			:: Recieve a msg from gserver and sets the item												**
**********************************************************************************************************************/
void CGame::NotifyMsg_SetExchangeItem(char *pData)
{short * sp, sDir, sSprite, sSpriteFrame, sCurLife, sMaxLife, sPerformance;
 int * ip, iAmount, i;
 char * cp, cColor, cItemName[24], cCharName[12];
 DWORD * dwp, dwAttribute;
	ZeroMemory(cItemName, sizeof(cItemName));
	ZeroMemory(cCharName, sizeof(cCharName));

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	sp = (short *)cp;
	sDir = *sp;
	cp += 2;
	sp = (short *)cp;
	sSprite = *sp;
	cp += 2;
	sp = (short *)cp;
	sSpriteFrame = *sp;
	cp += 2;
	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;
	cColor = *cp;
	cp++;
	sp = (short *)cp;
	sCurLife = *sp;
	cp += 2;
	sp = (short *)cp;
	sMaxLife = *sp;
	cp += 2;
	sp = (short *)cp;
	sPerformance = *sp;
	cp += 2;
	memcpy(cItemName, cp, 20);
	cp += 20;
	memcpy(cCharName, cp, 10);
	cp += 10;
	dwp = (DWORD *)cp;
	dwAttribute = *dwp;
	cp += 4;

	if (sDir >= 1000)  // Set the item I want to exchange
	{	i = 0;
		while (m_stDialogBoxExchangeInfo[i].sV1 !=-1)
		{	i++;
			if (i>=4) return; // Error situation
		}
	}else // Set the item he proposes me.
	{	i = 4;
		while (m_stDialogBoxExchangeInfo[i].sV1 !=-1)
		{	i++;
			if (i>=8) return; // Error situation
	}	}
	m_stDialogBoxExchangeInfo[i].sV1 = sSprite;
	m_stDialogBoxExchangeInfo[i].sV2 = sSpriteFrame;
	m_stDialogBoxExchangeInfo[i].sV3 = iAmount;
	m_stDialogBoxExchangeInfo[i].sV4 = cColor;
	m_stDialogBoxExchangeInfo[i].sV5 = (int)sCurLife;
	m_stDialogBoxExchangeInfo[i].sV6 = (int)sMaxLife;
	m_stDialogBoxExchangeInfo[i].sV7 = (int)sPerformance;
	memcpy(m_stDialogBoxExchangeInfo[i].cStr1, cItemName, 20);
	memcpy(m_stDialogBoxExchangeInfo[i].cStr2, cCharName, 10);
	m_stDialogBoxExchangeInfo[i].dwV1 = dwAttribute;
	//if (i<4) m_stDialogBoxExchangeInfo[i].sItemID = sDir -1000;
}

void CGame::NotifyMsg_DismissGuildApprove(char * pData)
{
 char * cp, cName[24], cLocation[12];
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cLocation, sizeof(cLocation));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 20);
	cp += 20;
	cp += 2;
	memcpy(cLocation, cp, 10);
	cp += 10;
	ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
	m_iGuildRank = -1;
	ZeroMemory(m_cLocation, sizeof(m_cLocation));
	memcpy(m_cLocation, cLocation, 10);
	if (memcmp(m_cLocation, "aresden", 7) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "arehunter", 9) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter  = TRUE;
	}else if (memcmp(m_cLocation, "elvine", 6) == 0)
	{	m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
	{	m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter  = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // m_bAresden, m_bCitizen, m_bHunter for me ready for later fix
	}else if (memcmp(m_cLocation, "executor", 8) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "evil", 4) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "NONE", 4) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = TRUE;
#endif

	}else
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = TRUE;
	}
	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 5);
}

void CGame::NotifyMsg_DismissGuildReject(char * pData)
{char * cp, cName[21];
	ZeroMemory(cName, sizeof(cName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 20);
	cp += 20;
	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 6);
}

void CGame::NotifyMsg_DownSkillIndexSet(char *pData)
{
 WORD * wp;
 short sSkillIndex;
 char * cp;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	sSkillIndex = (short)*wp;
	cp += 2;
	m_iDownSkillIndex = sSkillIndex;
	m_stDialogBoxInfo[15].bFlag = FALSE;
}

void CGame::NotifyMsg_FishChance(char * pData)
{
 int iFishChance;
 char * cp;
 WORD * wp;
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	iFishChance = (int)*wp;
	cp += 2;
	m_stDialogBoxInfo[24].sV1 = iFishChance;
}

void CGame::NotifyMsg_GuildDisbanded(char * pData)
{char * cp, cName[24], cLocation[12];
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cLocation, sizeof(cLocation));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 20);
	cp += 20;
	memcpy(cLocation, cp, 10);
	cp += 10;
	m_Misc.ReplaceString(cName, '_', ' ');
	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 7);
	ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
	m_iGuildRank = -1;
	ZeroMemory(m_cLocation, sizeof(m_cLocation));
	memcpy(m_cLocation, cLocation, 10);
	if (memcmp(m_cLocation, "aresden", 7) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "arehunter", 9) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = TRUE;
		m_bHunter  = TRUE;
	}else if (memcmp(m_cLocation, "elvine", 6) == 0)
	{	m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
	{	m_bAresden = FALSE;
		m_bCitizen = TRUE;
		m_bHunter  = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // m_bAresden, m_bCitizen, m_bHunter for me ready for later fix
	}else if (memcmp(m_cLocation, "executor", 8) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "evil", 4) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = FALSE;
	}else if (memcmp(m_cLocation, "NONE", 4) == 0)
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = TRUE;
#endif

	}else
	{	m_bAresden = TRUE;
		m_bCitizen = FALSE;
		m_bHunter  = TRUE;
	}
}

void CGame::NotifyMsg_WhetherChange(char * pData)
{
 char * cp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	m_cWhetherStatus = *cp;
	cp++;

	if (m_cWhetherStatus != NULL)
		 SetWhetherStatus(TRUE,  m_cWhetherStatus);
	else SetWhetherStatus(FALSE, NULL);
}

void CGame::NotifyMsg_TimeChange(char * pData)
{ char * cp;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	G_cSpriteAlphaDegree = *cp;
	switch (G_cSpriteAlphaDegree) {
	case 1:	m_bIsXmas = FALSE; PlaySound('E', 32, 0); break;
	case 2: m_bIsXmas = FALSE; PlaySound('E', 31, 0); break;
	case 3: // Snoopy Special night with chrismas bulbs
		if (m_cWhetherEffectType >3) m_bIsXmas = TRUE;
		else m_bIsXmas = FALSE;
		PlaySound('E', 31, 0);
		G_cSpriteAlphaDegree = 2;break;
	}
	m_cGameModeCount = 1;
	m_bIsRedrawPDBGS = TRUE;
}

void CGame::NotifyMsg_RepairItemPrice(char * pData)
{char * cp, cName[21];
 DWORD * dwp, wV1, wV2, wV3, wV4;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	dwp = (DWORD *)cp;
  	wV1 = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
  	wV2 = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
  	wV3 = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
  	wV4 = *dwp;
	cp += 4;
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;
	EnableDialogBox(23, 2, wV1, wV2);
	m_stDialogBoxInfo[23].sV3 = wV3;
}

void CGame::NotifyMsg_SellItemPrice(char * pData)
{char * cp, cName[21];
 DWORD * dwp, wV1, wV2, wV3, wV4;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	dwp = (DWORD *)cp;
  	wV1 = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
  	wV2 = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
  	wV3 = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
  	wV4 = *dwp;
	cp += 4;
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;
	EnableDialogBox(23, 1, wV1, wV2);
	m_stDialogBoxInfo[23].sV3 = wV3;
	m_stDialogBoxInfo[23].sV4 = wV4;
}

void CGame::NotifyMsg_QueryDismissGuildPermission(char * pData)
{char * cp, cName[12];
	ZeroMemory(cName, sizeof(cName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 10);
	cp += 10;
	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 2);
}


void CGame::NotifyMsg_QueryJoinGuildPermission(char * pData)
{char * cp, cName[12];
	ZeroMemory(cName, sizeof(cName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 10);
	cp += 10;
	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 1);
}


void CGame::NotifyMsg_QuestContents(char *pData)
{short * sp;
 char  * cp;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	sp = (short *)cp;
	m_stQuest.sWho = *sp;
	cp += 2;
	sp = (short *)cp;
	m_stQuest.sQuestType = *sp;
	cp += 2;
	sp = (short *)cp;
	m_stQuest.sContribution = *sp;
	cp += 2;
	sp = (short *)cp;
	m_stQuest.sTargetType = *sp;
	cp += 2;
	sp = (short *)cp;
	m_stQuest.sTargetCount = *sp;
	cp += 2;
	sp = (short *)cp;
	m_stQuest.sX = *sp;
	cp += 2;
	sp = (short *)cp;
	m_stQuest.sY = *sp;
	cp += 2;
	sp = (short *)cp;
	m_stQuest.sRange = *sp;
	cp += 2;
	sp = (short *)cp;
	m_stQuest.bIsQuestCompleted = (BOOL)*sp;
	cp += 2;
	ZeroMemory(m_stQuest.cTargetName, sizeof(m_stQuest.cTargetName));
	memcpy(m_stQuest.cTargetName, cp, 20);
	cp += 20;
	// v2.05
	//AddEventList(m_pGameMsgList[92]->m_pMsg, 10);
}

void CGame::NotifyMsg_PlayerProfile(char * pData)
{char * cp;
 char cTemp[500];
 int i;
	ZeroMemory(cTemp, sizeof(cTemp));
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	strcpy(cTemp, cp);
	for (i = 0; i < 500; i++)
	if (cTemp[i] == '_') cTemp[i] = ' ';
	AddEventList(cTemp, 10);
}

void CGame::NotifyMsg_NoticeMsg(char * pData)
{char * cp, cMsg[1000];
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	strcpy(cMsg, cp);
	AddEventList(cMsg, 10);
}
/*********************************************************************************************************************
**  void CGame::NotifyMsg_OpenExchageWindow(char *pData)		(snoopy)											**
**  description			:: Recieve a msg from gserver and sets the item	and opens trade windows						**
**********************************************************************************************************************/
void CGame::NotifyMsg_OpenExchageWindow(char *pData)
{short * sp, sDir, sSprite, sSpriteFrame, sCurLife, sMaxLife, sPerformance;
 int * ip, iAmount;
 char * cp, cColor, cItemName[24], cCharName[12];
 DWORD * dwp, dwAttribute;
	ZeroMemory(cItemName, sizeof(cItemName));
	ZeroMemory(cCharName, sizeof(cCharName));

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	sp = (short *)cp;
	sDir = *sp;
	cp += 2;
	sp = (short *)cp;
	sSprite = *sp;
	cp += 2;
	sp = (short *)cp;
	sSpriteFrame = *sp;
	cp += 2;
	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;
	cColor = *cp;
	cp++;
	sp = (short *)cp;
	sCurLife = *sp;
	cp += 2;
	sp = (short *)cp;
	sMaxLife = *sp;
	cp += 2;
	sp = (short *)cp;
	sPerformance = *sp;
	cp += 2;
	memcpy(cItemName, cp, 20);
	cp += 20;
	memcpy(cCharName, cp, 10);
	cp += 10;
	dwp = (DWORD *)cp;
	dwAttribute = *dwp;
	cp += 4;

	EnableDialogBox(27, 1, 0, 0, NULL);
	int i;
	if (sDir >= 1000)  // Set the item I want to exchange
	{	i = 0;
		while (m_stDialogBoxExchangeInfo[i].sV1 !=-1)
		{	i++;
			if (i>=4) return; // Error situation
		}
		if ((sDir >1000) && (i == 0))
		{	m_bIsItemDisabled[sDir -1000] = TRUE;
			m_stDialogBoxExchangeInfo[0].sItemID = sDir -1000;
		}
	}else // Set the item he proposes me.
	{	i = 4;
		while (m_stDialogBoxExchangeInfo[i].sV1 !=-1)
		{	i++;
			if (i>=8) return; // Error situation
	}	}
	m_stDialogBoxExchangeInfo[i].sV1 = sSprite;
	m_stDialogBoxExchangeInfo[i].sV2 = sSpriteFrame;
	m_stDialogBoxExchangeInfo[i].sV3 = iAmount;
	m_stDialogBoxExchangeInfo[i].sV4 = cColor;
	m_stDialogBoxExchangeInfo[i].sV5 = (int)sCurLife;
	m_stDialogBoxExchangeInfo[i].sV6 = (int)sMaxLife;
	m_stDialogBoxExchangeInfo[i].sV7 = (int)sPerformance;
	memcpy(m_stDialogBoxExchangeInfo[i].cStr1, cItemName, 20);
	memcpy(m_stDialogBoxExchangeInfo[i].cStr2, cCharName, 10);
	m_stDialogBoxExchangeInfo[i].dwV1 = dwAttribute;
}

void CGame::NotifyMsg_JoinGuildApprove(char * pData)
{char * cp, cName[21];
 short * sp;
	ZeroMemory(cName, sizeof(cName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 20);
	cp += 20;
	sp = (short *)cp;
	cp += 2;
	ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
	strcpy(m_cGuildName, cName);
	m_iGuildRank = *sp;
	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 3);
}


void CGame::NotifyMsg_JoinGuildReject(char * pData)
{char * cp, cName[21];
	ZeroMemory(cName, sizeof(cName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cName, cp, 20);
	cp += 20;
	EnableDialogBox(8, NULL, NULL, NULL);
	_PutGuildOperationList(cName, 4);
}

void CGame::DlgBoxClick_Help(int msX, int msY)
{ short sX, sY;
	sX = m_stDialogBoxInfo[35].sX;
	sY = m_stDialogBoxInfo[35].sY;
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*0) && (msY < sY +50+15*1))
	{	DisableDialogBox(18);
		EnableDialogBox(18, 1000, NULL, NULL);
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*1) && (msY < sY +50+15*2)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 900, NULL, NULL);
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*2) && (msY < sY +50+15*3)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 901, NULL, NULL);
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*3) && (msY < sY +50+15*4)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 902, NULL, NULL);
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*4) && (msY < sY +50+15*5)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 903, NULL, NULL);
		m_bIsF1HelpWindowEnabled = TRUE;
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*5) && (msY < sY +50+15*6)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 904, NULL, NULL); //
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*6) && (msY < sY +50+15*7)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 905, NULL, NULL); //
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*7) && (msY < sY +50+15*8)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 906, NULL, NULL); //
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*8) && (msY < sY +50+15*9)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 907, NULL, NULL); //
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*9) && (msY < sY +50+15*10)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 908, NULL, NULL); //
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*10) && (msY < sY +50+15*11)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 909, NULL, NULL); //
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*11) && (msY < sY +50+15*12)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 910, NULL, NULL); //
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*12) && (msY < sY +50+15*13)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 911, NULL, NULL); // FAQ
	}

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*13) && (msY < sY +50+15*14)) {
		DisableDialogBox(18);
		EnableDialogBox(18, 912, NULL, NULL); //
	}
	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		PlaySound('E', 14, 5);
		DisableDialogBox(35);
	}
}

/*********************************************************************************************************************
** void CGame::CreateScreenShot()										(snoopy)									**
**  description			:: Fixed Screen Shots																		**
**********************************************************************************************************************/
void CGame::CreateScreenShot()
{	//HelShot20060307_173003_Warehouse000.jpg
 int i;
 FILE * pFile;
 char cFn[256];
 char LongMapName[128];
 char SStime[32];
 SYSTEMTIME SysTime;
	GetLocalTime(&SysTime);
	ZeroMemory(LongMapName, sizeof(LongMapName));
	GetOfficialMapName(m_cMapName, LongMapName);
	ZeroMemory(SStime, sizeof(SStime));
	wsprintf(SStime, "%02d:%02d - %02d:%02d:%02d"
		, SysTime.wMonth, SysTime.wDay
		, SysTime.wHour, SysTime.wMinute, SysTime.wSecond
		, LongMapName);
	PutAlignedString(500, 600, 30, SStime, 255, 255, 255); //ScreenShot time
	PutString_SprFont3(500, 390, " Client coded by", 20, 20, 0, TRUE, 2);
	PutString_SprFont3(500, 405, "Diuuude & Snoopy81", 0, 20, 20, TRUE, 2);

	if (strcmp(m_cWorldServerName, NAME_WORLDNAME1) == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME1,255,255,255);//"ABADDON Server"
	else if (strcmp(m_cWorldServerName, "WS2") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME2,255,255,255);//"APOCALYPSE Server"
	else if (strcmp(m_cWorldServerName, "WS3") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME3,255,255,255);//"3rd Server"
	else if (strcmp(m_cWorldServerName, "WS4") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME4,255,255,255);//"4th Server"
	else if (strcmp(m_cWorldServerName, "WS5") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME5,255,255,255);//"5th Server"
	else if (strcmp(m_cWorldServerName, "WS6") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME6,255,255,255);//"6th Server"
	else if (strcmp(m_cWorldServerName, "WS7") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME7,255,255,255);//"7th Server"
	else if (strcmp(m_cWorldServerName, "WS8") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME8,255,255,255);//"8th Server"
	else if (strcmp(m_cWorldServerName, "WS9") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME9,255,255,255);//"9th Server"
	else if (strcmp(m_cWorldServerName, "WS10") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME10,255,255,255);//"10th Server"
	else if (strcmp(m_cWorldServerName, "WS11") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME11,255,255,255);//"11th Server"
	else if (strcmp(m_cWorldServerName, "WS12") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME12,255,255,255);//"12th Server"
	else if (strcmp(m_cWorldServerName, "WS13") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME13,255,255,255);//"13th Server"
	else if (strcmp(m_cWorldServerName, "WS14") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME14,255,255,255);//"14th Server"
	else if (strcmp(m_cWorldServerName, "WS15") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME15,255,255,255);//"15th Server"
	else if (strcmp(m_cWorldServerName, "WS16") == 0)
		PutAlignedString(500, 600, 15, MSG_WORLDNAME16,255,255,255);//"16th Server"

	for (i = 0; i < 1000; i++)
	{	ZeroMemory(cFn, sizeof(cFn));
		wsprintf(cFn, "Save\\HelShot%04d%02d%02d_%02d%02d%02d_%s%03d.jpg"
			, SysTime.wYear, SysTime.wMonth, SysTime.wDay
			, SysTime.wHour, SysTime.wMinute, SysTime.wSecond
			, LongMapName
			,i);
		_mkdir("SAVE");
		pFile = fopen(cFn, "rb");
		if (pFile == NULL)
		{	m_DDraw.Screenshot(cFn, m_DDraw.m_lpBackB4);
			CxImage  image;
			image.Load(cFn, CXIMAGE_FORMAT_BMP);
			if (image.IsValid())
			{   image.SetJpegQuality(80);
			    image.Save(cFn,CXIMAGE_FORMAT_JPG);
			}
			wsprintf(G_cTxt, NOTIFYMSG_CREATE_SCREENSHOT1, cFn);
			AddEventList(G_cTxt, 10);
			return;
		}
		fclose(pFile);
	}
	AddEventList(NOTIFYMSG_CREATE_SCREENSHOT2, 10);
}

void CGame::UpdateScreen_OnConnecting()
{
 short sX, sY, msX, msY, msZ;
 char cLB, cRB;
 DWORD dwTime = timeGetTime();
 static class CMouseInterface * pMI;
 static DWORD dwMTime, dwCTime;

	if (m_cGameModeCount == 0) {
		m_bEnterPressed = FALSE;
		m_bEscPressed   = FALSE;
		dwCTime = dwMTime = timeGetTime();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == TRUE) {

		if ((dwTime - m_dwTime) > 1000)
		{	ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			if (m_pLSock != NULL)
			{	delete m_pLSock;
				m_pLSock = NULL;
			}
			if (m_pGSock != NULL)
			{	delete m_pGSock;
				m_pGSock = NULL;
		}	}
		m_bEscPressed = FALSE;
		return;
	}

	if ((dwTime - dwMTime) > 150) dwMTime = dwTime;

	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	m_DDraw.ClearBackB4();

	m_bIsHideLocalCursor = TRUE;
	switch (m_cMsg[0]) {
	case '0':
		_Draw_UpdateScreen_OnCreateNewAccount();
		break;

	case '1':
		sX = 146;
		sY = 114;
		_Draw_OnLogin(m_cAccountName, m_cAccountPassword, 0, 0);
		break;

	case '2':
		_bDraw_OnCreateNewCharacter(m_cPlayerName, 0, 0, 0);
		break;

	case '3':
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0);
		break;

	case '4':
		// Change Password
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0, TRUE);
		break;

	case '5':
		m_DDraw.ClearBackB4();
		break;
	}
	m_bIsHideLocalCursor = FALSE;

	m_DDraw.DrawShadowBox(0,0,639,479);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);
	wsprintf(G_cTxt, "Connecting to Server... %3dSec", (dwTime - m_dwTime)/1000);
	PutString_SprFont(172 + 35, 190, G_cTxt, 7,0,0);

	if ((dwTime - m_dwTime) > 7000)
	{	PutAlignedString(180, 463, 195+30, UPDATE_SCREEN_ON_CONNECTING1);//"Press ESC key during long time of no"
		PutAlignedString(180, 463, 195+45, UPDATE_SCREEN_ON_CONNECTING2);//"connection and return to the main menu."
	}
	else PutAlignedString(180, 463, 195+30, UPDATE_SCREEN_ON_CONNECTING3);//"  Connecting to server. Please wait..."
	DrawVersion();
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 8, dwTime);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::UpdateScreen_OnWaitInitData()
{
 short msX, msY, msZ;
 char cLB, cRB;
 DWORD dwTime = timeGetTime();

	if (m_cGameModeCount == 0) {
		m_bEnterPressed = FALSE;
		m_bEscPressed   = FALSE;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == TRUE) {
		if ((dwTime - m_dwTime) > 7000)
		{	ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			if (m_pLSock != NULL)
			{	delete m_pLSock;
				m_pLSock = NULL;
			}
			if (m_pGSock != NULL)
			{	delete m_pGSock;
				m_pGSock = NULL;
		}	}
		m_bEscPressed = FALSE;
		return;
	}

	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);

	wsprintf(G_cTxt,"Waiting for response... %dsec", (dwTime - m_dwTime)/1000);
	PutString_SprFont(172+ 44, 190, G_cTxt, 7,0,0);
	if ((dwTime - m_dwTime) > 7000) {
		PutAlignedString(174, 467, 190+30, UPDATE_SCREEN_ON_WAIT_INIT_DATA1);//"Press ESC key during long time of no"
		PutAlignedString(174, 467, 190+45, UPDATE_SCREEN_ON_WAIT_INIT_DATA2);//"connection and return to the main menu."
	}
	else PutAlignedString(174, 467, 195+30, UPDATE_SCREEN_ON_WAIT_INIT_DATA3);//  Connecting to server. Please wait..."

	DrawVersion();
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 8, dwTime);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::UpdateScreen_OnConnectionLost()
{short msX, msY, msZ;
 char cLB, cRB;
 static DWORD dwTime;
	if (m_cGameModeCount == 0)
	{	dwTime = timeGetTime();
		if (m_bSoundFlag) m_pESound[38]->bStop();
		if ((m_bSoundFlag) && (m_bMusicStat == TRUE))
		{	StopBGM();	// Snoopy: mp3 support
			if (m_pBGM != NULL) m_pBGM->bStop();
	}	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;
	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);
	PutString_SprFont(172 + 54, 180, "Connection Lost!", 7,0,0);
	PutString(172+50, 180+30, UPDATE_SCREEN_ON_CONNECTION_LOST, RGB(0,0,0));//"
	DrawVersion();
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();

	if ((timeGetTime() - m_dwTime) > 5000)
	{	if (strlen(G_cCmdLineTokenA) != 0)
			 ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else
		{	ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
	}	}
}

BOOL CGame::_bDraw_OnCreateNewCharacter(char * pName, short msX, short msY, int iPoint)
{
 BOOL bFlag = TRUE;
 DWORD dwTime = timeGetTime();
 int i=0;

	m_DDraw.ClearBackB4();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWCHAR, 0, 0, 0, TRUE);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0, 0, 69, TRUE);
	PutAlignedString(64, 282, 90, _BDRAW_ON_CREATE_NEW_CHARACTER1, 5,5,5);//"
	PutAlignedString(57, 191, 110, DEF_MSG_CHARACTERNAME, 5,5,5);//"Character Name"
	if (m_cCurFocus != 1) PutString(197, 112, pName, RGB(25,35,25));
	PutAlignedString(64, 282, 140, _BDRAW_ON_CREATE_NEW_CHARACTER2, 5,5,5);//"
	PutString(100, 160, DEF_MSG_GENDER, RGB(5,5,5));//"Gender"
	PutString(100, 175, DEF_MSG_SKINCOLOR, RGB(5,5,5));//"Skin Color"
	PutString(100, 190, DEF_MSG_HAIRSTYLE, RGB(5,5,5));//"Hair Style"
	PutString(100, 205, DEF_MSG_HAIRCOLOR, RGB(5,5,5));//"Hair Color"
	PutString(100, 220, DEF_MSG_UNDERWEARCOLOR, RGB(5,5,5));//"Underwear Color"
	//PutAlignedString(64, 282, 245, _BDRAW_ON_CREATE_NEW_CHARACTER3, 5,5,5);
	//wsprintf(G_cTxt, _BDRAW_ON_CREATE_NEW_CHARACTER4,  iPoint);//" %d points"
	//PutAlignedString(64, 282, 260, G_cTxt, 15,10,10);
	PutString(100, 275, DEF_MSG_STRENGTH, RGB(5,5,5));//"Strength"
	PutString(100, 292, DEF_MSG_VITALITY, RGB(5,5,5));//"Vitality"
	PutString(100, 309, DEF_MSG_DEXTERITY, RGB(5,5,5));//"Dexterity"
	PutString(100, 326, DEF_MSG_INTELLIGENCE, RGB(5,5,5));//"Intelligence"
	PutString(100, 343, DEF_MSG_MAGIC, RGB(5,5,5));//"Magic"
	PutString(100, 360, DEF_MSG_CHARISMA, RGB(5,5,5));//"Charisma"

	wsprintf(G_cTxt, "%d", m_ccStr);
	PutString(204 , 277+ 16*i++ , G_cTxt, RGB(25,35,25));
	wsprintf(G_cTxt, "%d", m_ccVit);
	PutString(204 , 277+ 16*i++ , G_cTxt, RGB(25,35,25));
	wsprintf(G_cTxt, "%d", m_ccDex);
	PutString(204 , 277+ 16*i++ , G_cTxt, RGB(25,35,25));
	wsprintf(G_cTxt, "%d", m_ccInt);
	PutString(204 , 277+ 16*i++ , G_cTxt, RGB(25,35,25));
	wsprintf(G_cTxt, "%d", m_ccMag);
	PutString(204 , 277+ 16*i++ , G_cTxt, RGB(25,35,25));
	wsprintf(G_cTxt, "%d", m_ccChr);
	PutString(204 , 277+ 16*i++ , G_cTxt, RGB(25,35,25));

	if (strlen(pName) <= 0) bFlag = FALSE;
	if (iPoint > 0) bFlag = FALSE;
	if (m_Misc.bCheckValidName(pName) == FALSE) bFlag = FALSE;
	if (_bCheckBadWords(pName) == TRUE) bFlag = FALSE;

	if ( (bFlag == TRUE) && (m_cCurFocus == 2) ) m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(384, 445, 25, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(384, 445, 24, dwTime);
	if (m_cCurFocus == 3)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(500, 445, 17, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(500, 445, 16, dwTime);
	if (m_cCurFocus == 4)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(60, 445, 68, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(60, 445, 67, dwTime);
	if (m_cCurFocus == 5)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(145, 445, 66, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(145, 445, 65, dwTime);
	if (m_cCurFocus == 6)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(230, 445, 64, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(230, 445, 63, dwTime);
	/*if (m_cCurFocus == 4)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(60, 245, 68, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(60, 245, 67, dwTime);
	if (m_cCurFocus == 5)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(145, 245, 66, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(145, 245, 65, dwTime);
	if (m_cCurFocus == 6)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(230, 245, 64, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(230, 245, 63, dwTime);*/

	ShowReceivedString();

	switch (m_cGender) {
	case 1:	_tmp_sOwnerType = 1; break;
	case 2:	_tmp_sOwnerType = 4; break; //@@@@@@@@@@@@@@@@@!!!!!!!!!!!!!!!!!
	}
	_tmp_sOwnerType += m_cSkinCol - 1;
	_tmp_cDir   = m_cMenuDir;
	_tmp_sAppr1 = 0;
	_tmp_sAppr1 = _tmp_sAppr1 | (m_cUnderCol);
	_tmp_sAppr1 = _tmp_sAppr1 | (m_cHairStyle << 8);
	_tmp_sAppr1 = _tmp_sAppr1 | (m_cHairCol << 4);
	_tmp_sAppr2 = 0;
	_tmp_sAppr3 = 0;
	_tmp_sAppr4 = 0;
	ZeroMemory(_tmp_cName, sizeof(_tmp_cName));
	memcpy(_tmp_cName, m_cPlayerName,10);
	_tmp_cAction = DEF_OBJECTMOVE;
	_tmp_cFrame = m_cMenuFrame;

	_Draw_CharacterBody( 507 , 267, _tmp_sOwnerType);

	DrawObject_OnMove_ForMenu(0, 0, 500 , 174, FALSE, dwTime, msX, msY);

    i = 0 ;

	PutString(445, 192, DEF_MSG_HITPOINT, RGB(5,5,5));//"Hit Point"
	wsprintf(G_cTxt, "%d", m_ccVit*3 + 2 + m_ccStr/2);
	PutString(550, 192 + 16*i++, G_cTxt, RGB(25,35,25));

	PutString(445, 208, DEF_MSG_MANAPOINT, RGB(5,5,5));//"Mana Point"
	wsprintf(G_cTxt, "%d", m_ccMag*2 + 2 + m_ccInt/2);
	PutString(550, 192 + 16*i++, G_cTxt, RGB(25,35,25));

	PutString(445, 224, DEF_MSG_STAMINARPOINT, RGB(5,5,5));//"Staminar Point"
	wsprintf(G_cTxt, "%d", m_ccStr*2 + 2);
	PutString(550, 192 + 16*i++, G_cTxt, RGB(25,35,25));

	return bFlag;
}

void CGame::UpdateScreen_OnCreateNewCharacter()
{static class CMouseInterface * pMI;
 int i=0;
 int iMIbuttonNum;
 static int iPoint;
 char cLB, cRB, cMIresult;
 static char cName[12];
 static char cPrevFocus;
 short msX, msY, msZ;
 BOOL bFlag;
 static DWORD dwMTime;
 DWORD dwTime = timeGetTime();

	if (m_cGameModeCount == 0)
	{	pMI = new class CMouseInterface;
		pMI->AddRect(65+4, 65+45, 275+4, 82+45);

		pMI->AddRect(232+4, 111+45, 274+4 -21, 124+45);
		pMI->AddRect(255+4, 111+45, 289+4 -13, 124+45);

		pMI->AddRect(232+4, 126+45, 274+4 -21, 139+45);
		pMI->AddRect(255+4, 126+45, 289+4 -13, 139+45);

		pMI->AddRect(232+4, 141+45, 274+4 -21, 154+45);
		pMI->AddRect(255+4, 141+45, 289+4 -13, 154+45);

		pMI->AddRect(232+4, 156+45, 274+4 -21, 169+45);
		pMI->AddRect(255+4, 156+45, 289+4 -13, 169+45);

		pMI->AddRect(232+4, 171+45, 274+4 -21, 184+45);
		pMI->AddRect(255+4, 171+45, 289+4 -13, 184+45);


		pMI->AddRect(232+4, 231+45, 253+4, 244+45);
		pMI->AddRect(255+4, 231+45, 276+4, 244+45);

		pMI->AddRect(232+4, 246+45, 253+4, 259+45);
		pMI->AddRect(255+4, 246+45, 276+4, 259+45);

		pMI->AddRect(232+4, 261+45, 253+4, 274+45);
		pMI->AddRect(255+4, 261+45, 276+4, 274+45);

		pMI->AddRect(232+4, 276+45, 253+4, 289+45);
		pMI->AddRect(255+4, 276+45, 276+4, 289+45);

		pMI->AddRect(232+4, 291+45, 253+4, 304+45);
		pMI->AddRect(255+4, 291+45, 276+4, 304+45);

		pMI->AddRect(232+4, 306+45, 253+4, 319+45);
		pMI->AddRect(255+4, 306+45, 276+4, 319+45);

		pMI->AddRect(384, 445, 384+72, 445+15);
		pMI->AddRect(500, 445, 500+72, 445+15);

		pMI->AddRect(60, 445, 60+72, 445+15);
		pMI->AddRect(145, 445, 145+72, 445+15);
		pMI->AddRect(230, 445, 230+72, 445+15);

		iPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
		iPoint  = 70 - iPoint;
		cPrevFocus  = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 6;
		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
		dwMTime = timeGetTime();
		StartInputString(193+4, 65+45, 11, cName);
		ClearInputString();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{	switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;

		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (cPrevFocus != m_cCurFocus) {
		EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(193+4, 65+45, 11, cName);
			break;
		}
		cPrevFocus = m_cCurFocus;
	}

	if (m_bEscPressed == TRUE) {
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	bFlag = _bDraw_OnCreateNewCharacter(cName, msX, msY, iPoint);

	if ((dwTime - dwMTime) > 100)
	{	m_cMenuFrame++;
		dwMTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{	m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{	m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{	PlaySound('E', 14, 5);
		switch (iMIbuttonNum) {
		case 1:
			m_cCurFocus = 1;
			break;
		case 2:
			m_cGender--;
			if (m_cGender < 1) m_cGender = 2;
			break;
		case 3:
			m_cGender++;
			if (m_cGender > 2) m_cGender = 1;
			break;
		case 4:
			m_cSkinCol--;
			if (m_cSkinCol < 1) m_cSkinCol = 3;
			break;
		case 5:
			m_cSkinCol++;
			if (m_cSkinCol > 3) m_cSkinCol = 1;
			break;
		case 6:
			m_cHairStyle--;
			if (m_cHairStyle < 0) m_cHairStyle = 7;
			break;
		case 7:
			m_cHairStyle++;
			if (m_cHairStyle > 7) m_cHairStyle = 0;
			break;
		case 8:
			m_cHairCol--;
			if (m_cHairCol < 0) m_cHairCol = 15;
			break;
		case 9:
			m_cHairCol++;
			if (m_cHairCol > 15) m_cHairCol = 0;
			break;
		case 10:
			m_cUnderCol--;
			if (m_cUnderCol < 0) m_cUnderCol = 7;
			break;
		case 11:
			m_cUnderCol++;
			if (m_cUnderCol > 7) m_cUnderCol = 0;
			break;
		case 12:
			if (iPoint > 0) {
				if (m_ccStr < 14) {
					m_ccStr++;
					iPoint--;
				}
			}
			break;
		case 13:
			if (m_ccStr > 10) {
				m_ccStr--;
				iPoint++;
			}
			break;
		case 14:
			if (iPoint > 0) {
				if (m_ccVit < 14) {
					m_ccVit++;
					iPoint--;
				}
			}
			break;
		case 15:
			if (m_ccVit > 10) {
				m_ccVit--;
				iPoint++;
			}
			break;
		case 16:
			if (iPoint > 0) {
				if (m_ccDex < 14) {
					m_ccDex++;
					iPoint--;
				}
			}
			break;
		case 17:
			if (m_ccDex > 10) {
				m_ccDex--;
				iPoint++;
			}
			break;
		case 18:
			if (iPoint > 0) {
				if (m_ccInt < 14) {
					m_ccInt++;
					iPoint--;
				}
			}
			break;
		case 19:
			if (m_ccInt > 10) {
				m_ccInt--;
				iPoint++;
			}
			break;
		case 20:
			if (iPoint > 0) {
				if (m_ccMag < 14) {
					m_ccMag++;
					iPoint--;
				}
			}
			break;
		case 21:
			if (m_ccMag > 10) {
				m_ccMag--;
				iPoint++;
			}
			break;
		case 22:
			if (iPoint > 0) {
				if (m_ccChr < 14) {
					m_ccChr++;
					iPoint--;
				}
			}
			break;
		case 23:
			if (m_ccChr > 10)
			{	m_ccChr--;
				iPoint++;
			}
			break;

		case 24:
			if (m_cCurFocus != 2)
			{	m_cCurFocus = 2;
				return;
			}
			if (bFlag == FALSE) return;
			//if (m_Misc.bCheckValidName(m_cPlayerName) == FALSE) break;
			if (m_Misc.bCheckValidName(cName) == FALSE) break;
			ZeroMemory(m_cPlayerName, sizeof(m_cPlayerName));
			strcpy(m_cPlayerName, cName);
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CREATENEWCHARACTER;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg,"22");
			delete pMI;
			return;


		case 25:
			if (m_cCurFocus != 3)
			{	m_cCurFocus = 3;
				return;
			}
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete pMI;
			return;


		case 26: // WARRIOR
			if (m_cCurFocus != 4)
			{	m_cCurFocus = 4;
				return;
			}

			m_ccMag = 10 ;
			m_ccInt = 10 ;
			m_ccChr = 10 ;
			m_ccStr = 14 ;
			m_ccVit = 12 ;
			m_ccDex = 14 ;
			iPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
			iPoint  = 70 - iPoint;
			break;

		case 27: // MAGE
			if (m_cCurFocus != 5) {
				m_cCurFocus = 5;
				return;
			}

			m_ccMag = 14 ;
			m_ccInt = 14 ;
			m_ccChr = 10 ;
			m_ccStr = 10 ;
			m_ccVit = 12 ;
			m_ccDex = 10 ;
			iPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
			iPoint  = 70 - iPoint;
			break;

		case 28: // PRIEST
			if (m_cCurFocus != 6) {
				m_cCurFocus = 6;
				return;
			}

			m_ccMag = 12 ;
			m_ccInt = 10 ;
			m_ccChr = 14 ;
			m_ccStr = 14 ;
			m_ccVit = 10 ;
			m_ccDex = 10 ;
			iPoint = m_ccStr + m_ccVit + m_ccDex + m_ccInt + m_ccMag + m_ccChr;
			iPoint  = 70 - iPoint;
			break;
		}


	}

	if ((msX >= 65+4-127) && (msX <= 275+4) && (msY >= 65+45) && (msY <= 82+45)) {
		PutAlignedString(370, 580, 345, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER1);
	}
	else
	if ((msX >= 261+4-212) && (msX <= 289+4) && (msY >= 111+45) && (msY <= 124+45)) {
		PutAlignedString(370, 580, 345, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER2);
	}
	else
	if ((msX >= 261+4-212) && (msX <= 289+4) && (msY >= 126+45) && (msY <= 139+45)) {
		PutAlignedString(370, 580, 345, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER3);
	}
	else
	if ((msX >= 261+4-212) && (msX <= 289+4) && (msY >= 141+45) && (msY <= 154+45)) {
		PutAlignedString(370, 580, 345, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER4);
	}
	else
	if ((msX >= 261+4-212) && (msX <= 289+4) && (msY >= 156+45) && (msY <= 169+45)) {
		PutAlignedString(370, 580, 345, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER5);
	}
	else
	if ((msX >= 261+4-212) && (msX <= 289+4) && (msY >= 171+45) && (msY <= 184+45)) {
		PutAlignedString(370, 580, 345, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER6);
	}
	else
	if ((msX >= 240+4-175) && (msX <= 268+4) && (msY >= 231+45) && (msY <= 244+45)) {
		// Str
		i= 0 ;
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER7);
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER8);
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER9);
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER10);
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER11);
	}
	else if ((msX >= 240+4-175) && (msX <= 268+4) && (msY >= 246+45) && (msY <= 259+45)) {
			// Vit
		i= 0 ;
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER12);//"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER13);//"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER14);//"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER15);//"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER16);//"
	}
	else if ((msX >= 240+4-175) && (msX <= 268+4) && (msY >= 261+45) && (msY <= 274+45)) {
		// Dex
		i= 0 ;
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER17);//"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER18);//"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER19);//"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER20);//"
	}
	else if ((msX >= 240+4-175) && (msX <= 268+4) && (msY >= 276+45) && (msY <= 289+45)) {
		// Int
		i= 0 ;
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER21);//"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER22);//"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER23);//"
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER24);
	}
	else if ((msX >= 240+4-175) && (msX <= 268+4) && (msY >= 291+45) && (msY <= 304+45)) {
		// Mag
		i= 0 ;
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER25);
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER26);
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER27);
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER28);
	}
	else if ((msX >= 240+4-175) && (msX <= 268+4) && (msY >= 306+45) && (msY <= 319+45)) {
		// Charisma
		i= 0 ;
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER29);
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER30);
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER31);
		PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER32);
	}
	else if ((msX >= 384) && (msX <= 384+72) && (msY >= 445) && (msY <= 445+15))  {
		m_cCurFocus = 2;
		if (strlen(cName) <= 0)
		{	i= 0 ;
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER35);//"Please enter a character name."
		}
		else if (iPoint > 0)
		{	i= 0 ;
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER36);//"You need to select your character class."
		}else if (m_Misc.bCheckValidName(cName) == FALSE)
		{	i= 0 ;
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER39);//"Cannot use special characters "
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER40);//"in your character's name. Please"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER41);//"type another name."
		}else if (_bCheckBadWords(cName) == TRUE)
		{	i= 0 ;
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER42);//"The character's name is not appropriate."
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER43);//"Please retry with another name."
		}else
		{	i= 0 ;
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER44);//"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER45);//"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER46);//"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER47);//"
			PutAlignedString(370, 580, 345 + 16*i++, UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER48);//"
		}
	}else if ((msX >= 500) && (msX <= 500+72) && (msY >= 445) && (msY <= 445+15))
	{	m_cCurFocus = 3;
		PutAlignedString(370, 580, 345 , UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER49);
	}

	if ((msX >= 60) && (msX <= 60+72) && (msY >= 445) && (msY <= 445+15)) {
		m_cCurFocus = 4;
		PutAlignedString(370, 580, 345 , UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER50);
	}

	if ((msX >= 145) && (msX <= 145+72) && (msY >= 445) && (msY <= 445+15)) {
		m_cCurFocus = 5;
		PutAlignedString(370, 580, 345 , UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER51);
	}

	if ((msX >= 230) && (msX <= 230+72) && (msY >= 445) && (msY <= 445+15)) {
		m_cCurFocus = 6;
		PutAlignedString(370, 580, 345 , UPDATE_SCREEN_ON_CREATE_NEW_CHARACTER52);
	}

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

#ifdef DEF_MAKE_ACCOUNT

void CGame::_LoadAgreementTextContents(char cType)
{
 char * pContents, * token, cTemp[120], cFileName[120];
 char   seps[] = "\n";
 int    iIndex = 0, i;
 class  CStrTok * pStrTok;
 DWORD  dwFileSize;
 HANDLE hFile;
 FILE * pFile;

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++) {
		if (m_pAgreeMsgTextList[i] != NULL)
			delete m_pAgreeMsgTextList[i];
		m_pAgreeMsgTextList[i] = NULL;
	}

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));

	wsprintf(cTemp, "contents%d", cType);

	strcat(cFileName, "contents");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFile(cFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == NULL) return;
	else {
		pContents = new char[dwFileSize+1];
		ZeroMemory(pContents, dwFileSize+1);
		fread(pContents, dwFileSize, 1, pFile);
	}

	fclose(pFile);
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		m_pAgreeMsgTextList[iIndex] = new class CMsg(NULL, token, NULL);
		token = pStrTok->pGet();
		iIndex++;
	}
	delete pStrTok;
	delete[] pContents;
}

void CGame::UpdateScreen_OnAgreement()
{
 short sX, sY, msX, msY, msZ;
 char  cLB, cRB;
 char  cMIresult;
 static class CMouseInterface * pMI;
 int i, iTotalLines, iPointerLoc;
 DWORD dwTime = timeGetTime();
 double d1,d2,d3;
 int iMIbuttonNum;

	sX = 121;
	sY = 22;

	if (m_cGameModeCount == 0) {
		m_iAgreeView = 0;
		_LoadAgreementTextContents(0);

		pMI = new class CMouseInterface;
		pMI->AddRect(sX+82 -105, sY+355,sX+131 -105,sY+374);
		pMI->AddRect(sX+235 -105, sY+355,sX+303 -105,sY+375);
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;
	if (m_bEnterPressed == TRUE) {
		PlaySound('E', 14, 5);
		ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
		ClearContents_OnCreateNewAccount();
		delete pMI;
		return;
	}
	if (m_bEscPressed == TRUE) {
		PlaySound('E', 14, 5);
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		switch (iMIbuttonNum) {
		case 1: // Agree
			PlaySound('E', 14, 5);
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
			ClearContents_OnCreateNewAccount();
			delete pMI;
			return;

		case 2:	// Disagree
			PlaySound('E', 14, 5);
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_AGREEMENT, 0,0,0, TRUE);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, 43, 38,12, FALSE);

	iTotalLines = 0;
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	if (m_pAgreeMsgTextList[i] != NULL) iTotalLines++;

	d1 = (double)m_iAgreeView;
	d2 = (double)(iTotalLines - 20);
	d3 = (double)d1 / d2;
	d1 = 338.0f * d3;
	iPointerLoc = (int)d1;
	m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX +361 -112, sY +37 +13 +iPointerLoc, 7, dwTime);

	for (i = 0; i < 20; i++)
	if (m_pAgreeMsgTextList[i + m_iAgreeView] != NULL) {
		PutAlignedString(60, 360, sY + 65 +i*13, m_pAgreeMsgTextList[i + m_iAgreeView]->m_pMsg, 45,25,25);
	}

	if( msZ != 0 )
	{
		m_iAgreeView = m_iAgreeView - msZ/60;
		m_DInput.m_sZ = 0;
	}
	if (cLB != 0 && iTotalLines > 20)
	{ 	if ((msX >= sX +345 -112) && (msX <= sX +380 -112) && (msY >= sY +50) && (msY <= sY +395))
		{	d1 = (double)(msY - (sY + 37 +13));
			d2 = (double)(iTotalLines - 17);
			d3 = (double)(d1 * d2)/(338.0f);
			m_iAgreeView = (int)d3;
			m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutTransSprite(sX +361 -112, sY +37 +13 +iPointerLoc, 4, dwTime);
	}	}
	if( m_iAgreeView < 0 ) m_iAgreeView = 0;
	if( iTotalLines > 20 && m_iAgreeView > iTotalLines-20 ) m_iAgreeView = iTotalLines-20;

	if ((msX > sX + 82 -105) && (msX < sX + 131 -105) && (msY > sY + 355 -3) && (msY < sY + 374 +3))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 43 + 20 -23 +45 -105,  sY + 265 +90, 13);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 43 + 20 -23 +45 -105,  sY + 265 +90, 12);

	if ((msX > sX + 235 -105) && (msX < sX + 303 -105) && (msY > sY + 355 -3) && (msY < sY + 375 +3))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 158 + 57 -23 +45 -105, sY + 265 +90, 15);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 158 + 57 -23 +45 -105, sY + 265 +90, 14);

	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::UpdateScreen_OnCreateNewAccount()
{short msX, msY, msZ;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI;
 static char cName[12], cPassword[12], cConfirm[12], cPrevFocus, cSSN_A[8], cSSN_B[8], cQuiz[44] ,cAnswer[20], cTempQuiz[44] ;
 DWORD dwTime = timeGetTime();
 int iFlag = 0;

	if (m_cGameModeCount == 0)
	{	pMI = new class CMouseInterface;
		pMI->AddRect(310, 80,560,100);
		pMI->AddRect(310,101,558,122);
		pMI->AddRect(310,123,558,145);
		//pMI->AddRect(310,146,558,167); // real name
		//pMI->AddRect(310,168,477,191); // ssn
		//pMI->AddRect(488,168,557,191); // ssn
		pMI->AddRect(300,192,560,231);
		pMI->AddRect(300,232,560,268);   // Quiz 8  // +41
		pMI->AddRect(300,269,560,306);   // Answer 9
		pMI->AddRect(297, 399, 367, 417);  // Create 10
		pMI->AddRect(392, 399, 462, 417);  // Clear  11
		pMI->AddRect(488, 399, 558, 417);  // Cancel  12   Size 73 x 15
		cPrevFocus  = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 9; //12
		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
		ZeroMemory(m_cEmailAddr, sizeof(m_cEmailAddr));
		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cPassword, sizeof(cPassword));
		ZeroMemory(cConfirm, sizeof(cConfirm));
		ZeroMemory(cSSN_A, sizeof(cSSN_A));
		ZeroMemory(cSSN_B, sizeof(cSSN_B));
		ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
		ZeroMemory(cQuiz, sizeof(cQuiz));
		ZeroMemory(cTempQuiz, sizeof(cTempQuiz));
		ZeroMemory(cAnswer, sizeof(cAnswer));
		StartInputString(427, 84, 11, cName);
		ClearInputString();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;
	if (m_cArrowPressed != 0)
	{	switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;
		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEscPressed == TRUE)
	{	ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	if (cPrevFocus != m_cCurFocus)
	{	EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(427, 84, 11, cName);
			break;
		case 2:
			StartInputString(427, 106, 11, cPassword);
			break;
		case 3:
			StartInputString(427, 129, 11, cConfirm);
			break;
		case 4:
			StartInputString(311, 215, 31, m_cEmailAddr);
			break;
		case 5:
			StartInputString(311, 253, 44, cQuiz);
			break;
		case 6:
			StartInputString(311, 291 , 19, cAnswer);
			break;
		}
		cPrevFocus = m_cCurFocus;
	}

	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWACCOUNT, 0,0,0, TRUE);
	PutString(377, 84,  "Account:", RGB(100,100,200));
	PutString(372, 106, "Password:", RGB(100,100,200));
	PutString(372, 129, "(confirm)", RGB(100,100,200));
	PutString(271, 215, "eMail:", RGB(100,100,200));
	PutString(276, 253, "Quiz:", RGB(100,100,200));
	PutString(266, 291, "Answer:", RGB(100,100,200));

	if ((m_cCurFocus == 2) || (m_cCurFocus == 3))
		 ShowReceivedString(TRUE);
	else if ((m_cCurFocus == 1) || (m_cCurFocus == 4) || (m_cCurFocus == 5) || (m_cCurFocus == 6))
		ShowReceivedString();

	if (m_cCurFocus != 1) {
		if (m_Misc.bCheckValidName(cName) != FALSE)
			 PutString2(427, 84, cName, 100,200,100);
		else PutString2(427, 84, cName, 200,100,100);
	}
	if (m_cCurFocus != 2) {
		if (m_Misc.bCheckValidName(cPassword) != FALSE)
			 PutString(427, 106, cPassword, RGB(100,200,100), TRUE, 1);
		else PutString(427, 106, cPassword, RGB(200,100,100), TRUE, 1);
	}

	if (m_cCurFocus != 3) {
		if (memcmp(cPassword, cConfirm, 10) == 0)
			 PutString(427, 129, cConfirm, RGB(100,200,100), TRUE, 1);
		else PutString(427, 129, cConfirm, RGB(200,100,100), TRUE, 1);
	}
	if (memcmp(cPassword, cConfirm, 10) != 0) iFlag = 9;

	if (m_cCurFocus != 4) {
		if( m_Misc.bIsValidEmail(m_cEmailAddr) )
			PutString2(311, 48 + 190 -25 +2, m_cEmailAddr, 100,200,100);
		else PutString2(311, 48 + 190 -25 +2, m_cEmailAddr, 200,100,100);
	}

	wsprintf(cTempQuiz,"%s",cQuiz) ;
	m_Misc.ReplaceString(cTempQuiz, ' ', '_');

	if (m_cCurFocus != 5) {
		//if(m_Misc.bCheckValidName(cTempQuiz) != FALSE)
			PutString2(311, 48 + 226 -25 +4, cQuiz, 100,200,100);
		//else PutString2(311, 48 + 226 -25 +4, cQuiz, 200,100,100);
	}

	if (m_cCurFocus != 6) {
		//if (m_Misc.bCheckValidName(cAnswer) != FALSE)
			 PutString2(311, 291, cAnswer, 100,200,100);
		//else PutString2(311, 291, cAnswer, 200,100,100);
	}

	//if (m_Misc.bCheckValidName(cAnswer) == FALSE)		iFlag = 13;
	//if (m_Misc.bCheckValidName(cTempQuiz) == FALSE)		iFlag = 12;
	if (strlen(cAnswer) == 0)							iFlag = 11;
	if (strlen(cTempQuiz) == 0)							iFlag = 10;
	if (m_Misc.bCheckValidName(cPassword) == FALSE)		iFlag = 7;
	if (m_Misc.bCheckValidName(cName) == FALSE)			iFlag = 6;
	if (m_Misc.bIsValidEmail(m_cEmailAddr) == FALSE)	iFlag = 5;
	if (strlen(cConfirm) == 0)							iFlag = 3;
	if (strlen(cPassword) == 0)							iFlag = 2;
	if ((strlen(cName) == 0 ))							iFlag = 1;


	switch (m_cCurFocus) {
	case 1:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT1);
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT2);
		break;

	case 2:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT4);
		break;

	case 3:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT8);
		break;

	case 4:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT21);
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT22);
		PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT23);
		break;

	case 5:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT25);
		PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT26);
		break;

	case 6:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT29);
		break;

	case 7:
		switch (iFlag) {
		case 0:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT33);
			break;

		case 1:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT35);
			break;

		case 2:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT38);
			break;

		case 3:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT42);
			break;

		case 5:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT50);
			break;

		case 6:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT52);
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT53);
			break;

		case 7:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT56);
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT57);
			break;

		case 9:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT63);
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT64);
			PutAlignedString(290, 575, 360, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT65);
			break;
		case 10:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT67);
			break;
		case 11:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT69);
			break;
		case 12:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT73);
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT74);
			break;

		case 13:
			PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT77);
			PutAlignedString(290, 575, 345, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT78);
			break;

		}
		break;

	case 8:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT80);
		break;

	case 9:
		PutAlignedString(290, 575, 330, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT81);
		break;
	}


	if ( (iFlag == 0) && (m_cCurFocus == 7) )
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(199+98, 398, 25, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(199+98, 398, 24, dwTime);

	if (m_cCurFocus == 8)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(294+98, 398, 27, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(294+98, 398, 26, dwTime);

	if (m_cCurFocus == 9)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(390+98, 398, 17, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(390+98, 398, 16, dwTime);

	DrawVersion(TRUE);
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	if (m_bEnterPressed == TRUE)
	{	PlaySound('E', 14, 5);
		switch (m_cCurFocus) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;

		case 7:
			if (iFlag != 0) return;
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));

			ZeroMemory(m_cAccountQuiz, sizeof(m_cAccountQuiz));
			ZeroMemory(m_cAccountAnswer, sizeof(m_cAccountAnswer));

			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);

			strcpy(m_cAccountQuiz, cTempQuiz);
			strcpy(m_cAccountAnswer, cAnswer);
			m_cAccountQuiz[45] = ' ' ;
			m_cAccountAnswer[20] = ' ' ;

			ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
			wsprintf(m_cAccountSSN, "%s-%s", cSSN_A, cSSN_B);

			if (memcmp(cPassword, cConfirm, 10) != 0)
			{	ChangeGameMode(DEF_GAMEMODE_ONMSG);
				ZeroMemory(m_cMsg, sizeof(m_cMsg));
				strcpy(m_cMsg, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT82);
				               //"Cannot create account! - password not match!"
				delete pMI;
				return;
			}
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);

			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CREATENEWACCOUNT;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "00");
			delete pMI;
			return;

		case 8:
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cPassword, sizeof(cPassword));
			ZeroMemory(cConfirm, sizeof(cConfirm));
			ZeroMemory(m_cAccountAge, sizeof(m_cAccountAge));
			ZeroMemory(m_cAccountCountry, sizeof(m_cAccountCountry));
			ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
			ZeroMemory(m_cEmailAddr, sizeof(m_cEmailAddr));
			ZeroMemory(cSSN_A, sizeof(cSSN_A));
			ZeroMemory(cSSN_B, sizeof(cSSN_B));
			ZeroMemory(cQuiz, sizeof(cQuiz));
			ZeroMemory(cTempQuiz, sizeof(cTempQuiz));
			ZeroMemory(cAnswer, sizeof(cAnswer));

			break;

		case 9:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
		m_bEnterPressed = FALSE;
	}

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		default:
			m_cCurFocus = iMIbuttonNum;
			break;

		case 7:
			if (iFlag != 0) return;
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));

			ZeroMemory(m_cAccountQuiz, sizeof(m_cAccountQuiz));
			ZeroMemory(m_cAccountAnswer, sizeof(m_cAccountAnswer));


			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);
			strcpy(m_cAccountQuiz, cTempQuiz);
			strcpy(m_cAccountAnswer, cAnswer);

			ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
			wsprintf(m_cAccountSSN, "%s-%s", cSSN_A, cSSN_B);

			if (memcmp(cPassword, cConfirm, 10) != 0)
			{	ChangeGameMode(DEF_GAMEMODE_ONMSG);
				ZeroMemory(m_cMsg, sizeof(m_cMsg));
				strcpy(m_cMsg, UPDATE_SCREEN_ON_CREATE_NEW_ACCOUNT82);
				               //"Cannot create account! - password not match!"
				delete pMI;
				return;
			}

			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CREATENEWACCOUNT;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "00");
			delete pMI;
			return;

		case 8:
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cPassword, sizeof(cPassword));
			ZeroMemory(cConfirm, sizeof(cConfirm));
			ZeroMemory(m_cAccountAge, sizeof(m_cAccountAge));
			ZeroMemory(m_cAccountCountry, sizeof(m_cAccountCountry));
			ZeroMemory(m_cAccountSSN, sizeof(m_cAccountSSN));
			ZeroMemory(m_cEmailAddr, sizeof(m_cEmailAddr));
			ZeroMemory(cSSN_A, sizeof(cSSN_A));
			ZeroMemory(cSSN_B, sizeof(cSSN_B));
			ZeroMemory(cQuiz, sizeof(cQuiz));
			ZeroMemory(cTempQuiz, sizeof(cTempQuiz));
			ZeroMemory(cAnswer, sizeof(cAnswer));
			break;

		case 9:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	if ((msX >= 297) && (msX <= 370) && (msY >= 396) && (msY <= 417))  m_cCurFocus = 7;  //12
	if ((msX >= 392) && (msX <= 465) && (msY >= 396) && (msY <= 417)) m_cCurFocus = 8;  //13
	if ((msX >= 488) && (msX <= 561) && (msY >= 396) && (msY <= 417)) m_cCurFocus = 9; //14

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}
#endif //endif from #ifdef DEF_MAKE_ACCOUNT

void CGame::UpdateScreen_OnLogin()
{
 short msX, msY, msZ, sX, sY;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI;
 static char  cPassword[12], cPrevFocus;
 static char cName[12];
	sX = 146;
	sY = 114;
	if (m_cGameModeCount == 0)
	{	EndInputString();
		pMI = new class CMouseInterface;
		pMI->AddRect(80, 151, 337, 179);
		pMI->AddRect(80, 180, 337, 205);
		pMI->AddRect(80, 280, 163, 302);
		pMI->AddRect(258, 280, 327, 302);
		cPrevFocus  = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 4;
		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cPassword, sizeof(cPassword));
		StartInputString(180, 162, 11, cName);
		ClearInputString();
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{	switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;

		case 2:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;

		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;

		case 4:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE)
	{	m_bEnterPressed = FALSE;
		PlaySound('E', 14, 5);

		switch (m_cCurFocus) {
		case 1:
			m_cCurFocus++;
			if( m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		case 2:
		case 3:
			if ((strlen(cName) == 0) || (strlen(cPassword) == 0)) break;
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_LOGIN;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "11");
			delete pMI;
			return;
		case 4:	// Cancel
#ifdef DEF_SELECTSERVER
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER);
#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
#endif
			delete pMI;
			return;
	}	}

	if (m_bEscPressed == TRUE)
	{	EndInputString();
		ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	if (cPrevFocus != m_cCurFocus)
	{	EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(180, 162, 11, cName);
			break;
		case 2:
			StartInputString(180, 185, 11, cPassword, TRUE);
			break;
		case 3:
		case 4:
			break;
		}
		cPrevFocus = m_cCurFocus;
	}


	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{	PlaySound('E', 14, 5);
		switch (iMIbuttonNum) {
		case 1:
			m_cCurFocus = 1;
			break;

		case 2:
			m_cCurFocus = 2;
			break;

		case 3:
			if ((strlen(cName) == 0) || (strlen(cPassword) == 0)) break;
			EndInputString();
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort +(rand()%1), WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_LOGIN;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "11");
			delete pMI;
			return;

		case 4:
#ifdef DEF_SELECTSERVER
			ChangeGameMode(DEF_GAMEMODE_ONSELECTSERVER); // ONMAINMENU
#else
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
#endif
			delete pMI;
			return;
	}	}

	if ((msX >= 80) && (msX <= 163) && (msY >= 280) && (msY <= 302)) m_cCurFocus = 3;
	if ((msX >= 258) && (msX <= 327) && (msY >= 280) && (msY <= 302)) m_cCurFocus = 4;

	_Draw_OnLogin(cName, cPassword, msX, msY, m_cGameModeCount);
	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();

}

void CGame::UpdateScreen_OnSelectServer()
{
 short msX, msY, msZ, sX, sY;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI;
 static char  cPrevFocus;
 DWORD dwTime = timeGetTime();
 BOOL bFlag = TRUE;

	sX = 146;
	sY = 114;
	if (m_cGameModeCount == 0) {
		EndInputString();

		pMI = new class CMouseInterface;
		pMI->AddRect(130,177,270,198);
		pMI->AddRect(130,199,270,225);
		pMI->AddRect(256,279,331,308);

		cPrevFocus  = 1;
		m_cCurFocus = 1;
		m_cMaxFocus = 3;

		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_cArrowPressed != 0)
	{	switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;

		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE)
	{	m_bEnterPressed = FALSE;
		PlaySound('E', 14, 5);
		switch (m_cCurFocus) {
		case 1:
			if (strlen(m_cWorldServerName) ==0)
			ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
			strcpy(m_cWorldServerName, NAME_WORLDNAME1);
			ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
			delete pMI;
			return;

		case 2:
			ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
			strcpy(m_cWorldServerName, "WS2");
			ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
			delete pMI;
			return;

		case 3:	// Cancel
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
	}	}

	if (m_bEscPressed == TRUE)
	{	ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}
	if (cPrevFocus != m_cCurFocus)
	{	cPrevFocus = m_cCurFocus;
	}
	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 0,0,0, TRUE);
	if (m_cGameModeCount > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 40,121,1, TRUE);
	else if ((m_cGameModeCount >= 15) && (m_cGameModeCount <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->PutTransSprite25(40,121,1, TRUE);

	if (m_cGameModeCount > 20)
	{	if (m_cCurFocus == 1) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 138, 177, 5, TRUE);
		if (m_cCurFocus == 2) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 130, 205, 6, TRUE);
		if (m_cCurFocus == 3) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 256, 282, 4, TRUE);
	}
	DrawVersion();
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
			if (m_cCurFocus == 1) {
				ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
				strcpy(m_cWorldServerName, NAME_WORLDNAME1);
				ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
				delete pMI;
				return;
			}
			else m_cCurFocus = 1;
			break;

		case 2:
			if (m_cCurFocus == 2) {
				ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
				strcpy(m_cWorldServerName, "WS2");
				ChangeGameMode(DEF_GAMEMODE_ONLOGIN);
				delete pMI;
				return;
			}
			else m_cCurFocus = 2;
			break;

		case 3:
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			delete pMI;
			return;
		}
	}

	if ((msX >= 130) && (msX <= 295) && (msY >= 175) && (msY <= 198)) m_cCurFocus = 1;
	if ((msX >= 130) && (msX <= 295) && (msY >= 199) && (msY <= 225)) m_cCurFocus = 2;
	if ((msX >= 256) && (msX <= 331) && (msY >= 279) && (msY <= 308)) m_cCurFocus = 3;

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::OnSysKeyDown(WPARAM wParam)
{
	switch( wParam )
	{
	case VK_SHIFT:
		m_bShiftPressed = TRUE;
		break;
	case VK_CONTROL:
		m_bCtrlPressed = TRUE;
		break;
	case VK_RETURN:
		m_bEnterPressed = TRUE;
		break;
	}
}

void CGame::OnSysKeyUp(WPARAM wParam)
{
	switch( wParam )
	{
	case VK_SHIFT:
		m_bShiftPressed = FALSE;
		break;
	case VK_CONTROL:
		m_bCtrlPressed = FALSE;
		break;
	case VK_RETURN:
		m_bEnterPressed = FALSE;
		if( m_bToggleScreen == TRUE )
		{	m_bIsRedrawPDBGS = TRUE;
			m_DDraw.ChangeDisplayMode(G_hWnd);
		}
		break;
	case VK_ESCAPE:
		m_bEscPressed = FALSE;

#ifdef DEF_MULTI_SHORTCUT
	case VK_F10:
		UseShortCut( 3 );
		break;
#endif
	}
}

void CGame::OnKeyUp(WPARAM wParam)
{
 int i=0;
 DWORD dwTime = timeGetTime();

	switch (wParam) {

#ifdef DEF_EQUILIBRIUM_PROJECT //  pour marcher en mode Course
	case 222: // VK_OEM_7:
		m_bVK_OEM_7Pressed = FALSE;
		break;
#endif

	case VK_SHIFT:
		m_bShiftPressed = FALSE;
		break;
	case VK_CONTROL:
		m_bCtrlPressed = FALSE;
		break;
	case 65://'A'
		if (m_bCtrlPressed && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus) )
		{	if( m_bForceAttack )
			{	m_bForceAttack = FALSE;
				AddEventList( DEF_MSG_FORCEATTACK_OFF, 10 );
			}else
			{	m_bForceAttack = TRUE;
				AddEventList( DEF_MSG_FORCEATTACK_ON, 10 );
		}	}
		break;

	case 68://'D'
		if (m_bCtrlPressed == TRUE && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus) )
		{	m_cDetailLevel++;
			if( m_cDetailLevel > 2 ) m_cDetailLevel = 0;
			switch( m_cDetailLevel ) {
			case 0:
				AddEventList( NOTIFY_MSG_DETAIL_LEVEL_LOW, 10 );
				break;
			case 1:
				AddEventList( NOTIFY_MSG_DETAIL_LEVEL_MEDIUM, 10 );
				break;
			case 2:
				AddEventList( NOTIFY_MSG_DETAIL_LEVEL_HIGH, 10 );
				break;
		}	}
		break;

	case 72: // 'H' // Snoopy: Mimics VK_F1
		if (m_bCtrlPressed && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus) )
		{	if (m_bIsDialogEnabled[35] == FALSE)
				EnableDialogBox(35, NULL, NULL, NULL);
			else
			{	DisableDialogBox(35);
				DisableDialogBox(18);
		}	}
		break;

	case 87: // 'W' // Snoopy: mimics VK_F11 Togles transparency
		if (m_bCtrlPressed && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus) )
		{	m_bDialogTrans = !m_bDialogTrans;
		}
		break;

	case 88: // 'X' // Snoopy: mimics VK_F12 Logout Window
		if (m_bCtrlPressed && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus) )
		{	if (m_bIsDialogEnabled[19] == FALSE)
				EnableDialogBox(19, NULL, NULL, NULL);
			else DisableDialogBox(19);
		}
		break;

	case 77://'M'
		if( m_cGameMode == DEF_GAMEMODE_ONMAINGAME )
		{	if( m_bCtrlPressed )
			{	if( m_bIsDialogEnabled[9] == TRUE ) DisableDialogBox(9);
				else EnableDialogBox(9, 0, 0, 0, NULL);
		}	}
		break;

#ifdef _DEBUG
	case 81://'Q'
		if( ( m_bCtrlPressed == TRUE ) && ( m_cGameMode == DEF_GAMEMODE_ONMAINGAME ) )
		{	ZeroMemory(m_cChatMsg, sizeof(m_cChatMsg) );
			strcpy(m_cChatMsg, "/enableadmincommand 147258 ");
			StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg);
			//ClearInputString();
		}
		break;
#endif

	case 82://'R'
		if (m_bCtrlPressed == TRUE && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus) )
		{	if( m_bRunningMode )
			{	m_bRunningMode = FALSE;
				AddEventList( NOTIFY_MSG_CONVERT_WALKING_MODE, 10 );
			}else
			{	m_bRunningMode = TRUE;
				AddEventList( NOTIFY_MSG_CONVERT_RUNNING_MODE, 10 );
		}	}
		break;

	case 83://'S'
		if (m_bCtrlPressed == TRUE && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus) )
		{	if (m_bMusicStat == TRUE) // Music Off
			{	m_bMusicStat = FALSE;
				if (m_bSoundFlag)
				{	StopBGM();	// Snoopy: mp3 support
					if (m_pBGM != NULL)
					{	m_pBGM->bStop();
						delete m_pBGM;
						m_pBGM = NULL;
				}	}
				AddEventList( NOTIFY_MSG_MUSIC_OFF, 10 );
				break;
			}else if( m_bSoundStat == TRUE )
			{	m_pESound[38]->bStop();
				m_bSoundStat = FALSE;
				AddEventList( NOTIFY_MSG_SOUND_OFF, 10 );
				break;
			}else 	// Music On
			{	if( m_bSoundFlag ) 
				{	m_bMusicStat = TRUE;
					AddEventList( NOTIFY_MSG_MUSIC_ON, 10 );
				}
				if( m_bSoundFlag ) 
				{	m_bSoundStat = TRUE;
					AddEventList( NOTIFY_MSG_SOUND_ON, 10 );
				}
				StartBGM();
		}	}
		break;

	case 84: //'T'
		if (m_bCtrlPressed == TRUE && m_cGameMode == DEF_GAMEMODE_ONMAINGAME && (!m_bInputStatus) )
		{	char tempid[100], cLB, cRB;
			short sX, sY, msX, msY, msZ;
			sX = m_stDialogBoxInfo[10].sX;
			sY = m_stDialogBoxInfo[10].sY;
			ZeroMemory( tempid, sizeof( tempid ) );
			m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
			if( m_bIsDialogEnabled[10] == TRUE && (msX >= sX + 20) && (msX <= sX + 360) && (msY >= sY + 35) && (msY <= sY + 139) )
			{	CStrTok *pStrTok;
				char   * token, cBuff[64];
				char   seps[] = ":";
				int i = (139-msY+sY)/13;
				if( m_pChatScrollList[i + m_stDialogBoxInfo[10].sView] == NULL ) return;
				if( m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg[0] == ' ' ) i++;
				strcpy(cBuff, m_pChatScrollList[i + m_stDialogBoxInfo[10].sView]->m_pMsg);
				pStrTok = new class CStrTok(cBuff, seps);
				token = pStrTok->pGet();
				wsprintf( tempid, "/to %s", token );
				bSendCommand(MSGID_COMMAND_CHATMSG, NULL, NULL, NULL, NULL, NULL, tempid);
				delete pStrTok;
			}else if( _tmp_sOwnerType < 7 && (strlen(_tmp_cName)>0) && (m_iIlusionOwnerH==NULL)
						&& ((m_bIsCrusadeMode == FALSE) || _iGetFOE(_tmp_iStatus) >= 0))
			{	wsprintf( tempid, "/to %s", _tmp_cName );
				bSendCommand(MSGID_COMMAND_CHATMSG, NULL, NULL, NULL, NULL, NULL, tempid);
			}else
			{	EndInputString();
				wsprintf( m_cChatMsg, "/to " );
				StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg);
		}	}
		break;
	case 107: //'+'
		if(m_bInputStatus == FALSE) m_bZoomMap = TRUE;
		break;
	case 109: //'-'
		if(m_bInputStatus == FALSE) m_bZoomMap = FALSE;
		break;

	case VK_F2:
		UseShortCut( 1 );
		break;

	case VK_F3:
		UseShortCut( 2 );
		break;

	case VK_INSERT:
		if (m_iHP <= 0) return;
		if (m_bItemUsingStatus == TRUE)
		{	AddEventList(USE_RED_POTION1, 10);
			return;
		}
		if (m_bIsDialogEnabled[27] == TRUE)
		{	AddEventList(USE_RED_POTION2, 10);
			return;
		}
		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pItemList[i] != NULL) && (m_bIsItemDisabled[i] != TRUE) &&
			 (m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 1))
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, NULL, i, NULL, NULL, NULL);
			m_bIsItemDisabled[i] = TRUE;
			m_bItemUsingStatus = TRUE;
			return;
		}

		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pItemList[i] != NULL) && (m_bIsItemDisabled[i] != TRUE) &&
			 (m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 2))
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, NULL, i, NULL, NULL, NULL);
			m_bIsItemDisabled[i] = TRUE;
			m_bItemUsingStatus = TRUE;
			return;
		}
		break;

	case VK_DELETE:
		if (m_iHP <= 0) return;
		if (m_bItemUsingStatus == TRUE)
		{	AddEventList(USE_BLUE_POTION1, 10);
			return;
		}
		if (m_bIsDialogEnabled[27] == TRUE)
		{	AddEventList(USE_BLUE_POTION2, 10);
			return;
		}

		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pItemList[i] != NULL) && (m_bIsItemDisabled[i] != TRUE) &&
			 (m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 3))
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, NULL, i, NULL, NULL, NULL);
			m_bIsItemDisabled[i] = TRUE;
			m_bItemUsingStatus = TRUE;
			return;
		}

		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pItemList[i] != NULL) && (m_bIsItemDisabled[i] != TRUE) &&
			 (m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 4))
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, NULL, i, NULL, NULL, NULL);
			m_bIsItemDisabled[i] = TRUE;
			m_bItemUsingStatus = TRUE;
			return;
		}
		break;

	case VK_END:
		if ( ((m_bIsDialogEnabled[7] == TRUE) && (m_stDialogBoxInfo[7].cMode == 1) && (iGetTopDialogBoxIndex() == 7)) ||
			((m_bIsDialogEnabled[17] == TRUE) && (m_stDialogBoxInfo[17].cMode == 1) && (iGetTopDialogBoxIndex() == 17)) )
		{}else if ((!m_bInputStatus) && (m_cBackupChatMsg[0] != '!') && (m_cBackupChatMsg[0] != '~') && (m_cBackupChatMsg[0] != '^') &&
				 (m_cBackupChatMsg[0] != '@'))
		{	ZeroMemory(m_cChatMsg, sizeof(m_cChatMsg));
			strcpy(m_cChatMsg, m_cBackupChatMsg);
			StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg);
		}
		break;

	case VK_F4:
		if(m_cGameMode != DEF_GAMEMODE_ONMAINGAME) return;
		UseMagic(m_sMagicShortCut);
		break;

	case VK_F5:
		if (m_bIsDialogEnabled[1] == FALSE)
			EnableDialogBox(1, NULL, NULL, NULL);
		else DisableDialogBox(1);
		break;

	case VK_F6:
		if (m_bIsDialogEnabled[2] == FALSE)
			EnableDialogBox(2, NULL, NULL, NULL);
		else DisableDialogBox(2);
		break;

	case VK_F7:
		if (m_bIsDialogEnabled[3] == FALSE)
			EnableDialogBox(3, NULL, NULL, NULL);
		else DisableDialogBox(3);
		break;

	case VK_F8:
		if (m_bIsDialogEnabled[15] == FALSE)
			EnableDialogBox(15, NULL, NULL, NULL);
		else DisableDialogBox(15);
		break;

	case VK_F9:
		if (m_bIsDialogEnabled[10] == FALSE)
			EnableDialogBox(10, NULL, NULL, NULL);
		else DisableDialogBox(10);
		break;

	case VK_F11:
#ifdef DEF_MULTI_SHORTCUT
		UseShortCut( 4 );
#else
		m_bDialogTrans = !m_bDialogTrans;
#endif
		break;

	case VK_F12:
#ifdef DEF_MULTI_SHORTCUT
		UseShortCut( 5 );
#else
		if(m_bInputStatus) return;
		if (m_bIsDialogEnabled[19] == FALSE)
			EnableDialogBox(19, NULL, NULL, NULL);
		else DisableDialogBox(19);
#endif
		break;

	case VK_F1:
#ifdef DEF_MULTI_SHORTCUT
		UseShortCut( 0 );
#else
		if (m_bInputStatus) return;
		if (m_bIsDialogEnabled[35] == FALSE) // 35 CLEROTH
			EnableDialogBox(35, NULL, NULL, NULL);
		else
		{	DisableDialogBox(35);
			DisableDialogBox(18);
		}
#endif
		break;

	case VK_UP:
		m_cArrowPressed	= 1;
		if( m_cGameMode == DEF_GAMEMODE_ONMAINGAME )
		{	int iTotalMsg=0;
			for( int i=DEF_MAXWHISPERMSG-1 ; i>=0 ; i-- )
			{	if( m_pWhisperMsg[i] != NULL )
				{	iTotalMsg = i;
					break;
			}	}
			m_cWhisperIndex ++;
			if( m_cWhisperIndex > iTotalMsg ) m_cWhisperIndex = 0;
			if( m_cWhisperIndex < 0 ) m_cWhisperIndex = iTotalMsg;
			if( m_pWhisperMsg[m_cWhisperIndex] != NULL ) {
			EndInputString();
			wsprintf( m_cChatMsg, "/to %s", m_pWhisperMsg[m_cWhisperIndex]->m_pMsg );
			StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg);
		}	}
		break;

	case VK_RIGHT:
		m_cArrowPressed	= 2;
		break;

	case VK_DOWN:
		m_cArrowPressed	= 3;
		if( m_cGameMode == DEF_GAMEMODE_ONMAINGAME )
		{	int iTotalMsg=0;
			for( int i=DEF_MAXWHISPERMSG-1 ; i>=0 ; i-- )
			{	if( m_pWhisperMsg[i] != NULL )
				{	iTotalMsg = i;
					break;
			}	}
			m_cWhisperIndex --;
			if( m_cWhisperIndex < 0 ) m_cWhisperIndex = iTotalMsg;
			if( m_cWhisperIndex > iTotalMsg ) m_cWhisperIndex = 0;
			if( m_pWhisperMsg[m_cWhisperIndex] != NULL ) {
			EndInputString();
			wsprintf( m_cChatMsg, "/to %s", m_pWhisperMsg[m_cWhisperIndex]->m_pMsg );
			StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg);
		}	}
		break;

	case VK_LEFT:
		m_cArrowPressed	= 4;
		break;

	case VK_SNAPSHOT:
		CreateScreenShot();
		break;

#ifndef DEF_USING_WIN_IME
	case VK_TAB:
		if( m_bShiftPressed )
		{	m_cCurFocus--;
			if( m_cCurFocus < 1 ) m_cCurFocus = m_cMaxFocus;
		}else
		{	m_cCurFocus++;
			if( m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
		}
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLECOMBATMODE, NULL, NULL, NULL, NULL, NULL);
		}
		break;

	case VK_RETURN:
		m_bEnterPressed = TRUE;
		break;
#endif

	case VK_HOME:
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME) 
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLESAFEATTACKMODE, NULL, NULL, NULL, NULL, NULL);
		}
		break;

	case VK_ESCAPE:
		m_bEscPressed = TRUE;
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
		{	if ((m_bIsObserverMode == TRUE) && (m_bShiftPressed))  //ObserverMode Shift+Esc
			{	// Log Out
				if (m_cLogOutCount == -1) m_cLogOutCount = 1;
				DisableDialogBox(19);
				PlaySound('E', 14, 5);
			}else if(m_cLogOutCount != -1) 
			{	if (m_bForceDisconn == FALSE)  //Esc
				{	m_cLogOutCount = -1;
					AddEventList(DLGBOX_CLICK_SYSMENU2, 10);//"Logout count stopped."
				}
			}
			if (m_bIsGetPointingMode == TRUE) 
			{	m_bIsGetPointingMode = FALSE;
				AddEventList(COMMAND_PROCESSOR1, 10);
			}
			m_bIsF1HelpWindowEnabled = FALSE;
		}
		break;

	case 33:
		if (m_cGameMode != DEF_GAMEMODE_ONMAINGAME) return;
		if (m_bInputStatus) return;
		if (m_bIsSpecialAbilityEnabled == TRUE)
		{	if (m_iSpecialAbilityType != 0) {
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY, NULL, NULL, NULL, NULL, NULL);
				m_bIsSpecialAbilityEnabled = FALSE;
			}
			else AddEventList(ON_KEY_UP26, 10);
		}
		else {
			if (m_iSpecialAbilityType == 0) AddEventList(ON_KEY_UP26, 10);
			else {
				if ((m_sPlayerAppr4 & 0x00F0) != 0) {
					AddEventList(ON_KEY_UP28, 10);
					return;
				}

				i = (dwTime - m_dwSpecialAbilitySettingTime)/1000;
				i = m_iSpecialAbilityTimeLeftSec - i;
				if (i < 0) i = 0;

				ZeroMemory(G_cTxt, sizeof(G_cTxt));
				if (i < 60) {
					switch (m_iSpecialAbilityType) {
					case 1: wsprintf(G_cTxt, ON_KEY_UP29, i); break;//"
					case 2: wsprintf(G_cTxt, ON_KEY_UP30, i); break;//"
					case 3: wsprintf(G_cTxt, ON_KEY_UP31, i); break;//"
					case 4: wsprintf(G_cTxt, ON_KEY_UP32, i); break;//"
					case 5: wsprintf(G_cTxt, ON_KEY_UP33, i); break;//"
					case 50:wsprintf(G_cTxt, ON_KEY_UP34, i); break;//"
					case 51:wsprintf(G_cTxt, ON_KEY_UP35, i); break;//"
					case 52:wsprintf(G_cTxt, ON_KEY_UP36, i); break;//"
					}
				}
				else {
					switch (m_iSpecialAbilityType) {
					case 1: wsprintf(G_cTxt, ON_KEY_UP37, i/60); break;//"
					case 2: wsprintf(G_cTxt, ON_KEY_UP38, i/60); break;//"
					case 3: wsprintf(G_cTxt, ON_KEY_UP39, i/60); break;//"
					case 4: wsprintf(G_cTxt, ON_KEY_UP40, i/60); break;//"
					case 5: wsprintf(G_cTxt, ON_KEY_UP41, i/60); break;//"
					case 50:wsprintf(G_cTxt, ON_KEY_UP42, i/60); break;//"
					case 51:wsprintf(G_cTxt, ON_KEY_UP43, i/60); break;//"
					case 52:wsprintf(G_cTxt, ON_KEY_UP44, i/60); break;//"
					}
				}
				AddEventList(G_cTxt, 10);
			}
		}
		break;
	}
}

void CGame::OnKeyDown(WPARAM wParam)
{
	switch (wParam) {

#ifdef DEF_EQUILIBRIUM_PROJECT //  pour marcher en mode Course
	case 222: // VK_OEM_7:
		m_bVK_OEM_7Pressed = TRUE;
		break;
#endif

	case VK_CONTROL:
		m_bCtrlPressed = TRUE;
		break;
	case VK_SHIFT:
		m_bShiftPressed = TRUE;
		break;
	case VK_INSERT:
	case VK_DELETE:
	case VK_TAB:
	case VK_RETURN:
	case VK_ESCAPE:
	case VK_END:
	case VK_HOME:
	case VK_F1:
	case VK_F2:
	case VK_F3:
	case VK_F4:
	case VK_F5:
	case VK_F6:
	case VK_F7:
	case VK_F8:
	case VK_F9:
	case VK_F10:
	case VK_F11:
	case VK_F12:
	case VK_PRIOR: // Page-Up
	case VK_NEXT: // Page-Down
	case VK_LWIN:
	case VK_RWIN:
	case VK_MULTIPLY:
	case VK_ADD: //'+'
	case VK_SEPARATOR:
	case VK_SUBTRACT: //'-'
	case VK_DECIMAL:
	case VK_DIVIDE:
	case VK_NUMLOCK:
	case VK_SCROLL:
		break;

	default:
		if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
		{	if (m_bCtrlPressed) 
			{	switch (wParam) {
				case 48: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 9; break; // 0
				case 49: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 0; break; // 1
				case 50: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 1; break; // 2
				case 51: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 2; break; // 3
				case 52: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 3; break; // 4
				case 53: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 4; break; // 5
				case 54: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 5; break; // 6
				case 55: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 6; break; // 7
				case 56: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 7; break; // 8
				case 57: EnableDialogBox(3, NULL, NULL, NULL); m_stDialogBoxInfo[3].sView = 8; break; // 9
				}
			}else if ((m_bInputStatus == FALSE) && (GetAsyncKeyState(VK_MENU)>>15 == FALSE))
			{	StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg);
				ClearInputString();
		}	}
		break;
	}
}

void CGame::UpdateScreen_OnQuit()
{
 short msX, msY, msZ;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;

 static class CMouseInterface * pMI;

 DWORD dwTime = timeGetTime();

	if (m_cGameModeCount == 0) {
		if (G_pCalcSocket != NULL) 
		{	delete G_pCalcSocket;
			G_pCalcSocket = NULL;
		}
		if (m_pGSock != NULL) 
		{	delete m_pGSock;
			m_pGSock = NULL;
		}
		m_bEscPressed = FALSE;
		m_bEnterPressed = FALSE;
		pMI = new class CMouseInterface;
		pMI->AddRect(0,0,640,480);
		m_bEnterPressed = FALSE;
	}

    m_cGameModeCount++;
	if (m_cGameModeCount > 120) m_cGameModeCount = 120;

	m_DDraw.ClearBackB4();

	if (m_bEscPressed == TRUE || m_bEnterPressed == TRUE) {
		m_bEscPressed = FALSE;
		m_bEnterPressed = FALSE;
		delete pMI;
		ChangeGameMode(DEF_GAMEMODE_NULL);
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
		return;
	}
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_QUIT, 0,0,0, TRUE);
	if (m_cGameModeCount > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_QUIT, 255,123,1, TRUE);
	else if ((m_cGameModeCount >= 15) && (m_cGameModeCount <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_QUIT]->PutTransSprite25(255,123,1, TRUE);
	DrawVersion(TRUE);
	if(m_cGameModeCount == 100)
	{	ChangeGameMode(DEF_GAMEMODE_NULL);
		delete pMI;
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
		return;
	}
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if ((cMIresult == DEF_MIRESULT_CLICK) && (iMIbuttonNum == 1)) {
		ChangeGameMode(DEF_GAMEMODE_NULL);
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
		delete pMI;
		return;
	}

//	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
//	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::UpdateScreen_OnQueryForceLogin()
{
 short msX, msY, msZ;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;

 static class CMouseInterface * pMI;
 static DWORD dwCTime;
 DWORD dwTime = timeGetTime();

	if (m_cGameModeCount == 0) {
		pMI = new class CMouseInterface;
		pMI->AddRect(200,244,200+DEF_BTNSZX,244+DEF_BTNSZY);
		pMI->AddRect(370,244,370+DEF_BTNSZX,244+DEF_BTNSZY);
		m_bEnterPressed = FALSE;
		m_bEscPressed   = FALSE;
		m_cArrowPressed = 0;

		dwCTime = timeGetTime();

		PlaySound('E', 25, 0);
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == TRUE) {
		ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	UpdateScreen_OnSelectCharacter(0, 0, 0, 0);
	if ((m_cGameModeCount >= 0) && (m_cGameModeCount < 6)) {
		m_DDraw.DrawShadowBox(0,0,639,479);
	}
	else if (m_cGameModeCount >= 6) {
		m_DDraw.DrawShadowBox(0,0,639,479);
		m_DDraw.DrawShadowBox(0,0,639,479);
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162, 130, 2);

	PutString_SprFont(172 + 86, 160, "Character on Use", 7,0,0);
	PutAlignedString(178, 453, 195, UPDATE_SCREEN_ON_QUERY_FORCE_LOGIN1);
	PutAlignedString(178, 453, 215, UPDATE_SCREEN_ON_QUERY_FORCE_LOGIN2);

	if ((msX >= 200) && (msX <= 200 + DEF_BTNSZX) && (msY >= 244) && (msY <= 244 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200, 244, 19);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200, 244, 18);

	if ((msX >= 370) && (msX <= 370 + DEF_BTNSZX) && (msY >= 244) && (msY <= 244 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370, 244, 3);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370, 244, 2);

	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8) {
		m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8) {
			m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{	PlaySound('E', 14, 5);
		switch (iMIbuttonNum) {
		case 1:
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode  = MSGID_REQUEST_ENTERGAME;
			m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NOENTER_FORCEDISCONN;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg,"33");
			delete pMI;
			return;

		case 2:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete pMI;
			break;
	}	}
	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::UpdateScreen_OnSelectCharacter(short sX, short sY, short msX, short msY, BOOL bIgnoreFocus)
{int i;
 int iYear, iMonth, iDay, iHour, iMinute;
 __int64 iTemp1, iTemp2;
 char cTotalChar = 0;
 DWORD dwTime = timeGetTime();
	sY = 10;
	m_DDraw.ClearBackB4();
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_SELECTCHAR, 0, 0, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0, 0, 50);

	iTemp1 = 0;
	iTemp2 = 0;
	iYear = iMonth = iDay = iHour = iMinute = 0;
	for (i = 0; i < 4; i++)
	{	if ((m_cCurFocus - 1 == i) && (bIgnoreFocus == FALSE))
			 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(sX + 110 + i*109 -7, 63 -9, 62, dwTime);
		else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(sX + 110 + i*109 -7, 63 -9, 61, dwTime);

		if (m_pCharList[i] != NULL)
		{	cTotalChar++;
			switch (m_pCharList[i]->m_sSex) {
			case 1:	_tmp_sOwnerType = 1; break;
			case 2:	_tmp_sOwnerType = 4; break;
			}
			_tmp_sOwnerType += m_pCharList[i]->m_sSkinCol - 1;
			_tmp_cDir   = m_cMenuDir;
			_tmp_sAppr1 = m_pCharList[i]->m_sAppr1;
			_tmp_sAppr2 = m_pCharList[i]->m_sAppr2;
			_tmp_sAppr3 = m_pCharList[i]->m_sAppr3;
			_tmp_sAppr4 = m_pCharList[i]->m_sAppr4;
			_tmp_iApprColor = m_pCharList[i]->m_iApprColor; // v1.4

			ZeroMemory(_tmp_cName, sizeof(_tmp_cName));
			memcpy(_tmp_cName, m_pCharList[i]->m_cName, 10);
			// CLEROTH - NO USE
			_tmp_cAction = DEF_OBJECTMOVE;
			_tmp_cFrame = m_cMenuFrame;

			if (m_pCharList[i]->m_sSex != NULL)
			{	if (m_Misc.bCheckValidString(m_pCharList[i]->m_cName) == TRUE)
				{	m_pEffectSpr[0]->PutTransSprite(sX +157 +i*109, sY +138, 1, dwTime);
					DrawObject_OnMove_ForMenu(0, 0, sX +157 +i*109, sY +138, FALSE, dwTime, 0, 0);
					PutString(sX +112 +i*109, sY +179 -9, m_pCharList[i]->m_cName, RGB(51,0,51));//25,35,25);
					int	_sLevel = m_pCharList[i]->m_sLevel;
					wsprintf(G_cTxt, "%d", _sLevel);
					PutString(sX + 138 +i*109, sY +196 -10, G_cTxt, RGB(51,0,51)); //25,35,25);

					wsprintf(G_cTxt, "%d", m_pCharList[i]->m_iExp);
					PutString(sX + 138 +i*109, sY +211 -10, G_cTxt, RGB(51,0,51)); //25,35,25);
				}
				iTemp2 = m_pCharList[i]->m_iYear*1000000 + m_pCharList[i]->m_iMonth*60000 + m_pCharList[i]->m_iDay*1700 + m_pCharList[i]->m_iHour*70 + m_pCharList[i]->m_iMinute;
				if (iTemp1 < iTemp2)
				{	iYear   = m_pCharList[i]->m_iYear;
					iMonth  = m_pCharList[i]->m_iMonth;
					iDay    = m_pCharList[i]->m_iDay;
					iHour   = m_pCharList[i]->m_iHour;
					iMinute = m_pCharList[i]->m_iMinute;
					iTemp1 = iTemp2;
	}	}	}	}
    i = 0 ;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,51);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,52);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,53);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,54);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,55);

	if ((msX > 360) && (msY >= 283) && (msX < 545) & (msY <= 315)) {
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,56);
		PutAlignedString(98, 357, 290 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER1);//"
		PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER2);//"
		PutAlignedString(98, 357, 320 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER3);//"
		PutAlignedString(98, 357, 335 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER4);//"
	} else
	if ((msX > 360) && (msY >= 316) && (msX < 545) & (msY <= 345)) {
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,57);
		PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER5);//"

	} else
	if ((msX > 360) && (msY >= 346) && (msX < 545) & (msY <= 375)) {

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,58);
		PutAlignedString(98, 357, 275 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER6);//"
		PutAlignedString(98, 357, 290 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER7);//"
		PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER8);//"
		PutAlignedString(98, 357, 320 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER9);//"
		PutAlignedString(98, 357, 335 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER10);//"
		PutAlignedString(98, 357, 350 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER11);//"

	}else if ((msX > 360) && (msY >= 376) && (msX < 545) & (msY <= 405))
	{	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,59);
		PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER12);//"
	}else if ((msX > 360) && (msY >= 406) && (msX < 545) & (msY <= 435)) {
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 0,0,60);
		PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER13);//"
	}else
	{	if (cTotalChar == 0)
		{	PutAlignedString(98, 357, 275 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER14);//"
			PutAlignedString(98, 357, 290 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER15);//"
			PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER16);//"
			PutAlignedString(98, 357, 320 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER17);//"New Character
			PutAlignedString(98, 357, 335 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER18);//"
		}else if (cTotalChar < 4)
		{	PutAlignedString(98, 357, 275 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER19);//"
			PutAlignedString(98, 357, 290 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER20);//"Play¹
			PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER21);//"
			PutAlignedString(98, 357, 320 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER22);//"
			PutAlignedString(98, 357, 335 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER23);//"Delete Character
			PutAlignedString(98, 357, 350 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER24);//"
		}
		if (cTotalChar == 4)
		{	PutAlignedString(98, 357, 290 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER25);//"
			PutAlignedString(98, 357, 305 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER26);//"Play
			PutAlignedString(98, 357, 320 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER27);//"Delete Character
			PutAlignedString(98, 357, 335 +15,  UPDATE_SCREEN_ON_SELECT_CHARACTER28);//"
	}	}
	int iTempMon, iTempDay, iTempHour, iTempMin ;
	iTempMon = iTempDay = iTempHour =iTempMin = 0;

	if (m_iAccntYear != 0)
	{	 iTempMin =  (m_iTimeLeftSecAccount / 60 ) ;
		 wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER37, m_iAccntYear, m_iAccntMonth, m_iAccntDay, iTempMin);
	}else
	{	if (m_iTimeLeftSecAccount > 0)
		{	iTempDay =   (m_iTimeLeftSecAccount /(60*60*24)) ;
			iTempHour =  (m_iTimeLeftSecAccount /(60*60)) % 24;
			iTempMin =   (m_iTimeLeftSecAccount / 60 ) % 60;
			wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER38, iTempDay, iTempHour, iTempMin);
		}else strcpy(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER39);
	}
	PutAlignedString(98, 357, 385 +10, G_cTxt);

	if (m_iIpYear != 0)
	{	iTempHour =  (m_iTimeLeftSecIP / (60*60)) ;
		iTempMin =   (m_iTimeLeftSecIP / 60 ) % 60;
		wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER40, m_iIpYear, m_iIpMonth, m_iIpDay, iTempHour, iTempMin) ;
	}else
	{	if (m_iTimeLeftSecIP > 0)
 		{	iTempDay =   (m_iTimeLeftSecIP / (60*60*24)) ;
			iTempHour =  (m_iTimeLeftSecIP / (60*60)) % 24;
			iTempMin =   (m_iTimeLeftSecIP / 60 ) % 60;
			wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER41, iTempDay, iTempHour, iTempMin);
		} else strcpy(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER42);
	}
	PutAlignedString(98, 357, 400 +10, G_cTxt);
	if (iYear != 0)
	{	wsprintf(G_cTxt, UPDATE_SCREEN_ON_SELECT_CHARACTER43, iYear, iMonth, iDay, iHour, iMinute);
		PutAlignedString(98, 357, 415 +10, G_cTxt);
	}

#ifdef _DEBUG
	PutAlignedString(122, 315, 456, UPDATE_SCREEN_ON_SELECT_CHARACTER36);//"Test Server"
#else
	if (strcmp(m_cWorldServerName, NAME_WORLDNAME1) == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME1);//"ABADDON Server"
	else if (strcmp(m_cWorldServerName, "WS2") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME2);//"APOCALYPSE Server"
	else if (strcmp(m_cWorldServerName, "WS3") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME3);//"3rd Server"
	else if (strcmp(m_cWorldServerName, "WS4") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME4);//"4th Server"
	else if (strcmp(m_cWorldServerName, "WS5") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME5);//"5th Server"
	else if (strcmp(m_cWorldServerName, "WS6") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME6);//"6th Server"
	else if (strcmp(m_cWorldServerName, "WS7") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME7);//"7th Server"
	else if (strcmp(m_cWorldServerName, "WS8") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME8);//"8th Server"
	else if (strcmp(m_cWorldServerName, "WS9") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME9);//"9th Server"
	else if (strcmp(m_cWorldServerName, "WS10") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME10);//"10th Server"
	else if (strcmp(m_cWorldServerName, "WS11") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME11);//"11th Server"
	else if (strcmp(m_cWorldServerName, "WS12") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME12);//"12th Server"
	else if (strcmp(m_cWorldServerName, "WS13") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME13);//"13th Server"
	else if (strcmp(m_cWorldServerName, "WS14") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME14);//"14th Server"
	else if (strcmp(m_cWorldServerName, "WS15") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME15);//"15th Server"
	else if (strcmp(m_cWorldServerName, "WS16") == 0)
		PutAlignedString(129, 321, 456, MSG_WORLDNAME16);//"16th Server"
#endif



}

void CGame::UpdateScreen_OnWaitingResponse()
{
 short sX, sY, msX, msY, msZ;
 char cLB, cRB;

 DWORD dwTime = timeGetTime();
 //static class CMouseInterface * pMI;
 static DWORD dwCTime;

	if (m_cGameModeCount == 0)
	{	m_bEnterPressed = FALSE;
		m_bEscPressed   = FALSE;
		dwCTime = timeGetTime();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == TRUE)
	{	if ((dwTime - m_dwTime) > 7000)
		{	ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			if (m_pLSock != NULL)
			{	delete m_pLSock;
				m_pLSock = NULL;
			}
			if (m_pGSock != NULL)
			{	delete m_pGSock;
				m_pGSock = NULL;
		}	}
		m_bEscPressed = FALSE;
		return;
	}

	if ((dwTime - dwCTime) > 100)
	{	m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{	m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{	m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	m_bIsHideLocalCursor = TRUE;
	m_DDraw.ClearBackB4();
	switch (m_cMsg[0]) {
	case '0':
		_Draw_UpdateScreen_OnCreateNewAccount();
		break;
	case '1':
		sX = 146;
		sY = 114;
		_Draw_OnLogin(m_cAccountName, m_cAccountPassword, 0, 0);
		break;
	case '2':
		_bDraw_OnCreateNewCharacter(m_cPlayerName, 0, 0, 0);
		break;
	case '3':
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0);
		break;
	case '4':// Change Password
		UpdateScreen_OnSelectCharacter(0, 0, 0, 0, TRUE);
		break;
	case '5':
		m_DDraw.ClearBackB4();
		break;
	}
	m_bIsHideLocalCursor = FALSE;

	m_DDraw.DrawShadowBox(0,0, 639,479);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);
	PutString_SprFont(172 + 44 -17, 190, "Connected. Waiting for response...", 7,0,0);

	if ((dwTime - m_dwTime) > 7000)
	{	PutAlignedString(180, 463, 195+30, UPDATE_SCREEN_ON_WATING_RESPONSE1);
		PutAlignedString(180, 463, 195+45, UPDATE_SCREEN_ON_WATING_RESPONSE2);
	}else PutAlignedString(180, 463, 195+30, UPDATE_SCREEN_ON_WATING_RESPONSE3);

	DrawVersion();
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 8, dwTime);

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::UpdateScreen_OnQueryDeleteCharacter()
{
 short msX, msY, msZ;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;

 static class CMouseInterface * pMI;
 static DWORD dwCTime;
 DWORD dwTime = timeGetTime();

	if (m_cGameModeCount == 0) 
	{	pMI = new class CMouseInterface;
		pMI->AddRect(200, 244, 200 + DEF_BTNSZX, 244 + DEF_BTNSZY);
		pMI->AddRect(370, 244, 370 + DEF_BTNSZX, 244 + DEF_BTNSZY);
		//m_cCurFocus = 1;
		//m_cMaxFocus = 2;
		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;

		dwCTime = timeGetTime();

		PlaySound('E', 25, 0);
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == TRUE) 
	{	ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	UpdateScreen_OnSelectCharacter(0, 0, 500, 70);
	if ((m_cGameModeCount >= 0) && (m_cGameModeCount < 6)) 
	{	m_DDraw.DrawShadowBox(0,0,639,479);
	}else if (m_cGameModeCount >= 6) 
	{	m_DDraw.DrawShadowBox(0,0,639,479);
		m_DDraw.DrawShadowBox(0,0,639,479);
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);

	PutString_SprFont(172 + 86, 160, "Delete Character", 7,0,0);
	PutString(215, 195, UPDATE_SCREEN_ON_QUERY_DELETE_CHARACTER1, RGB(5,5,5));//"Character Name"
	                   //"Character Name"
	PutString(335, 199, "__________", RGB(5,5,5));
	PutString(335, 195, m_pCharList[m_wEnterGameType - 1]->m_cName, RGB(25,35,25));
	PutAlignedString(178, 453, 220, UPDATE_SCREEN_ON_QUERY_DELETE_CHARACTER2);//"Do you want to delete the character above?"

	// v2.05
	if ((msX >= 200) && (msX <= 200 + DEF_BTNSZX) && (msY >= 244) && (msY <= 244 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200, 244, 19);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 200, 244, 18);

	if ((msX >= 370) && (msX <= 370 + DEF_BTNSZX) && (msY >= 244) && (msY <= 244 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370, 244, 3);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370, 244, 2);

	if ((dwTime - dwCTime) > 100)
	{	m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{	m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{	m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{	PlaySound('E', 14, 5);
		switch (iMIbuttonNum) {
		case 1:
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode  = MSGID_REQUEST_DELETECHARACTER;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg,"33");
			delete pMI;
			return;

		case 2:
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete pMI;
			break;
	}	}
	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::NotifyMsgHandler(char * pData)
{DWORD * dwp, dwTime, dwTemp;
 WORD  * wp, wEventType;
 char  * cp, cTemp[510], cTxt[120];
 short * sp, sX, sY, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9;
 int   * ip, i, iV1, iV2, iV3, iV4;

	dwTime = timeGetTime();

	wp   = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wEventType = *wp;

	switch (wEventType) {

	case DEF_NOTIFY_SLATE_BERSERK:		// reversed by Snoopy: 0x0BED
		AddEventList( DEF_MSG_NOTIFY_SLATE_BERSERK, 10 );//"Berserk magic casted!"
		m_bUsingSlate = TRUE;
		break;
	
	case DEF_NOTIFY_LOTERY_LOST:		// reversed by Snoopy: 0x0BEE:	
		AddEventList( DEF_MSG_NOTIFY_LOTERY_LOST, 10 );//"You draw a blank. Please try again next time.."
		break;

	case DEF_NOTIFY_0BEF:				// 0x0BEF: // Snoopy: Crash or closes the client? (Calls SE entry !)
		// I'm noot sure at all of this function's result, so let's quit game...
		
		break;

	case DEF_NOTIFY_CRAFTING_SUCCESS:	//reversed by Snoopy: 0x0BF0:
		m_iContribution -= m_iContributionPrice;
		m_iContributionPrice = 0;
		DisableDialogBox(25);
		AddEventList(NOTIFY_MSG_HANDLER42, 10);		// "Item manufacture success!"
		PlaySound('E', 23, 5);
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 21, 0);
			break;
		case 4:
		case 5:
		case 6:
			PlaySound('C', 22, 0);
			break;
		}
		break;

	case DEF_NOTIFY_CRAFTING_FAIL:		//reversed by Snoopy: 0x0BF1:
		m_iContributionPrice = 0;
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		iV1 = *ip; // Error reason
		switch (iV1) {
		case 1: 
			AddEventList(DEF_MSG_NOTIFY_CRAFTING_NO_PART, 10);		// "There is not enough material"		
			PlaySound('E', 24, 5);
			break;
		case 2: 
			AddEventList(DEF_MSG_NOTIFY_CRAFTING_NO_CONTRIB, 10);	// "There is not enough Contribution Point"	
			PlaySound('E', 24, 5);
			break;
		default:
		case 3: 
			AddEventList(DEF_MSG_NOTIFY_CRAFTING_FAILED, 10);		// "Crafting failed"	
			PlaySound('E', 24, 5);
			break;
		}
		break;

	case DEF_NOTIFY_ANGELIC_STATS:		// reversed by Snoopy: 0x0BF2
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		m_iAngelicStr = *ip;  // m_iAngelicStr
		cp +=4;
		ip = (int *)cp;
		m_iAngelicInt = *ip;  // m_iAngelicInt
		cp +=4;
		ip = (int *)cp;
		m_iAngelicDex = *ip;  // m_iAngelicDex
		cp +=4;
		ip = (int *)cp;
		m_iAngelicMag = *ip;  // m_iAngelicMag
		break;			

	case DEF_NOTIFY_ITEM_CANT_RELEASE:	// reversed by Snoopy: 0x0BF3	
		AddEventList(DEF_MSG_NOTIFY_NOT_RELEASED , 10 );//"Item cannot be released"			
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		ItemEquipHandler(*cp);
		break;

	case DEF_NOTIFY_ANGEL_FAILED:		// reversed by Snoopy: 0x0BF4
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		iV1 = *ip; // Error reason
		switch (iV1) {
		case 1: // "BFB9BBF3C4A120BECAC0BA20B9F6B1D7C0D4B4CFB4D92E20A4D02E2EA4D0" (Stolen bytes ?)
			AddEventList(DEF_MSG_NOTIFY_ANGEL_FAILED , 10 ); //"Impossible to get a Tutelary Angel." // Invented by Snoopy.
			break;
		case 2: //
			AddEventList(DEF_MSG_NOTIFY_ANGEL_MAJESTIC , 10 );//"You need additional Majesty Points."
			break;
		case 3: //
			AddEventList(DEF_MSG_NOTIFY_ANGEL_LOW_LVL , 10 ); //"Only Majesty characters can receive Tutelary Angel"
			break;
		}
		break;

	case DEF_NOTIFY_ANGEL_RECEIVED:		// reversed by Snoopy: 0x0BF5:	
		AddEventList(DEF_MSG_NOTIFY_ANGEL_RECEIVED, 10 );// "You have received the Tutelary Angel."
		break;

	case DEF_NOTIFY_SPELL_SKILL:		// reversed by Snoopy: 0x0BF6
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		{	m_cMagicMastery[i] = *cp;
			cp++;
		}
		for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		{	m_cSkillMastery[i] = (unsigned char)*cp;
			if (m_pSkillCfgList[i] != NULL)
				m_pSkillCfgList[i]->m_iLevel = (int)*cp;
			cp++;
		}
		break;	

#ifdef DEF_EQUILIBRIUM_PROJECT // Avatar msg
	case DEF_NOTIFY_AVATAR: // 0x0BFFE Snoopy,'s Avatar event
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		iV1 = *ip; // Msg type
		cp += 4;
		ip = (int *)cp;
		iV2 = *ip; // Statue rank
		cp += 4;
		ip = (int *)cp;
		iV3 = *ip; // Side of winer/messenger
		cp += 4;
		ZeroMemory(cTxt, sizeof(cTxt));
		memcpy(cTxt, cp, 10);
		cp += 10;  // Messenger's Name
		ip = (int *)cp;
		iV4 = *ip; // XP
		cp += 4;
		switch(iV1) { // Msg type
		case 1: // Begin Avatar
			PlaySound('E', 39, 0);
			m_bIsAvatarMode = TRUE;
			if( m_bMusicStat ) StartBGM();
			wsprintf(G_cTxt, "Avatar's relic quest on...", cTxt);
			SetTopMsg(G_cTxt, 10);
			break;
		case 2: // Relique ramassée	
			PlaySound('E', 53, 0);
			if ( m_bCitizen == TRUE)
			{	if (   ((m_bAresden == TRUE)  && (iV3 == 1))
					|| ((m_bAresden == FALSE) && (iV3 == 2)))
				{	  wsprintf(G_cTxt, "Avatar's relic grasped by %s", cTxt);
				}else
				{	  wsprintf(G_cTxt, "Avatar's relic captured by ennemi %s", cTxt);
				}
			}else wsprintf(G_cTxt, "Avatar's relic seized by %s", cTxt);
			if (strcmp(cTxt, m_cPlayerName) ==0 )
			{	wsprintf(G_cTxt, "By taking the relic, you're now the Avatar. Fetch the Great Dragon!");
				m_bIsAvatarMessenger = TRUE;
			}
			SetTopMsg(G_cTxt, 10);
			break;
		case 3: // Relique droppée				
			m_bIsAvatarMessenger = FALSE;
			PlaySound('E', 39, 0);
			wsprintf(G_cTxt, "Avatar's relic dropped by %s", cTxt);
			SetTopMsg(G_cTxt, 10);
			break;
		case 4: // Statue won
			PlaySound('E', 53, 0);
			if (strcmp(cTxt, m_cPlayerName) !=0 )
			{	switch (iV2) {
				case 2: // Dragon
					wsprintf(G_cTxt, "The Great Dragon gave %s's relic the Air elemental magic.", cTxt);
					break;
				case 3: // Demon
					wsprintf(G_cTxt, "The DemonLord imbued %s's relic with Fire's power.", cTxt);
					break;
				case 4: // Centaure
					wsprintf(G_cTxt, "The Faery's Earth magic replenishes %s's relic.", cTxt);
					break;
				case 5: // Allien
					wsprintf(G_cTxt, "Some Water magic refills %s's relic near the Allien.", cTxt);
					break;
				case 6: // Kloness
				case 7: // Kloness
					wsprintf(G_cTxt, "The Kloness divine Power blessed %s's relic.", cTxt);
					break;
				}
			}else // msg for the messenger
			{	switch (iV2) {
				case 2: // Dragon
					wsprintf(G_cTxt, "After the Great Dragon find the DemonLord.", cTxt);
					break;
				case 3: // Demon
					wsprintf(G_cTxt, "After the DemonLord search the Faery.", cTxt);
					break;
				case 4: // Centaure
					wsprintf(G_cTxt, "You found the Faery, but what about the Allien?", cTxt);
					break;
				case 5: // Allien
					wsprintf(G_cTxt, "Four elements already, now time go for a blessing!", cTxt);
					break;
				case 6: // Kloness
					wsprintf(G_cTxt, "Your nearlly achieved the Quest, find Aresien's statue...", cTxt);
					break;
				case 7: // Kloness
					wsprintf(G_cTxt, "Your nearlly achieved the Quest, find Aresien's statue...", cTxt);
					break;						
			}	}
			SetTopMsg(G_cTxt, 10);

			break;
		case 5: // Finish Avatar			
			m_bIsAvatarMode = FALSE;	
			m_bIsAvatarMessenger = FALSE;
			if( m_bMusicStat ) StartBGM();
			switch (iV3) {
			case 1: // Aresien
				wsprintf(G_cTxt, "%s reached Aresien with the restored relic.", cTxt);
				if ((m_bCitizen == TRUE) && (m_bAresden == TRUE))
				{	PlaySound('E', 53, 0);	  
				}else 
				{	PlaySound('E', 39, 0);
				}
				break;
			case 2: // Eldiniel
				wsprintf(G_cTxt, "%s reached Eldiniel with the restored relic.", cTxt);
				if ((m_bCitizen == TRUE) && (m_bAresden == FALSE))
				{	PlaySound('E', 53, 0);	  
				}else 
				{	PlaySound('E', 39, 0);
				}
				break;
			default:
				wsprintf(G_cTxt, "The Avatar's relic quest was finished.", cTxt);
				PlaySound('E', 53, 0);	
				break;
			}
			SetTopMsg(G_cTxt, 10);
			if (iV4 !=0)
			{	wsprintf(G_cTxt, "You won %d XP for participation in Avatar's relic quest.", iV4 );
				AddEventList( G_cTxt, 10 );
			}
			break;		
		}
		break;
#endif

	case DEF_NOTIFY_NORECALL: // Snoopy 0x0BD1
		AddEventList( "You can not recall in this map.", 10 );
		break;

	case DEF_NOTIFY_APOCGATESTARTMSG: // Snoopy 0x0BD2
		SetTopMsg("The portal to the Apocalypse is opened.", 10);
		break;

	case DEF_NOTIFY_APOCGATEENDMSG: // Snoopy 0x0BD3
		SetTopMsg("The portal to the Apocalypse is closed.", 10);
		break;

	case DEF_NOTIFY_APOCGATEOPEN: // Snoopy ;  Case BD4 of switch 00454077
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		ip  = (int *)cp;
		m_iGatePositX = *ip;
		cp += 4;
		ip  = (int *)cp;
		m_iGatePositY = *ip;
		cp += 4;
		ZeroMemory(m_cGateMapName, sizeof(m_cGateMapName));
		memcpy(m_cGateMapName, cp, 10);
		cp += 10;
		break;

	case DEF_NOTIFY_QUESTCOUNTER: // Snoopy;  Case BE2 of switch 00454077
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		ip  = (int *)cp;
		m_stQuest.sCurrentCount = (short)*ip;
		cp += 4;
		break;

	case DEF_NOTIFY_MONSTERCOUNT: // Snoopy ;  Case BE3 of switch 00454077
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		sV1 = *sp;
		cp+=2;
		wsprintf(cTxt,"Rest Monster :%d", sV1) ;
		AddEventList(cTxt, 10);
		break;

	case DEF_NOTIFY_APOCGATECLOSE: // Snoopy ;  Case BD5 of switch 00454077
		m_iGatePositX = m_iGatePositY = -1;
		ZeroMemory(m_cGateMapName, sizeof(m_cGateMapName));
		break;

	case DEF_NOTIFY_APOCFORCERECALLPLAYERS: // Snoopy ;  Case BD7 of switch 00454077
		AddEventList( "You are recalled by force, because the Apocalypse is started.", 10 );
		break;

	case DEF_NOTIFY_ABADDONKILLED: // Snoopy ;  Case BD6 of switch 00454077
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		ZeroMemory(cTxt, sizeof(cTxt));
		memcpy(cTxt, cp, 10);
		cp += 10;
		wsprintf(G_cTxt, "Abaddon is destroyed by %s", cTxt);
		AddEventList(G_cTxt, 10);
		break;

	case DEF_NOTIFY_0BE5: // Snoopy Abaddon's related? Thunder?;  Case BE5 of switch 00454077
/*00454255  |> B8 01000000    MOV EAX,1         ;  Case BE5 of switch 00454077
0045425A  |. 5F             POP EDI
0045425B  |. 8985 D8380700  MOV DWORD PTR SS:[EBP+738D8],EAX
00454261  |. 8985 DC380700  MOV DWORD PTR SS:[EBP+738DC],EAX
00454267  |. 8B85 88250700  MOV EAX,DWORD PTR SS:[EBP+72588]
0045426D  |. 5E             POP ESI
0045426E  |. 8985 E0380700  MOV DWORD PTR SS:[EBP+738E0],EAX
00454274  |. 5D             POP EBP
00454275  |. 5B             POP EBX
00454276  |. 81C4 10080000  ADD ESP,810
0045427C  |. C2 0400        RETN 4*/

		break;

	case DEF_NOTIFY_RESURRECTPLAYER: // Case BE9 of switch 00454077
			EnableDialogBox(50, 0, NULL, NULL);
		break;

	case DEF_NOTIFY_HELDENIANTELEPORT: //;  Case BE6 of switch 00454077
		m_bIsHeldenianMode = TRUE;
		m_bIsHeldenianMap  = ((m_cMapIndex == 35) || (m_cMapIndex == 36) || (m_cMapIndex == 37));
		SetTopMsg("Teleport to Heldenian field is available from now. Magic casting is forbidden until real battle.", 10);
		break;

	case DEF_NOTIFY_HELDENIANEND: //    ;  Case BE7 of switch 00454077
		m_bIsHeldenianMode = FALSE;
		SetTopMsg("Heldenian holy war has been closed.", 10);
		break;

	case DEF_NOTIFY_0BE8: // ;  Case BE8 of switch 00454077
		SetTopMsg("Characters will be recalled by force as Heldenian begins.", 10);
		break;

	case DEF_NOTIFY_HELDENIANSTART: //  Case BEA of switch 00454077
		m_bIsHeldenianMode = TRUE;		
		m_bIsHeldenianMap  = ((m_cMapIndex == 35) || (m_cMapIndex == 36) || (m_cMapIndex == 37));
		SetTopMsg("Heldenian real battle has been started form now on.", 10);
		break;

	case DEF_NOTIFY_HELDENIANVICTORY: // Case BEB of switch 00454077
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		sV1 = *sp;
		cp+=2;
		ShowHeldenianVictory(sV1);
		m_iHeldenianAresdenLeftTower	= -1;
		m_iHeldenianElvineLeftTower		= -1;
		m_iHeldenianAresdenFlags		= -1;
		m_iHeldenianElvineFlags			= -1;
		break;

	case DEF_NOTIFY_HELDENIANCOUNT: // Case BEC of switch 00454077
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		m_iHeldenianAresdenLeftTower = (int)*sp;
		cp+=2;
		sp  = (short *)cp;
		m_iHeldenianElvineLeftTower = (int)*sp;
		cp+=2;
		sp  = (short *)cp;
		m_iHeldenianAresdenFlags = (int)*sp;
		cp+=2;
		sp  = (short *)cp;
		m_iHeldenianElvineFlags = (int)*sp;
		cp+=2;
		break;

	// Slates - Diuuude
	case DEF_NOTIFY_SLATE_CREATESUCCESS:	// 0x0BC1
		AddEventList( DEF_MSG_NOTIFY_SLATE_CREATESUCCESS, 10 );
		break;
	case DEF_NOTIFY_SLATE_CREATEFAIL:		// 0x0BC2
		AddEventList( DEF_MSG_NOTIFY_SLATE_CREATEFAIL, 10 );
		break;
	case DEF_NOTIFY_SLATE_INVINCIBLE:		// 0x0BD8
		AddEventList( DEF_MSG_NOTIFY_SLATE_INVINCIBLE, 10 );
		m_bUsingSlate = TRUE;
		break;
	case DEF_NOTIFY_SLATE_MANA:				// 0x0BD9
		AddEventList( DEF_MSG_NOTIFY_SLATE_MANA, 10 );
		m_bUsingSlate = TRUE;
		break;
	case DEF_NOTIFY_SLATE_EXP:				// 0x0BE0
		AddEventList( DEF_MSG_NOTIFY_SLATE_EXP, 10 );
		m_bUsingSlate = TRUE;
		break;
	case DEF_NOTIFY_SLATE_STATUS:			// 0x0BE1
		AddEventList( DEF_MSG_NOTIFY_SLATECLEAR, 10 ); // "The effect of the prophecy-slate is disappeared."
		m_bUsingSlate = FALSE;
		break;

	// MJ Stats Change - Diuuude: Erreur, ici il s'agit de sorts et skills, le serveur comme la v351 sont aussi bugués !
	case DEF_NOTIFY_STATECHANGE_SUCCESS:	// 0x0BB5
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		{	m_cMagicMastery[i] = *cp;
			cp++;
		}
		for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		{	m_cSkillMastery[i] = (unsigned char)*cp;
			if (m_pSkillCfgList[i] != NULL)
				m_pSkillCfgList[i]->m_iLevel = (int)*cp;
			//else m_pSkillCfgList[i]->m_iLevel = 0;
			cp++;
		}
		// MJ Stats Change - Diuuude
		m_iStr += m_cLU_Str;
		m_iVit += m_cLU_Vit;
		m_iDex += m_cLU_Dex;
		m_iInt += m_cLU_Int;
		m_iMag += m_cLU_Mag;
		m_iCharisma += m_cLU_Char;
		m_iLU_Point = m_iLevel*3 - ((m_iStr + m_iVit + m_iDex + m_iInt + m_iMag + m_iCharisma) - 70) - 3;
		m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;
		AddEventList( "Your stat has been changed.", 10 ); // "Your stat has been changed."
		break;

	case DEF_NOTIFY_LEVELUP: // 0x0B16
		NotifyMsg_LevelUp(pData);
		break;

	case DEF_NOTIFY_STATECHANGE_FAILED:		// 0x0BB6
		m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;
		m_iLU_Point = m_iLevel*3 - ((m_iStr + m_iVit + m_iDex + m_iInt + m_iMag + m_iCharisma) - 70) - 3;
		AddEventList( "Your stat has not been changed.", 10 );
		break;

	case DEF_NOTIFY_SETTING_FAILED: // 0x0BB4 -  Case BB4 of switch 00454077
		AddEventList( "Your stat has not been changed.", 10 );
		m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;
		m_iLU_Point = m_iLevel*3 - ((m_iStr + m_iVit + m_iDex + m_iInt + m_iMag + m_iCharisma) - 70) - 3;
		break;

	// CLEROTH - LU
	case DEF_NOTIFY_SETTING_SUCCESS: // 0x0BB3 - envoie le niv et les stats
		NotifyMsg_SettingSuccess(pData);
		break;

	case DEF_NOTIFY_AGRICULTURENOAREA:		// 0x0BB2
		AddEventList( DEF_MSG_NOTIFY_AGRICULTURENOAREA, 10 );
		break;
	case DEF_NOTIFY_AGRICULTURESKILLLIMIT:	// 0x0BB1
		AddEventList( DEF_MSG_NOTIFY_AGRICULTURESKILLLIMIT, 10 );
		break;

	case DEF_NOTIFY_NOMOREAGRICULTURE:		// 0x0BB0
		AddEventList( DEF_MSG_NOTIFY_NOMOREAGRICULTURE, 10 );
		break;
	case DEF_NOTIFY_SPAWNEVENT:				// 0x0BAA
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		m_sMonsterID = (short)(*cp);
		cp++;
		sp  = (short *)cp;
		m_sEventX = *sp;
		cp+=2;
		sp  = (short *)cp;
		m_sEventY = *sp;
		cp+=2;
		m_dwMonsterEventTime = dwTime;
		break;

	case DEF_NOTIFY_CHANGEPLAYMODE:			// 0x0BA9
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		memcpy(m_cLocation, cp, 10);
		cp += 10;
		if (memcmp(m_cLocation, "aresden", 7) == 0)
		{	m_bAresden = TRUE;
			m_bCitizen = TRUE;
			m_bHunter = FALSE;
		}else if (memcmp(m_cLocation, "arehunter", 9) == 0)
		{	m_bAresden = TRUE;
			m_bCitizen = TRUE;
			m_bHunter = TRUE;
		}else if (memcmp(m_cLocation, "elvine", 6) == 0)
		{	m_bAresden = FALSE;
			m_bCitizen = TRUE;
			m_bHunter = FALSE;
		}else if (memcmp(m_cLocation, "elvhunter", 9) == 0)
		{	m_bAresden = FALSE;
			m_bCitizen = TRUE;
			m_bHunter = TRUE;

#ifdef DEF_EQUILIBRIUM_PROJECT // m_bAresden, m_bCitizen, m_bHunter for me ready for later fix
		}else if (memcmp(m_cLocation, "executor", 8) == 0)
		{	m_bAresden = TRUE;
			m_bCitizen = FALSE;
			m_bHunter  = FALSE;
		}else if (memcmp(m_cLocation, "evil", 4) == 0)
		{	m_bAresden = TRUE;
			m_bCitizen = FALSE;
			m_bHunter  = FALSE;
		}else if (memcmp(m_cLocation, "NONE", 4) == 0)
		{	m_bAresden = TRUE;
			m_bCitizen = FALSE;
			m_bHunter  = TRUE;
#endif

		}else
		{	m_bAresden = TRUE;
			m_bCitizen = FALSE;
			m_bHunter = TRUE;
		}
		AddEventList( DEF_MSG_GAMEMODE_CHANGED, 10 );
		break;

	case DEF_NOTIFY_REQGUILDNAMEANSWER:	 //   0x0BA6
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;
		sp  = (short *)cp;
		sV2 = *sp;
		cp += 2;
		ZeroMemory(cTemp, sizeof(cTemp));
		memcpy(cTemp, cp, 20);
		cp += 20;

		ZeroMemory( m_stGuildName[sV2].cGuildName, sizeof(m_stGuildName[sV2].cGuildName) );
		strcpy(m_stGuildName[sV2].cGuildName, cTemp);
		m_stGuildName[sV2].iGuildRank = sV1;
		for (i = 0; i < 20; i++) if (m_stGuildName[sV2].cGuildName[i] == '_') m_stGuildName[sV2].cGuildName[i] = ' ';
		break;

	case DEF_NOTIFY_FORCERECALLTIME: // 0x0BA7
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;
		if ( (int)(sV1/20) > 0)
			wsprintf(G_cTxt,NOTIFY_MSG_FORCERECALLTIME1,(int) (sV1/20)) ;
		else
			wsprintf(G_cTxt,NOTIFY_MSG_FORCERECALLTIME2) ;
		AddEventList(G_cTxt, 10);
		break;

	case DEF_NOTIFY_GIZONITEMUPGRADELEFT: // 0x0BA4// Item upgrade is possible.
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;
		m_iGizonItemUpgradeLeft = sV1;
		dwp = (DWORD *)cp;
		switch (*dwp) {
		case 1: //
			AddEventList(NOTIFY_MSG_HANDLER_GIZONITEMUPGRADELEFT1, 10);
			break;
		}
		cp += 4;
		break;

	case DEF_NOTIFY_GIZONITEMCHANGE: // 0x0BA5
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;
		m_pItemList[sV1]->m_cItemType = *cp ;
		cp++ ;
		wp  = (WORD *)cp;
		m_pItemList[sV1]->m_wCurLifeSpan = *wp;
		cp += 2;
		sp  = (short *)cp;
		m_pItemList[sV1]->m_sSprite = *sp;
		cp += 2;
		sp  = (short *)cp;
		m_pItemList[sV1]->m_sSpriteFrame = *sp;
		cp += 2;
		m_pItemList[sV1]->m_cItemColor = *cp ;
		cp++ ;
		m_pItemList[sV1]->m_sItemSpecEffectValue2 = *cp ;
		cp++ ;
		dwp = (DWORD *) cp ;
		m_pItemList[sV1]->m_dwAttribute =  *dwp ;
		cp +=4 ;
		ZeroMemory( m_pItemList[sV1]->m_cName, sizeof(m_pItemList[sV1]->m_cName) );
		memcpy(m_pItemList[sV1]->m_cName,cp,20) ;
		cp += 20 ;
		if (m_bIsDialogEnabled[34] == TRUE)
		{	m_stDialogBoxInfo[34].cMode = 3; // succes
		}
		PlaySound('E', 23, 5);
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 21, 0);
			break;

		case 4:
		case 5:
		case 6:
			PlaySound('C', 22, 0);
			break;
		}
		break;

	case DEF_NOTIFY_ITEMATTRIBUTECHANGE: // 0x0BA3
	case 0x0BC0: // 0x0BC0 Unknown msg, but real in client v3.51
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;
		dwTemp = m_pItemList[sV1]->m_dwAttribute;
		dwp  = (DWORD *)cp;
		m_pItemList[sV1]->m_dwAttribute = *dwp;
		cp += 4;
		dwp  = (DWORD *)cp;
		if (*dwp != 0) m_pItemList[sV1]->m_sItemSpecEffectValue1 = (short)*dwp;
		cp += 4;
		dwp  = (DWORD *)cp;
		if (*dwp != 0) m_pItemList[sV1]->m_sItemSpecEffectValue2 = (short)*dwp;
		cp += 4;
		if (dwTemp == m_pItemList[sV1]->m_dwAttribute)
		{	if (m_bIsDialogEnabled[34] == TRUE)
			{	m_stDialogBoxInfo[34].cMode = 4;// Failed
			}
			PlaySound('E', 24, 5);
		}else
		{	if (m_bIsDialogEnabled[34] == TRUE)
			{	m_stDialogBoxInfo[34].cMode = 3; // Success
			}
			PlaySound('E', 23, 5);
			switch (m_sPlayerType) {
			case 1:
			case 2:
			case 3:
				PlaySound('C', 21, 0);
				break;
			case 4:
			case 5:
			case 6:
				PlaySound('C', 22, 0);
				break;
		}	}
		break;

	case DEF_NOTIFY_ITEMUPGRADEFAIL:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;
		if (m_bIsDialogEnabled[34] == FALSE) return ;
		PlaySound('E', 24, 5);
		switch(sV1){
		case 1:
			m_stDialogBoxInfo[34].cMode = 8 ; // Failed
			break ;
		case 2:
			m_stDialogBoxInfo[34].cMode = 9 ; // Failed
			break ;
		case 3:
			m_stDialogBoxInfo[34].cMode = 10 ; // Failed
			break ;
		}
		break;

	case DEF_NOTIFY_PARTY:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;
		sp  = (short *)cp;
		sV2 = *sp;
		cp += 2;
		sp  = (short *)cp;
		sV3 = *sp;
		cp += 2;
		switch (sV1) {
		case 1: //
			switch (sV2) {
			case 0:
				EnableDialogBox(32, NULL, NULL, NULL);
				m_stDialogBoxInfo[32].cMode = 9;
				break;

			case 1:
				m_iPartyStatus = 1;
				m_iTotalPartyMember = NULL;
				EnableDialogBox(32, NULL, NULL, NULL);
				m_stDialogBoxInfo[32].cMode = 8;
				for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_JOINPARTY, NULL, 2, NULL, NULL, m_cMCName);
				break;
			}
			break;

		case 2: //
			m_iPartyStatus = 0;
			m_iTotalPartyMember = NULL;
			EnableDialogBox(32, NULL, NULL, NULL);
			m_stDialogBoxInfo[32].cMode = 10;
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));
			break;

		case 4:
			ZeroMemory(cTxt, sizeof(cTxt));
			memcpy(cTxt, cp, 10);
			cp += 10;

			switch (sV2) {
			case 0: //
				EnableDialogBox(32, NULL, NULL, NULL);
				m_stDialogBoxInfo[32].cMode = 9;
				break;

			case 1: //
				if (strcmp(cTxt, m_cPlayerName) == 0) {
					m_iPartyStatus = 2;
					EnableDialogBox(32, NULL, NULL, NULL);
					m_stDialogBoxInfo[32].cMode = 8;
				}
				else {
					wsprintf(G_cTxt, NOTIFY_MSG_HANDLER1, cTxt);
					AddEventList(G_cTxt, 10);
				}

				m_iTotalPartyMember++;
				for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
				if (strlen(m_stPartyMemberNameList[i].cName) == 0) {
					ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));
					memcpy(m_stPartyMemberNameList[i].cName, cTxt, 10);
					goto NMH_LOOPBREAK1;
				}
NMH_LOOPBREAK1:;
				break;

			case 2: //
				break;
			}
			break;

		case 5: //
			m_iTotalPartyMember = NULL;
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));

			m_iTotalPartyMember = sV3;
			for (i = 1; i <= sV3; i++) {
				ZeroMemory(m_stPartyMemberNameList[i-1].cName, sizeof(m_stPartyMemberNameList[i-1].cName));
				memcpy(m_stPartyMemberNameList[i-1].cName, cp, 10);
				cp += 11;
			}
			break;

		default:
			sp  = (short *)cp;
			sV4 = *sp;
			cp += 2;
			break;

		case 6:
			ZeroMemory(cTxt, sizeof(cTxt));
			memcpy(cTxt, cp, 10);
			cp += 10;

			switch (sV2) {
			case 0: //
				EnableDialogBox(32, NULL, NULL, NULL);
				m_stDialogBoxInfo[32].cMode = 7;
				break;

			case 1: //
				if (strcmp(cTxt, m_cPlayerName) == 0) {
					m_iPartyStatus = 0;
					EnableDialogBox(32, NULL, NULL, NULL);
					m_stDialogBoxInfo[32].cMode = 6;
				}
				else {
					wsprintf(G_cTxt, NOTIFY_MSG_HANDLER2 , cTxt);
					AddEventList(G_cTxt, 10);
				}
				for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
				if (strcmp(m_stPartyMemberNameList[i].cName, cTxt) == 0) {
					ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));
					m_iTotalPartyMember--;
					goto NMH_LOOPBREAK2;
				}
NMH_LOOPBREAK2:;
				break;
			}
			break;

		case 7: //
			EnableDialogBox(32, NULL, NULL, NULL);
			m_stDialogBoxInfo[32].cMode = 9;
			break;

		case 8: //
			m_iPartyStatus = 0;
			m_iTotalPartyMember = NULL;
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) ZeroMemory(m_stPartyMemberNameList[i].cName, sizeof(m_stPartyMemberNameList[i].cName));
			break;
		}
		break;

	case DEF_NOTIFY_CANNOTCONSTRUCT:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;

		CannotConstruct(sV1);
		PlaySound('E', 25, 0, 0);
		break;

	case DEF_NOTIFY_TCLOC:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

		sp  = (short *)cp;
		m_iTeleportLocX = *sp;
		cp += 2;

		sp  = (short *)cp;
		m_iTeleportLocY = *sp;
		cp += 2;

		ZeroMemory(m_cTeleportMapName, sizeof(m_cTeleportMapName));
		memcpy(m_cTeleportMapName, cp, 10);
		cp += 10;

		sp  = (short *)cp;
		m_iConstructLocX = *sp;
		cp += 2;

		sp  = (short *)cp;
		m_iConstructLocY = *sp;
		cp += 2;

		ZeroMemory(m_cConstructMapName, sizeof(m_cConstructMapName));
		memcpy(m_cConstructMapName, cp, 10);
		cp += 10;
		break;

	case DEF_NOTIFY_CONSTRUCTIONPOINT:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

		sp  = (short *)cp;
		sV1 = *sp;
		cp += 2;

		sp  = (short *)cp;
		sV2 = *sp;
		cp += 2;

		sp  = (short *)cp;
		sV3 = *sp;
		cp += 2;

		if (sV3 == 0) {
			if ((sV1 > m_iConstructionPoint) && (sV2 > m_iWarContribution)) {
				wsprintf(G_cTxt, "%s +%d, %s +%d", m_pGameMsgList[13]->m_pMsg, (sV1 - m_iConstructionPoint), m_pGameMsgList[21]->m_pMsg, (sV2 - m_iWarContribution));
				SetTopMsg(G_cTxt, 5);
				PlaySound('E', 23, 0, 0);
			}

			if ((sV1 > m_iConstructionPoint) && (sV2 == m_iWarContribution)) {
				if (m_iCrusadeDuty == 3) {
					wsprintf(G_cTxt, "%s +%d", m_pGameMsgList[13]->m_pMsg, sV1 - m_iConstructionPoint);
					SetTopMsg(G_cTxt, 5);
					PlaySound('E', 23, 0, 0);
				}
			}

			if ((sV1 == m_iConstructionPoint) && (sV2 > m_iWarContribution)) {
				wsprintf(G_cTxt, "%s +%d", m_pGameMsgList[21]->m_pMsg, sV2 - m_iWarContribution);
				SetTopMsg(G_cTxt, 5);
				PlaySound('E', 23, 0, 0);
			}

			if (sV1 < m_iConstructionPoint) {
				if (m_iCrusadeDuty == 3) {
					wsprintf(G_cTxt, "%s -%d", m_pGameMsgList[13]->m_pMsg, m_iConstructionPoint - sV1);
					SetTopMsg(G_cTxt, 5);
					PlaySound('E', 25, 0, 0);
				}
			}

			if (sV2 < m_iWarContribution) {
				wsprintf(G_cTxt, "%s -%d", m_pGameMsgList[21]->m_pMsg, m_iWarContribution - sV2);
				SetTopMsg(G_cTxt, 5);
				PlaySound('E', 24, 0, 0);
			}
		}

		m_iConstructionPoint = sV1;
		m_iWarContribution   = sV2;
		break;

	case DEF_NOTIFY_NOMORECRUSADESTRUCTURE:
		SetTopMsg(m_pGameMsgList[12]->m_pMsg, 5);
		PlaySound('E', 25, 0, 0);
		break;

	case DEF_NOTIFY_GRANDMAGICRESULT:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

		wp  = (WORD *)cp;
		sV1 = *wp;
		cp += 2;

		wp  = (WORD *)cp;
		sV2 = *wp;
		cp += 2;

		wp  = (WORD *)cp;
		sV3 = *wp;
		cp += 2;

		ZeroMemory(cTxt, sizeof(cTxt));
		memcpy(cTxt, cp, 10);
		cp += 10;

		wp  = (WORD *)cp;
		sV4 = *wp;
		cp += 2;

		wp  = (WORD *)cp;
		sV5 = *wp;  //
		cp += 2;

		if (sV5  > 0 ) {
			wp  = (WORD *)cp;
			sV6 = *wp;
			cp += 2;
			sV5-- ;
		}
		else sV6 = 0 ;

		if ( sV5  > 0 ) {
			wp  = (WORD *)cp;
			sV7 = *wp;
			cp += 2;
			sV5-- ;
		}
		else sV7 = 0 ;

		if ( sV5  > 0 ) {
			wp  = (WORD *)cp;
			sV8 = *wp;
			cp += 2;
			sV5-- ;
		}
		else sV8 = 0 ;

		if ( sV5  > 0 ) {
			wp  = (WORD *)cp;
			sV9 = *wp;
			cp += 2;
			sV5-- ;
		}
		else sV9 = 0 ;

		GrandMagicResult(cTxt, sV1, sV2, sV3, sV4, sV6, sV7, sV8, sV9);
		break;

	case DEF_NOTIFY_METEORSTRIKECOMING:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		wp  = (WORD *)cp;
		sV1 = *wp;
		cp += 2;
		MeteorStrikeComing(sV1);
		PlaySound('E', 25, 0, 0);
		break;

	case DEF_NOTIFY_METEORSTRIKEHIT:
		SetTopMsg(m_pGameMsgList[17]->m_pMsg, 5);
		//StartMeteorStrikeEffect
		for( i=0 ; i<36 ; i++ ) bAddNewEffect(60, m_sViewPointX +(rand() % 640), m_sViewPointY +(rand() % 480), NULL, NULL, -(rand() % 80));
		break;

	case DEF_NOTIFY_MAPSTATUSNEXT:
		AddMapStatusInfo(pData, FALSE);
		break;

	case DEF_NOTIFY_MAPSTATUSLAST:
		AddMapStatusInfo(pData, TRUE);
		break;

	case DEF_NOTIFY_LOCKEDMAP:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		sV1 = *sp;
		cp += 2;

		ZeroMemory(cTemp, sizeof(cTemp));
		ZeroMemory(cTxt, sizeof(cTxt));
		memcpy(cTxt, cp, 10);
		cp += 10;

		GetOfficialMapName(cTxt, cTemp);
		wsprintf( G_cTxt, NOTIFY_MSG_HANDLER3, sV1, cTemp );
		SetTopMsg(G_cTxt, 10);
		PlaySound('E', 25, 0, 0);
		break;

	case DEF_NOTIFY_CRUSADE: // Crusade msg
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		iV1 = *ip; // Crusademode
		cp += 4;
		ip = (int *)cp;
		iV2 = *ip; // crusade duty
		cp += 4;
		ip = (int *)cp;
		iV3 = *ip;
		cp += 4;
		ip = (int *)cp;
		iV4 = *ip;
		cp += 4;
		if (m_bIsCrusadeMode == FALSE)
		{	if (iV1 != 0) // begin crusade
			{	m_bIsCrusadeMode = TRUE;
				if( m_bMusicStat ) StartBGM(); // Change mp3 music for crusade 
				m_iCrusadeDuty = iV2;
				if( (m_iCrusadeDuty != 3) && (m_bCitizen==TRUE) )
					_RequestMapStatus("middleland", 3);
				if (m_iCrusadeDuty != NULL)
					 EnableDialogBox(33, 2, iV2, NULL);
				else EnableDialogBox(33, 1, NULL, NULL);
				if( m_bCitizen == FALSE ) EnableDialogBox(18, 800, NULL, NULL);
				else if( m_bAresden == TRUE ) EnableDialogBox(18, 801, NULL, NULL);
				else if( m_bAresden == FALSE ) EnableDialogBox(18, 802, NULL, NULL);
				if (m_bCitizen == FALSE) SetTopMsg(NOTIFY_MSG_CRUSADESTART_NONE, 10);
				else SetTopMsg(m_pGameMsgList[9]->m_pMsg, 10);
				PlaySound('E', 25, 0, 0);
			}
			if (iV3 != 0) // Crusade finished, show XP result screen
			{	CrusadeContributionResult(iV3);
			}
			if (iV4 == -1) // The crusade you played in was finished.
			{	CrusadeContributionResult(0); // You connect in this crusade, but did not connect after previous one => no XP....
			}
		}else
		{	if (iV1 == 0) // crusade finished show result (1st result: winner)
			{	m_bIsCrusadeMode = FALSE;
				if( m_bMusicStat ) StartBGM(); // Change mp3 at crusade's end
				m_iCrusadeDuty   = NULL;
				CrusadeWarResult(iV4);
				SetTopMsg(m_pGameMsgList[57]->m_pMsg, 8);
			}else
			{	if (m_iCrusadeDuty != iV2)
				{	m_iCrusadeDuty = iV2;
					EnableDialogBox(33, 2, iV2, NULL);
					PlaySound('E', 25, 0, 0);
			}	}
			if (iV4 == -1)
			{	CrusadeContributionResult(0); // You connect in this crusade, but did not connect after previous one => no XP....
		}	}
		break;

	case DEF_NOTIFY_SPECIALABILITYSTATUS:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		sV1 = *sp;
		cp += 2;
		sp = (short *)cp;
		sV2 = *sp;
		cp += 2;
		sp = (short *)cp;
		sV3 = *sp;
		cp += 2;
		if (sV1 == 1) // Use SA
		{	PlaySound('E', 35, 0);
			AddEventList(NOTIFY_MSG_HANDLER4, 10); // "Use special ability!"
			switch (sV2) {
			case 1: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER5,sV3); break;//"You are untouchable for %d seconds!"
			case 2: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER6, sV3); break;//"
			case 3: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER7, sV3); break;//"
			case 4: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER8, sV3); break;//"
			case 5: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER9, sV3); break;//"
			case 50:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER10, sV3); break;//"
			case 51:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER11, sV3); break;//"
			case 52:wsprintf(G_cTxt, NOTIFY_MSG_HANDLER12, sV3); break;//"
			case 55: // Spell effect
				if (sV3 >90)
					wsprintf(G_cTxt, "You cast a powerfull incantation, you can't use it again before %d minutes.", sV3/60);
				else
					wsprintf(G_cTxt, "You cast a powerfull incantation, you can't use it again before %d seconds.", sV3);
				break;
			}
			AddEventList(G_cTxt, 10);
		}else if (sV1 == 2) // Finished using
		{	if (m_iSpecialAbilityType != (int)sV2)
			{	PlaySound('E', 34, 0);
				AddEventList(NOTIFY_MSG_HANDLER13, 10);//"Special ability has been set!"
				if (sV3 >= 60)
				{	switch (sV2) {
					case 1: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER14, sV3/60); AddEventList(G_cTxt, 10); break;//"Ability that decreases enemy's HP by 50%: Can use after %dMin"
					case 2: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER15, sV3/60); AddEventList(G_cTxt, 10); break;//"
					case 3: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER16, sV3/60); AddEventList(G_cTxt, 10); break;//"
					case 4: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER17, sV3/60); AddEventList(G_cTxt, 10); break;//"
					case 5: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER18, sV3/60); AddEventList(G_cTxt, 10); break;//"
					case 50:wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER19, sV3/60); AddEventList(G_cTxt, 10); break;//"
					case 51:wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER20, sV3/60); AddEventList(G_cTxt, 10); break;//"
					case 52:wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER21, sV3/60); AddEventList(G_cTxt, 10); break;//"
					}
				}else
				{	switch (sV2) {
					case 1: wsprintf(G_cTxt, NOTIFY_MSG_HANDLER22, sV3); AddEventList(G_cTxt, 10); break;//"
					case 2: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER23, sV3); AddEventList(G_cTxt, 10); break;//"
					case 3: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER24, sV3); AddEventList(G_cTxt, 10); break;//"
					case 4: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER25, sV3); AddEventList(G_cTxt, 10); break;//"
					case 5: wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER26, sV3); AddEventList(G_cTxt, 10); break;//"
					case 50:wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER27, sV3); AddEventList(G_cTxt, 10); break;//"
					case 51:wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER28, sV3); AddEventList(G_cTxt, 10); break;//"
					case 52:wsprintf(G_cTxt,  NOTIFY_MSG_HANDLER29, sV3); AddEventList(G_cTxt, 10); break;//""Ability that makes character untouchable: Can use after %dSec"
			}	}	}
			m_iSpecialAbilityType = (int)sV2;
			m_dwSpecialAbilitySettingTime = dwTime;
			m_iSpecialAbilityTimeLeftSec  = (int)sV3;
		}else if (sV1 == 3)  // End of using time
		{	m_bIsSpecialAbilityEnabled = FALSE;
			m_dwSpecialAbilitySettingTime = dwTime;
			if (sV3 == 0)
			{	m_iSpecialAbilityTimeLeftSec  = 1200;
				AddEventList(NOTIFY_MSG_HANDLER30, 10);//"Special ability has run out! Will be available in 20 minutes."
			}else
			{	m_iSpecialAbilityTimeLeftSec  = (int)sV3;
				if (sV3 >90)
					 wsprintf(G_cTxt, "Special ability has run out! Will be available in %d minutes." , sV3/60);
				else wsprintf(G_cTxt, "Special ability has run out! Will be available in %d seconds." , sV3);
				AddEventList(G_cTxt, 10);
			}
		}else if (sV1 == 4) // Unequiped the SA item
		{	AddEventList(NOTIFY_MSG_HANDLER31, 10);//"Special ability has been released."
			m_iSpecialAbilityType = 0;
		}else if (sV1 == 5) // Angel
		{	PlaySound('E', 52, 0); // Angel
		}
		break;

	case DEF_NOTIFY_SPECIALABILITYENABLED:
		if (m_bIsSpecialAbilityEnabled == FALSE) {
			PlaySound('E', 30, 5);
			AddEventList(NOTIFY_MSG_HANDLER32, 10);//"
		}
		m_bIsSpecialAbilityEnabled = TRUE;
		break;

	case DEF_NOTIFY_ENERGYSPHEREGOALIN:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		sV1 = *sp;
		cp += 2;
		sp = (short *)cp;
		sV2 = *sp;
		cp += 2;
		sp = (short *)cp;
		sV3 = *sp;
		cp += 2;
		ZeroMemory(cTxt, sizeof(cTxt));
		memcpy(cTxt, cp, 20);

		if (sV2 == sV3)
		{	PlaySound('E', 24, 0);
			if (strcmp(cTxt, m_cPlayerName) == 0)
			{	AddEventList(NOTIFY_MSG_HANDLER33, 10);//You pushed energy sphere to enemy's energy portal! Contribution point will be decreased by 10 points."
				m_iContribution += sV1; // fixed, server must match...
				m_iContributionPrice = 0;
				if (m_iContribution < 0) m_iContribution = 0;
			}
			else {
				ZeroMemory(G_cTxt, sizeof(G_cTxt));
				if( m_bAresden == TRUE ) wsprintf(G_cTxt, NOTIFY_MSG_HANDLER34, cTxt);//"%s(Aresden) pushed energy sphere to enemy's portal!!..."
				else if (m_bAresden == FALSE) wsprintf(G_cTxt, NOTIFY_MSG_HANDLER34_ELV, cTxt);//"%s(Elvine) pushed energy sphere to enemy's portal!!..."
				AddEventList(G_cTxt, 10);
			}
		}else
		{	PlaySound('E', 23, 0);
			if (strcmp(cTxt, m_cPlayerName) == 0)
			{	switch (m_sPlayerType) {
				case 1:
				case 2:
				case 3:	PlaySound('C', 21, 0); break;
				case 4:
				case 5:
				case 6:	PlaySound('C', 22, 0); break;
				}
				AddEventList(NOTIFY_MSG_HANDLER35, 10);//"Congulaturations! You brought energy sphere to energy portal and earned experience and prize gold!"

				m_iContribution += sV1; // fixed, server must match...
				m_iContributionPrice = 0;
				if (m_iContribution < 0) m_iContribution = 0;
			}else
			{	ZeroMemory(G_cTxt, sizeof(G_cTxt));
				if (sV3 == 1)
				{	wsprintf(G_cTxt, NOTIFY_MSG_HANDLER36, cTxt);//"Elvine %s : Goal in!"
					AddEventList(G_cTxt, 10);
				}else if (sV3 == 2)
				{	wsprintf(G_cTxt, NOTIFY_MSG_HANDLER37, cTxt);//"Aresden %s : Goal in!"
					AddEventList(G_cTxt, 10);
		}	}	}
		break;

	case DEF_NOTIFY_ENERGYSPHERECREATED:
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		sV1 = *sp;
		cp += 2;
		sp = (short *)cp;
		sV2 = *sp;
		cp += 2;
		ZeroMemory(G_cTxt, sizeof(G_cTxt));
		wsprintf(G_cTxt, NOTIFY_MSG_HANDLER38, sV1, sV2);//"Energy sphere was dropped in (%d, %d) of middleland!"
		AddEventList(G_cTxt, 10);
		AddEventList(NOTIFY_MSG_HANDLER39, 10);//"A player who pushed energy sphere to the energy portal of his city will earn many Exp and Contribution."
		break;

	case DEF_NOTIFY_QUERY_JOINPARTY:
		EnableDialogBox(32, NULL, NULL, NULL);
		m_stDialogBoxInfo[32].cMode = 1;
		ZeroMemory(m_stDialogBoxInfo[32].cStr, sizeof(m_stDialogBoxInfo[32].cStr));
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		strcpy(m_stDialogBoxInfo[32].cStr, cp);
		break;

	case DEF_NOTIFY_RESPONSE_CREATENEWPARTY:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;

		if ((BOOL)*sp == TRUE)
		{	m_stDialogBoxInfo[32].cMode = 2;
		}else
		{	m_stDialogBoxInfo[32].cMode = 3;
		}
		break;

	case DEF_NOTIFY_DAMAGEMOVE:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		m_sDamageMove = *sp;
		cp += 2;
		sp = (short *)cp;
		m_sDamageMoveAmount = *sp;
		cp += 2;
		break;

	case DEF_NOTIFY_OBSERVERMODE:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		if (*sp == 1)
		{	AddEventList(NOTIFY_MSG_HANDLER40);//"Observer Mode On. Press 'SHIFT + ESC' to Log Out..."
			m_bIsObserverMode = TRUE;
			m_dwObserverCamTime = timeGetTime();
			char cName[12];
			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, m_cPlayerName, 10);
			m_pMapData->bSetOwner(m_sPlayerObjectID, -1, -1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, cName, NULL, NULL, NULL, NULL);
		}else
		{	AddEventList(NOTIFY_MSG_HANDLER41);//"Observer Mode Off"
			m_bIsObserverMode = FALSE;
			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir, m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, m_iPlayerStatus, m_cPlayerName, DEF_OBJECTSTOP, NULL, NULL, NULL);
		}
		break;

	case DEF_NOTIFY_BUILDITEMSUCCESS:
		DisableDialogBox(26);
		cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		sV1 = *sp;
		cp += 2;
		sp = (short *)cp;
		sV2 = *sp;
		cp += 2;
		if (sV1 < 10000)
		{	EnableDialogBox(26, 6, 1, sV1, NULL);
			m_stDialogBoxInfo[26].sV1 = sV2;
		}else
		{	EnableDialogBox(26, 6, 1, -1*(sV1 - 10000), NULL);
			m_stDialogBoxInfo[26].sV1 = sV2;
		}
		AddEventList(NOTIFY_MSG_HANDLER42, 10);
		PlaySound('E', 23, 5);
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 21, 0);
			break;

		case 4:
		case 5:
		case 6:
			PlaySound('C', 22, 0);
			break;
		}
		break;

	case DEF_NOTIFY_BUILDITEMFAIL:
		DisableDialogBox(26);
		EnableDialogBox(26, 6, 0, NULL);
		AddEventList(NOTIFY_MSG_HANDLER43, 10);
		PlaySound('E', 24, 5);
		break;

	case DEF_NOTIFY_QUESTREWARD:
		NotifyMsg_QuestReward(pData);
		break;

	case DEF_NOTIFY_QUESTCOMPLETED:
		m_stQuest.bIsQuestCompleted = TRUE;
		DisableDialogBox(28);
		EnableDialogBox(28, 1, NULL, NULL);
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:	PlaySound('C', 21, 0); break;
		case 4:
		case 5:
		case 6:	PlaySound('C', 22, 0); break;
		}
		PlaySound('E', 23, 0);
		AddEventList(NOTIFY_MSG_HANDLER44, 10);
		break;

	case DEF_NOTIFY_QUESTABORTED:
		m_stQuest.sQuestType = NULL;
		DisableDialogBox(28);
		EnableDialogBox(28, 2, NULL, NULL);
		break;

	case DEF_NOTIFY_QUESTCONTENTS:
		NotifyMsg_QuestContents(pData);
		break;

	case DEF_NOTIFY_ITEMCOLORCHANGE:
		NotifyMsg_ItemColorChange(pData);
		break;

	case DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED:
		NotifyMsg_DropItemFin_CountChanged(pData);
		break;

	case DEF_NOTIFY_CANNOTGIVEITEM:
		NotifyMsg_CannotGiveItem(pData);
		break;

	case DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
		NotifyMsg_GiveItemFin_CountChanged(pData);
		break;

	case DEF_NOTIFY_EXCHANGEITEMCOMPLETE:
		AddEventList(NOTIFYMSG_EXCHANGEITEM_COMPLETE1, 10);
		DisableDialogBox(27);
		//Snoopy: MultiTrade
		DisableDialogBox(41);
		PlaySound('E', 23, 5);
		break;

	case DEF_NOTIFY_CANCELEXCHANGEITEM:
		PlaySound('E', 24, 5);
		AddEventList(NOTIFYMSG_CANCEL_EXCHANGEITEM1, 10);
		AddEventList(NOTIFYMSG_CANCEL_EXCHANGEITEM2, 10);
		//Snoopy: MultiTrade
		DisableDialogBox(41);
		DisableDialogBox(27);
		break;

	case DEF_NOTIFY_SETEXCHANGEITEM:
		NotifyMsg_SetExchangeItem(pData);
		break;

	case DEF_NOTIFY_OPENEXCHANGEWINDOW:
		NotifyMsg_OpenExchageWindow(pData);
		break;

	case DEF_NOTIFY_NOTFLAGSPOT:
		AddEventList(NOTIFY_MSG_HANDLER45, 10);
		break;

	case DEF_NOTIFY_ITEMPOSLIST:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		for (i = 0; i < DEF_MAXITEMS; i++) {
			sp = (short *)cp;
			sX = *sp;
			cp += 2;
			sp = (short *)cp;
			sY = *sp;
			cp += 2;
			if (m_pItemList[i] != NULL) {
				if (sY < -10) sY = -10;
				if (sX < 0)   sX = 0;
				if (sX > 170) sX = 170;
				if (sY > 95)  sY = 95;

				m_pItemList[i]->m_sX = sX;
				m_pItemList[i]->m_sY = sY;
			}
		}
		break;

	case DEF_NOTIFY_ENEMYKILLS:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		m_iEnemyKillCount = *ip;
		break;

	case DEF_NOTIFY_DOWNSKILLINDEXSET:
		NotifyMsg_DownSkillIndexSet(pData);
		break;

	case DEF_NOTIFY_ADMINIFO:
		NotifyMsg_AdminInfo(pData);
		break;

	case DEF_NOTIFY_NPCTALK:
		NpcTalkHandler(pData);
		break;

	case DEF_NOTIFY_PORTIONSUCCESS:
		AddEventList(NOTIFY_MSG_HANDLER46, 10);
		break;

	case DEF_NOTIFY_PORTIONFAIL:
		AddEventList(NOTIFY_MSG_HANDLER47, 10);
		break;

	case DEF_NOTIFY_LOWPORTIONSKILL:
		AddEventList(NOTIFY_MSG_HANDLER48, 10);
		break;

	case DEF_NOTIFY_NOMATCHINGPORTION:
		AddEventList(NOTIFY_MSG_HANDLER49, 10);
		break;

	case DEF_NOTIFY_SUPERATTACKLEFT:
		sp = (short *)(pData + DEF_INDEX2_MSGTYPE + 2);
		m_iSuperAttackLeft = (int)*sp;
		break;

	case DEF_NOTIFY_SAFEATTACKMODE:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		switch (*cp) {
		case 1:
			if(!m_bIsSafeAttackMode) AddEventList(NOTIFY_MSG_HANDLER50, 10);//"
			m_bIsSafeAttackMode = TRUE;
			break;
		case 0:
			if(m_bIsSafeAttackMode) AddEventList(NOTIFY_MSG_HANDLER51, 10);//"
			m_bIsSafeAttackMode = FALSE;
			break;
		}
		break;

	case DEF_NOTIFY_IPACCOUNTINFO:
		ZeroMemory(cTemp, sizeof(cTemp));
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		strcpy(cTemp, cp);
		AddEventList(cTemp);
		break;

	case DEF_NOTIFY_REWARDGOLD:
		dwp = (DWORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
		m_iRewardGold = *dwp;
		break;

	case DEF_NOTIFY_SERVERSHUTDOWN:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		if (m_bIsDialogEnabled[25] == FALSE)
			 EnableDialogBox(25, *cp, NULL, NULL);
		else m_stDialogBoxInfo[25].cMode = *cp;
		PlaySound('E', 27, NULL);
		break;

	case DEF_NOTIFY_GLOBALATTACKMODE:
		NotifyMsg_GlobalAttackMode(pData);
		break;

	case DEF_NOTIFY_WHETHERCHANGE:
		NotifyMsg_WhetherChange(pData);
		break;

	case DEF_NOTIFY_FISHCANCELED:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		wp = (WORD *)cp;
		switch (*wp) {
		case NULL:
			AddEventList(NOTIFY_MSG_HANDLER52, 10);
			DisableDialogBox(24);
			break;

		case 1:
			AddEventList(NOTIFY_MSG_HANDLER53, 10);
			DisableDialogBox(24);
			break;

		case 2:
			AddEventList(NOTIFY_MSG_HANDLER54, 10);
			DisableDialogBox(24);
			break;
		}
		break;

	case DEF_NOTIFY_FISHSUCCESS:
		AddEventList(NOTIFY_MSG_HANDLER55, 10);
		PlaySound('E', 23, 5);
		PlaySound('E', 17, 5);
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 21, 0);
			break;

		case 4:
		case 5:
		case 6:
			PlaySound('C', 22, 0);
			break;
		}
		break;

	case DEF_NOTIFY_FISHFAIL:
		AddEventList(NOTIFY_MSG_HANDLER56, 10);
		PlaySound('E', 24, 5);
		break;

	case DEF_NOTIFY_FISHCHANCE:
		NotifyMsg_FishChance(pData);
		break;

	case DEF_NOTIFY_EVENTFISHMODE:
		NotifyMsg_EventFishMode(pData);
		break;

	case DEF_NOTIFY_NOTICEMSG:
		NotifyMsg_NoticeMsg(pData);
		break;

	case DEF_NOTIFY_RATINGPLAYER:
		NotifyMsg_RatingPlayer(pData);
		break;

	case DEF_NOTIFY_CANNOTRATING:
		NotifyMsg_CannotRating(pData);
		break;

	case DEF_NOTIFY_ADMINUSERLEVELLOW:
		AddEventList(NOTIFY_MSG_HANDLER58, 10);
		break;

	case DEF_NOTIFY_NOGUILDMASTERLEVEL:
		AddEventList(NOTIFY_MSG_HANDLER59, 10);
		break;
	case DEF_NOTIFY_SUCCESSBANGUILDMAN:
		AddEventList(NOTIFY_MSG_HANDLER60, 10);
		break;
	case DEF_NOTIFY_CANNOTBANGUILDMAN:
		AddEventList(NOTIFY_MSG_HANDLER61, 10);
		break;

	case DEF_NOTIFY_PLAYERSHUTUP:
		NotifyMsg_PlayerShutUp(pData);
		break;

	case DEF_NOTIFY_TIMECHANGE:
		NotifyMsg_TimeChange(pData);
		break;

	case DEF_NOTIFY_TOBERECALLED:
		AddEventList(NOTIFY_MSG_HANDLER62, 10);
		break;

	case DEF_NOTIFY_HUNGER:
		NotifyMsg_Hunger(pData);
		break;

	case DEF_NOTIFY_PLAYERPROFILE:
		NotifyMsg_PlayerProfile(pData);
		break;

	case DEF_NOTIFY_WHISPERMODEON:
		NotifyMsg_WhisperMode(TRUE, pData);
		break;

	case DEF_NOTIFY_WHISPERMODEOFF:
		NotifyMsg_WhisperMode(FALSE, pData);
		break;

	case DEF_NOTIFY_PLAYERONGAME:
		NotifyMsg_PlayerStatus(TRUE, pData);
		break;

	case DEF_NOTIFY_PLAYERNOTONGAME:
		NotifyMsg_PlayerStatus(FALSE, pData);
		break;

	case DEF_NOTIFY_CHARISMA:
		NotifyMsg_Charisma(pData);
		break;

	case DEF_NOTIFY_ITEMSOLD:
		DisableDialogBox(23);
		break;

	case DEF_NOTIFY_ITEMREPAIRED:
		DisableDialogBox(23);
		NotifyMsg_ItemRepaired(pData);
		break;

	case DEF_NOTIFY_CANNOTREPAIRITEM:
		NotifyMsg_CannotRepairItem(pData);
		break;

	case DEF_NOTIFY_CANNOTSELLITEM:
		NotifyMsg_CannotSellItem(pData);
		break;

	case DEF_NOTIFY_REPAIRITEMPRICE:
		NotifyMsg_RepairItemPrice(pData);
		break;

	case DEF_NOTIFY_SELLITEMPRICE:
		NotifyMsg_SellItemPrice(pData);
		break;

	case DEF_NOTIFY_SHOWMAP:
		NotifyMsg_ShowMap(pData);
		break;

	case DEF_NOTIFY_SKILLUSINGEND:
		NotifyMsg_SkillUsingEnd(pData);
		break;

	case DEF_NOTIFY_TOTALUSERS:
		NotifyMsg_TotalUsers(pData);
		break;

	case DEF_NOTIFY_MAGICEFFECTOFF:
		NotifyMsg_MagicEffectOff(pData);
		break;

	case DEF_NOTIFY_MAGICEFFECTON:
		NotifyMsg_MagicEffectOn(pData);
		break;

	case DEF_NOTIFY_CANNOTITEMTOBANK:
		AddEventList(NOTIFY_MSG_HANDLER63, 10);
		break;

	case DEF_NOTIFY_SERVERCHANGE:
		NotifyMsg_ServerChange(pData);
		break;

	case DEF_NOTIFY_SKILL:
		NotifyMsg_Skill(pData);
		break;

	case DEF_NOTIFY_SETITEMCOUNT:
		NotifyMsg_SetItemCount(pData);
		break;

	case DEF_NOTIFY_ITEMDEPLETED_ERASEITEM:
		NotifyMsg_ItemDepleted_EraseItem(pData);
		break;

	case DEF_NOTIFY_DROPITEMFIN_ERASEITEM:
		NotifyMsg_DropItemFin_EraseItem(pData);
		break;

	case DEF_NOTIFY_GIVEITEMFIN_ERASEITEM:
		NotifyMsg_GiveItemFin_EraseItem(pData);
		break;

	case DEF_NOTIFY_ENEMYKILLREWARD:
		NotifyMsg_EnemyKillReward(pData);
		break;

	case DEF_NOTIFY_PKCAPTURED:
		NotifyMsg_PKcaptured(pData);
		break;

	case DEF_NOTIFY_PKPENALTY:
		NotifyMsg_PKpenalty(pData);
		break;

	case DEF_NOTIFY_ITEMTOBANK:
		NotifyMsg_ItemToBank(pData);
		break;

	case DEF_NOTIFY_TRAVELERLIMITEDLEVEL:
		AddEventList(NOTIFY_MSG_HANDLER64, 10);
		break;

	case DEF_NOTIFY_LIMITEDLEVEL:
		AddEventList(NOTIFYMSG_LIMITED_LEVEL1, 10);
		break;

	case DEF_NOTIFY_ITEMLIFESPANEND:
		NotifyMsg_ItemLifeSpanEnd(pData);
		break;

	case DEF_NOTIFY_ITEMRELEASED:
		NotifyMsg_ItemReleased(pData);
		break;

	case DEF_NOTIFY_ITEMOBTAINED:
		NotifyMsg_ItemObtained(pData);
		break;

	case DEF_NOTIFY_ITEMPURCHASED:
		NotifyMsg_ItemPurchased(pData);
		break;

	case DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION:
		NotifyMsg_QueryJoinGuildPermission(pData);
		break;

	case DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
		NotifyMsg_QueryDismissGuildPermission(pData);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		NotifyMsg_JoinGuildApprove(pData);
		break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:
		NotifyMsg_JoinGuildReject(pData);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
		NotifyMsg_DismissGuildApprove(pData);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		NotifyMsg_DismissGuildReject(pData);
		break;

	case DEF_NOTIFY_CANNOTCARRYMOREITEM:
		AddEventList(NOTIFY_MSG_HANDLER65, 10);//"
		AddEventList(NOTIFY_MSG_HANDLER66, 10);//"
		// Bank dialog Box
		m_stDialogBoxInfo[14].cMode = 0;
		break;

	case DEF_NOTIFY_NOTENOUGHGOLD:
		DisableDialogBox(23);
		AddEventList(NOTIFY_MSG_HANDLER67, 10);//"Gold
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		if (*cp >= 0) {
			m_bIsItemDisabled[*cp] = FALSE;
		}
		break;

	case DEF_NOTIFY_HP:
		NotifyMsg_HP(pData);
		break;
	case DEF_NOTIFY_MP:
		NotifyMsg_MP(pData);
		break;
	case DEF_NOTIFY_SP:
		NotifyMsg_SP(pData);
		break;
	case DEF_NOTIFY_KILLED:
		NotifyMsg_Killed(pData);
		break;
	case DEF_NOTIFY_EXP:
		NotifyMsg_Exp(pData);
		break;
	case DEF_NOTIFY_GUILDDISBANDED:
		NotifyMsg_GuildDisbanded(pData);
		break;
	case DEF_NOTIFY_CANNOTJOINMOREGUILDSMAN:
		NotifyMsg_CannotJoinMoreGuildsMan(pData);
		break;
	case DEF_NOTIFY_NEWGUILDSMAN:
		NotifyMsg_NewGuildsMan(pData);
		break;
	case DEF_NOTIFY_DISMISSGUILDSMAN:
		NotifyMsg_DismissGuildsMan(pData);
		break;
	case DEF_NOTIFY_MAGICSTUDYSUCCESS:
		NotifyMsg_MagicStudySuccess(pData);
		break;
	case DEF_NOTIFY_MAGICSTUDYFAIL:
		NotifyMsg_MagicStudyFail(pData);
		break;
	case DEF_NOTIFY_SKILLTRAINSUCCESS:
		NotifyMsg_SkillTrainSuccess(pData);
		break;
	case DEF_NOTIFY_SKILLTRAINFAIL:
		break;
	case DEF_NOTIFY_FORCEDISCONN:
		NotifyMsg_ForceDisconn(pData);
		break;
	case DEF_NOTIFY_FIGHTZONERESERVE:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		switch (*ip) {
		case -5:
			AddEventList(NOTIFY_MSG_HANDLER68, 10);
			break;
		case -4:
			AddEventList(NOTIFY_MSG_HANDLER69, 10);
			break;
		case -3:
			AddEventList(NOTIFY_MSG_HANDLER70, 10);
			break;
		case -2:
			m_iFightzoneNumber = 0;
			AddEventList(NOTIFY_MSG_HANDLER71, 10);
			break;
		case -1:
			m_iFightzoneNumber = m_iFightzoneNumber * -1 ;
			AddEventList(NOTIFY_MSG_HANDLER72, 10);
			break;
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
			wsprintf(cTxt, NOTIFY_MSG_HANDLER73, *ip);//"
			AddEventList(cTxt, 10);
			break;
		}
		break;
	}
}

void CGame::ReserveFightzoneResponseHandler(char * pData)
{
 	WORD * wpResult;
	char * cp ;
	int * ip ;
 	wpResult = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	switch (*wpResult) {
	case DEF_MSGTYPE_CONFIRM:
		AddEventList(RESERVE_FIGHTZONE_RESPONSE_HANDLER1, 10);
		m_stDialogBoxInfo[7].cMode = 14;
		m_iFightzoneNumber = m_iFightzoneNumberTemp ;
		break;

	case DEF_MSGTYPE_REJECT:
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ip   = (int *)cp;
		cp += 4;
		AddEventList(RESERVE_FIGHTZONE_RESPONSE_HANDLER2, 10);
		m_iFightzoneNumberTemp = 0 ;

		if (*ip == 0) {
		 	m_stDialogBoxInfo[7].cMode = 15;
		}else if (*ip == -1){
			m_stDialogBoxInfo[7].cMode = 16;
		} else if (*ip == -2) {
			m_stDialogBoxInfo[7].cMode = 17;
		}else if (*ip == -3) {
			m_stDialogBoxInfo[7].cMode = 21;
		}else if (*ip == -4) {
			m_stDialogBoxInfo[7].cMode = 22;
		}
		break;
	}
}

void CGame::UpdateScreen_OnLogResMsg()
{
 short msX, msY, msZ, sX, sY;
 char  cLB, cRB;
 DWORD dwTime = timeGetTime();
 static DWORD dwCTime;
 static class CMouseInterface * pMI;
 int   iMIbuttonNum;
 char  cMIresult;


	if (m_cGameModeCount == 0)
	{	pMI = new class CMouseInterface;
		pMI->AddRect(370, 240, 370 + DEF_BTNSZX, 240 + DEF_BTNSZY);
		m_bEnterPressed = FALSE;
		m_bEscPressed   = FALSE;
		m_cArrowPressed = 0;
		dwCTime = timeGetTime();
		if (m_bSoundFlag) m_pESound[38]->bStop();
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if (m_bEscPressed == TRUE || m_bEnterPressed) {
		switch (m_cMsg[0]) {
		case '0':
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
			break;
		case '1':
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			break;
		case '2':
			ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
			break;
		case '3':
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			break;
		case '4':
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			break;
		case '5':
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			break;
		case '6':
			switch (m_cMsg[1]) {
			case 'B':
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				break;
			case 'C': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
			case 'M': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
			}
			break;
		case '7':
		case '8':
			ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
			break;
		}

		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);

	m_DDraw.ClearBackB4();

	switch (m_cMsg[0]) {
	case '0':
	case '5':
		_Draw_UpdateScreen_OnCreateNewAccount();
		break;

	case '1':
	case '7':
		sX = 146;
		sY = 114;

		_Draw_OnLogin(m_cAccountName, m_cAccountPassword, 0, 0);
		break;

	case '2':
	case '4':
		_bDraw_OnCreateNewCharacter(m_cPlayerName, 0, 0, 0);
		break;

	case '3':
		sX = 0;
		sY = 0;
		UpdateScreen_OnSelectCharacter(sX, sY, 0, 0);
		break;

	case '6':
		sX = 146;
		sY = 114;

		UpdateScreen_OnSelectCharacter(0, 0, 0, 0, TRUE);
		break;
	case '8':
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_MAINMENU, -1, -1, 0, TRUE);
		break;
	}

	m_DDraw.DrawShadowBox(0,0,639,479);

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);

	if ((msX >= 370) && (msX <= 370 + DEF_BTNSZX) && (msY >= 244) && (msY <= 244 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370, 244, 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, 370, 244, 0);

	switch (m_cMsg[1]) {
	case '1':
		PutString_SprFont(172 + 70, 165, "Password is not correct!", 7,0,0);
		PutAlignedString(198, 453, 195, UPDATE_SCREEN_ON_LOG_MSG5);//"
		break;

	case '2':
		PutString_SprFont(172 + 70, 165, "Not existing account!", 7,0,0);
		PutAlignedString(198, 453, 195, UPDATE_SCREEN_ON_LOG_MSG6);//"
		PutAlignedString(198, 453, 215, UPDATE_SCREEN_ON_LOG_MSG7);//"
		break;

	case '3':
		PutString_SprFont(172 + 10 +34, 165, "Can not connect to game server!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG8);//"
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG9);//"
		PutAlignedString(198, 453, 225,  UPDATE_SCREEN_ON_LOG_MSG10);//"
		break;

	case '4':
		PutString_SprFont(172 + 58, 165, "New account created.", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG11);//"
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG12);//"
		break;

	case '5':
		PutString_SprFont(172 + 58, 165, "Can not create new account!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG13);//"
		break;

	case '6':
		PutString_SprFont(172 + 36, 165, "Can not create new account!", 7,0,0);
		PutString_SprFont(172 + 24, 180, "Already existing account name.", 7,0,0);
		PutAlignedString(198, 453, 205,  UPDATE_SCREEN_ON_LOG_MSG14);//"
		PutAlignedString(198, 453, 220,  UPDATE_SCREEN_ON_LOG_MSG15);//"
		break;

	case '7':
		PutString_SprFont(172 + 58, 165, "New character created.", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG16);//"
		break;

	case '8':
		PutString_SprFont(172 + 58, 165, "Can not create new character!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG17);//"
		break;

	case '9':
		PutString_SprFont(172 + 36, 165, "Can not create new character!", 7,0,0);
		PutString_SprFont(172 + 24, 180, "Already existing character name.", 7,0,0);
		PutAlignedString(198, 453, 205,  UPDATE_SCREEN_ON_LOG_MSG18);//"
		PutAlignedString(198, 453, 220,  UPDATE_SCREEN_ON_LOG_MSG19);//"
		break;

	case 'A':
		PutString_SprFont(172 + 36 +45, 165, "Character deleted.", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG20);//"

		break;
	case 'B':
		PutString_SprFont(172 + 36 +45, 165, "Password changed.", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG21);//"
		break;
	case 'C':
		PutString_SprFont(172 + 36, 165, "Can not change password!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG22);//"
		break;

	case 'D':
		PutString_SprFont(172 + 10 +34, 165, "Can not connect to game server!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG23);//"
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG24);//"
		break;

	case 'E':
		PutString_SprFont(172 + 10 +34, 165, "Can not connect to game server!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG25);//"
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG26);//"
		PutAlignedString(198, 453, 225,  UPDATE_SCREEN_ON_LOG_MSG27);//"
		break;

	case 'F':
		PutString_SprFont(172 + 10 +34, 165, "Can not connect to game server!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG28);//"
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG29);//"
		break;

	case 'G':
		PutString_SprFont(172 + 10 +34, 165, "Can not connect to game server!", 7,0,0);
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG30);//"
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG31);//"
		break;

	case 'H':
		PutString_SprFont(172 + 68, 165, "Connection Rejected!", 7,0,0);
		if (m_iBlockYear == 0) {
			PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG32);//"
			PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG33);//"
		}
		else {
			PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG34);//"
			wsprintf(G_cTxt, UPDATE_SCREEN_ON_LOG_MSG35, m_iBlockYear, m_iBlockMonth, m_iBlockDay);//"
			PutAlignedString(198, 453, 210,  G_cTxt);
		}
		break;

	case 'I': //
		PutString_SprFont(172 + 68, 165, "Not Enough Point!", 7,0,0);
		PutAlignedString(198, 453, 210,  "ÂI¼Æ¨Ï¥Î´Á­­¤wµ²§ô, ½Ð¦ÜGD2S.gamania.com©µªø¨Ï¥Î´Á­­");

		break;

	case 'J': // v2.15 2002-5-21
		PutString_SprFont(172 + 68, 165, "World Server Full", 7,0,0);
		PutAlignedString(198, 453, 210,  "Please ! Try Other World Server");
		break;

	case 'M': 	// v2.18
		PutString_SprFont(172 + 68, 165, "Your password expired", 7,0,0);
		PutAlignedString(198, 453, 210,  "Please! Change password");
		break;


	case 'U': // v2.15
		PutString_SprFont(172 + 68, 165, "Keycode input Success!", 7,0,0);
		PutAlignedString(198, 453, 210,  "Keycode Registration successed.");

		break;

	case 'X':
		PutAlignedString(198, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG38);//"
		PutAlignedString(198, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG39);//"
		break;

	case 'Y':
		PutAlignedString(178, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG40);//"
		PutAlignedString(178, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG41);//"
		break;

	case 'Z':
		PutAlignedString(178, 453, 195,  UPDATE_SCREEN_ON_LOG_MSG42);//"
		PutAlignedString(178, 453, 210,  UPDATE_SCREEN_ON_LOG_MSG41);//"
		break;
	}

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK) {
		switch (iMIbuttonNum) {
		case 1:
			switch (m_cMsg[0]) {
			case '0':
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWACCOUNT);
				break;
			case '1':
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				break;
			case '2':
				ChangeGameMode(DEF_GAMEMODE_ONCREATENEWCHARACTER);
				break;
			case '3':
				ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
				break;
			case '4':
				ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
				break;
			case '5':
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				break;
			case '6':
				switch (m_cMsg[1]) {
					case 'B':
						ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
						break;
					case 'C': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
					case 'M': ChangeGameMode(DEF_GAMEMODE_ONCHANGEPASSWORD); break;
				}
				break;
			case '7':
			case '8':
				ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
				break;
			}
			delete pMI;
			return;
		}
	}

	if ((dwTime - dwCTime) > 100)
	{	m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{	m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{	m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;
	DrawVersion();
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::RetrieveItemHandler(char *pData)
{char * cp, cBankItemIndex, cItemIndex, cTxt[120];
 WORD * wp;
 int j;
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	if (*wp != DEF_MSGTYPE_REJECT)
	{	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		cBankItemIndex = *cp;
		cp++;
		cItemIndex = *cp;
		cp++;

		if (m_pBankList[cBankItemIndex] != NULL) {
			// v1.42
			char cStr1[64], cStr2[64], cStr3[64];
			GetItemName(m_pBankList[cBankItemIndex], cStr1, cStr2, cStr3);

			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, RETIEVE_ITEM_HANDLER4, cStr1);//""You took out %s."
			AddEventList(cTxt, 10);

			if ( (m_pBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				 (m_pBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) )
			{	if (m_pItemList[cItemIndex]	== NULL) goto RIH_STEP2;
				delete m_pBankList[cBankItemIndex];
				m_pBankList[cBankItemIndex] = NULL;
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++)
				{	if ((m_pBankList[j+1] != NULL) && (m_pBankList[j] == NULL))
					{	m_pBankList[j] = m_pBankList[j+1];
						m_pBankList[j+1] = NULL;
				}	}
			}else
			{
RIH_STEP2:;
				if (m_pItemList[cItemIndex] != NULL) return;
				short nX, nY;
				nX = 40;
				nY = 30;
				for (j = 0; j < DEF_MAXITEMS; j++)
				{	if ( ( m_pItemList[j] != NULL) && (memcmp(m_pItemList[j]->m_cName, cStr1, 20) == 0))
					{	nX = m_pItemList[j]->m_sX+1;
						nY = m_pItemList[j]->m_sY+1;
						break;
				}	}
				m_pItemList[cItemIndex] = m_pBankList[cBankItemIndex];
				m_pItemList[cItemIndex]->m_sX =	nX;
				m_pItemList[cItemIndex]->m_sY =	nY;
                bSendCommand(MSGID_REQUEST_SETITEMPOS, NULL, cItemIndex, nX, nY, NULL, NULL);

				for (j = 0; j < DEF_MAXITEMS; j++)
				if (m_cItemOrder[j] == -1)
				{	m_cItemOrder[j] = cItemIndex;
					break;
				}
				m_bIsItemEquipped[cItemIndex] = FALSE;
				m_bIsItemDisabled[cItemIndex] = FALSE;
				m_pBankList[cBankItemIndex] = NULL;
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++)
				{	if ((m_pBankList[j+1] != NULL) && (m_pBankList[j] == NULL))
					{	m_pBankList[j] = m_pBankList[j+1];
						m_pBankList[j+1] = NULL;
	}	}	}	}	}
	m_stDialogBoxInfo[14].cMode = 0;
}

void CGame::EraseItem(char cItemID)
{int i;
 char cStr1[64], cStr2[64], cStr3[64];
	ZeroMemory(cStr1, sizeof(cStr1));
	ZeroMemory(cStr2, sizeof(cStr2));
	ZeroMemory(cStr3, sizeof(cStr3));
	for( i=0 ; i<6 ; i++ )
	{	if (m_sShortCut[i] == cItemID)
		{	GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
			if( i < 3 ) wsprintf(G_cTxt, ERASE_ITEM, cStr1, cStr2, cStr3, i+1);
			else wsprintf(G_cTxt, ERASE_ITEM, cStr1, cStr2, cStr3, i+7);
			AddEventList(G_cTxt, 10);
			m_sShortCut[i] = -1;
	}	}

	if (cItemID == m_sRecentShortCut)
		m_sRecentShortCut = -1;
	// ItemOrder
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_cItemOrder[i] == cItemID)
			m_cItemOrder[i] = -1;
	for (i = 1; i < DEF_MAXITEMS; i++)
	if ((m_cItemOrder[i-1] == -1) && (m_cItemOrder[i] != -1))
	{	m_cItemOrder[i-1] = m_cItemOrder[i];
		m_cItemOrder[i]   = -1;
	}
	// ItemList
	delete m_pItemList[cItemID];
	m_pItemList[cItemID] = NULL;
	m_bIsItemEquipped[cItemID] = FALSE;
	m_bIsItemDisabled[cItemID] = FALSE;
}

void CGame::DlbBoxDoubleClick_Character(short msX, short msY)
{
	char cEquipPoiStatus[DEF_MAXITEMEQUIPPOS], cItemID = -1;
	short sX, sY, sSprH, sFrame;
	int i;
	if (m_bIsDialogEnabled[17] == TRUE) return;
	sX = m_stDialogBoxInfo[1].sX;
	sY = m_stDialogBoxInfo[1].sY;

	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
		cEquipPoiStatus[i] = -1;

	for (i = 0; i < DEF_MAXITEMS; i++) {
		if ((m_pItemList[i] != NULL) && (m_bIsItemEquipped[i] == TRUE))	cEquipPoiStatus[ m_pItemList[i]->m_cEquipPos ] = i;
	}
	if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3))
	{
		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison( sX + 41, sY + 137, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BACK];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_PANTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_ARMS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BOOTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BODY];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 90, sY + 170, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_LHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_RHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_NECK];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_RFINGER];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 98, sY + 182, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_LFINGER];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1) {
			sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 72, sY + 135, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_HEAD];
		}
	}
	else if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6)) {
		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 45, sY + 143, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BACK];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BOOTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_PANTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_ARMS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BOOTS];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_BODY];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 84, sY + 175, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_LHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_RHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_NECK];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_RFINGER];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 98, sY + 182, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_LFINGER];
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1) {
			sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 72, sY + 139, sFrame, msX, msY ) )
				cItemID = cEquipPoiStatus[DEF_EQUIPPOS_HEAD];
		}
	}

	if( cItemID == -1 || m_pItemList[cItemID] == NULL ) return;
	if (   (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT) 
		|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) 
		|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW) 
		|| (m_pItemList[cItemID]->m_dwCount > 1) ) return;
	if ( (m_bIsDialogEnabled[11]==TRUE) && (m_bIsDialogEnabled[23] == FALSE) && (m_stDialogBoxInfo[39].sV3 == 24))
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_REPAIRITEM, NULL, cItemID, m_stDialogBoxInfo[39].sV3, NULL, m_pItemList[cItemID]->m_cName, m_stDialogBoxInfo[39].sV4); // v1.4
	else {
		if (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == TRUE) 
		{	char cStr1[64], cStr2[64], cStr3[64];
			GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);
			ZeroMemory(G_cTxt, sizeof(G_cTxt) );
			wsprintf(G_cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);//"
			AddEventList(G_cTxt, 10);
			if(memcmp(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, "AngelicPendant", 14) == 0) PlaySound('E', 53, 0);
			else PlaySound('E', 29, 0);

			// Remove Angelic Stats
			if (   (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos >= 11)
				&& (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cItemType == 1))
			{	char cItemID = m_stMCursor.sSelectedObjectID;
				if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(STR)", 19) == 0)
				{	m_iAngelicStr = 0; 
				}else if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(DEX)", 19) == 0)
				{	m_iAngelicDex = 0;
				}else if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(INT)", 19) == 0)
				{	m_iAngelicInt = 0;
				}else if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(MAG)", 19) == 0)
				{	m_iAngelicMag = 0;
			}	}
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_RELEASEITEM, NULL, m_stMCursor.sSelectedObjectID, NULL, NULL, NULL);
			m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] = FALSE;
			m_sItemEquipmentStatus[	m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos ] = -1;
			m_stMCursor.cSelectedObjectType	= NULL;
			m_stMCursor.sSelectedObjectID   = NULL;
	}	}
}

void CGame::DlbBoxDoubleClick_GuideMap(short msX, short msY)
{short si = m_stMCursor.sCursorFrame;
	if( si != 0 ) return;
	if( m_cMapIndex < 0 ) return;

	short sX, sY, shX, shY, szX, szY;
	sX = m_stDialogBoxInfo[9].sX;
	sY = m_stDialogBoxInfo[9].sY;
	szX = m_stDialogBoxInfo[9].sSizeX;
	szY = m_stDialogBoxInfo[9].sSizeY;
	if( sX < 20 ) sX = 0;
	if( sY < 20 ) sY = 0;
	if( sX > 640-128-20 ) sX = 640-128;
	if( sY > 427-128-20 ) sY = 427-128;
	if( m_bZoomMap )
	{	shX = m_sPlayerX-64;
		shY = m_sPlayerY-64;
		if( shX < 0 ) shX = 0;
		if( shY < 0 ) shY = 0;
		if( shX > m_pMapData->m_sMapSizeX-128 ) shX = m_pMapData->m_sMapSizeX-128;
		if( shY > m_pMapData->m_sMapSizeY-128 ) shY = m_pMapData->m_sMapSizeY-128;
		shX = shX + msX - sX;
		shY = shY + msY - sY;
	}else
	{	shX = (m_pMapData->m_sMapSizeX*(msX-sX))/128;
		shY = (m_pMapData->m_sMapSizeX*(msY-sY))/128;
	}
	if( shX < 30 || shY < 30 ) return;
	if( shX > m_pMapData->m_sMapSizeX-30 || shY > m_pMapData->m_sMapSizeY-30 ) return;
	if( (m_bRunningMode==TRUE) && (m_iSP>0) )
		m_cCommand = DEF_OBJECTRUN;
	else m_cCommand = DEF_OBJECTMOVE;
	m_sCommX = shX;
	m_sCommY = shY;
	GetPlayerTurn();
}

void CGame::DlbBoxDoubleClick_Inventory(short msX, short msY)
{
 register int i;
 char  cItemID, cTxt[120];
 short sX, sY, x1, x2, y1, y2;
 char cStr1[64], cStr2[64], cStr3[64];
	//if (m_iHP <= 0) return;
	if (m_bItemUsingStatus == TRUE) 
	{	AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY1, 10); // "You can use after using the other item."
		return;
	}
	sX = m_stDialogBoxInfo[2].sX;
	sY = m_stDialogBoxInfo[2].sY;
	for (i = 0; i < DEF_MAXITEMS; i++)
	{	if (m_cItemOrder[DEF_MAXITEMS - 1 - i] == -1) continue;
		cItemID = m_cItemOrder[DEF_MAXITEMS - 1 - i];
		if (m_pItemList[cItemID] == NULL) continue;

		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + 32 + m_pItemList[cItemID]->m_sX, sY + 44 + m_pItemList[cItemID]->m_sY, m_pItemList[cItemID]->m_sSpriteFrame);
		// Order
		x1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
		y1 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
		x2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
		y2 = (short)m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;

		if ((m_bIsItemDisabled[cItemID] == FALSE) && (m_bIsItemEquipped[cItemID] == FALSE) && (msX > x1) && (msX < x2) && (msY > y1) && (msY < y2)) 
		{	// Order
			_SetItemOrder(0, cItemID);
			GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);

			if ( m_bIsDialogEnabled[11] && (m_bIsDialogEnabled[23] == FALSE) && (m_bIsDialogEnabled[23] == FALSE) && (m_stDialogBoxInfo[39].sV3 == 24) )
			{	if (m_pItemList[cItemID]->m_cEquipPos != DEF_EQUIPPOS_NONE)
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_REPAIRITEM, NULL, cItemID, m_stDialogBoxInfo[39].sV3, NULL, m_pItemList[cItemID]->m_cName, m_stDialogBoxInfo[39].sV4); // v1.4
					return;
			}	}
			
			// DblClick Meats if Alchemy in progress
			if (   (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT) )		// 7
			{	if ( m_bIsDialogEnabled[26] == FALSE) // bouffe pas le meat si alchi en cours
				{	if (bCheckItemOperationEnabled(cItemID) == FALSE) return;
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, NULL, cItemID, NULL, NULL, NULL);
					m_bIsItemDisabled[cItemID] = TRUE;
						m_bItemUsingStatus = TRUE;
			}	}
			
			// DblClick scrolls & co
			if (   (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE)	// 3
				|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_PERM)     // 9
				|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW))		// 6				
			{	if (bCheckItemOperationEnabled(cItemID) == FALSE) return;
				if ((timeGetTime() - m_dwDamagedTime) < 10000)
				{	if ((m_pItemList[cItemID]->m_sSprite == 6) && (m_pItemList[cItemID]->m_sSpriteFrame == 9))
					{	wsprintf(G_cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY3, cStr1);//"Item %s: Scrolls cannot be used until 10 seconds after taking damage."
						AddEventList(G_cTxt, 10);
						return;
					}
					if ((m_pItemList[cItemID]->m_sSprite == 6) && (m_pItemList[cItemID]->m_sSpriteFrame == 89))
					{	wsprintf(G_cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY3, cStr1);//"Item %s: Scrolls cannot be used until 10 seconds after taking damage."
						AddEventList(G_cTxt, 10);
						return;
				}	}
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, NULL, cItemID, NULL, NULL, NULL);

				if (   (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE)
					|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT) )
				{	m_bIsItemDisabled[cItemID] = TRUE;
					m_bItemUsingStatus = TRUE;
			}	}

			if ( m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_SKILL )		// 8
			{	if (_bIsItemOnHand() == TRUE)
				{	AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//"Your hands should be free to use this item."
					return;
				}
				if (m_bSkillUsingStatus == TRUE)
				{	AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY5, 10);//"You are already using another skill."
					return;
				}
				if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
				{	AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY6, 10);//"You can't use this item because it is exhausted."
				}else
				{	m_bIsGetPointingMode = TRUE;
					m_iPointCommandType  = cItemID;
					wsprintf(cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY7, cStr1);//"Item %s: Select a position which you want to use."
					AddEventList(cTxt, 10);
			}	}

			if ( m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST )	// 11
			{	if (_bIsItemOnHand() == TRUE)
				{	AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//"Your hands should be free to use this item."
					return;
				}
				if (m_bSkillUsingStatus == TRUE)
				{	AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY13, 10);//"You are already using another skill."
					return;
				}
				if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
				{	AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY6, 10);//"You can't use this item because it is exhausted."
				}else
				{	m_bIsGetPointingMode = TRUE;
					m_iPointCommandType  = cItemID;
					wsprintf(cTxt, BDLBBOX_DOUBLE_CLICK_INVENTORY8, cStr1);//"Item %s: Select an item which you want to use."
					AddEventList(cTxt, 10);
			}	}

			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) // 10
			{	if (_bIsItemOnHand() == TRUE)
				{	AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//"Your hands should be free to use this item."
					return;
				}

				if (m_bSkillUsingStatus == TRUE) {
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY5, 10);//"You are already using another skill."
					return;
				}

				if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
				{	AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY6, 10);//"You can't use this item because it is exhausted."
				}else
				{	switch (m_pItemList[cItemID]->m_sSpriteFrame) {
					case 55: // Alchemy pot
						if (m_cSkillMastery[12] == 0) 
						{	AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY9, 10);//"You should learn alchemy skill to use this item."
						}else 
						{	EnableDialogBox(26, 1, NULL, NULL, NULL);
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY10, 10);//"Using alchemy skill..."
						}
						break;
					case 113: // Smith's Anvil
						if (m_cSkillMastery[13] == 0)
						{	AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY11, 10);//"You should learn manufacturing skill to use this item.."
						}else
						{	EnableDialogBox(26, 3, NULL, NULL, NULL);
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY12, 10);//"Using a manufacturing skill..."
						}
						break;

					// Crafting
					case 0:	
						//if (m_pItemList[i]->m_sSprite == 22) 
						{	EnableDialogBox(26, 7, NULL, NULL, NULL);
							AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY17, 10);	//  "Initiating item Crafting..."
						}
						break;

					case 151:
					case 152:
					case 153:
					case 154:
							EnableDialogBox(40, 1, NULL, NULL, NULL);
						break;
			}	}	}
			// Dblclick Alchemy bowl
			if (( m_bIsDialogEnabled[26] == TRUE) && (m_stDialogBoxInfo[26].cMode == 1))
			{	bItemDrop_SkillDialog();
			}
			// Dblclick Manuf box
			if (( m_bIsDialogEnabled[26] == TRUE) && (m_stDialogBoxInfo[26].cMode == 4))
			{	bItemDrop_SkillDialog();
			}
			// Crafting
			// Dblclick Crafting box
			if (( m_bIsDialogEnabled[26] == TRUE) && (m_stDialogBoxInfo[26].cMode == 7))
			{	bItemDrop_SkillDialog();
			}
			if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EQUIP)
			{	m_stMCursor.cSelectedObjectType = DEF_SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = (short)cItemID;
				bItemDrop_Character();
				m_stMCursor.cSelectedObjectType = NULL;
				m_stMCursor.sSelectedObjectID   = NULL;
			}
			return;
	}	}
}


void CGame::UpdateScreen_OnChangePassword()
{
 short msX, msY, msZ;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI;
 static char  cName[12], cPassword[12], cNewPassword[12], cNewPassConfirm[12], cPrevFocus;
 static DWORD dwCTime;
 DWORD dwTime = timeGetTime();
 BOOL bFlag = TRUE;

	if (m_cGameModeCount == 0) {
		EndInputString();

		pMI = new class CMouseInterface;
		pMI->AddRect(300, 148, 425, 170);
		pMI->AddRect(300, 172, 425, 194);
		pMI->AddRect(300, 196, 425, 218);
		pMI->AddRect(300, 220, 425, 242);

		pMI->AddRect(197, 320, 197 + DEF_BTNSZX, 320 + DEF_BTNSZY);
		pMI->AddRect(370, 320, 370 + DEF_BTNSZX, 320 + DEF_BTNSZY);

		cPrevFocus  = 2; //1
		m_cCurFocus = 2; //1
		m_cMaxFocus = 6;
		m_bEnterPressed = FALSE;
		m_cArrowPressed = 0;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cPassword, sizeof(cPassword));
		ZeroMemory(cNewPassword, sizeof(cNewPassword));
		ZeroMemory(cNewPassConfirm, sizeof(cNewPassConfirm));

		strcpy( cName, m_cAccountName );
		//StartInputString(314, 155, 11, cName);
		StartInputString(314, 179, 11, cPassword);
		ClearInputString();
		dwCTime = dwTime;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 100) m_cGameModeCount = 100;

	if ((dwTime - dwCTime) > 100) {
		m_cMenuFrame++;
		dwCTime = dwTime;
	}
	if (m_cMenuFrame >= 8)
	{	m_cMenuDirCnt++;
		if (m_cMenuDirCnt > 8)
		{	m_cMenuDir++;
			m_cMenuDirCnt = 1;
		}
		m_cMenuFrame = 0;
	}
	if (m_cMenuDir > 8) m_cMenuDir = 1;

	if (m_cArrowPressed != 0)
	{	switch (m_cArrowPressed) {
		case 1:
			m_cCurFocus--;
			if (m_cCurFocus <= 0) m_cCurFocus = m_cMaxFocus;
			break;

		case 2:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;

		case 3:
			m_cCurFocus++;
			if (m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;

		case 4:
			if (m_cCurFocus == 3) m_cCurFocus = 4;
			else if (m_cCurFocus == 4) m_cCurFocus = 3;
			break;
		}
		m_cArrowPressed = 0;
	}

	if (m_bEnterPressed == TRUE)
	{	PlaySound('E', 14, 5);
		switch (m_cCurFocus) {
		case 1:
		case 2:
		case 3:
		case 4:
			m_cCurFocus++;
			if( m_cCurFocus > m_cMaxFocus) m_cCurFocus = 1;
			break;

		case 5:	// Connect
			if ( (m_Misc.bCheckValidString(cPassword) == FALSE) || (strlen(cPassword) == 0) ||
				 (m_Misc.bCheckValidName(cNewPassword) == FALSE) || (m_Misc.bCheckValidName(cNewPassConfirm) == FALSE) ||
				 (strlen(cNewPassword) == 0) || (memcmp(cNewPassword, cNewPassConfirm, 10) != 0) ) break;

			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
			ZeroMemory(m_cNewPassword, sizeof(m_cNewPassword));
			ZeroMemory(m_cNewPassConfirm, sizeof(m_cNewPassConfirm));
			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);
			strcpy(m_cNewPassword, cNewPassword);
			strcpy(m_cNewPassConfirm, cNewPassConfirm);
			m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CHANGEPASSWORD;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "41");
			delete pMI;
			return;

		case 6:	// Cancel
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			//m_dwLoginMode = MSGID_REQUEST_LOGIN;
			delete pMI;
			return;
		}
		m_bEnterPressed = FALSE;
	}

	if (m_bEscPressed == TRUE)
	{	ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		delete pMI;
		m_bEscPressed = FALSE;
		return;
	}

	if (cPrevFocus != m_cCurFocus)
	{	EndInputString();
		switch (m_cCurFocus) {
		case 1:
			StartInputString(314, 155, 11, cName);
			break;
		case 2:
			StartInputString(314, 179, 11, cPassword);
			break;
		case 3:
			StartInputString(314, 203, 11, cNewPassword);
			break;
		case 4:
			StartInputString(314, 227, 11, cNewPassConfirm);
			break;
		}
		cPrevFocus = m_cCurFocus;
	}

	m_DDraw.ClearBackB4();

	UpdateScreen_OnSelectCharacter(0, 0, 0, 0, TRUE);
	m_DDraw.DrawShadowBox(0,0,639,479);//SelectCharacter

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 153, 112, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT , 153, 112, 13);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 153 + 157, 112 + 109, 7);//

	PutString(206, 155, UPDATE_SCREEN_ON_CHANGE_PASSWORD1, RGB(25,35,25));
	PutString(206, 179, UPDATE_SCREEN_ON_CHANGE_PASSWORD2, RGB(25,35,25));
	PutString(206, 203, UPDATE_SCREEN_ON_CHANGE_PASSWORD3, RGB(25,35,25));
	PutString(206, 227, UPDATE_SCREEN_ON_CHANGE_PASSWORD4, RGB(25,35,25));

	if (m_cCurFocus != 1) {
		if (m_Misc.bCheckValidString(cName) != FALSE)
			 PutString(314, 155, cName, RGB(25,35,25));
		else PutString(314, 155, cName, RGB(55,18,13));
	}
	if ((m_Misc.bCheckValidString(cName) == FALSE) || (strlen(cName) == 0)) bFlag = FALSE;

	if (m_cCurFocus != 2) {
		if ((m_Misc.bCheckValidString(cPassword) != FALSE))
			 PutString(314, 179, cPassword, RGB(25,35,25), TRUE, 3);
		else PutString(314, 179, cPassword, RGB(55,18,13), TRUE, 3);
	}

	if (m_cCurFocus != 3) {
		if ((m_Misc.bCheckValidName(cNewPassword) != FALSE))
			 PutString(314, 203, cNewPassword, RGB(25,35,25), TRUE, 3);
		else PutString(314, 203, cNewPassword, RGB(55,18,13), TRUE, 3);
	}

	if (m_cCurFocus != 4) {
		if ((m_Misc.bCheckValidName(cNewPassConfirm) != FALSE))
			 PutString(314, 227, cNewPassConfirm, RGB(25,35,25), TRUE, 3);
		else PutString(314, 227, cNewPassConfirm, RGB(55,18,13), TRUE, 3);
	}

	if ( (m_Misc.bCheckValidString(cPassword) == FALSE) || (strlen(cPassword) == 0) ||
		 (strlen(cNewPassword) < 8) || (memcmp(cNewPassword, cNewPassConfirm, 10) != 0) ||
		 ( memcmp(cPassword, cNewPassword, 10) == 0 ) ) bFlag = FALSE;


	if (m_cCurFocus == 1) ShowReceivedString();
	else if ((m_cCurFocus == 2) || (m_cCurFocus == 3) || (m_cCurFocus == 4)) ShowReceivedString(TRUE);

	PutAlignedString(153, 487, 258, UPDATE_SCREEN_ON_CHANGE_PASSWORD5);//"
	PutAlignedString(153, 487, 273, UPDATE_SCREEN_ON_CHANGE_PASSWORD6);//"
	PutAlignedString(153, 487, 288, UPDATE_SCREEN_ON_CHANGE_PASSWORD7);//"

	if ( (bFlag == TRUE) && (m_cCurFocus == 5) )
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(197, 320, 21, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(197, 320, 20, dwTime);

	if (m_cCurFocus == 6)
		 m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(370, 320, 17, dwTime);
	else m_pSprite[DEF_SPRID_INTERFACE_ND_BUTTON]->PutSpriteFast(370, 320, 16, dwTime);

	DrawVersion();
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if (cMIresult == DEF_MIRESULT_CLICK)
	{	PlaySound('E', 14, 5);

		switch (iMIbuttonNum) {
		case 1:
		case 2:
		case 3:
		case 4:
			m_cCurFocus = iMIbuttonNum;
			break;

		case 5:
			if ( (m_Misc.bCheckValidString(cPassword) == FALSE) || (strlen(cPassword) == 0) ||
				 (m_Misc.bCheckValidName(cNewPassword) == FALSE) || (m_Misc.bCheckValidName(cNewPassConfirm) == FALSE) ||
				 (strlen(cNewPassword) == 0) || (memcmp(cNewPassword, cNewPassConfirm, 10) != 0) ) break;

			EndInputString();
			ZeroMemory(m_cAccountName, sizeof(m_cAccountName));
			ZeroMemory(m_cAccountPassword, sizeof(m_cAccountPassword));
			ZeroMemory(m_cNewPassword, sizeof(m_cNewPassword));
			ZeroMemory(m_cNewPassConfirm, sizeof(m_cNewPassConfirm));
			strcpy(m_cAccountName, cName);
			strcpy(m_cAccountPassword, cPassword);
			strcpy(m_cNewPassword, cNewPassword);
			strcpy(m_cNewPassConfirm, cNewPassConfirm);
						m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
			m_pLSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_USER_LOGSOCKETEVENT);
			m_pLSock->bInitBufferSize(30000);
			ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
			m_dwConnectMode = MSGID_REQUEST_CHANGEPASSWORD;
			ZeroMemory(m_cMsg, sizeof(m_cMsg));
			strcpy(m_cMsg, "41");
			delete pMI;
			return;

		case 6:
			// Cancel
			ChangeGameMode(DEF_GAMEMODE_ONSELECTCHARACTER);
			delete pMI;
			return;
		}
	}

	if ((msX >= 197) && (msX <= 197 + DEF_BTNSZX) && (msY >= 320) && (msY <= 320 + DEF_BTNSZY)) m_cCurFocus = 5;
	if ((msX >= 370) && (msX <= 370 + DEF_BTNSZX) && (msY >= 320) && (msY <= 320 + DEF_BTNSZY)) m_cCurFocus = 6;

	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::DlgBoxClick_SysMenu(short msX, short msY)
{ short sX, sY;
	sX = m_stDialogBoxInfo[19].sX;
	sY = m_stDialogBoxInfo[19].sY;
	if ((msX >= sX + 120) && (msX <= sX + 150) && (msY >= sY + 63) && (msY <= sY + 74))
	{	m_cDetailLevel = 0; // v1.41
		AddEventList( NOTIFY_MSG_DETAIL_LEVEL_LOW, 10 );
		PlaySound('E', 14, 5);
   	}

	if ((msX >= sX + 151) && (msX <= sX + 200) && (msY >= sY + 63) && (msY <= sY + 74))
	{	m_cDetailLevel = 1;
		AddEventList( NOTIFY_MSG_DETAIL_LEVEL_MEDIUM, 10 );
		PlaySound('E', 14, 5);
	}

	if ((msX >= sX + 201) && (msX <= sX + 234) && (msY >= sY + 63) && (msY <= sY + 74))
	{	m_cDetailLevel = 2;
		AddEventList( NOTIFY_MSG_DETAIL_LEVEL_HIGH, 10 );
		PlaySound('E', 14, 5);
	}

	if ((msX >= sX + 24) && (msX <= sX + 115) && (msY >= sY + 81) && (msY <= sY + 100))
	{	if( m_bSoundFlag )
		{	if (m_bSoundStat == TRUE)
			{	m_pESound[38]->bStop();
				m_bSoundStat = FALSE;
				AddEventList( NOTIFY_MSG_SOUND_OFF, 10 );
			}else
			{	m_bSoundStat = TRUE;
				AddEventList( NOTIFY_MSG_SOUND_ON, 10 );
	}	}	}

	if ((msX >= sX + 116) && (msX <= sX + 202) && (msY >= sY + 81) && (msY <= sY + 100))
	{	if( m_bSoundFlag )
		{	if (m_bMusicStat == TRUE) 	// Music Off
			{	m_bMusicStat = FALSE;
				AddEventList( NOTIFY_MSG_MUSIC_OFF, 10 );
				if (m_bSoundFlag)
				{	StopBGM();	// Snoopy: mp3 support
					if (m_pBGM != NULL)
					{	m_pBGM->bStop();
						delete m_pBGM;
						m_pBGM = NULL;
				}	}
			}else // Music On
			{	if (m_bSoundFlag)
				{	m_bMusicStat = TRUE;
					AddEventList( NOTIFY_MSG_MUSIC_ON, 10 );
					StartBGM();
	}	}	}	}


	if ((msX >= sX + 23) && (msX <= sX + 108) && (msY >= sY + 108) && (msY <= sY + 119))
	{	if (m_bWhisper == TRUE)
		{	m_bWhisper = FALSE;
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND7, 10 );
		}else
		{	m_bWhisper = TRUE;
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND6, 10 );
	}	}

	if ((msX >= sX + 123) && (msX <= sX + 203) && (msY >= sY + 108) && (msY <= sY + 119))
	{	if (m_bShout == TRUE)
		{	m_bShout = FALSE;
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND9, 10 );
		}else
		{	m_bShout = TRUE;
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND8, 10 );
	}	}

	//Transparency Change
	if ((msX >= sX + 28) && (msX <= sX + 235) && (msY >= sY + 156) && (msY <= sY + 171)) m_bDialogTrans = !m_bDialogTrans;

	//Guide Map Toggle
	if ((msX >= sX + 28) && (msX <= sX + 127) && (msY >= sY + 178) && (msY <= sY + 193))
	{	if( m_bIsDialogEnabled[9] ) DisableDialogBox(9);
		else EnableDialogBox(9, 0, 0, 0, NULL);
	}

	if (m_bForceDisconn) return;
	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + 225) && (msY <= sY + 225 + DEF_BTNSZY)) 
	{


#ifdef DEF_EQUILIBRIUM_PROJECT // Full par prevents logout
		if( m_cLogOutCount == -1 )	
		{	if (m_bFullParalyze == FALSE)
			{
#ifdef _DEBUG
				m_cLogOutCount = 1;
#else
				m_cLogOutCount = 11;
#endif
			}else // Medusa kiss prevents logout
			{	m_cLogOutCount = -1;
				AddEventList(DLGBOX_CLICK_SYSMENU3, 10);//"Logout impossible while victim of a Medusa's kiss.."
				DisableDialogBox(19);
			}
		}else if( m_cLogOutCount != -1 )
		{	m_cLogOutCount = -1;
			AddEventList(DLGBOX_CLICK_SYSMENU2, 10);//"Logout count stopped."
			DisableDialogBox(19);
		}
		PlaySound('E', 14, 5);
	}
#else
		if( m_cLogOutCount == -1 )	
		{	
#ifdef _DEBUG
			m_cLogOutCount = 1;
#else
			m_cLogOutCount = 11;
#endif

		}else if( m_cLogOutCount != -1 )
		{	m_cLogOutCount = -1;
			AddEventList(DLGBOX_CLICK_SYSMENU2, 10);//"Logout count stopped."
			DisableDialogBox(19);
		}
		PlaySound('E', 14, 5);
	}
#endif


	if ((m_iHP <= 0) && (m_cRestartCount == -1))	
	{	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 225) && (msY <= sY + 225 + DEF_BTNSZY))
		{	m_cRestartCount = 5;
			m_dwRestartCountTime = timeGetTime();
			DisableDialogBox(19);
			wsprintf(G_cTxt, DLGBOX_CLICK_SYSMENU1, m_cRestartCount); // "Restarting game....%d"
			AddEventList(G_cTxt, 10);
			PlaySound('E', 14, 5);
	}	}
}

void CGame::DrawNpcName(short sX, short sY, short sOwnerType, int iStatus)
{	char cTxt[32], cTxt2[64];
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTxt2, sizeof(cTxt2));
	GetNpcName(sOwnerType, cTxt);
	if ((iStatus & 0x20) != 0) strcat(cTxt, DRAW_OBJECT_NAME50);//" Berserk"
	if ((iStatus & 0x40) != 0) strcat(cTxt, DRAW_OBJECT_NAME51);//" Frozen"
	PutString2(sX, sY, cTxt, 255,255,255);
	if (m_bIsObserverMode == TRUE) PutString2(sX, sY+14, cTxt, 50,50,255);
	else if (m_bIsConfusion || (m_iIlusionOwnerH != NULL))
	{	ZeroMemory(cTxt, sizeof(cTxt));
		strcpy(cTxt, DRAW_OBJECT_NAME87);//"(Unknown)"
		PutString2(sX, sY+14, cTxt, 150,150,150); // v2.171
	}else
	{	switch( _iGetFOE(iStatus) ){

#ifdef DEF_EQUILIBRIUM_PROJECT // Mob's Boss
		case -2:
			PutString2(sX, sY+14, "(Enemy Boss)", 210, 0, 255);
			break;
#else
		case -2:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME90, 255, 0, 0); // "(Enemy)"
			break;
#endif

		case -1:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME90, 255, 0, 0); // "(Enemy)"
			break;
		case 0:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME88, 50,50,255); // "Neutral"
			break;
		case 1:
			PutString2(sX, sY+14, DRAW_OBJECT_NAME89, 30,255,30); // "(Friendly)"
			break;
	}	}
#ifdef _DEBUG
	wsprintf(cTxt2,"Status: 0x%.8X ",iStatus);
	PutString2(sX, sY+42, cTxt2, 30,255,30);
	ZeroMemory(cTxt2, sizeof(cTxt2));
#endif

	switch ((iStatus & 0x0F00) >> 8) {
	case 0: break;
	case 1: strcpy(cTxt2, DRAW_OBJECT_NAME52); break;//"Clairvoyant"
	case 2: strcpy(cTxt2, DRAW_OBJECT_NAME53); break;//"Destruction of Magic Protection"
	case 3: strcpy(cTxt2, DRAW_OBJECT_NAME54); break;//"Anti-Physical Damage"
	case 4: strcpy(cTxt2, DRAW_OBJECT_NAME55); break;//"Anti-Magic Damage"
	case 5: strcpy(cTxt2, DRAW_OBJECT_NAME56); break;//"Poisonous"
	case 6: strcpy(cTxt2, DRAW_OBJECT_NAME57); break;//"Critical Poisonous"
	case 7: strcpy(cTxt2, DRAW_OBJECT_NAME58); break;//"Explosive"
	case 8: strcpy(cTxt2, DRAW_OBJECT_NAME59); break;//"Critical Explosive"
	// Snoopy SA
#ifdef DEF_EQUILIBRIUM_PROJECT // Mob's Special Abilities
	case 9:  strcpy(cTxt2, DRAW_OBJECT_NAME46); break;//"Swift"
	case 10: strcpy(cTxt2, DRAW_OBJECT_NAME47); break;//"Mighty"
	case 11: strcpy(cTxt2, DRAW_OBJECT_NAME48); break;//"Shaman"
	case 12: strcpy(cTxt2, DRAW_OBJECT_NAME49); break;//"Crippled"
#endif
	}
	if( m_Misc.bCheckIMEString(cTxt2) ) PutString_SprFont3(sX, sY + 28, cTxt2, m_wR[13]*4, m_wG[13]*4, m_wB[13]*4, FALSE, 2);
	else PutString2(sX, sY + 28, cTxt2, 240,240,70);

}

void CGame::DrawObjectName(short sX, short sY, char * pName, int iStatus)
{	char cTxt[64], cTxt2[64];
	short sR, sG, sB;
	int i, iGuildIndex, iFOE, iAddY=0;
	BOOL bPK, bCitizen, bAresden, bHunter;
	iFOE = _iGetFOE(iStatus);
	if( iFOE < 0 )
	{	sR = 255; sG = 0; sB = 0;
	//{	sR = 250; sG = 250; sB = 250;
	}else if( iFOE == 0 )
	{	sR = 50; sG = 50; sB = 255;
	}else
	{	sR = 30; sG = 200; sB = 30;
	}
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTxt2, sizeof(cTxt2));

	if (m_iIlusionOwnerH == NULL)
	{	if (m_bIsCrusadeMode == FALSE) wsprintf(cTxt, "%s", pName);
		else
		{	if (_tmp_wObjectID >= 10000) strcpy(cTxt, NPC_NAME_MERCENARY); //"Mercenary"
			else
			{	if( iFOE == -1 ) wsprintf(cTxt, "%d", _tmp_wObjectID);
				else strcpy(cTxt, pName);
		}	}
		if (m_iPartyStatus != NULL)
		{	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			{	if (strcmp(m_stPartyMemberNameList[i].cName, pName) == 0)
				{	strcat(cTxt, BGET_NPC_NAME23); // ", Party Member"
					break;
		}	}	}
	}else strcpy(cTxt, "?????");

	if ((iStatus & 0x20) != 0) strcat(cTxt, DRAW_OBJECT_NAME50);//" Berserk"
	if ((iStatus & 0x40) != 0) strcat(cTxt, DRAW_OBJECT_NAME51);//" Frozen"

	PutString2(sX, sY, cTxt, 255,255,255);
	ZeroMemory(cTxt, sizeof(cTxt));

#ifdef DEF_EQUILIBRIUM_PROJECT	// Naming an "Executor"
	// CLEROTH - CRASH BUG ( STATUS )
	if( iStatus & 0x80000000 ) bPK = TRUE;
	else bPK = FALSE;
	if( iStatus & 0x40000000 ) bCitizen = TRUE;
	else bCitizen = FALSE;
	if( iStatus & 0x20000000 ) bAresden = TRUE;
	else bAresden = FALSE;
	if( iStatus & 0x10000000 ) bHunter = TRUE;
	else bHunter = FALSE;
	if( memcmp(m_cPlayerName, pName, 10) == 0 )
	{	if( m_iGuildRank == 0 )
		{	wsprintf( G_cTxt, DEF_MSG_GUILDMASTER, m_cGuildName );//" Guildmaster)"
			PutString2(sX, sY+14, G_cTxt, 180,180,180);
			iAddY = 14;
		}
		if( m_iGuildRank > 0 )
		{	wsprintf( G_cTxt, DEF_MSG_GUILDSMAN, m_cGuildName );//" Guildsman)"
			PutString2(sX, sY+14, G_cTxt, 180,180,180);
			iAddY = 14;
		}
		if( bPK == TRUE )
		{	sR = 255; sG = 0; sB = 0;
		}else
		{	sR = 30; sG = 200; sB = 30;
		}
	}else
	{
#else
	if( memcmp(m_cPlayerName, pName, 10) == 0 )
	{	if( m_iGuildRank == 0 )
		{	wsprintf( G_cTxt, DEF_MSG_GUILDMASTER, m_cGuildName );//" Guildmaster)"
			PutString2(sX, sY+14, G_cTxt, 180,180,180);
			iAddY = 14;
		}
		if( m_iGuildRank > 0 )
		{	wsprintf( G_cTxt, DEF_MSG_GUILDSMAN, m_cGuildName );//" Guildsman)"
			PutString2(sX, sY+14, G_cTxt, 180,180,180);
			iAddY = 14;
		}
		if( m_iPKCount != 0 )
		{	bPK = TRUE;
			sR = 255; sG = 0; sB = 0;
		}else
		{	bPK = FALSE;
			sR = 30; sG = 200; sB = 30;
		}
		bCitizen = m_bCitizen;
		bAresden = m_bAresden;
		bHunter = m_bHunter;
	}else
	{	// CLEROTH - CRASH BUG ( STATUS )
		if( iStatus & 0x80000000 ) bPK = TRUE;
		else bPK = FALSE;
		if( iStatus & 0x40000000 ) bCitizen = TRUE;
		else bCitizen = FALSE;
		if( iStatus & 0x20000000 ) bAresden = TRUE;
		else bAresden = FALSE;
		if( iStatus & 0x10000000 ) bHunter = TRUE;
		else bHunter = FALSE;
#endif

		if( m_bIsCrusadeMode==FALSE || iFOE>=0 )
		{	if( FindGuildName(pName, &iGuildIndex) == TRUE )
			{	if (m_stGuildName[iGuildIndex].cGuildName[0] != NULL)
				{	if( strcmp(m_stGuildName[iGuildIndex].cGuildName, "NONE" )!=0 )
					{	if( m_stGuildName[iGuildIndex].iGuildRank == 0 )
						{	wsprintf( G_cTxt, DEF_MSG_GUILDMASTER, m_stGuildName[iGuildIndex].cGuildName );//
							PutString2(sX, sY+14, G_cTxt, 180,180,180);
							m_stGuildName[iGuildIndex].dwRefTime = m_dwCurTime;
							iAddY = 14;
						}else if( m_stGuildName[iGuildIndex].iGuildRank > 0 )
						{	wsprintf( G_cTxt, DEF_MSG_GUILDSMAN, m_stGuildName[iGuildIndex].cGuildName );//"
							PutString2(sX, sY+14, G_cTxt, 180,180,180);
							m_stGuildName[iGuildIndex].dwRefTime = m_dwCurTime;
							iAddY = 14;
						}
					}else
					{	m_stGuildName[iGuildIndex].dwRefTime = 0;
				}	}
			}else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQGUILDNAME, NULL, _tmp_wObjectID, iGuildIndex, NULL, NULL);
	}	}

#ifdef DEF_EQUILIBRIUM_PROJECT // Naming an "Executor"
	if( bCitizen == FALSE)
	{	if (bHunter == TRUE)
			 strcpy(cTxt, DRAW_OBJECT_NAME60); // "Traveller"
		else strcpy(cTxt, "Executor"); // "Executor"
	}else
	{	if( bAresden )
		{	if( bHunter == TRUE ) strcpy(cTxt, DEF_MSG_ARECIVIL); // "Aresden Civilian"
			else strcpy(cTxt, DEF_MSG_ARESOLDIER); // "Aresden Combatant"
		}else
		{	if( bHunter == TRUE ) strcpy(cTxt, DEF_MSG_ELVCIVIL);// "Elvine Civilian"
			else strcpy(cTxt, DEF_MSG_ELVSOLDIER);	// "Elvine Combatant"
	}	}
	if( bPK == TRUE )
	{	if( bCitizen == FALSE )
		{	if (bHunter == TRUE)
				 strcpy( cTxt, DEF_MSG_PK );	//"Criminal"
			else strcpy(cTxt, "Executor Traitor");
		}else
		{	if( bAresden ) strcpy( cTxt, DEF_MSG_AREPK );// "Aresden Criminal"
			else strcpy( cTxt, DEF_MSG_ELVPK );   // "Elvine Criminal"
	}	}
#else
	if( bCitizen == FALSE )	strcpy(cTxt, DRAW_OBJECT_NAME60);// "Traveller"
	else
	{	if( bAresden )
		{	if( bHunter == TRUE ) strcpy(cTxt, DEF_MSG_ARECIVIL); // "Aresden Civilian"
			else strcpy(cTxt, DEF_MSG_ARESOLDIER); // "Aresden Combatant"
		}else
		{	if( bHunter == TRUE ) strcpy(cTxt, DEF_MSG_ELVCIVIL);// "Elvine Civilian"
			else strcpy(cTxt, DEF_MSG_ELVSOLDIER);	// "Elvine Combatant"
	}	}
	if( bPK == TRUE )
	{	if( bCitizen == FALSE ) strcpy( cTxt, DEF_MSG_PK );	//"Criminal"
		else
		{	if( bAresden ) strcpy( cTxt, DEF_MSG_AREPK );// "Aresden Criminal"
			else strcpy( cTxt, DEF_MSG_ELVPK );  // "Elvine Criminal"
	}	}
#endif

	PutString2(sX, sY+14 +iAddY, cTxt, sR, sG, sB);

#ifdef _DEBUG
	wsprintf(cTxt2,"Status: 0x%.8X ",iStatus);
	PutString2(sX, sY+42, cTxt2, 30,255,30);
	ZeroMemory(cTxt2, sizeof(cTxt2));
#endif
}

BOOL CGame::FindGuildName(char* pName, int* ipIndex)
{
	int i, iRet = 0;
	DWORD dwTmpTime;
	for( i=0 ; i < DEF_MAXGUILDNAMES ; i++ )
	{
		if( memcmp(m_stGuildName[i].cCharName, pName, 10) == 0 )
		{
			m_stGuildName[i].dwRefTime = m_dwCurTime;
			*ipIndex = i;
			return TRUE;
		}
	}
	dwTmpTime = m_stGuildName[0].dwRefTime;
	for( i=0 ; i < DEF_MAXGUILDNAMES ; i++ )
	{
		if( m_stGuildName[i].dwRefTime < dwTmpTime )
		{
			iRet = i;
			dwTmpTime = m_stGuildName[i].dwRefTime;
		}
	}
	ZeroMemory( m_stGuildName[iRet].cGuildName, sizeof(m_stGuildName[iRet].cGuildName) );
	memcpy( m_stGuildName[iRet].cCharName, pName, 10 );
	m_stGuildName[iRet].dwRefTime = m_dwCurTime;
	m_stGuildName[iRet].iGuildRank = -1;
	*ipIndex = iRet;
	return FALSE;
}

void CGame::UpdateScreen_OnVersionNotMatch()
{short msX, msY, msZ;
 char cLB, cRB;
 char cMIresult;
 int  iMIbuttonNum;
 static class CMouseInterface * pMI;
 DWORD dwTime = timeGetTime();
	if (m_cGameModeCount == 0)
	{	if (G_pCalcSocket != NULL)
		{	delete G_pCalcSocket;
			G_pCalcSocket = NULL;
		}
		if (m_pGSock != NULL)
		{	delete m_pGSock;
			m_pGSock = NULL;
		}
		pMI = new class CMouseInterface;
		pMI->AddRect(0,0,640,480);
		m_bEnterPressed = FALSE;
	}
	m_cGameModeCount++;
	if (m_cGameModeCount > 120) m_cGameModeCount = 120;
	m_DDraw.ClearBackB4();
	if (m_bEscPressed == TRUE || m_bEnterPressed == TRUE)
	{	m_bEscPressed = FALSE;
		m_bEnterPressed = FALSE;
		delete pMI;
		ChangeGameMode(DEF_GAMEMODE_NULL);
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
		return;
	}
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_QUIT, 0,0,0, TRUE);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, 162,125,2);
	PutAlignedString(168, 474, 160, UPDATE_SCREEN_ON_VERSION_NO_MATCH1);
	PutAlignedString(168, 474, 180, UPDATE_SCREEN_ON_VERSION_NO_MATCH2);
	PutAlignedString(168, 474, 250, MSG_HOMEPAGE);
	DrawVersion();
	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);

	iMIbuttonNum = pMI->iGetStatus(msX, msY, cLB, &cMIresult);
	if ((cMIresult == DEF_MIRESULT_CLICK) && (iMIbuttonNum == 1))
	{	ChangeGameMode(DEF_GAMEMODE_NULL);
		delete pMI;
		SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
		return;
	}
	if (m_DDraw.iFlip() == DDERR_SURFACELOST) RestoreSprites();
}

void CGame::DrawVersion(BOOL bAuthor)
{DWORD dwTime = timeGetTime();
 WORD  wR, wG, wB;
	m_Misc.ColorTransfer(m_DDraw.m_cPixelFormat, RGB(140, 140, 140), &wR, &wG, &wB);
	// Ver
	m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(14, 463, 19, wR, wG, wB, dwTime);
	// Upper Version
	wsprintf(G_cTxt, "%d", DEF_UPPERVERSION);
	PutString_SprNum(36, 463, G_cTxt, 140, 140, 140);
	// .
	m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(42, 463, 18, wR, wG, wB, dwTime);
	// Lower Version
	wsprintf(G_cTxt, "%d", DEF_LOWERVERSION);
	PutString_SprNum(46, 463, G_cTxt, 140, 140, 140);
	if (bAuthor == FALSE) return;
	// Of course it's easy to remove those lines, but those people deserve some credit
	// at least for releasing their work....
	PutString2(14, 375, "V3.51 compatibility by Cleroth", 220, 200, 200);
	PutString2(14, 390, "V3.51 dialogs by Diuuude", 220, 200, 200);
	PutString2(14, 405, "Effects, mobs, Apocalypse, Heldenian,", 220, 200, 200);
	PutString2(14, 420, "& finalizing by Snoopy81", 220, 200, 200);

}

char CGame::GetOfficialMapName(char * pMapName, char * pName)
{	// MapIndex
	if (strcmp(pMapName, "middleland") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME28);	// Middleland
		return 4;
	}else if (strcmp(pMapName, "huntzone3") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME31);	// Death Valley
		return 0;
	}else if (strcmp(pMapName, "huntzone1") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME29);	// Rocky Highland
		return 1;
	}else if (strcmp(pMapName, "elvuni") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME57);	// Eldiniel Garden
		return 2;
	}else if (strcmp(pMapName, "elvine") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME24);	// Elvine City
		return 3;
	}else if (strcmp(pMapName, "elvfarm") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME2);	// Elvine Farm
		return 5;
	}else if (strcmp(pMapName, "arefarm") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME1);	// Aresden Farm
		return 6;
	}else if (strcmp(pMapName, "default") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME3);	// Beginner Zone
		return 7;
	}else if (strcmp(pMapName, "huntzone4") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME32);	// Silent Wood
		return 8;
	}else if (strcmp(pMapName, "huntzone2") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME30);	// Eternal Field
		return 9;
	}else if (strcmp(pMapName, "areuni") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME56);	// Aresien Garden
		return 10;
	}else if (strcmp(pMapName, "aresden") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME22);	// Aresden City
		return 11;
	}else if (strcmp(pMapName, "dglv2") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME25);	// Dungeon L2
		return 12;
	}else if (strcmp(pMapName, "dglv3") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME26);	// Dungeon L3
		return 13;
	}else if (strcmp(pMapName, "dglv4") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME53);	// Dungeon L4
		return 14;
	}else if (strcmp(pMapName, "elvined1") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME23);	// Elvine Dungeon
		return 15;
	}else if (strcmp(pMapName, "aresdend1") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME21);	// Aresden Dungeon
		return 16;
	}else if (strcmp(pMapName, "bisle") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME27);	// Bleeding Island
		return 17;
	}else if (strcmp(pMapName, "toh1") == 0) {
		strcpy(pName, GET_OFFICIAL_MAP_NAME60);	// Tower of Hell 1
		return 18;
	}else if (strcmp(pMapName, "toh2") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME61);	// Tower of Hell 2
		return 19;
	}else if (strcmp(pMapName, "toh3") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME62);	// Tower of Hell 3
		return 20;
	}else if (strcmp(pMapName, "middled1x") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME58);	// Middleland Mine
		return 21;
	}else if (strcmp(pMapName, "middled1n") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME59);	// Middleland Dungeon
		return 22;
	}else if (strcmp(pMapName, "2ndmiddle") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME65);	// Promiseland
		return 23;
	}else if (strcmp(pMapName, "icebound") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME66);	// Ice Map
		return 24;
	// Snoopy:
	}else if (strcmp(pMapName, "druncncity") == 0) // Snoopy: Apocalypse maps
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME70);
		return 25;
	}else if (strcmp(pMapName, "inferniaA") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME71);
		return 26;
	}else if (strcmp(pMapName, "inferniaB") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME72);
		return 27;
	}else if (strcmp(pMapName, "maze") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME73);
		return 28;
	}else if (strcmp(pMapName, "procella") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME74);
		return 29;
	}else if (strcmp(pMapName, "abaddon") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME75);
		return 30;
	}else if (strcmp(pMapName, "BtField") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME76);
		return 35;
	}else if (strcmp(pMapName, "GodH") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME77);
		return 36;
	}else if (strcmp(pMapName, "HRampart") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME78);
		return 37;
	}else if (strcmp(pMapName, "cityhall_1") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME35);	// Aresden Cityhall
		return -1;
	}else if (strcmp(pMapName, "cityhall_2") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME36);	// Elvine Cityhall
		return -1;
	}else if (strcmp(pMapName, "gldhall_1") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME37);	// Aresden Guildhall
		return -1;
	}else if (strcmp(pMapName, "gldhall_2") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME38);	// Elvine Guildhall
		return -1;
	}else if (memcmp(pMapName, "bsmith_1", 8) == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME33);	// Aresden Blacksmith
		return -1;
	}else if (memcmp(pMapName, "bsmith_2", 8) == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME34);	// Elvine Blacksmith
		return -1;
	}else if (memcmp(pMapName, "gshop_1", 7) == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME39);	// Aresden Shop
		return -1;
	}else if (memcmp(pMapName, "gshop_2", 7) == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME40);	// Elvine Shop
		return -1;
	}else if (memcmp(pMapName, "wrhus_1", 7) == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME43);	// Aresden Warehouse
		return -1;
	}else if (memcmp(pMapName, "wrhus_2", 7) == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME44);	// Elvine Warehouse
		return -1;
#ifdef DEF_EQUILIBRIUM_PROJECT	// Equilibrium WH
	}else if (strcmp(pMapName, "arewrhus") == 0)
	{	strcpy(pName, "Equilibrium Warehouse");	// Aresden Warehouse
		return -1;
	}else if (strcmp(pMapName, "elvwrhus") == 0)
	{	strcpy(pName, "Mayor's Warehouse");	// Elvine Warehouse
		return -1;
#else
	}else if (strcmp(pMapName, "arewrhus") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME45);	// Aresden Warehouse
		return -1;
	}else if (strcmp(pMapName, "elvwrhus") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME46);	// Elvine Warehouse
		return -1;
#endif


	}else if (strcmp(pMapName, "wzdtwr_1") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME41);	// Magic Tower
		return -1;
	}else if (strcmp(pMapName, "wzdtwr_2") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME42);	// Magic Tower
		return -1;
	}else if (strcmp(pMapName, "cath_1") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME47);	// Aresien Church
		return -1;
	}else if (strcmp(pMapName, "cath_2") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME48);	// Eldiniel Church
		return -1;
	}else if (strcmp(pMapName, "resurr1") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME54);	// Revival Zone
		return -1;
	}else if (strcmp(pMapName, "resurr2") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME55);	// Revival Zone
		return -1;
	}else if (strcmp(pMapName, "arebrk11") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME4);	// Aresden Barrack 1
		return -1;
	}else if (strcmp(pMapName, "arebrk12") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME5);	// Aresden Barrack 1
		return -1;
	}else if (strcmp(pMapName, "arebrk21") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME6);	// Aresden Barrack 2
		return -1;
	}else if (strcmp(pMapName, "arebrk22") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME7);	// Aresden Barrack 2
		return -1;
	}else if (strcmp(pMapName, "elvbrk11") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME8);	// Elvine Barrack 1
		return -1;
	}else if (strcmp(pMapName, "elvbrk12") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME9);	// Elvine Barrack 1
		return -1;
	}else if (strcmp(pMapName, "elvbrk21") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME10);	// Elvine Barrack 2
		return -1;
	}else if (strcmp(pMapName, "elvbrk22") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME11);	// Elvine Barrack 2
		return -1;
	}else if (strcmp(pMapName, "fightzone1") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME12);	// Arena 1
		return -1;
	}else if (strcmp(pMapName, "fightzone2") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME13);	// Arena 2
		return -1;
	}else if (strcmp(pMapName, "fightzone3") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME14);	// Arena 3
		return -1;
	}else if (strcmp(pMapName, "fightzone4") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME15);	// Arena 4
		return -1;
	}else if (strcmp(pMapName, "fightzone5") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME16);	// Arena 5
		return -1;
	}else if (strcmp(pMapName, "fightzone6") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME17);	// Arena 6
		return -1;
	}else if (strcmp(pMapName, "fightzone7") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME18);	// Arena 7
		return -1;
	}else if (strcmp(pMapName, "fightzone8") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME19);	// Arena 8
		return -1;
	}else if (strcmp(pMapName, "fightzone9") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME20);	// Arena 9
		return -1;
	}else if (strcmp(pMapName, "arejail") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME63);	// Aresden Jail
		return -1;
	}else if (strcmp(pMapName, "elvjail") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME64);	// Elvine Jail
		return -1;
	}else if (strcmp(pMapName, "CmdHall_1") == 0) // Snoopy: Commander Halls
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME79);
		return -1;
	}else if (strcmp(pMapName, "CmdHall_2") == 0)
	{	strcpy(pName, GET_OFFICIAL_MAP_NAME79);
		return -1;
	}
#ifdef DEF_EQUILIBRIUM_PROJECT	// Equilibrium map names
	else if (strcmp(pMapName, "catacombs") == 0)
	{	strcpy(pName, "Equilibrium Catacombs");
		return 38;
	}else if (strcmp(pMapName, "qusmarsh") == 0)
	{	strcpy(pName, "Qu's marsh");
		return 39;
	}else if (strcmp(pMapName, "asgarde") == 0)
	{	strcpy(pName, "Mount Asgarde");
		return 40;
	}else if (strcmp(pMapName, "lost") == 0)
	{	strcpy(pName, "Equilibrium City"); // Equilibrium city
		return 41;
	}else if (strcmp(pMapName, "stadium") == 0)
	{	strcpy(pName, "Lost Stadium");
		return 42;
	}else if (strcmp(pMapName, "bsmith_3") == 0) // Equilibrium's stores
	{	strcpy(pName, "Equilibrium Blacksmith");
		return -1;
	}else if (strcmp(pMapName, "gshop_3") == 0)
	{	strcpy(pName, "Equilibrium Shop");
		return -1;
	}else if (strcmp(pMapName, "wrhus_3") == 0)
	{	strcpy(pName, "Equilibrium Warehouse");
		return -1;
	}
#endif
	else
	{	strcpy(pName, pMapName);
		return -1;
	}
}

BOOL CGame::bCheckLocalChatCommand(char * pMsg)
{class  CStrTok * pStrTok = NULL;
 char   * token, cBuff[256], cTxt[120], cName[12], cTemp[120];
 char   seps[] = " \t\n";
	ZeroMemory(cBuff, sizeof(cBuff));
	ZeroMemory(cName, sizeof(cName));
	strcpy(cBuff, pMsg);
	if (memcmp(cBuff, "/showframe", 10)==0)
	{	if(m_bShowFPS) m_bShowFPS = FALSE;
		else m_bShowFPS = TRUE;
		return TRUE;
	}
	if (memcmp(cBuff, "/enabletogglescreen", 19)==0)
	{	m_bToggleScreen = TRUE;
		return TRUE;
	}
	if (memcmp(cBuff, "/debug", 6)==0)
	{	/*wsprintf(G_cTxt,"Debug MP3: %d  wMain: %d"
				, (int) Mp3Debug()
				, (int) G_hWnd);
				DebugLog(G_cTxt);*/
		return TRUE;
	}
	if (memcmp(cBuff, "/whon", 5) == 0)
	{	m_bWhisper = TRUE;
	    AddEventList(BCHECK_LOCAL_CHAT_COMMAND6, 10);// Enable to listen to whispers."
		return TRUE;
	}else if (memcmp(cBuff, "/whoff", 6) == 0)
	{	m_bWhisper = FALSE;
	    AddEventList(BCHECK_LOCAL_CHAT_COMMAND7, 10);//
		return TRUE;
	}else if (memcmp(cBuff, "/shon", 5) == 0)
	{	m_bShout = TRUE;
	    AddEventList(BCHECK_LOCAL_CHAT_COMMAND8, 10); //Enalbe to chat in public."
		return TRUE;
	}else if (memcmp(cBuff, "/shoff", 6) == 0)
	{	m_bShout = FALSE;
	    AddEventList(BCHECK_LOCAL_CHAT_COMMAND9, 10); //Unable to chat in public."
		return TRUE;
	}
	if (memcmp(cBuff, "/tooff", 6) == 0)
	{	pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != NULL)
		{	if (strlen(token) <= 10)
			{	strcpy(cName, token);
				if (memcmp(m_cPlayerName, cName, 10) == 0)
				{	AddEventList(BCHECK_LOCAL_CHAT_COMMAND2, 10);
					if (pStrTok != NULL) delete pStrTok;
					return TRUE;
				}
				if( m_pExID != NULL ) delete m_pExID;
				wsprintf(cTxt, BCHECK_LOCAL_CHAT_COMMAND3, token);
				AddEventList(cTxt, 10);
				m_pExID = new class CMsg(NULL, token, NULL);
				if (pStrTok != NULL) delete pStrTok;
				return TRUE;
   			}
			else AddEventList(BCHECK_LOCAL_CHAT_COMMAND5, 10);
		}
		if (pStrTok != NULL) delete pStrTok;
		return TRUE;
	}else if (memcmp(cBuff, "/toon", 5) == 0)
	{	pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != NULL)
		{	if (strlen(token) <= 10)
			{	strcpy(cName, token);
				if (m_pExID != NULL)
				{	ZeroMemory(cTemp, sizeof(cTemp));
					strcpy(cTemp, m_pExID->m_pMsg);
					if (memcmp(cTemp, cName, 10) == 0)
					{	wsprintf(cTxt, BCHECK_LOCAL_CHAT_COMMAND1, token);
						AddEventList(cTxt, 10);
						delete m_pExID;
						m_pExID = NULL;
						if (pStrTok != NULL) delete pStrTok;
						return TRUE;
				}	}
   			}else AddEventList(BCHECK_LOCAL_CHAT_COMMAND5, 10);
		}
		if (pStrTok != NULL) delete pStrTok;
		return TRUE;
	}
	if (pStrTok != NULL) delete pStrTok;
	return FALSE;
}

BOOL CGame::bCheckItemOperationEnabled(char cItemID)
{
	if (m_pItemList[cItemID] == NULL) return FALSE;
	if (m_cCommand < 0) return FALSE;
	if (m_bIsTeleportRequested == TRUE) return FALSE;
	if (m_bIsItemDisabled[cItemID] == TRUE) return FALSE;
	if( m_bFullParalyze ) return FALSE;

	if ((m_pItemList[cItemID]->m_sSpriteFrame == 155) && (m_bUsingSlate == TRUE))
	{	if ((m_cMapIndex==35)||(m_cMapIndex==36)||(m_cMapIndex==37))
		{	AddEventList(DEF_MSG_NOTIFY_SLATE_WRONG_MAP, 10); // "You cannot use it right here."
			return FALSE;
		}
		AddEventList(DEF_MSG_NOTIFY_SLATE_ALREADYUSING, 10); // Already Using Another Slate
		return FALSE;
	}

	if ( m_bIsDialogEnabled[17] == TRUE )		// Inventory
	{	AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10); // "Item transaction not finished."
		return FALSE;
	}

	if (m_bIsDialogEnabled[20] == TRUE)			// NpcActionQuery Dialog
	{	AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return FALSE;
	}

	if (m_bIsDialogEnabled[23] == TRUE) 		//ItemSellorRepair Dialog
	{	AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return FALSE;
	}

	if (m_bIsDialogEnabled[26] == TRUE)			//Manufacture Dialog
	{	AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return FALSE;
	}

	if (m_bIsDialogEnabled[27] == TRUE)			//Exchange Dialog
	{	AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return FALSE;
	}

	if (m_bIsDialogEnabled[31] == TRUE) 		//Sell List Dialog
	{	AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return FALSE;
	}

	if (m_bIsDialogEnabled[4] == TRUE) 			// Item drop confirmation
	{	AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return FALSE;
	}

	return TRUE;
}

void CGame::ClearSkillUsingStatus()
{
	if (m_bSkillUsingStatus == TRUE)
	{	AddEventList(CLEAR_SKILL_USING_STATUS1, 10);//"
		DisableDialogBox(24);
		DisableDialogBox(26);
		if ((m_sPlayerType >= 1) && (m_sPlayerType <= 6)/* && ((m_sPlayerAppr2 & 0xF000) == 0)*/) {
			m_cCommand = DEF_OBJECTSTOP;
			m_sCommX = m_sPlayerX;
			m_sCommY = m_sPlayerY;
		}
	}
	m_bSkillUsingStatus = FALSE;
}


void CGame::NpcTalkHandler(char *pData)
{
 char  * cp, cRewardName[21], cTargetName[21], cTemp[21], cTxt[250];
 short * sp, sType, sResponse;
 int     iAmount, iIndex, iContribution, iX, iY, iRange;
 int     iTargetType, iTargetCount, iQuestionType;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	sp = (short *)cp;
	sType = *sp;
	cp += 2;
	sp = (short *)cp;
	sResponse = *sp;
	cp += 2;
	sp = (short *)cp;
	iAmount = *sp;
	cp += 2;
	sp = (short *)cp;
	iContribution = *sp;
	cp += 2;
	sp = (short *)cp;
	iTargetType = *sp;
	cp += 2;
	sp = (short *)cp;
	iTargetCount = *sp;
	cp += 2;
	sp = (short *)cp;
	iX = *sp;
	cp += 2;
	sp = (short *)cp;
	iY = *sp;
	cp += 2;
	sp = (short *)cp;
	iRange = *sp;
	cp += 2;
	ZeroMemory(cRewardName, sizeof(cRewardName));
	memcpy(cRewardName, cp, 20);
	cp += 20;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	memcpy(cTargetName, cp, 20);
	cp += 20;
	EnableDialogBox(21, sResponse, sType, 0);

	if ((sType >= 1) && (sType <= 100))
	{	iIndex = m_stDialogBoxInfo[21].sV1;
		m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
		iIndex++;
		iQuestionType = NULL;
		switch (sType) {
		case 1: //Monster Hunt
			ZeroMemory(cTemp, sizeof(cTemp));
			GetNpcName(iTargetType, cTemp);
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, NPC_TALK_HANDLER16, iTargetCount, cTemp);
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
			iIndex++;

			ZeroMemory(cTxt, sizeof(cTxt));
			if (memcmp(cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, NPC_TALK_HANDLER17);//"
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
				iIndex++;
			}
			else {
				ZeroMemory(cTemp, sizeof(cTemp));
				GetOfficialMapName(cTargetName, cTemp);
				wsprintf(cTxt, NPC_TALK_HANDLER18, cTemp);//"Map : %s"
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
				iIndex++;

				if (iX != 0) {
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, NPC_TALK_HANDLER19, iX, iY, iRange);//"Position: %d,%d within %d blocks"
					m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
					iIndex++;
				}

				ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt, NPC_TALK_HANDLER20, iContribution);//"
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
				iIndex++;
			}
			iQuestionType = 1;
			break;

		case 7: //
			ZeroMemory(cTxt, sizeof(cTxt));
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, NPC_TALK_HANDLER21, NULL);
			iIndex++;

			ZeroMemory(cTxt, sizeof(cTxt));
			if (memcmp(cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, NPC_TALK_HANDLER22);
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
				iIndex++;
			}
			else {
				ZeroMemory(cTemp, sizeof(cTemp));
				GetOfficialMapName(cTargetName, cTemp);
				wsprintf(cTxt, NPC_TALK_HANDLER23, cTemp);
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
				iIndex++;

				if (iX != 0) {
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, NPC_TALK_HANDLER24, iX, iY, iRange);
					m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
					iIndex++;
				}

				ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt, NPC_TALK_HANDLER25, iContribution);
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
				iIndex++;
			}
			iQuestionType = 1;
			break;

		case 10: // Crusade
			ZeroMemory(cTxt, sizeof(cTxt));
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, NPC_TALK_HANDLER26, NULL);
			iIndex++;

			ZeroMemory(cTxt, sizeof(cTxt));
            strcpy(cTxt, NPC_TALK_HANDLER27);//"
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
			iIndex++;

			ZeroMemory(cTxt, sizeof(cTxt));
            strcpy(cTxt, NPC_TALK_HANDLER28);//"
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
			iIndex++;

			ZeroMemory(cTxt, sizeof(cTxt));
            strcpy(cTxt, NPC_TALK_HANDLER29);//"
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
			iIndex++;

			ZeroMemory(cTxt, sizeof(cTxt));
            strcpy(cTxt, NPC_TALK_HANDLER30);//"
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
			iIndex++;

			ZeroMemory(cTxt, sizeof(cTxt));
			strcpy(cTxt, " ");
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
			iIndex++;

			ZeroMemory(cTxt, sizeof(cTxt));
			if (memcmp(cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, NPC_TALK_HANDLER31);//"
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
				iIndex++;
			}
			else {
				ZeroMemory(cTemp, sizeof(cTemp));
				GetOfficialMapName(cTargetName, cTemp);
				wsprintf(cTxt, NPC_TALK_HANDLER32, cTemp);//"
				m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
				iIndex++;
			}
			iQuestionType = 2;
			break;
		}

		switch (iQuestionType) {
		case 1:
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, NPC_TALK_HANDLER33, NULL);//"
			iIndex++;
			m_pMsgTextList2[iIndex]  = new class CMsg(NULL, NPC_TALK_HANDLER34, NULL);//"
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
			iIndex++;
			break;

		case 2:
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, NPC_TALK_HANDLER35, NULL);//"
			iIndex++;
			m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
			iIndex++;
			break;

		default: break;
		}
	}
}

void CGame::GetNpcName(short sType, char *pName)
{
	switch (sType)
	{
	case 10: strcpy(pName, NPC_NAME_SLIME); break;
	case 11: strcpy(pName, NPC_NAME_SKELETON); break;
	case 12: strcpy(pName, NPC_NAME_STONEGOLEM); break;
	case 13: strcpy(pName, NPC_NAME_CYCLOPS); break;
	case 14: strcpy(pName, NPC_NAME_ORC); break;
	case 15: strcpy(pName, NPC_NAME_SHOP_KEEPER); break;
	case 16: strcpy(pName, NPC_NAME_GIANTANT); break;
	case 17: strcpy(pName, NPC_NAME_GIANTSCORPION); break;
	case 18: strcpy(pName, NPC_NAME_ZOMBIE); break;
	case 19: strcpy(pName, NPC_NAME_MAGICIAN); break;
	case 20: strcpy(pName, NPC_NAME_WAREHOUSE_KEEPER); break;
	case 21: strcpy(pName, NPC_NAME_GUARD); break;
	case 22: strcpy(pName, NPC_NAME_SNAKE); break;
	case 23: strcpy(pName, NPC_NAME_CLAYGOLEM); break;
	case 24: strcpy(pName, NPC_NAME_BLACKSMITH_KEEPER); break;
	case 25: strcpy(pName, NPC_NAME_CITYHALL_OFFICER); break;
	case 26: strcpy(pName, NPC_NAME_GUILDHALL_OFFICER); break;
	case 27: strcpy(pName, NPC_NAME_HELHOUND); break;
	case 28: strcpy(pName, NPC_NAME_TROLL); break;
	case 29: strcpy(pName, NPC_NAME_OGRE); break;
	case 30: strcpy(pName, NPC_NAME_LICHE); break;
	case 31: strcpy(pName, NPC_NAME_DEMON); break;
	case 32: strcpy(pName, NPC_NAME_UNICORN); break;
	case 33: strcpy(pName, NPC_NAME_WEREWOLF); break;
	case 34: strcpy(pName, NPC_NAME_DUMMY); break;
	case 35: strcpy(pName, NPC_NAME_ENERGYSPHERE); break;
	case 36:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_ARROWGUARDTOWER_CK);
		else strcpy(pName, NPC_NAME_ARROWGUARDTOWER);
		break;
	case 37:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_CANNONGUARDTOWER_CK);
		else strcpy(pName, NPC_NAME_CANNONGUARDTOWER);
		break;
	case 38:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_MANACOLLECTOR_CK);
		else strcpy(pName, NPC_NAME_MANACOLLECTOR);
		break;
	case 39:
		if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_DETECTOR_CK);
		else strcpy(pName, NPC_NAME_DETECTOR);
		break;
	case 40: strcpy(pName, NPC_NAME_ENERGYSHIELD); break;
	case 41: strcpy(pName, NPC_NAME_GRANDMAGICGENERATOR); break;
	case 42: strcpy(pName, NPC_NAME_MANASTONE); break;
	case 43: strcpy(pName, NPC_NAME_LIGHTWARBEETLE); break;
	case 44: strcpy(pName, NPC_NAME_GODSHANDKNIGHT); break;
	case 45: strcpy(pName, NPC_NAME_GODSHANDKNIGHT_CK); break;
	case 46: strcpy(pName, NPC_NAME_TEMPLEKNIGHT); break;
	case 47: strcpy(pName, NPC_NAME_BATTLEGOLEM); break;
	case 48: strcpy(pName, NPC_NAME_STALKER); break;
	case 49: strcpy(pName, NPC_NAME_HELLCLAW); break;
	case 50: strcpy(pName, NPC_NAME_TIGERWORM); break;
	case 51: strcpy(pName, NPC_NAME_CATAPULT); break;
	case 52: strcpy(pName, NPC_NAME_GARGOYLE); break;
	case 53: strcpy(pName, NPC_NAME_BEHOLDER); break;
	case 54: strcpy(pName, NPC_NAME_DARKELF); break;
	case 55: strcpy(pName, NPC_NAME_RABBIT); break;
	case 56: strcpy(pName, NPC_NAME_CAT); break;
	case 57: strcpy(pName, NPC_NAME_FROG); break;
	case 58: strcpy(pName, NPC_NAME_MOUNTAIN_GIANT); break;
	case 59: strcpy(pName, NPC_NAME_ETTIN); break;
	case 60: strcpy(pName, NPC_NAME_CANNIBAL); break;
	case 61: strcpy(pName, NPC_NAME_RUDOLPH); break;
	case 62: strcpy(pName, NPC_NAME_DIREBOAR); break;
	case 63: strcpy(pName, NPC_NAME_FROST); break;
	case 64:
		{	switch((_tmp_sAppr2 & 0xFF00)>>8)	{
			case 1:	strcpy(pName, NPC_NAME_WATERMELON);	break;
			case 2: strcpy(pName, NPC_NAME_PUMPKIN); break;
			case 3: strcpy(pName, NPC_NAME_GARLIC); break;
			case 4: strcpy(pName, NPC_NAME_BARLEY); break;
			case 5:	strcpy(pName, NPC_NAME_CARROT); break;
			case 6: strcpy(pName, NPC_NAME_RADISH); break;
			case 7: strcpy(pName, NPC_NAME_CORN); break;
			case 8: strcpy(pName, NPC_NAME_BFLOWER); break;
			case 9: strcpy(pName, NPC_NAME_MELON); break;
			case 10: strcpy(pName, NPC_NAME_TOMATO); break;
			case 11: strcpy(pName, NPC_NAME_GRAPPE); break;
			case 12: strcpy(pName, NPC_NAME_BLUEGRAPPE); break;
			case 13: strcpy(pName, NPC_NAME_MUSHROM); break;
			case 14: strcpy(pName, NPC_NAME_GINSENG); break;
			default: strcpy(pName, NPC_NAME_CROP); break;
			}
		}
		break;
	case 65: strcpy(pName, NPC_NAME_ICEGOLEM); break;
	case 66: strcpy(pName, NPC_NAME_WYVERN); break;
	case 67: strcpy(pName, NPC_NAME_MCGAFFIN); break;
	case 68: strcpy(pName, NPC_NAME_PERRY); break;
	case 69: strcpy(pName, NPC_NAME_DEVLIN); break;

	case 70: strcpy(pName, NPC_NAME_DRAGON); break;
	case 71: strcpy(pName, NPC_NAME_CENTAUR); break;
	case 72: strcpy(pName, NPC_NAME_CLAWTUR); break;
	case 73: strcpy(pName, NPC_NAME_FIREWYV); break;
	case 74: strcpy(pName, NPC_NAME_GICRAYF); break;
	case 75: strcpy(pName, NPC_NAME_GILIZAR); break;
	case 76: strcpy(pName, NPC_NAME_GITREE); break;
	case 77: strcpy(pName, NPC_NAME_MASTORC); break;
	case 78: strcpy(pName, NPC_NAME_MINAUS); break;
	case 79: strcpy(pName, NPC_NAME_NIZIE); break;

	case 80: strcpy(pName, NPC_NAME_TENTOCL); break;
	case 81: strcpy(pName, NPC_NAME_ABADDON); break;
	case 82: strcpy(pName, NPC_NAME_SORCERS); break;
	case 83: strcpy(pName, NPC_NAME_ATK); break;
	case 84: strcpy(pName, NPC_NAME_MASTELF); break;
	case 85: strcpy(pName, NPC_NAME_DSK); break;
	case 86: strcpy(pName, NPC_NAME_HBT); break;
	case 87: strcpy(pName, NPC_NAME_CT); break;
	case 88: strcpy(pName, NPC_NAME_BARBAR); break;
	case 89: strcpy(pName, NPC_NAME_AGC); break;
	case 90: strcpy(pName, NPC_NAME_GAIL); break;
	case 91: strcpy(pName, NPC_NAME_GATE); break;

	// CLEROTH - NEW MONSTERS & Snoopy ... 
	case 95: strcpy(pName, NPC_NAME_WILLOWISP); break;
	case 96: strcpy(pName, NPC_NAME_AIRLEMENTAL); break;
	case 97: strcpy(pName, NPC_NAME_FIRELEMENTAL); break;
	case 98: strcpy(pName, NPC_NAME_EARTHLEMENTAL); break;
	case 99: strcpy(pName, NPC_NAME_ICELEMENTAL); break;
	}
}

void CGame::GetItemName(CItem *pItem, char *pStr1, char *pStr2, char *pStr3)
{int i;
 char cTxt[256], cTxt2[256], cName[51];
 DWORD dwType1, dwType2, dwValue1, dwValue2, dwValue3;

	m_bIsSpecial = FALSE;
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(pStr1, sizeof(pStr1));
	ZeroMemory(pStr2, sizeof(pStr2));
	ZeroMemory(pStr3, sizeof(pStr3));

	strcpy(cName, pItem->m_cName);
	for (i = 0; i < DEF_MAXITEMNAMES; i++)
	if ((m_pItemNameList[i] != NULL) && (strcmp(m_pItemNameList[i]->m_cOriginName, pItem->m_cName) == 0)) 
	{	strcpy(cName, m_pItemNameList[i]->m_cName);
		break;
	}

#ifdef DEF_EQUILIBRIUM_PROJECT
	     if (0 == memcmp(pItem->m_cName,"Eldiniel", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Aresien", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"SwordSB", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Sting-Dart", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Excalibur", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"AresdenFlag", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"ElvineFlag", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"WandMShield", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"WandMS30", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"MagicNecklace", 13)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Neck", 4)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"ClericSymbol", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"RingInfame", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"LuckyGoldRing", 13)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"EmeraldRing", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"SapphireRing", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"aHero", 5)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"eHero", 5)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"ElfCape", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Blood", 5)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Xelima", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Merien", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"IceElemental", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Medusa", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"DemonSlayer", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"DarkElf", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"RingOf", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Zem", 3)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Ice", 3)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Storm", 5)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"DefenderAxe", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"DarkExecutor", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"LightingBlade", 13)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Kloness", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"BerserkWand ", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"ResurWand", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"AcientTablet", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Fire-Bow", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Direction-Bow", 13)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"BlueArmor", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"RedArmor", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"YellowArmor", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"LuckyArmor", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"LicheArmor", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"AbaddonArmor", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Egg9", 4)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"LichMS10", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"RevivalAxe", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Drow", 4)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"OgressArmor", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"LicheRobe", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Pink", 4)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"AirRing", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"EarthRing", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"FireRing", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"IceRing", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"AvatarRelic", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Magic", 5)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"AngelicPandent", 14)) m_bIsSpecial = TRUE;
#else
     	 if (0 == memcmp(pItem->m_cName,"AcientTablet", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"NecklaceOf", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"DarkElfBow", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"DarkExecutor", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"The_Devastator", 14)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"DemonSlayer", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"LightingBlade", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"5thAnniversary", 13)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"RubyRing", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"SapphireRing", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Ringof", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"MagicNecklace", 13)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"MagicWand(M.Shield)", 19)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"MagicWand(MS30-LLF)", 19)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Merien", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"BerserkWand", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"ResurWand", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Blood", 5)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Swordof", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"StoneOf", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"ZemstoneofSacrifice", 19)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"StormBringer", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Aresden", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Elvine", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"EmeraldRing", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Excaliber", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Xelima", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"Kloness", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"aHeroOf", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(pItem->m_cName,"eHeroOf", 7)) m_bIsSpecial = TRUE;
#endif

	if ((pItem->m_dwAttribute & 0x00000001) != 0)
	{	m_bIsSpecial = TRUE;
		strcpy(pStr1, cName);
		if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL)
			wsprintf(pStr2, GET_ITEM_NAME1, pItem->m_sItemSpecEffectValue2);		//"Purity: %d%%"
		else 
		{	// Crafting Magins completion fix
			if (pItem->m_cEquipPos == DEF_EQUIPPOS_LFINGER)
			{	wsprintf(pStr2, GET_ITEM_NAME2, pItem->m_sItemSpecEffectValue2);	//"Completion: 
			}else
			{	wsprintf(pStr2, GET_ITEM_NAME2, pItem->m_sItemSpecEffectValue2 +100);	//"Completion: +100	
		}	}
	}else
	{	if (pItem->m_dwCount == 1)
			wsprintf(G_cTxt, "%s", cName);
		else wsprintf(G_cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM1, pItem->m_dwCount, cName);//"%d %s"
		strcpy(pStr1, G_cTxt);
	}

	if ((pItem->m_dwAttribute & 0x00F0F000) != 0)
	{	m_bIsSpecial = TRUE;
		dwType1  = (pItem->m_dwAttribute & 0x00F00000) >> 20;
		dwValue1 = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		dwType2  = (pItem->m_dwAttribute & 0x0000F000) >> 12;
		dwValue2 = (pItem->m_dwAttribute & 0x00000F00) >> 8;
		if (dwType1 != 0)
		{	ZeroMemory(cTxt, sizeof(cTxt));
			switch (dwType1) {
			case 1: strcpy(cTxt, GET_ITEM_NAME3);   break;
			case 2: strcpy(cTxt, GET_ITEM_NAME4);   break; // "Poisoning "
			case 3: strcpy(cTxt, GET_ITEM_NAME5);   break; // "Righteous "

#ifdef DEF_EQUILIBRIUM_PROJECT
			case 4: strcpy(cTxt, "Wizard's ");		break; // "Wizard's "
#else
			case 4: break;
#endif
			case 5: strcpy(cTxt, GET_ITEM_NAME6);   break; // "Agile "
			case 6: strcpy(cTxt, GET_ITEM_NAME7);   break;
			case 7: strcpy(cTxt, GET_ITEM_NAME8);   break;
			case 8: strcpy(cTxt, GET_ITEM_NAME9);   break;
			case 9: strcpy(cTxt, GET_ITEM_NAME10);  break;
			case 10: strcpy(cTxt, GET_ITEM_NAME11); break;
			case 11: strcpy(cTxt, GET_ITEM_NAME12); break;
			case 12: strcpy(cTxt, GET_ITEM_NAME13); break;
			}
			strcat(cTxt, pStr1);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt);

			ZeroMemory(cTxt, sizeof(cTxt));
			switch (dwType1) {
			case 1: wsprintf(cTxt, GET_ITEM_NAME14, dwValue1); break; // "Critical Hit Damage+%d"
			case 2: wsprintf(cTxt, GET_ITEM_NAME15, dwValue1*5); break; // "Poison Damage+%d"
			case 3: break;

#ifdef DEF_EQUILIBRIUM_PROJECT
			case 4:
				switch (dwValue1) {
				case 1:  wsprintf(cTxt, "Casts Magic Missile"); break;
				case 2:  wsprintf(cTxt, "Casts Energy Bolt"); break;
				case 3:  wsprintf(cTxt, "Casts FireBall"); break;
				case 4:  wsprintf(cTxt, "Casts FireStrike"); break;
				case 5:  wsprintf(cTxt, "Casts Triple Energy Bolt"); break;
				case 6:  wsprintf(cTxt, "Casts Chill Wind"); break;
				case 7:  wsprintf(cTxt, "Casts Ice Strike"); break;
				case 8:  wsprintf(cTxt, "Casts Energy Strike"); break;
				case 9:  wsprintf(cTxt, "Casts Armor Break"); break;
				case 10: wsprintf(cTxt, "Casts EarthWorm Strike"); break;
				case 11: wsprintf(cTxt, "Casts Mass Chill Wind"); break;
				case 12: wsprintf(cTxt, "Casts Mass Fire Strike"); break;
				case 13: wsprintf(cTxt, "Casts Mass Lightning Strike"); break;
				case 14: wsprintf(cTxt, "Casts Mass Ice Strike"); break;
				case 15: wsprintf(cTxt, "Casts Meteor Strike"); break;
				}
				break;
#else
			case 4: break;
#endif

			case 5: strcpy(cTxt, GET_ITEM_NAME16); break; // "Attack Speed -1"
			case 6: wsprintf(cTxt, GET_ITEM_NAME17, dwValue1*4); break;
			case 7: strcpy(cTxt, GET_ITEM_NAME18); break;
			case 8: wsprintf(cTxt, GET_ITEM_NAME19, dwValue1*7); break;
			case 9: strcpy(cTxt, GET_ITEM_NAME20); break;
			case 10: wsprintf(cTxt, GET_ITEM_NAME21, dwValue1*3); break;
			case 11: wsprintf(cTxt, GET_ITEM_NAME22, dwValue1); break;
			case 12: wsprintf(cTxt, GET_ITEM_NAME23, dwValue1); break;
			}
			strcat(pStr2, cTxt);

			if (dwType2 != 0) {
				ZeroMemory(cTxt, sizeof(cTxt));
				switch (dwType2) {
				case 1:  wsprintf(cTxt, GET_ITEM_NAME24, dwValue2*7); break;
				case 2:  wsprintf(cTxt, GET_ITEM_NAME25, dwValue2*7); break;
				case 3:  wsprintf(cTxt, GET_ITEM_NAME26, dwValue2*7); break;
				case 4:  wsprintf(cTxt, GET_ITEM_NAME27, dwValue2*7); break;
				case 5:  wsprintf(cTxt, GET_ITEM_NAME28, dwValue2*7); break;//"SPrec
				case 6:  wsprintf(cTxt, GET_ITEM_NAME29, dwValue2*7); break;//"MPrec
				case 7:  wsprintf(cTxt, GET_ITEM_NAME30, dwValue2*7); break;
				case 8:  wsprintf(cTxt, GET_ITEM_NAME31, dwValue2*3); break;
				case 9:  wsprintf(cTxt, GET_ITEM_NAME32, dwValue2*3); break;
				case 10: wsprintf(cTxt, GET_ITEM_NAME33, dwValue2);   break;
				case 11: wsprintf(cTxt, GET_ITEM_NAME34, dwValue2*10); break;
				case 12: wsprintf(cTxt, GET_ITEM_NAME35, dwValue2*10); break;//"Gold +%
				}
				strcpy(pStr3, cTxt);
	}	}	}

	dwValue3 = (pItem->m_dwAttribute & 0xF0000000) >> 28;
	if (dwValue3 > 0)
	{	if (pStr1[strlen(pStr1)-2] == '+')
		{	dwValue3 = atoi((char *)(pStr1 + strlen(pStr1)-1)) + dwValue3;
			ZeroMemory(cTxt, sizeof(cTxt));
			memcpy(cTxt, pStr1, strlen(pStr1)-2);
			ZeroMemory(cTxt2, sizeof(cTxt2));
			wsprintf(cTxt2, "%s+%d", cTxt, dwValue3);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt2);

#ifdef DEF_EQUILIBRIUM_PROJECT // MS10..MS11..12..13..
		}else if(  (strcmp( pItem->m_cName, "NeckMS10" ) == 0)	
				|| (strcmp( pItem->m_cName, "NeckMS15" ) == 0))
		{	dwValue3 = atoi((char *)(pItem->m_cName + strlen(pItem->m_cName)-1)) + dwValue3;
			ZeroMemory(cTxt, sizeof(cTxt));
			memcpy(cTxt, pStr1, strlen(pStr1)-2);
			ZeroMemory(cTxt2, sizeof(cTxt2));
			wsprintf(cTxt2, "%s%d)", cTxt, dwValue3);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt2);
#endif
		}else
		{	ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "+%d", dwValue3);
			strcat(pStr1, cTxt);
	}	}
}

void CGame::GetItemName(char * cItemName, DWORD dwAttribute, char *pStr1, char *pStr2, char *pStr3)
{
 int i;
 char cTxt[256], cTxt2[256], cName[51];
 DWORD dwType1, dwType2, dwValue1, dwValue2, dwValue3;

 m_bIsSpecial = FALSE;
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(pStr1, sizeof(pStr1));
	ZeroMemory(pStr2, sizeof(pStr2));
	ZeroMemory(pStr3, sizeof(pStr3));

	strcpy(cName, cItemName);
	for (i = 0; i < DEF_MAXITEMNAMES; i++)
	if ((m_pItemNameList[i] != NULL) && (strcmp(m_pItemNameList[i]->m_cOriginName, cItemName) == 0)) {
		strcpy(cName, m_pItemNameList[i]->m_cName);
		break;
	}

#ifdef DEF_EQUILIBRIUM_PROJECT
	     if (0 == memcmp(cItemName,"Eldiniel", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Aresien", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"SwordSB", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Sting-Dart", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Excalibur", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"AresdenFlag", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"ElvineFlag", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"WandMShield", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"WandMS30", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"MagicNecklace", 13)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Neck", 4)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"ClericSymbol", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"RingInfame", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"LuckyGoldRing", 13)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"EmeraldRing", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"SapphireRing", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"aHero", 5)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"eHero", 5)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"ElfCape", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Blood", 5)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Xelima", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Merien", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"IceElemental", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Medusa", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"DarkElf", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"RingOf", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Zem", 3)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Ice", 3)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Storm", 5)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"DefenderAxe", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"DarkExecutor", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"LightingBlade", 13)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Kloness", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"BerserkWand ", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"ResurWand", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"AcientTablet", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Fire-Bow", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Direction-Bow", 13)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"BlueArmor", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"RedArmor", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"YellowArmor", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"LuckyArmor", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"LicheArmor", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"AbaddonArmor", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Egg9", 4)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"LichMS10", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"RevivalAxe", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Drow", 4)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"OgressArmor", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"LicheRobe", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Pink", 4)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"AirRing", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"EarthRing", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"FireRing", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"IceRing", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"AvatarRelic", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Magin", 5)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"AngelicPandent", 14)) m_bIsSpecial = TRUE;
#else
     	 if (0 == memcmp(cItemName,"AcientTablet", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"NecklaceOf", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"DarkElfBow", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"DarkExecutor", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"The_Devastator", 14)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"DemonSlayer", 10)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"LightingBlade", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"5thAnniversary", 13)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"RubyRing", 8)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"SapphireRing", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Ringof", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"MagicNecklace", 13)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"MagicWand(M.Shield)", 19)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"MagicWand(MS30-LLF)", 19)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Merien", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"BerserkWand", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"ResurWand", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Blood", 5)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Swordof", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"StoneOf", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"ZemstoneofSacrifice", 19)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"StormBringer", 12)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Aresden", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Elvine", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"EmeraldRing", 11)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Excaliber", 9)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Xelima", 6)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"Kloness", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"aHeroOf", 7)) m_bIsSpecial = TRUE;
	else if (0 == memcmp(cItemName,"eHeroOf", 7)) m_bIsSpecial = TRUE;
#endif


	strcpy(pStr1, cName);

	if ((dwAttribute & 0x00F0F000) != 0)
	{	m_bIsSpecial = TRUE;
		dwType1  = (dwAttribute & 0x00F00000) >> 20;
		dwValue1 = (dwAttribute & 0x000F0000) >> 16;
		dwType2  = (dwAttribute & 0x0000F000) >> 12;
		dwValue2 = (dwAttribute & 0x00000F00) >> 8;
		if (dwType1 != 0)
		{	ZeroMemory(cTxt, sizeof(cTxt));
			switch (dwType1) {
			case 1: strcpy(cTxt, GET_ITEM_NAME3); break;
			case 2: strcpy(cTxt, GET_ITEM_NAME4); break;
			case 3: strcpy(cTxt, GET_ITEM_NAME5); break;

#ifdef DEF_EQUILIBRIUM_PROJECT 
			case 4: strcpy(cTxt, "Wizard's ");	break; // "Wizard's "
#else
			case 4: break;
#endif

			case 5: strcpy(cTxt, GET_ITEM_NAME6); break;
			case 6: strcpy(cTxt, GET_ITEM_NAME7); break;
			case 7: strcpy(cTxt, GET_ITEM_NAME8); break;
			case 8: strcpy(cTxt, GET_ITEM_NAME9); break;
			case 9: strcpy(cTxt, GET_ITEM_NAME10); break;
			case 10: strcpy(cTxt, GET_ITEM_NAME11); break;
			case 11: strcpy(cTxt, GET_ITEM_NAME12); break;
			case 12: strcpy(cTxt, GET_ITEM_NAME13); break;
			}
			strcat(cTxt, pStr1);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt);

			ZeroMemory(cTxt, sizeof(cTxt));
			switch (dwType1) {
			case 1: wsprintf(cTxt, GET_ITEM_NAME14, dwValue1); break;
			case 2: wsprintf(cTxt, GET_ITEM_NAME15, dwValue1*5); break;
			case 3: break;

#ifdef DEF_EQUILIBRIUM_PROJECT
			case 4:
				switch (dwValue1) {
				case 1:  wsprintf(cTxt, "Casts Magic Missile"); break;
				case 2:  wsprintf(cTxt, "Casts Energy Bolt"); break;
				case 3:  wsprintf(cTxt, "Casts FireBall"); break;
				case 4:  wsprintf(cTxt, "Casts FireStrike"); break;
				case 5:  wsprintf(cTxt, "Casts Triple Energy Bolt"); break;
				case 6:  wsprintf(cTxt, "Casts Chill Wind"); break;
				case 7:  wsprintf(cTxt, "Casts Ice Strike"); break;
				case 8:  wsprintf(cTxt, "Casts Energy Strike"); break;
				case 9:  wsprintf(cTxt, "Casts Armor Break"); break;
				case 10: wsprintf(cTxt, "Casts EarthWorm Strike"); break;
				case 11: wsprintf(cTxt, "Casts Mass Chill Wind"); break;
				case 12: wsprintf(cTxt, "Casts Mass Fire Strike"); break;
				case 13: wsprintf(cTxt, "Casts Mass Lightning Strike"); break;
				case 14: wsprintf(cTxt, "Casts Mass Ice Strike"); break;
				case 15: wsprintf(cTxt, "Casts Meteor Strike"); break;
				}
				break;
#else
			case 4: break;
#endif

			case 5: strcpy(cTxt, GET_ITEM_NAME16); break;
			case 6: wsprintf(cTxt, GET_ITEM_NAME17, dwValue1*4); break;
			case 7: strcpy(cTxt, GET_ITEM_NAME18); break;
			case 8: wsprintf(cTxt, GET_ITEM_NAME19, dwValue1*7); break;
			case 9: strcpy(cTxt, GET_ITEM_NAME20); break;
			case 10: wsprintf(cTxt, GET_ITEM_NAME21, dwValue1*3); break;
			case 11: wsprintf(cTxt, GET_ITEM_NAME22, dwValue1); break;
			case 12: wsprintf(cTxt, GET_ITEM_NAME23, dwValue1); break;
			}
			strcat(pStr2, cTxt);

			if (dwType2 != 0)
			{	ZeroMemory(cTxt, sizeof(cTxt));
				switch (dwType2) {
				case 1:  wsprintf(cTxt, GET_ITEM_NAME24, dwValue2*7);  break;
				case 2:  wsprintf(cTxt, GET_ITEM_NAME25, dwValue2*7);  break;
				case 3:  wsprintf(cTxt, GET_ITEM_NAME26, dwValue2*7);  break;
				case 4:  wsprintf(cTxt, GET_ITEM_NAME27, dwValue2*7);  break;
				case 5:  wsprintf(cTxt, GET_ITEM_NAME28, dwValue2*7);  break;
				case 6:  wsprintf(cTxt, GET_ITEM_NAME29, dwValue2*7);  break;
				case 7:  wsprintf(cTxt, GET_ITEM_NAME30, dwValue2*7);  break;
				case 8:  wsprintf(cTxt, GET_ITEM_NAME31, dwValue2*3);  break;
				case 9:  wsprintf(cTxt, GET_ITEM_NAME32, dwValue2*3);  break;
				case 10: wsprintf(cTxt, GET_ITEM_NAME33, dwValue2);    break;
				case 11: wsprintf(cTxt, GET_ITEM_NAME34, dwValue2*10); break;
				case 12: wsprintf(cTxt, GET_ITEM_NAME35, dwValue2*10); break;
				}
				strcpy(pStr3, cTxt);
	}	}	}

	dwValue3 = (dwAttribute & 0xF0000000) >> 28;
	if (dwValue3 > 0)
	{	if (pStr1[strlen(pStr1)-2] == '+')
		{	dwValue3 = atoi((char *)(pStr1 + strlen(pStr1)-1)) + dwValue3;
			ZeroMemory(cTxt, sizeof(cTxt));
			memcpy(cTxt, pStr1, strlen(pStr1)-2);
			ZeroMemory(cTxt2, sizeof(cTxt2));
			wsprintf(cTxt2, "%s+%d", cTxt, dwValue3);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt2);
		}else 

#ifdef DEF_EQUILIBRIUM_PROJECT  // MS10..MS11..12..13..
		if (   (strcmp( cItemName, "NeckMS10" ) == 0)	
			|| (strcmp( cItemName, "NeckMS15" ) == 0))
		{	dwValue3 = atoi((char *)(cItemName + strlen(cItemName)-1)) + dwValue3;
			ZeroMemory(cTxt, sizeof(cTxt));
			memcpy(cTxt, pStr1, strlen(pStr1)-2);
			ZeroMemory(cTxt2, sizeof(cTxt2));
			wsprintf(cTxt2, "%s%d)", cTxt, dwValue3);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt2);	
		}else
#endif

		{	ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "+%d", dwValue3);
			strcat(pStr1, cTxt);
	}	}
}

void CGame::_CalcSocketClosed()
{	if (m_cGameMode == DEF_GAMEMODE_ONMAINGAME)
	{	delete m_pGSock;
		m_pGSock = NULL;
		m_bEscPressed = FALSE;
		PlaySound('E', 14, 5);
		if (m_bSoundFlag) m_pESound[38]->bStop();
		if ((m_bSoundFlag) && (m_bMusicStat == TRUE))
		{	StopBGM();	// Snoopy: mp3 support
			if (m_pBGM != NULL) m_pBGM->bStop();
		}
		ChangeGameMode(DEF_GAMEMODE_ONQUIT);
	}
}

void CGame::PointCommandHandler(int indexX, int indexY, char cItemID)
{char cTemp[31];
	if ((m_iPointCommandType >= 100) && (m_iPointCommandType < 200))
	{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_MAGIC, NULL, indexX, indexY, m_iPointCommandType, NULL);
	}else if ((m_iPointCommandType >= 0) && (m_iPointCommandType < 50))
	{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USEITEM, NULL, m_iPointCommandType, indexX, indexY, cTemp, cItemID); // v1.4

		if (m_pItemList[m_iPointCommandType]->m_cItemType == DEF_ITEMTYPE_USE_SKILL)
			m_bSkillUsingStatus = TRUE;
	}else if (m_iPointCommandType == 200) // Normal Hand
	{	if ((strlen(m_cMCName) == 0) || (strcmp(m_cMCName, m_cPlayerName) == 0) || (m_cMCName[0] == '_')) 
		{	m_stDialogBoxInfo[32].cMode = 0;
			PlaySound('E', 14, 5);
			AddEventList(POINT_COMMAND_HANDLER1, 10);
		}else
		{	m_stDialogBoxInfo[32].cMode = 3;
			PlaySound('E', 14, 5);
			ZeroMemory(m_stDialogBoxInfo[32].cStr, sizeof(m_stDialogBoxInfo[32].cStr));
			strcpy(m_stDialogBoxInfo[32].cStr, m_cMCName);
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQUEST_JOINPARTY, NULL, 1, NULL, NULL, m_cMCName);
			return;
	}	}
}

void CGame::UpdateScreen_OnGame()
{
 short sVal, sDivX, sModX, sDivY, sModY, sPivotX, sPivotY, sVPXsave, sVPYsave;
 static int  iUpdateRet = -1;
 short msX, msY, msZ, absX, absY, tX, tY;
 char cLB, cRB;
 char cItemColor;
 int  i, iAmount;
 DWORD dwTime = timeGetTime();
 static DWORD dwPrevChatTime = 0;
 //static int   imX = 0, imY = 0;
 static int iColorCounter = 5;
 static int iColorCounter2 = 11;

	if (m_cGameModeCount == 0)
	{	m_DDraw.ClearBackB4();
		m_dwFPStime = m_dwCheckConnTime = m_dwCheckSprTime = m_dwCheckChatTime = dwTime;
		m_sFrameCount = 0;
		if( m_bMusicStat ) StartBGM();
		//if(m_iLevel < 40) AddEventList(UPDATE_SCREEN_ONGAME12, 10);
	}

	m_cGameModeCount++;
	if (m_cGameModeCount > 20) m_cGameModeCount = 20;
	// ----------------------------------------------------

	m_DInput.UpdateMouseState(&msX, &msY, &msZ, &cLB, &cRB);
	m_dwCurTime = timeGetTime();

	if (m_bEnterPressed == TRUE)
	{
		m_bEnterPressed = FALSE;

		if ((m_bIsDialogEnabled[7] == TRUE) && (m_stDialogBoxInfo[7].cMode == 1) && (iGetTopDialogBoxIndex() == 7)) {

			EndInputString();

			m_bEnterPressed = FALSE;
			if (strlen(m_cGuildName) == 0) return;
			if (strcmp(m_cGuildName, "NONE") != 0) {
				bSendCommand(MSGID_REQUEST_CREATENEWGUILD, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL, NULL, NULL);
				m_stDialogBoxInfo[7].cMode = 2;
				//
			}
		}
		else if ((m_bIsDialogEnabled[17] == TRUE) && (m_stDialogBoxInfo[17].cMode == 1) && (iGetTopDialogBoxIndex() == 17)) {
			// Drop Item Query

			EndInputString();

			if (m_bSkillUsingStatus == TRUE)
			{	AddEventList(UPDATE_SCREEN_ONGAME1, 10);
				return;
			}

			if (   (m_bIsDialogEnabled[20] == TRUE)
				&& ((m_stDialogBoxInfo[20].cMode == 1) || (m_stDialogBoxInfo[20].cMode == 2)) )
			{	AddEventList(UPDATE_SCREEN_ONGAME1, 10);//"You can not give or drop before the actual Item transaction."
				return;
			}

			if ( (m_bIsDialogEnabled[4] == TRUE) || (m_bIsDialogEnabled[23] == TRUE) || (m_bIsDialogEnabled[26] == TRUE))
			{	AddEventList(UPDATE_SCREEN_ONGAME1, 10);
				return;
			}

			if (strlen(m_cAmountString) == 0) return;
			iAmount = atoi(m_cAmountString);

			if ((int)(m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwCount) < iAmount){
				iAmount = m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwCount ;
			}

			if (iAmount != 0) {
				if ((int)(m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwCount) >= iAmount) {
					if (m_stDialogBoxInfo[17].sV1 != NULL) {
						absX = abs(m_stDialogBoxInfo[17].sV1 - m_sPlayerX);
						absY = abs(m_stDialogBoxInfo[17].sV2 - m_sPlayerY);

						if ((absX == 0)	&& (absY ==0))
							AddEventList(UPDATE_SCREEN_ONGAME5, 10);
						else if ((absX <= 8) && (absY <= 8)) {
							switch (m_stDialogBoxInfo[17].sV3) {
							case 1:
							case 2:
							case 3:
							case 4:
							case 5:
							case 6:
								EnableDialogBox(20, 1, m_stDialogBoxInfo[17].sView, m_stDialogBoxInfo[17].sV3);
								m_stDialogBoxInfo[20].sV3 = iAmount;
								m_stDialogBoxInfo[20].sV4 = m_wCommObjectID;	// v1.4
								m_stDialogBoxInfo[20].sV5 = m_stDialogBoxInfo[17].sV1;
								m_stDialogBoxInfo[20].sV6 = m_stDialogBoxInfo[17].sV2;

								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;

								ZeroMemory(m_stDialogBoxInfo[20].cStr, sizeof(m_stDialogBoxInfo[20].cStr));
								strcpy(m_stDialogBoxInfo[20].cStr, m_stDialogBoxInfo[17].cStr);
								break;

							case 20:
								EnableDialogBox(20, 3, m_stDialogBoxInfo[17].sView, m_stDialogBoxInfo[17].sV3);
								m_stDialogBoxInfo[20].sV3 = iAmount;
								m_stDialogBoxInfo[20].sV4 = m_wCommObjectID;
								m_stDialogBoxInfo[20].sV5 = m_stDialogBoxInfo[17].sV1;
								m_stDialogBoxInfo[20].sV6 = m_stDialogBoxInfo[17].sV2;

								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;

								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;

								ZeroMemory(m_stDialogBoxInfo[20].cStr, sizeof(m_stDialogBoxInfo[20].cStr));
								GetNpcName(m_stDialogBoxInfo[17].sV3, m_stDialogBoxInfo[20].cStr);
								break;

							case 15:
		  					case 24:
								EnableDialogBox(20, 2, m_stDialogBoxInfo[17].sView, m_stDialogBoxInfo[17].sV3);
								m_stDialogBoxInfo[20].sV3 = iAmount;
								m_stDialogBoxInfo[20].sV4 = m_wCommObjectID;

								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;

								ZeroMemory(m_stDialogBoxInfo[20].cStr, sizeof(m_stDialogBoxInfo[20].cStr));
								GetNpcName(m_stDialogBoxInfo[17].sV3, m_stDialogBoxInfo[20].cStr);
								break;

							case 1000: // Trade stackable items
								// hum, déjà affiché? , j'attends le retour et je désactive!
								/*m_stDialogBoxInfo[27].sV1 = m_pItemList[m_stDialogBoxInfo[17].sV4]->m_sSprite;
								m_stDialogBoxInfo[27].sV2 = m_pItemList[m_stDialogBoxInfo[17].sV4]->m_sSpriteFrame;
								m_stDialogBoxInfo[27].sV3 = iAmount;
								m_stDialogBoxInfo[27].sV4 = m_pItemList[m_stDialogBoxInfo[17].sV4]->m_cItemColor;*/

								if (m_stDialogBoxExchangeInfo[0].sV1 == -1)			m_stDialogBoxExchangeInfo[0].sItemID = m_stDialogBoxInfo[17].sV4;
								else if (m_stDialogBoxExchangeInfo[1].sV1 == -1)	m_stDialogBoxExchangeInfo[1].sItemID = m_stDialogBoxInfo[17].sV4;
								else if (m_stDialogBoxExchangeInfo[2].sV1 == -1)	m_stDialogBoxExchangeInfo[2].sItemID = m_stDialogBoxInfo[17].sV4;
								else if (m_stDialogBoxExchangeInfo[3].sV1 == -1)	m_stDialogBoxExchangeInfo[3].sItemID = m_stDialogBoxInfo[17].sV4;
								else return; // Impossible case, tested at function beginning

								bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_SETEXCHANGEITEM, NULL, m_stDialogBoxInfo[17].sV4, iAmount, NULL, NULL);
								break;

							case 1001:
								// Sell List
								for (i = 0; i < DEF_MAXSELLLIST; i++)
								if (m_stSellItemList[i].iIndex == -1) {
									m_stSellItemList[i].iIndex = m_stDialogBoxInfo[17].sV4;
									m_stSellItemList[i].iAmount = iAmount;
									m_bIsItemDisabled[m_stDialogBoxInfo[17].sV4] = TRUE;
									break;
								}
								if( i == DEF_MAXSELLLIST ) AddEventList(UPDATE_SCREEN_ONGAME6, 10);
								break;

							case 1002:
								if (_iGetBankItemCount() >= (DEF_MAXBANKITEMS-1)) AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);
								else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, m_stDialogBoxInfo[39].sV1, iAmount, m_stDialogBoxInfo[39].sV5, m_stDialogBoxInfo[39].sV6, m_pItemList[m_stDialogBoxInfo[39].sV1]->m_cName, m_stDialogBoxInfo[39].sV4); //v1.4
								break;

							default:
								bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, (char)(m_stDialogBoxInfo[17].sView), iAmount, m_stDialogBoxInfo[17].sV1, m_stDialogBoxInfo[17].sV2, m_pItemList[m_stDialogBoxInfo[17].sView]->m_cName);
								break;
							}
							m_bIsItemDisabled[m_stDialogBoxInfo[17].sView] = TRUE;
		   				}else AddEventList(UPDATE_SCREEN_ONGAME7, 10);
					}else {
						if (iAmount <= 0)
						{	AddEventList(UPDATE_SCREEN_ONGAME8, 10);
						}else
						{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_ITEMDROP, NULL, m_stDialogBoxInfo[17].sView, iAmount, NULL, m_pItemList[m_stDialogBoxInfo[17].sView]->m_cName);
							m_bIsItemDisabled[m_stDialogBoxInfo[17].sView] = TRUE;
					}	}
				}else
				{	AddEventList(UPDATE_SCREEN_ONGAME9, 10);//"You entered more quantity that you can carry."
				}
			}
			DisableDialogBox(17);
		}else
		{	if (!m_bInputStatus)
			{	switch( m_cBackupChatMsg[0] ){
				case '!':
				case '@':
				case '#':
				case '$':
				case '^':
					ZeroMemory(m_cChatMsg, sizeof(m_cChatMsg));
					m_cChatMsg[0] = m_cBackupChatMsg[0];
					StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg);
					break;
				default:
					StartInputString(10, 414, sizeof(m_cChatMsg), m_cChatMsg);
					ClearInputString();
					break;
				}
			}else
			{	EndInputString();
				ZeroMemory(G_cTxt, sizeof(G_cTxt));
				ReceiveString((char *)G_cTxt);
				ZeroMemory(m_cBackupChatMsg, sizeof(m_cBackupChatMsg));
				strcpy(m_cBackupChatMsg, G_cTxt);
				if ((m_dwCurTime - dwPrevChatTime) < 700)
				{}else
				{	dwPrevChatTime = m_dwCurTime;
					m_curse.ConvertString( G_cTxt, strlen(G_cTxt) );
					if ( strlen(G_cTxt) > 0 )
					{	if( (G_cTxt[0]=='!') || (G_cTxt[0]=='~'))
						{	if( m_Misc.bCheckIMEString(G_cTxt) == FALSE ) return;
						}
						bSendCommand(MSGID_COMMAND_CHATMSG, NULL, NULL, NULL, NULL, NULL, G_cTxt);
	}	}	}	}	}

	sVPXsave = m_sViewPointX;
	sVPYsave = m_sViewPointY;

	if ((m_iCameraShakingDegree > 0) && (iUpdateRet != 0))
	{	m_sViewPointX += m_iCameraShakingDegree - (rand() % m_iCameraShakingDegree*2);
		m_sViewPointY += m_iCameraShakingDegree - (rand() % m_iCameraShakingDegree*2);
		m_iCameraShakingDegree--;
		if (m_iCameraShakingDegree <= 0) m_iCameraShakingDegree = 0;
	}
	sPivotX = m_pMapData->m_sPivotX;
	sPivotY = m_pMapData->m_sPivotY;
	sVal = m_sViewPointX - (sPivotX*32);
	sDivX = sVal / 32;
	sModX = sVal % 32;
	sVal = m_sViewPointY - (sPivotY*32);
	sDivY = sVal / 32;
	sModY = sVal % 32;
	if (iUpdateRet != 0)
		DrawBackground(sDivX, sModX, sDivY, sModY);

	if (iUpdateRet != 0)
		DrawEffectLights();
	if (iUpdateRet != 0)
		DrawObjects(sPivotX, sPivotY, sDivX, sDivY, sModX, sModY, msX, msY);

	if (iUpdateRet != 0)
	{	DrawEffects();
		DrawWhetherEffects();
		DrawChatMsgs(-100, 0, 800, 600);
		WhetherObjectFrameCounter();
	}

	if (m_cMapIndex == 26)	//Snoopy: Add Apocalypse map effect (fires in inferniaA)
	{	m_pEffectSpr[89]->PutTransSprite(1296 - m_sViewPointX, 1283 - m_sViewPointY, _tmp_iEffectFrame %12, 0);
		m_pEffectSpr[89]->PutTransSprite(1520 - m_sViewPointX, 1123 - m_sViewPointY, _tmp_iEffectFrame %12, 0);
		m_pEffectSpr[89]->PutTransSprite(1488 - m_sViewPointX, 3971 - m_sViewPointY, _tmp_iEffectFrame %12, 0);
		m_pEffectSpr[93]->PutTransSprite(2574 - m_sViewPointX, 3677 - m_sViewPointY, _tmp_iEffectFrame %12, 0);
		m_pEffectSpr[93]->PutTransSprite(3018 - m_sViewPointX, 3973 - m_sViewPointY, _tmp_iEffectFrame %12, 0);
	}else if (m_cMapIndex == 27)	//Add Apocalypse map effect (fires in inferniaB)
	{	m_pEffectSpr[89]->PutTransSprite(1293 - m_sViewPointX, 3657 - m_sViewPointY, _tmp_iEffectFrame %12, 0);
		m_pEffectSpr[89]->PutTransSprite(944  - m_sViewPointX, 3881 - m_sViewPointY, _tmp_iEffectFrame %12, 0);
		m_pEffectSpr[89]->PutTransSprite(1325 - m_sViewPointX, 4137 - m_sViewPointY, _tmp_iEffectFrame %12, 0);
		m_pEffectSpr[89]->PutTransSprite(1648 - m_sViewPointX, 3913 - m_sViewPointY, _tmp_iEffectFrame %12, 0);
	}
	//Snoopy: Add Apocalypse Gate and apocalypse map effects (if no Gate, m_iGatePositX will be -1...
	if (   (m_iGatePositX >= m_sViewPointX/32) && (m_iGatePositX <= m_sViewPointX/32 + 20)
		&& (m_iGatePositY >= m_sViewPointY/32) && (m_iGatePositY <= m_sViewPointY/32 + 15))
	{	m_pEffectSpr[101]->PutTransSprite(m_iGatePositX*32 - m_sViewPointX - 96, m_iGatePositY*32 - m_sViewPointY - 69, _tmp_iEffectFrame%30, dwTime);
	}
	if (iUpdateRet != 0)
		DrawDialogBoxs(msX, msY, msZ, cLB);

	if ((iUpdateRet != 0) && m_bInputStatus)
	{	if (((m_bIsDialogEnabled[7] == TRUE) && (m_stDialogBoxInfo[7].cMode == 1)) ||
			((m_bIsDialogEnabled[17] == TRUE) && (m_stDialogBoxInfo[17].cMode == 1)) )
		{}else m_DDraw.DrawShadowBox(0, 413, 639, 429);
		ShowReceivedString();
	}

	if (iUpdateRet != 0)
		ShowEventList(m_dwCurTime);

	if ( (iUpdateRet != 0) && (m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_ITEM) &&
		 (m_pItemList[m_stMCursor.sSelectedObjectID] != NULL) )
	{	cItemColor = m_pItemList[m_stMCursor.sSelectedObjectID]->m_cItemColor;
		if (cItemColor != 0) {
			if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos == DEF_EQUIPPOS_LHAND) ||
				(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos == DEF_EQUIPPOS_RHAND) ||
				(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite]->PutSpriteRGB(msX - m_stMCursor.sDistX, msY - m_stMCursor.sDistY,
					                                                  m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame,
																	  m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0],
																	  dwTime);
			}else
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite]->PutSpriteRGB(msX - m_stMCursor.sDistX, msY - m_stMCursor.sDistY,
					                                                  m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame,
																	  m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0],
																	  dwTime);
			}
		}else m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite]->PutSpriteFast(msX - m_stMCursor.sDistX, msY - m_stMCursor.sDistY,
					                                                  m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame, dwTime);

		char cStr1[64], cStr2[64], cStr3[64];
		int  iLoc;
		GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);

		iLoc = 0;
		if (strlen(cStr1) != 0)
		{	if(m_bIsSpecial)
				PutString(msX, msY +25, cStr1, RGB(0,255,50), FALSE, 1);
			else
				PutString(msX, msY +25, cStr1, RGB(255,255,255), FALSE, 1);
			iLoc += 15;
		}
		if (strlen(cStr2) != 0)
		{	PutString(msX, msY +25 +iLoc, cStr2, RGB(150,150,150), FALSE, 1);
			iLoc += 15;
		}
		if (strlen(cStr3) != 0)
		{	PutString(msX, msY +25 +iLoc, cStr3, RGB(150,150,150), FALSE, 1);
			iLoc += 15;
		}
		if ( (m_pItemList[m_stMCursor.sSelectedObjectID]->m_sLevelLimit != 0) && ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_dwAttribute & 0x00000001) == 0) )
		{	wsprintf(G_cTxt, "%s: %d", DRAW_DIALOGBOX_SHOP24, m_pItemList[m_stMCursor.sSelectedObjectID]->m_sLevelLimit);//"·¹º§ Á¦ÇÑ: %d"
			PutString(msX, msY +25 +iLoc, G_cTxt, RGB(150,150,150), FALSE, 1);
			iLoc += 15;
		}
		if( (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos != DEF_EQUIPPOS_NONE) && (m_pItemList[m_stMCursor.sSelectedObjectID]->m_wWeight>=1100) )
		{	int	_wWeight = 0;
			if(m_pItemList[m_stMCursor.sSelectedObjectID]->m_wWeight%100) _wWeight = 1;
			wsprintf( G_cTxt, DRAW_DIALOGBOX_SHOP15, m_pItemList[m_stMCursor.sSelectedObjectID]->m_wWeight/100 + _wWeight);
			PutString(msX, msY +25 +iLoc, G_cTxt, RGB(150,150,150), FALSE, 1);
			iLoc += 15;
		}
		if (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos != DEF_EQUIPPOS_NONE)
		{	wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME10, m_pItemList[m_stMCursor.sSelectedObjectID]->m_wCurLifeSpan);
			PutString(msX, msY +25 +iLoc, G_cTxt, RGB(150,150,150), FALSE, 1);
			iLoc += 15;
		}
		if ( iLoc == 15 )
		{	iLoc = 0;
			for ( int iTmp = 0 ; iTmp < DEF_MAXITEMS ; iTmp++ )
			{	if( m_pItemList[iTmp] != NULL )
				{	if( strcmp(m_pItemList[iTmp]->m_cName, m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName ) == 0 ) iLoc++;
				}
			}
			if( iLoc > 1 )
			{	wsprintf(G_cTxt, DEF_MSG_TOTAL_NUMBER, iLoc);
				PutString(msX, msY + 40, G_cTxt, RGB(150,150,150), FALSE, 1);
	}	}	}

	//Snoopy: Add Apocalypse map effect (druncncity bubbles)
	if (m_cMapIndex == 25)
	{	bAddNewEffect(13, m_sViewPointX + rand() %640, m_sViewPointY + rand() %480, 0, 0, -1*(rand() %80), 1);
		DrawDruncncity();
	}

	//Snoopy adding Heldenian turret count:
	if (   (iUpdateRet != 0 ) && (m_iHeldenianAresdenLeftTower != -1)
		&& (memcmp(m_cCurLocation, "BtField", 7) == 0))
	{	wsprintf( G_cTxt, "Aresden Flags : %d",  m_iHeldenianAresdenFlags);
		PutString( 10, 140, G_cTxt, RGB(255,255,255) );
		wsprintf( G_cTxt, "Aresden Flags : %d",  m_iHeldenianElvineFlags);
		PutString( 10, 160, G_cTxt, RGB(255,255,255) );
		wsprintf( G_cTxt, "Aresden's rest building number : %d",  m_iHeldenianAresdenLeftTower);
		PutString( 10, 180, G_cTxt, RGB(255,255,255) );
		wsprintf( G_cTxt, "Elvine's rest building number : %d",  m_iHeldenianElvineLeftTower);
		PutString( 10, 200, G_cTxt, RGB(255,255,255) );
	}
	DrawTopMsg();

#ifdef _DEBUG
	wsprintf(G_cTxt, "M(%d,%d) T(%d,%d)", msX, msY, (m_sViewPointX + msX)/32, (m_sViewPointY + msY)/32);
	PutString(msX, msY +30, G_cTxt, RGB(255,255,255));
#endif

	// LogOut process
#ifdef DEF_EQUILIBRIUM_PROJECT // m_bFullParalyze prevents logout
	if ((m_cLogOutCount > 0) && (m_bFullParalyze == FALSE))	
	{	if ((dwTime - m_dwLogOutCountTime) > 1000)
		{	m_cLogOutCount--;
			m_dwLogOutCountTime = dwTime;
			wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME13, m_cLogOutCount);
			AddEventList(G_cTxt, 10);
		}	
	}else if ((m_cLogOutCount > 0) && (m_bFullParalyze == TRUE) && (m_bForceDisconn == FALSE))
	{	m_cLogOutCount = -1;
		AddEventList(MOTION_RESPONSE_HANDLER3, 10);//"Logout count cancels if held by Medusa Kiss."
	}
#else
	if (m_cLogOutCount > 0)
	{	if ((dwTime - m_dwLogOutCountTime) > 1000)
		{	m_cLogOutCount--;
			m_dwLogOutCountTime = dwTime;
			wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME13, m_cLogOutCount);//"Logging out...%d"
			AddEventList(G_cTxt, 10);
	}	}
#endif


	// Logout
	if (m_cLogOutCount == 0)
	{	delete m_pGSock;
		m_pGSock = NULL;
		m_bEscPressed = FALSE;

		PlaySound('E', 14, 5);
		if (m_bSoundFlag) m_pESound[38]->bStop();
		if ((m_bSoundFlag) && (m_bMusicStat == TRUE))
		{	StopBGM();	// Snoopy: mp3 support
			if (m_pBGM != NULL) m_pBGM->bStop();
		}
		if (strlen(G_cCmdLineTokenA) != 0)
			 ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		return;
	}

	// Restart Process
	if (m_cRestartCount > 0)
	{	if ((dwTime - m_dwRestartCountTime) > 1000)
		{	m_cRestartCount--;
			m_dwRestartCountTime = dwTime;
			wsprintf(G_cTxt, UPDATE_SCREEN_ONGAME14, m_cRestartCount); // "Restarting game...%d"
			AddEventList(G_cTxt, 10);
	}	}
	// Restart
	if (m_cRestartCount == 0)
	{	m_cRestartCount = -1;
		bSendCommand(MSGID_REQUEST_RESTART, NULL, NULL, NULL, NULL, NULL, NULL);
		return;
	}

	//Snoopy: Added diag "LEVEL UP" right down
	if (m_iLU_Point >0) PutString_SprFont(560, 390, "Level Up", 250, 250, 0);

	if (m_cGameModeCount < 6) m_DDraw.DrawShadowBox(0,0,639,479);
	if (m_cGameModeCount < 2) m_DDraw.DrawShadowBox(0,0,639,479);

	if (m_bIsObserverMode == TRUE)
	{	m_DDraw.PutPixel(msX, msY,   255,255,255);
		m_DDraw.PutPixel(msX+1, msY, 255,255,255);
		m_DDraw.PutPixel(msX-1, msY, 255,255,255);
		m_DDraw.PutPixel(msX, msY+1, 255,255,255);
		m_DDraw.PutPixel(msX, msY-1, 255,255,255);
	}
	else m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, m_stMCursor.sCursorFrame, dwTime);

	if( iUpdateRet == 0 ) m_sFrameCount++;
	else m_sFrameCount+=256;

	if( dwTime - m_dwFPStime > 500 )
	{	m_dwFPStime = dwTime;
		m_sFPS = m_sFrameCount>>7;
		if( m_sFPS < 10 ) m_sFPS += 6;
		m_sFrameCount = 0;
	}

	if( iUpdateRet != 0 )
	{	if( m_bShowFPS )
		{	wsprintf( G_cTxt, "fps : %d", m_sFPS );
			PutString( 10, 100, G_cTxt, RGB(255,255,255) );
		}
		if( m_DDraw.iFlip() == DDERR_SURFACELOST ) RestoreSprites();		

		// Couleurs 13 et 14 d'armes tournantes // m_Misc.ColorTransfer
		iColorCounter ++; 
		if (iColorCounter > 20) iColorCounter = 1 ;
		if (iColorCounter < 11) //1..6 
		{	m_wWR[14] += 1; // rouge<->bleu
			m_wWG[14] -= 1;
			m_wWB[14] -= 1;
			if ((iColorCounter%2) == 1) m_wWR[13] += 1; //blanc<->jaune
			if ((iColorCounter%3) == 1) m_wWG[13] -= 1;
			m_wWB[13] -= 1;	
		}else // 7..12
		{	m_wWR[14] -= 1; // rouge<->bleu
			m_wWG[14] += 1;
			m_wWB[14] += 1;
			if ((iColorCounter%2) == 1) m_wWR[13] -= 1; // blanc<->jaune
			if ((iColorCounter%3) == 2) m_wWG[13] += 1;
			m_wWB[13] += 1;
		}
		// Couleur 12 d'armes tournantes
		iColorCounter2 ++; 
		if (iColorCounter2 > 72) iColorCounter2 = 1 ;
		if (iColorCounter2 <= 36) 
		{	if (iColorCounter2 > 31) m_wWR[12] += 1; // noir<-> rouge
		}else // 7..12
		{	if (iColorCounter2 < 42) m_wWR[12] -= 1; // noir<-> rouge
		}	
	}

	// m_iPlayerStatus 0x000F
	iUpdateRet = m_pMapData->iObjectFrameCounter(m_cPlayerName, m_sViewPointX, m_sViewPointY);

	if ((bEffectFrameCounter() == TRUE) && (iUpdateRet == 0)) iUpdateRet = -1;
	if (iUpdateRet == 2)
	{	m_bCommandAvailable = TRUE;
		m_dwCommandTime = 0;
	}
	CommandProcessor( msX, msY, ((sDivX + sPivotX)*32 + sModX + msX - 17)/32 + 1, ((sDivY + sPivotY)*32 + sModY + msY - 17)/32 + 1, cLB, cRB);

	m_sViewPointX = sVPXsave;
	m_sViewPointY = sVPYsave;

	if (iUpdateRet > 0) CalcViewPoint();

	if (m_bIsObserverMode)
	{	if ((dwTime - m_dwObserverCamTime) > 25)
		{	m_dwObserverCamTime = dwTime;
			CalcViewPoint();
			iUpdateRet = -1;
	}	}

	if (iUpdateRet > 0)
	{	if (m_bDrawFlagDir == FALSE)
		{	m_iDrawFlag++;
			if (m_iDrawFlag >= 25)
			{	m_iDrawFlag = 25;
				m_bDrawFlagDir = TRUE;
			}
		}else
		{	m_iDrawFlag--;
			if (m_iDrawFlag < 0)
			{	m_iDrawFlag = 0;
				m_bDrawFlagDir = FALSE;
	}	}	}
	// iUpdateRet
}

////////////////////////////////////////////////////////////////////////////////////////
//	Snoopy: mp3 functions
//
////////////////////////////////////////////////////////////////////////////////////////
void CGame::LoopBGM()
{	Mp3Event();
}
void CGame::PauseBGM()
{	Mp3Pause();
}
void CGame::ResumeBGM()
{	Mp3Resume();
}
void CGame::StopBGM()
{	Mp3Stop();
}
void CGame::SetBGMVolume()
{	int iVolume = (m_cMusicVolume - 100)*20;
	if (iVolume > 0) iVolume = 0;
	if (iVolume < -10000) iVolume = -10000; //iVolume == Volume
	Mp3SetVolume(iVolume);
}
void CGame::StartBGM()
{	if( m_bSoundFlag == FALSE )
	{	StopBGM();	// Snoopy: mp3 support
		if (m_pBGM != NULL)
		{	m_pBGM->bStop();
			delete m_pBGM;
			m_pBGM = NULL;
		}
		return;
	}
	char cWavFileName[32];
	ZeroMemory( cWavFileName, sizeof(cWavFileName) );
	if ((m_bIsXmas == TRUE) && (m_cWhetherEffectType >= 4)) strcpy( cWavFileName, "music\\Carol.wav" );
	else
	{	if (memcmp(m_cCurLocation, "aresden", 7) == 0) strcpy( cWavFileName, "music\\aresden.wav" );
		else if (memcmp(m_cCurLocation, "elvine", 6) == 0) strcpy( cWavFileName, "music\\elvine.wav" );
		else if (memcmp(m_cCurLocation, "dglv", 4) == 0) strcpy( cWavFileName, "music\\dungeon.wav" );
		else if (memcmp(m_cCurLocation, "middled1", 8) == 0) strcpy( cWavFileName, "music\\dungeon.wav" );
		else if (memcmp(m_cCurLocation, "middleland", 10) == 0) strcpy( cWavFileName, "music\\middleland.wav" );
		// Snoopy: new musics
		else if (memcmp(m_cCurLocation, "druncncity", 10) == 0) strcpy( cWavFileName, "music\\druncncity.wav" );
		else if (memcmp(m_cCurLocation, "inferniaA", 9) == 0) strcpy( cWavFileName, "music\\middleland.wav" );
		else if (memcmp(m_cCurLocation, "inferniaB", 9) == 0) strcpy( cWavFileName, "music\\middleland.wav" );
		else if (memcmp(m_cCurLocation, "maze", 4) == 0) strcpy( cWavFileName, "music\\dungeon.wav" );
		else if (memcmp(m_cCurLocation, "abaddon", 7) == 0) strcpy( cWavFileName, "music\\abaddon.wav" );

#ifdef DEF_EQUILIBRIUM_PROJECT // Equi music
		else if (memcmp(m_cCurLocation, "stadium", 7) == 0) strcpy( cWavFileName, "music\\stadium.mp3" );
		else if (memcmp(m_cCurLocation, "lost", 4) == 0)// strcpy( cWavFileName, "music\\lost.wav" );
		{	strcpy( cWavFileName, "music\\lost.mp3" );
			SYSTEMTIME sysTime;
			HANDLE hFile;
			GetLocalTime(&sysTime);
			switch (sysTime.wDayOfWeek) {
			default:
			case 0: // Dimanche: default music
				break;
			case 1: // Lundi
				hFile = CreateFile("music\\lost1.mp3", 0, NULL, NULL, OPEN_EXISTING, NULL, NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{	CloseHandle(hFile);
					ZeroMemory( cWavFileName, sizeof(cWavFileName) );
					strcpy( cWavFileName, "music\\lost1.mp3" );
				}
				break;
			case 2: // Mardi
				hFile = CreateFile("music\\lost2.mp3", 0, NULL, NULL, OPEN_EXISTING, NULL, NULL);
				if (hFile != INVALID_HANDLE_VALUE) 
				{	CloseHandle(hFile);
					ZeroMemory( cWavFileName, sizeof(cWavFileName) );
					strcpy( cWavFileName, "music\\lost2.mp3" );
				}
				break;
			case 3: // Mercredi
				hFile = CreateFile("music\\lost3.mp3", 0, NULL, NULL, OPEN_EXISTING, NULL, NULL);
				if (hFile != INVALID_HANDLE_VALUE) 
				{	CloseHandle(hFile);
					ZeroMemory( cWavFileName, sizeof(cWavFileName) );
					strcpy( cWavFileName, "music\\lost3.mp3" );
				}
				break;
			case 4: // Jeudi
				hFile = CreateFile("music\\lost4.mp3", 0, NULL, NULL, OPEN_EXISTING, NULL, NULL);
				if (hFile != INVALID_HANDLE_VALUE) 
				{	CloseHandle(hFile);
					ZeroMemory( cWavFileName, sizeof(cWavFileName) );
					strcpy( cWavFileName, "music\\lost4.mp3" );
				}
				break;
			case 5: // Vendredi
				hFile = CreateFile("music\\lost5.mp3", 0, NULL, NULL, OPEN_EXISTING, NULL, NULL);
				if (hFile != INVALID_HANDLE_VALUE) 
				{	CloseHandle(hFile);
					ZeroMemory( cWavFileName, sizeof(cWavFileName) );
					strcpy( cWavFileName, "music\\lost5.mp3" );
				}
				break;
			case 6: // Samedi
				hFile = CreateFile("music\\lost6.mp3", 0, NULL, NULL, OPEN_EXISTING, NULL, NULL);
				if (hFile != INVALID_HANDLE_VALUE) 
				{	CloseHandle(hFile);
					ZeroMemory( cWavFileName, sizeof(cWavFileName) );
					strcpy( cWavFileName, "music\\lost6.mp3" );
				}
				break;
		}	}
#endif

		else strcpy( cWavFileName, "music\\MainTm.wav" );
	}

	if (m_bIsCrusadeMode == TRUE) 
	{	ZeroMemory( cWavFileName, sizeof(cWavFileName) );
		strcpy( cWavFileName, "music\\crusade.mp3" );
	}
	if (m_bIsAvatarMode == TRUE) 
	{	ZeroMemory( cWavFileName, sizeof(cWavFileName) );
		strcpy( cWavFileName, "music\\avatar.mp3" );
	}

	//Snoopy: mp3 support
	//ZeroMemory( cWavFileName, sizeof(cWavFileName) );
	if (Mp3Playing(cWavFileName) == false)
	{	Mp3Stop();
		Mp3Load(cWavFileName);

		int iVolume = (m_cMusicVolume - 100)*20;
		if (iVolume > 0) iVolume = 0;
		if (iVolume < -10000) iVolume = -10000; //iVolume == Volume
		Mp3SetVolume(iVolume);
		if( m_bIsProgramActive == TRUE ) 
		{	Mp3Play();
		}else
		{	Mp3Play();
			PauseBGM();
		}
	}	
/*
	if (m_pBGM != NULL)
	{	if( strcmp( m_pBGM->m_cWavFileName, cWavFileName ) == 0 ) return;
		m_pBGM->bStop();
		delete m_pBGM;
		m_pBGM = NULL;
	}
	int iVolume = (m_cMusicVolume - 100)*20;
	if (iVolume > 0) iVolume = 0;
	if (iVolume < -10000) iVolume = -10000; //iVolume == Volume
	m_pBGM = new class CSoundBuffer(m_DSound.m_lpDS, m_DSound.m_DSCaps, cWavFileName, TRUE);
	m_pBGM->Play(TRUE, 0, iVolume);
*/
}

void CGame::MotionResponseHandler(char * pData)
{
 WORD  * wp, wResponse;
 short * sp, sX, sY;
 char  * cp, cDir;
 int   * ip, iPreHP;
	//						          0 3        4 5						 6 7		8 9		   10	    11
	// Confirm Code(4) | MsgSize(4) | MsgID(4) | DEF_OBJECTMOVE_CONFIRM(2) | Loc-X(2) | Loc-Y(2) | Dir(1) | MapData ...
	// Confirm Code(4) | MsgSize(4) | MsgID(4) | DEF_OBJECTMOVE_REJECT(2)  | Loc-X(2) | Loc-Y(2)
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wResponse = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	switch (wResponse) {
	case DEF_OBJECTMOTION_CONFIRM:
		m_cCommandCount--;
		break;

	case DEF_OBJECTMOTION_ATTACK_CONFIRM:
		m_cCommandCount--;
		break;

	case DEF_OBJECTMOTION_REJECT:

		if (m_iHP <= 0) return;

		sp = (short *)cp;
		m_sPlayerX = *sp;
		cp += 2;

		sp = (short *)cp;
		m_sPlayerY = *sp;
		cp += 2;

		m_cCommand = DEF_OBJECTSTOP;
		m_sCommX = m_sPlayerX;
		m_sCommY = m_sPlayerY;

		m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
						                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
										  m_iPlayerStatus, m_cPlayerName,
										  DEF_OBJECTSTOP, NULL, NULL, NULL);
		m_cCommandCount = 0;
		m_bIsGetPointingMode = FALSE;
		m_sViewDstX = m_sViewPointX = (m_sPlayerX-10)*32;
		m_sViewDstY = m_sViewPointY = (m_sPlayerY-7)*32;

		m_bIsRedrawPDBGS = TRUE;
		break;

	case DEF_OBJECTMOVE_CONFIRM:
		sp = (short *)cp;
		sX = *sp;
		cp += 2;
		sp = (short *)cp;
		sY = *sp;
		cp += 2;
		cDir = *cp;
		cp++;
		m_iSP = m_iSP - *cp;
		cp++;
		if( m_iSP < 0 ) m_iSP = 0;
		// v1.3
		//m_iOccupyStatus = (int)*cp;
		cp++;
		// v1.4
		iPreHP = m_iHP;
		ip = (int *)cp;
		m_iHP = *ip;
		cp += 4;

		if (m_iHP != iPreHP)
		{	if (m_iHP < iPreHP)
			{	wsprintf(G_cTxt, NOTIFYMSG_HP_DOWN, iPreHP - m_iHP);
				AddEventList(G_cTxt, 10);
				m_dwDamagedTime = timeGetTime();
				if ((m_cLogOutCount>0) && (m_bForceDisconn==FALSE))
				{	m_cLogOutCount = -1;
					AddEventList(MOTION_RESPONSE_HANDLER2, 10);
				}
			}else
			{	wsprintf(G_cTxt, NOTIFYMSG_HP_UP, m_iHP - iPreHP);
				AddEventList(G_cTxt, 10);
		}	}
		m_pMapData->ShiftMapData(cDir);
		_ReadMapData(sX, sY, cp);
		m_bIsRedrawPDBGS = TRUE;
		m_cCommandCount--;
		break;

	case DEF_OBJECTMOVE_REJECT:
		if (m_iHP <= 0) return;
		wp = (WORD *)cp;
		if (m_sPlayerObjectID != *wp) return;
		cp += 2;
		sp  = (short *)cp;
		m_sPlayerX = *sp;
		cp += 2;
		sp  = (short *)cp;
		m_sPlayerY = *sp;
		cp += 2;
		sp  = (short *)cp;
		m_sPlayerType = *sp;
		cp += 2;
		m_cPlayerDir = *cp;
		cp++;
		//memcpy(cName, cp, 10);
		cp += 10;
		sp = (short *)cp;
		m_sPlayerAppr1 = *sp;
		cp += 2;
		sp = (short *)cp;
		m_sPlayerAppr2 = *sp;
		cp += 2;
		sp = (short *)cp;
		m_sPlayerAppr3 = *sp;
		cp += 2;
		sp = (short *)cp;
		m_sPlayerAppr4 = *sp;
		cp += 2;
		ip = (int *)cp;
		m_iPlayerApprColor = *ip;
		cp += 4;
		ip = (int *)cp;
		m_iPlayerStatus = *ip;
		cp += 4;
		m_cCommand = DEF_OBJECTSTOP;
		m_sCommX = m_sPlayerX;
		m_sCommY = m_sPlayerY;
		m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
						                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
										  m_iPlayerStatus, m_cPlayerName,
										  DEF_OBJECTSTOP, NULL, NULL, NULL,
										  0, 7);
		m_cCommandCount = 0;
		m_bIsGetPointingMode = FALSE;
		m_sViewDstX = m_sViewPointX = (m_sPlayerX-10)*32;
		m_sViewDstY = m_sViewPointY = (m_sPlayerY-7)*32;
		m_bIsPrevMoveBlocked = TRUE;
		switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			PlaySound('C', 12, 0);
			break;
		case 4:
		case 5:
		case 6:
			PlaySound('C', 13, 0);
			break;
		}
		//m_bCommandAvailable = TRUE;
		break;
	}
}


void CGame::CommandProcessor(short msX, short msY, short indexX, short indexY, char cLB, char cRB)
{
 char   cDir, absX, absY, cName[12];
 short  sX, sY, sObjectType, tX, tY;
 int iObjectStatus;
 int    iRet;
 DWORD  dwTime = timeGetTime();
 WORD   wType = 0;
 int i;//, iFOE;
 char   cTxt[120];

 char  pDstName[21];
 short sDstOwnerType;
 int iDstOwnerStatus;

 BOOL  bGORet;
 // Fixed by Snoopy
	if ((m_bIsObserverCommanded == FALSE) && (m_bIsObserverMode == TRUE))
	{	if ((msX == 0) && (msY == 0) && (m_sViewDstX > 32*21) && (m_sViewDstY > 32*16)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 8, NULL, NULL, NULL, NULL);
		else
		if ((msX == 639) && (msY == 0) && (m_sViewDstX < 32*m_pMapData->m_sMapSizeX - 32*21) && (m_sViewDstY > 32*16)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 2, NULL, NULL, NULL, NULL);
		else
		if ((msX == 639) && (msY == 479) && (m_sViewDstX < 32*m_pMapData->m_sMapSizeX - 32*21) && (m_sViewDstY < 32*m_pMapData->m_sMapSizeY - 32*16)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 4, NULL, NULL, NULL, NULL);
		else
		if ((msX == 0) && (msY == 479)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 6, NULL, NULL, NULL, NULL);
		else
		if ((msX == 0) && (m_sViewDstX > 32*21)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 7, NULL, NULL, NULL, NULL);
		else
		if ((msX == 639) && (m_sViewDstX < 32*m_pMapData->m_sMapSizeX - 32*21)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 3, NULL, NULL, NULL, NULL);
		else
		if ((msY == 0) && (m_sViewDstY > 32*16)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 1, NULL, NULL, NULL, NULL);
		else
		if ((msY == 479) && (m_sViewDstY < 32*m_pMapData->m_sMapSizeY - 32*16)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 5, NULL, NULL, NULL, NULL);
		else return;

		m_bIsObserverCommanded = TRUE;
		m_cArrowPressed = 0;
		return;
	}

	if (m_bIsObserverMode == TRUE) return;

	if (GetAsyncKeyState(VK_MENU)>>15) // [ALT]
		 m_bSuperAttackMode = TRUE;
	else m_bSuperAttackMode = FALSE;

	switch (m_stMCursor.cPrevStatus) {
	case DEF_CURSORSTATUS_NULL:
		if (cLB != 0)
		{	iRet = _iCheckDlgBoxFocus(msX, msY, 1);
			if (iRet == 1)
			{	m_stMCursor.cPrevStatus	= DEF_CURSORSTATUS_SELECTED;
				return;
			}else if (iRet == 0)
			{	m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_PRESSED;
				// Snoopy: Added Golden LevelUp
				if (   (msX >560) && (msX <620) && (msY>390) && (msY<405)
					&& (m_iLU_Point >0))
				{	if (m_bIsDialogEnabled[12] != TRUE)
					{	EnableDialogBox(12, NULL, NULL, NULL);
						PlaySound('E', 14, 5);
					}
					m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
					return;
				}
			}else if (iRet == -1)
			{	return;
			}
		}else if (cRB != 0)
		{	iRet = _iCheckDlgBoxFocus(msX, msY, 2);
			if (iRet == 1) return;
		}
		break;
	case DEF_CURSORSTATUS_PRESSED:
		if (cLB == 0) // Normal Click
		{	m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
		}
		break;
	case DEF_CURSORSTATUS_SELECTED:
		if (cLB == 0)
		{	if (   ((dwTime - m_stMCursor.dwSelectClickTime) < DEF_DOUBLECLICKTIME) 	// Double Click
				&& (msX == m_stMCursor.sClickX) && (msY == m_stMCursor.sClickY) ) 
			{	m_stMCursor.dwSelectClickTime = m_stMCursor.dwSelectClickTime;
				_bCheckDlgBoxDoubleClick(msX, msY);
			}else // Click
			{	_bCheckDlgBoxClick(msX, msY);
				m_stMCursor.sClickX = msX;
				m_stMCursor.sClickY = msY;
			}
			m_stMCursor.dwSelectClickTime = dwTime;
			m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
			if (m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_ITEM)
			{	_bCheckDraggingItemRelease(msX, msY);
				m_stMCursor.cSelectedObjectType = NULL;
				m_stMCursor.sSelectedObjectID   = NULL;
			}
			return;
		}
		if (cLB != 0) 			// v2.05 01-11-30
		{	if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == TRUE) && (m_cCommandCount == 0)) goto CP_SKIPMOUSEBUTTONSTATUS;

			if ((m_stMCursor.sPrevX != msX)	|| (m_stMCursor.sPrevY != msY))
			{	m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_DRAGGING;
				m_stMCursor.sPrevX = msX;
				m_stMCursor.sPrevY = msY;
				if ( (m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					 ((m_stMCursor.sSelectedObjectID == 30) || (m_stMCursor.sSelectedObjectID == 29)) )
				{	m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				}
				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 7) && (m_stDialogBoxInfo[7].cMode == 1))
				{	EndInputString();
					m_stDialogBoxInfo[7].cMode = 20;
				}
				// Query Drop Item Amount
				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 17) && (m_stDialogBoxInfo[17].cMode == 1))
					// Guild Menu
				{	EndInputString();
					m_stDialogBoxInfo[17].cMode = 20;
				}
				return;
			}
			if ((m_cCommand == DEF_OBJECTMOVE) || (m_cCommand == DEF_OBJECTRUN)) goto MOTION_COMMAND_PROCESS;
			return;
		}
		break;
	case DEF_CURSORSTATUS_DRAGGING:
		if (cLB != 0)
		{	if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == TRUE) && (m_cCommandCount == 0)) goto CP_SKIPMOUSEBUTTONSTATUS;
			if (m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX)
			{	m_stDialogBoxInfo[m_stMCursor.sSelectedObjectID].sX = msX - m_stMCursor.sDistX;
				m_stDialogBoxInfo[m_stMCursor.sSelectedObjectID].sY = msY - m_stMCursor.sDistY;
			}
			m_stMCursor.sPrevX = msX;
			m_stMCursor.sPrevY = msY;

			if ((m_cCommand == DEF_OBJECTMOVE) || (m_cCommand == DEF_OBJECTRUN)) goto MOTION_COMMAND_PROCESS;
			return;
		}
		if (cLB == 0) {
			switch (m_stMCursor.cSelectedObjectType) {
			case DEF_SELECTEDOBJTYPE_DLGBOX:
				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 7) && (m_stDialogBoxInfo[7].cMode == 20))
				{	sX = m_stDialogBoxInfo[7].sX;
					sY = m_stDialogBoxInfo[7].sY;
					StartInputString(sX + 75, sY + 140, 21, m_cGuildName);
					m_stDialogBoxInfo[7].cMode = 1;
				}

				if ((m_stMCursor.cSelectedObjectType == DEF_SELECTEDOBJTYPE_DLGBOX) &&
					(m_stMCursor.sSelectedObjectID == 17) && (m_stDialogBoxInfo[17].cMode == 20))
				{	// Query Drop Item Amount
					sX = m_stDialogBoxInfo[17].sX;
					sY = m_stDialogBoxInfo[17].sY;
					StartInputString(sX + 40, sY + 57, 11, m_cAmountString);
					m_stDialogBoxInfo[17].cMode = 1;
				}

				if ( m_stMCursor.sSelectedObjectID == 9 )
				{	if( msX < 320 ) m_stDialogBoxInfo[9].sX = 0;
					else m_stDialogBoxInfo[9].sX = 640 - m_stDialogBoxInfo[9].sSizeX;
					if( msY < 213 ) m_stDialogBoxInfo[9].sY = 0;
					else m_stDialogBoxInfo[9].sY = 427 - m_stDialogBoxInfo[9].sSizeY;
				}

				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				m_stMCursor.cSelectedObjectType = NULL;
				m_stMCursor.sSelectedObjectID   = NULL;
				break;

			case DEF_SELECTEDOBJTYPE_ITEM:
				_bCheckDraggingItemRelease(msX, msY);
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				m_stMCursor.cSelectedObjectType = NULL;
				m_stMCursor.sSelectedObjectID   = NULL;
				break;

			default:
				m_stMCursor.cPrevStatus = DEF_CURSORSTATUS_NULL;
				m_stMCursor.cSelectedObjectType = NULL;
				m_stMCursor.sSelectedObjectID   = NULL;
				break;
			}
			return;
		}
		break;
	}

CP_SKIPMOUSEBUTTONSTATUS:;
	if (m_bCommandAvailable == FALSE) return;
	if ( (dwTime - m_dwCommandTime) < 300 )
	{	delete m_pGSock;
		m_pGSock = NULL;
		m_bEscPressed = FALSE;
		PlaySound('E', 14, 5);
		if (m_bSoundFlag) m_pESound[38]->bStop();
		if ((m_bSoundFlag) && (m_bMusicStat == TRUE))
		{	StopBGM();	// Snoopy: mp3 support
			if (m_pBGM != NULL) m_pBGM->bStop();
		}
		if (strlen(G_cCmdLineTokenA) != 0)
			 ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
		return;
	}
	if (m_iHP <= 0) return;

	if (m_sDamageMove != 0)
	{	m_cCommand = DEF_OBJECTDAMAGEMOVE;
		goto MOTION_COMMAND_PROCESS;
	}

	if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == TRUE) && (m_cCommandCount == 0))
		RequestTeleportAndWaitData();

	// indexX, indexY
	if (cLB != 0) // Mouse Left button
	{	if (m_bIsGetPointingMode == TRUE)
		{	if ((m_sMCX != 0) || (m_sMCY != 0))
				 PointCommandHandler(m_sMCX, m_sMCY);
			else PointCommandHandler(indexX, indexY);

			m_bCommandAvailable  = FALSE;
			m_dwCommandTime = timeGetTime();
			m_bIsGetPointingMode = FALSE;
			return;
		}

		m_pMapData->bGetOwner(m_sMCX, m_sMCY-1, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID); // v1.4
		//m_pMapData->m_pData[dX][dY].m_sItemSprite
		if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && ( sObjectType <= 6 || m_pMapData->m_pData[m_sPlayerX-m_pMapData->m_sPivotX][m_sPlayerY-m_pMapData->m_sPivotY].m_sItemSprite != 0 ))
		{//if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && ( sObjectType <= 6 || m_pMapData->m_pData[15][15].m_sItemSprite != 0 )) {
		 //if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && sObjectType <= 6){
			if ((m_sPlayerType >= 1) && (m_sPlayerType <= 6)/* && ((m_sPlayerAppr2 & 0xF000) == 0)*/)
			{	m_cCommand = DEF_OBJECTGETITEM;
				m_sCommX = m_sPlayerX;
				m_sCommY = m_sPlayerY;
			}
		}else
		{	if( memcmp(m_cMCName, m_cPlayerName, 10) == 0 ) m_sMCY -= 1;
			if ((m_sMCX != 0) && (m_sMCY != 0)) // m_sMCX, m_sMCY
			{	if (m_bCtrlPressed == TRUE)
				{	m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
					if ( (iObjectStatus & 0x10) != 0) return;
					if ((sObjectType == 15) || (sObjectType == 20) || (sObjectType == 24)) return;
					m_stMCursor.sCursorFrame = 3;
					absX = abs(m_sPlayerX - m_sMCX);
					absY = abs(m_sPlayerY - m_sMCY);
					if ((absX <= 1) && (absY <= 1))
					{	wType = _iGetAttackType();
						m_cCommand = DEF_OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
					}else if ( (absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
							&& ((sObjectType == 66)||(sObjectType == 73)||(sObjectType == 81)||(sObjectType == 91)))
					{	wType = _iGetAttackType();
						m_cCommand = DEF_OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
					}else // Pas au corp à corp
					{	switch (_iGetWeaponSkillType()) {
						case 6: // Bow
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
							break;

						case 5: // OpenHand
						case 7: // SS
							if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0)))
							{	if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
								{	if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
									{	m_cCommand = DEF_OBJECTATTACKMOVE;
										wType = _iGetAttackType();
									}else
									{	m_cCommand = DEF_OBJECTRUN;
										GetPlayerTurn();
									}
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}else
								{	m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}else
							{	if (   (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)
									&& (m_sPlayerType >= 1) && (m_sPlayerType <= 6))
									 m_cCommand = DEF_OBJECTRUN;	// Staminar
								else m_cCommand = DEF_OBJECTMOVE;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								GetPlayerTurn();
							}
							break;

						case 8: // LS
							if (   (absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)
								&& (_iGetAttackType() != 30)) // Crit without StormBlade
							{	wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}else if ( (absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)
								&& (_iGetAttackType() == 30))  // Crit with StormBlade (by Snoopy)
							{	wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}else if ( (absX <= 3) && (absY <= 3)
								&& (_iGetAttackType() == 5))  // Normal hit with StormBlade (by Snoopy)
							{	wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}else // Swing
							{	if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))
									&& (_iGetAttackType() != 5)) // no Dash possible with StormBlade
								{	if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
									{	if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
										{	m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}else
										{	m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}else
									{	m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}else
								{	if (   (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)
										&& (m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										 m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
							}	}
							break;

						case 9: // Fencing
							if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE))
							{	m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)) {
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										 m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							break;

						case 10: // Axe
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) 
							{	m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}else
							{	if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) 
								{	if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)) 
									{	if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) 
										{	m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}else 
										{	m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}else 
									{	m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}else
								{	if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										 m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
							}	}
							break;
						case 14: // Hammer
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)) {
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										 m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
							}	}
							break;
						case 21: // Wand
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							else {
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))) {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)) {
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100) {
											m_cCommand = DEF_OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else {
											m_cCommand = DEF_OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else {
										m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else {
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
										(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										 m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
							}
							break;
						}
					}
				}else // CTRL not pressed
				{	m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
					if (sObjectType >= 10 || ((sObjectType >= 1) && (sObjectType <= 6)))
					{	switch (sObjectType) { 	// CLEROTH - NPC TALK
						case 15: // ShopKeeper-W°
							/*switch (cName[0]) {
							case '1':*/
								EnableDialogBox(20, 5, 11, 1);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 15;
							/*	break;
							}*/
							break;

						case 19: // Gandlf
							/*switch (cName[0]) {
							case '1':*/
								EnableDialogBox(20, 0, 16, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 19;
							/*	break;
						 	}*/
							break;

						case 20: // Howard
							/*switch (cName[0]) {
							case '1':*/
								EnableDialogBox(20, 0, 14, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 20;
								m_stDialogBoxInfo[39].sV3 = 20;
								m_stDialogBoxInfo[39].sV4 = m_wCommObjectID;
								m_stDialogBoxInfo[39].sV5 = m_sMCX;
								m_stDialogBoxInfo[39].sV6 = m_sMCY;
							/*	break;
						 	}*/
							break;

						case 24: // Tom
							/*switch (cName[0]) {
							case '1':*/
								EnableDialogBox(20, 5, 11, 2);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 24;
								m_stDialogBoxInfo[39].sV3 = 24;
								m_stDialogBoxInfo[39].sV4 = m_wCommObjectID;
								m_stDialogBoxInfo[39].sV5 = m_sMCX;
								m_stDialogBoxInfo[39].sV6 = m_sMCY;
							/*	break;
						 	}*/
							break;

						case 25: // William
							/*switch (cName[0]) {
							case '1':*/
								EnableDialogBox(20, 0, 13, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 25;
							/*	break;
						 	}*/
							break;

						case 26: // Kennedy
							/*switch (cName[0]) {
							case '1':*/
								EnableDialogBox(20, 0, 7, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 26;
							/*	break;
						 	}*/
							break;

						case 21: // Guard
							if ((_iGetFOE(iObjectStatus)>=0) && (!m_bIsCombatMode)) 
							{	EnableDialogBox(20, 4, NULL, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 21;
							}
							break;
						case 67: // McGaffin
						case 68: // Perry
						case 69: // Devlin
							if (!m_bIsCombatMode)
							{	EnableDialogBox(20, 4, NULL, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = sObjectType;
							}
							break;

						case 32: // Unicorn
							if (!m_bIsCombatMode)
							{	EnableDialogBox(20, 4, NULL, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 32;
							}
							break;

						case 90: // Snoopy: Gail
							/*switch (cName[0]) {
							case '1':*/
								EnableDialogBox(20, 6, 0, NULL);
								tX = msX - 117;
								tY = msY - 50;
								if (tX < 0) tX = 0;
								if ((tX + 235) > 639) tX = 639 - 235;
								if (tY < 0) tY = 0;
								if ((tY + 100) > 479) tY = 479 - 100;
								m_stDialogBoxInfo[20].sX  = tX;
								m_stDialogBoxInfo[20].sY  = tY;
								m_stDialogBoxInfo[20].sV3 = 90;
								/*break;
						 	}*/
							break;

						default: // Other mobs
							if ( _iGetFOE(iObjectStatus) >= 0 ) break;
							if ( (sObjectType>=1) && (sObjectType<=6) && (m_bForceAttack==FALSE) ) break;
							absX = abs(m_sPlayerX - m_sMCX);
							absY = abs(m_sPlayerY - m_sMCY);
							if ((absX <= 1) && (absY <= 1))
							{	wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}else if ( (absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
							&& ((sObjectType == 66)||(sObjectType == 73)||(sObjectType == 81)||(sObjectType == 91)))
							{	wType = _iGetAttackType();
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}else // Normal hit from a range.
							{	switch (_iGetWeaponSkillType()) {
								case 6: // Bow
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
									break;

								case 5: // Boxe
								case 7: // SS
									if (   (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)
										&& (m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = DEF_OBJECTRUN;
									else m_cCommand = DEF_OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
									break;

								case 8: // LS
									if (   (absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)
										&& (_iGetAttackType() != 30)) // Crit without StormBlade by Snoopy
									{	if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											 m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}else if ((absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)
										   && (_iGetAttackType() == 30)) // Crit with StormBlade by Snoopy
									{	if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											 m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}else if ((absX <= 3) && (absY <= 3)
										   && (_iGetAttackType() == 5)) // Normal hit with StormBlade by Snoopy
									{	m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}else
									{	if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;

								case 9: // Fencing
									if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE))
									{	if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											 m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}else
									{	if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;

								case 10: //
									if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											 m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;
								case 14: //
									if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											 m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;
								case 21: //
									if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
										if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
											 m_cCommand = DEF_OBJECTATTACKMOVE;
										else m_cCommand = DEF_OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
									}
									else {
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = DEF_OBJECTRUN;
										else m_cCommand = DEF_OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
									break;
								}
							}
							break;
						}
					}
					else {
						if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
							(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
							 m_cCommand = DEF_OBJECTRUN;
						else m_cCommand = DEF_OBJECTMOVE;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
						GetPlayerTurn();
					}
				}
			}else
			{	if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
					(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
					 m_cCommand = DEF_OBJECTRUN;
				else m_cCommand = DEF_OBJECTMOVE;
				m_sCommX = indexX;
				m_sCommY = indexY;
				GetPlayerTurn();
			}
		}
	}else if (cRB != 0) // Mouse Right button
	{	m_cCommand = DEF_OBJECTSTOP;
		if (m_bIsGetPointingMode == TRUE)
		{	m_bIsGetPointingMode = FALSE;
			AddEventList(COMMAND_PROCESSOR1, 10);
		}
		if (m_bCommandAvailable == FALSE) return;
		if (m_cCommandCount >= 6) return;

		if ((m_sMCX != 0) && (m_sMCY != 0))
		{	absX = abs(m_sPlayerX - m_sMCX);
			absY = abs(m_sPlayerY - m_sMCY);
			if( absX==0 && absY==0 ) return;

			if (m_bCtrlPressed == TRUE)
			{	m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
				if ( (iObjectStatus & 0x10) != 0) return;
				if ((sObjectType == 15) || (sObjectType == 20) || (sObjectType == 24)) return;

				if ((absX <= 1) && (absY <= 1))
				{	wType = _iGetAttackType();
					m_cCommand = DEF_OBJECTATTACK;
					m_sCommX = m_sMCX;
					m_sCommY = m_sMCY;
				}else if ( (absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
							&& ((sObjectType == 66)||(sObjectType == 73)||(sObjectType == 81)||(sObjectType == 91)))
				{	wType = _iGetAttackType();
					m_cCommand = DEF_OBJECTATTACK;
					m_sCommX = m_sMCX;
					m_sCommY = m_sMCY;
				}else
				{	switch (_iGetWeaponSkillType()) {
					case 6: // Bow
						m_cCommand = DEF_OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
						wType = _iGetAttackType();
						break;

					case 5: // Boxe
					case 7: // SS
						break;

					case 8: // LS
						if (   (absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)
							&& (_iGetAttackType() != 30)) // without StormBlade by Snoopy
						{	wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}else if (   (absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)
							&& (_iGetAttackType() == 30)) // with stormBlade crit by Snoopy
						{	wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}else if (   (absX <= 3) && (absY <= 3)
							&& (_iGetAttackType() == 5)) // with stormBlade no crit by Snoopy
						{	wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}
						break;

					case 9: // Fencing
						if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;

					case 10: //
						if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;

					case 14: //
						if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;
					case 21: //
						if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						break;
					}
				}
			}else // CTRL not pressed
			{	absX = abs(m_sPlayerX - m_sMCX);
				absY = abs(m_sPlayerY - m_sMCY);
				m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
				if (sObjectType >= 10 || ((sObjectType >= 1) && (sObjectType <= 6))) {
					switch (sObjectType) {
					case 15:
					case 19:
					case 20:
					case 24:
					case 25:
					case 26: // npcs
						break;

					default: // All "normal mobs"
						if ( _iGetFOE(iObjectStatus) >= 0 ) break;
						if ( (sObjectType>=1) && (sObjectType<=6) && (m_bForceAttack==FALSE) ) break;
						if ((absX <= 1) && (absY <= 1))
						{	wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}else if ( (absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
							&& ((sObjectType == 66)||(sObjectType == 73)||(sObjectType == 81)||(sObjectType == 91)))
						{	wType = _iGetAttackType();
							m_cCommand = DEF_OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
						}else //
						{	switch (_iGetWeaponSkillType()) {
							case 6: // Bow
								m_cCommand = DEF_OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
								break;

							case 5: // Boxe
							case 7: // SS
								break;

							case 8: // LS
								if (   (absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)
									&& (_iGetAttackType() != 30)) // crit without StormBlade by Snoopy
								{	wType = _iGetAttackType();
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}else if (   (absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)
									&& (_iGetAttackType() == 30)) // with stormBlade crit by Snoopy
								{	wType = _iGetAttackType();
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}else if (   (absX <= 3) && (absY <= 3)
									&& (_iGetAttackType() == 5)) // with stormBlade no crit by Snoopy
								{	wType = _iGetAttackType();
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								break;

							case 9: // fencing
								if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;

							case 10: //
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;
							case 14: // hammer
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;
							case 21: // wand
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE)) {
									m_cCommand = DEF_OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								break;
						}	}
						break;
			}	}	}
		}else
		{	cDir = m_Misc.cGetNextMoveDir(m_sPlayerX, m_sPlayerY, indexX, indexY);
			if (m_iHP <= 0) return;
			if (cDir == 0) return;
			if (m_cPlayerDir  == cDir) return;
			ClearSkillUsingStatus();
			m_cPlayerDir = cDir;
			if( m_bFullParalyze ) return;
			bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTSTOP, m_cPlayerDir, NULL, NULL, NULL, NULL);

			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
							                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
											  m_iPlayerStatus, m_cPlayerName,
											  m_cCommand, NULL, NULL, NULL, 0,
											  10);
			m_bCommandAvailable = FALSE;
			m_dwCommandTime = timeGetTime();
			return;
	}	}

MOTION_COMMAND_PROCESS:;

	if (m_cCommand != DEF_OBJECTSTOP)
	{	if (m_iHP <= 0) return;
		if (m_cCommandCount == 5) AddEventList(COMMAND_PROCESSOR2, 10, FALSE);
		if (m_bCommandAvailable == FALSE) return;
		if (m_cCommandCount >= 6) return;

		if (m_sPlayerType > 6)
		{	switch (m_cCommand) {
			case DEF_OBJECTRUN:
			case DEF_OBJECTMAGIC:
			case DEF_OBJECTGETITEM:
				m_cCommand = DEF_OBJECTSTOP;
				break;
			case DEF_OBJECTDAMAGEMOVE:
			case DEF_OBJECTATTACKMOVE:
				m_cCommand = DEF_OBJECTMOVE;

		}	}

		ClearSkillUsingStatus();

		if (m_sDamageMove != 0)
		{	m_cCommand = DEF_OBJECTDAMAGEMOVE;
			m_sCommX = m_sPlayerX;
			m_sCommY = m_sPlayerY;

			switch (m_sDamageMove) {
			case 1: m_sCommY--; break;
			case 2: m_sCommX++; m_sCommY--; break;
			case 3: m_sCommX++; break;
			case 4: m_sCommX++; m_sCommY++; break;
			case 5: m_sCommY++; break;
			case 6: m_sCommX--; m_sCommY++; break;
			case 7: m_sCommX--; break;
			case 8: m_sCommX--; m_sCommY--; break;
			}

			for (i = 1; i < DEF_MAXCHATMSGS; i++)
			if (m_pChatMsgList[i] == NULL)
			{	ZeroMemory(cTxt, sizeof(cTxt));


#ifdef DEF_EQUILIBRIUM_PROJECT // damages critical a 200+
				short sV1 = m_sDamageMoveAmount;
				if (sV1 < 0) sV1 = 256 + sV1;
				if (sV1 >= 200) strcpy(cTxt, COMMAND_PROCESSOR6); // "Critical!"
				else			wsprintf(cTxt, "-%dPts", sV1); //pts
				int iFontType;	
				if ((sV1 >= 0) && (sV1 < 20))		iFontType = 21;
				else if ((sV1 >= 20) && (sV1 < 50)) iFontType = 22;
				else if ((sV1 >= 50) || (sV1 < 0))	iFontType = 23;
#else				
				if (m_sDamageMoveAmount > 0)
					wsprintf(cTxt, "-%dPts", m_sDamageMoveAmount); //pts
				else strcpy(cTxt, COMMAND_PROCESSOR6); // "Critical!"
				int iFontType;	
				if ((m_sDamageMoveAmount >= 0) && (m_sDamageMoveAmount < 12))		iFontType = 21;
				else if ((m_sDamageMoveAmount >= 12) && (m_sDamageMoveAmount < 40)) iFontType = 22;
				else if ((m_sDamageMoveAmount >= 40) || (m_sDamageMoveAmount < 0))	iFontType = 23;
#endif
		
				m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
				m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;

				if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == FALSE) 
				{	delete m_pChatMsgList[i];
					m_pChatMsgList[i] = NULL;
				}
				break;
			}
			m_sDamageMove = 0;
		}

		switch (m_cCommand) {
		case DEF_OBJECTRUN:
		case DEF_OBJECTMOVE:
		case DEF_OBJECTDAMAGEMOVE: // v1.43

			if( m_bParalyze ) return;
			if( m_bHackMoveBlocked ) return;
			bGORet = m_pMapData->bGetOwner(m_sCommX, m_sCommY, pDstName, &sDstOwnerType, &iDstOwnerStatus, &m_wCommObjectID); // v1.4

			if ((m_sPlayerX == m_sCommX) && (m_sPlayerY == m_sCommY))
				m_cCommand = DEF_OBJECTSTOP;
			else if ( (abs(m_sPlayerX - m_sCommX) <= 1) && (abs(m_sPlayerY - m_sCommY) <= 1) &&
				      (bGORet == TRUE) && (sDstOwnerType != NULL) )
				m_cCommand = DEF_OBJECTSTOP;
			else if((abs(m_sPlayerX - m_sCommX) <= 2) && (abs(m_sPlayerY - m_sCommY) <= 2) &&
				(m_pMapData->m_tile[m_sCommX][m_sCommY].m_bIsMoveAllowed == FALSE))
				m_cCommand = DEF_OBJECTSTOP;
			else
			{	if (( m_cCommand == DEF_OBJECTMOVE ) && (m_sPlayerType <= 6))
				{	if(m_bRunningMode || m_bShiftPressed) m_cCommand = DEF_OBJECTRUN;
				}
				if( m_cCommand == DEF_OBJECTRUN )
				{	if( (m_bRunningMode == FALSE) && (m_bShiftPressed == FALSE) ) m_cCommand = DEF_OBJECTMOVE;
					// Snoopy EP special!

#ifdef DEF_EQUILIBRIUM_PROJECT // RunMode + 2" = move 
					if( (m_bRunningMode == TRUE) && (m_bVK_OEM_7Pressed == TRUE) ) m_cCommand = DEF_OBJECTMOVE;	
#endif

					if( m_iSP < 1 ) m_cCommand = DEF_OBJECTMOVE;
				}

				cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, TRUE);
				// Snoopy: Illusion Movement
			/*	if ((m_bIllusionMVT == TRUE) && (m_cCommand != DEF_OBJECTDAMAGEMOVE))
				{	cDir +=4;
					if (cDir >8) cDir -=8;
				}*/
				// Snoopy: Illusion Movement
				if ((m_bIllusionMVT == TRUE) && (m_cCommand != DEF_OBJECTDAMAGEMOVE))
				{	cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, TRUE, TRUE);
				}
				if (cDir != 0)
				{	m_cPlayerDir = cDir;
					bSendCommand(MSGID_COMMAND_MOTION, m_cCommand, cDir, NULL, NULL, NULL, NULL);
					switch (cDir) {
					case 1:	m_sPlayerY--; break;
					case 2:	m_sPlayerY--; m_sPlayerX++;	break;
					case 3:	m_sPlayerX++; break;
					case 4:	m_sPlayerX++; m_sPlayerY++;	break;
					case 5:	m_sPlayerY++; break;
					case 6:	m_sPlayerX--; m_sPlayerY++;	break;
					case 7:	m_sPlayerX--; break;
					case 8:	m_sPlayerX--; m_sPlayerY--;	break;
					}
					m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
						                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
										  m_iPlayerStatus, m_cPlayerName,
										  m_cCommand, NULL, NULL, NULL);
					m_bCommandAvailable = FALSE;
					m_dwCommandTime = timeGetTime();
					m_iPrevMoveX = m_sPlayerX;
					m_iPrevMoveY = m_sPlayerY;
			}	}

			if (m_cCommand == DEF_OBJECTDAMAGEMOVE)
			{	m_bIsGetPointingMode = FALSE;
				m_iPointCommandType	 = -1;
				m_stMCursor.sCursorFrame = 0;
				ClearSkillUsingStatus();
				m_cCommand = DEF_OBJECTSTOP;
			}
			break;

		case DEF_OBJECTATTACK:
			if( m_bFullParalyze ) return;
			cDir = m_Misc.cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY);
			// Snoopy: Illusion movement
			if (m_bIllusionMVT == TRUE)
			{	cDir +=4;
				if (cDir >8) cDir -=8;
			}
			if (cDir != 0)
			{	if ((wType == 2) || (wType == 25))
				{	if (_bCheckItemByType(DEF_ITEMTYPE_ARROW) == FALSE)
						wType = 0;
				}
				if (wType >= 20)
				{	m_iSuperAttackLeft--;
					if (m_iSuperAttackLeft < 0) m_iSuperAttackLeft = 0;
				}
				m_cPlayerDir = cDir;
				bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTATTACK, cDir, m_sCommX, m_sCommY, wType, NULL, m_wCommObjectID);
				m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
					                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
									  m_iPlayerStatus, m_cPlayerName,
									  DEF_OBJECTATTACK,
									  m_sCommX - m_sPlayerX, m_sCommY - m_sPlayerY, wType);
				m_bCommandAvailable = FALSE;
				m_dwCommandTime = timeGetTime();
			}
			m_cCommand = DEF_OBJECTSTOP;
			break;

		case DEF_OBJECTATTACKMOVE:
			if( m_bParalyze ) return;
			if( m_bHackMoveBlocked ) return;
			bGORet = m_pMapData->bGetOwner(m_sCommX, m_sCommY, pDstName, &sDstOwnerType, &iDstOwnerStatus, &m_wCommObjectID);
			if ((m_sPlayerX == m_sCommX) && (m_sPlayerY == m_sCommY))
				m_cCommand = DEF_OBJECTSTOP;
			else if ( (abs(m_sPlayerX - m_sCommX) <= 1) && (abs(m_sPlayerY - m_sCommY) <= 1) &&
				      (bGORet == TRUE) && (sDstOwnerType != NULL) )
				m_cCommand = DEF_OBJECTSTOP;
			else
			{	cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, TRUE);
				// Snoopy: Illusion mvt
			/*	if (m_bIllusionMVT == TRUE)
				{	cDir +=4;
					if (cDir >8) cDir -=8;
				}*/
				if (m_bIllusionMVT == TRUE)
				{	cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, TRUE, TRUE);
				}
				if (cDir != 0)
				{	m_cPlayerDir = cDir;
					bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTATTACKMOVE, cDir, m_sCommX, m_sCommY, wType, NULL, m_wCommObjectID);
					switch (cDir) {
					case 1:	m_sPlayerY--; break;
					case 2:	m_sPlayerY--; m_sPlayerX++;	break;
					case 3:	m_sPlayerX++; break;
					case 4:	m_sPlayerX++; m_sPlayerY++;	break;
					case 5:	m_sPlayerY++; break;
					case 6:	m_sPlayerX--; m_sPlayerY++;	break;
					case 7:	m_sPlayerX--; break;
					case 8:	m_sPlayerX--; m_sPlayerY--;	break;
					}

					m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
						                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
										  m_iPlayerStatus, m_cPlayerName,
										  m_cCommand, m_sCommX - m_sPlayerX, m_sCommY - m_sPlayerY, wType);
					m_bCommandAvailable = FALSE;
					m_dwCommandTime = timeGetTime();
					m_iPrevMoveX = m_sPlayerX;
					m_iPrevMoveY = m_sPlayerY;
			}	}
			m_cCommand = DEF_OBJECTSTOP;
			break;

		case DEF_OBJECTGETITEM:
			if( m_bFullParalyze ) return;
			bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTGETITEM, m_cPlayerDir, NULL, NULL, NULL, NULL);
			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
				                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
								  m_iPlayerStatus, m_cPlayerName,
								  DEF_OBJECTGETITEM, NULL, NULL, NULL);
			m_bCommandAvailable = FALSE;
			m_cCommand = DEF_OBJECTSTOP;
			break;

		case DEF_OBJECTMAGIC:
			if( m_bFullParalyze ) return;
			bSendCommand(MSGID_COMMAND_MOTION, DEF_OBJECTMAGIC, m_cPlayerDir, m_iCastingMagicType, NULL, NULL, NULL);
			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
				                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
								  m_iPlayerStatus, m_cPlayerName,
								  DEF_OBJECTMAGIC, m_iCastingMagicType, NULL, NULL);
			m_bCommandAvailable = FALSE;
			m_dwCommandTime = timeGetTime();
			m_bIsGetPointingMode = TRUE;
			m_cCommand = DEF_OBJECTSTOP;
			_RemoveChatMsgListByObjectID(m_sPlayerObjectID);
			for (i = 1; i < DEF_MAXCHATMSGS; i++)
			if (m_pChatMsgList[i] == NULL)
			{	ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt, "%s!", m_pMagicCfgList[m_iCastingMagicType]->m_cName);
				m_pChatMsgList[i] = new class CMsg(41, cTxt, timeGetTime());
				m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;
				m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i);
				return;
			}
			break;

		default:
			break;
	}	}
}

void CGame::DrawDialogBox_Bank(short msX, short msY, short msZ, char cLB)
{	short sX, sY, szX;
	int  i, iTotalLines, iPointerLoc, iLoc;
	double d1, d2, d3;
	char cItemColor, cStr1[64], cStr2[64], cStr3[64];
	BOOL bFlag = FALSE;

	sX = m_stDialogBoxInfo[14].sX;
	sY = m_stDialogBoxInfo[14].sY;
	szX = m_stDialogBoxInfo[14].sSizeX - 5;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 21);
	ZeroMemory( cStr1, sizeof(cStr1) );
	ZeroMemory( cStr2, sizeof(cStr2) );
	ZeroMemory( cStr3, sizeof(cStr3) );
	iLoc = 45;

	switch (m_stDialogBoxInfo[14].cMode) {
	case -1:
		PutString(sX + 30 + 15, sY + 70, DRAW_DIALOGBOX_BANK1, RGB(0,0,0));//"
		PutString(sX + 30 + 15, sY + 85, DRAW_DIALOGBOX_BANK2, RGB(0,0,0));//"
		break;

	case 0:
		for (i = 0; i < m_stDialogBoxInfo[14].sV1; i++)
		if ((m_pBankList[i + m_stDialogBoxInfo[14].sView] != NULL) && ((i + m_stDialogBoxInfo[14].sView) < DEF_MAXBANKITEMS)) {
			GetItemName(m_pBankList[i + m_stDialogBoxInfo[14].sView], cStr1, cStr2, cStr3);
			if ((msX > sX + 30) && (msX < sX + 210) && (msY >= sY + 110 + i*15) && (msY <= sY + 124 + i*15))
			{
				bFlag = TRUE;

				PutAlignedString(sX, sX+szX, sY + 110 + i*15, cStr1, 255, 255, 255 );
				if(m_bIsSpecial)
					PutAlignedString(sX + 70, sX + szX, sY + iLoc, cStr1, 0, 255, 50 );
				else
					PutAlignedString(sX + 70, sX + szX, sY + iLoc, cStr1, 255, 255, 255 );

				if( strlen(cStr2) > 0 )
				{
					iLoc += 15;
					PutAlignedString(sX + 70, sX + szX, sY + iLoc, cStr2, 150, 150, 150 );
				}
				if( strlen(cStr3) > 0 )
				{
					iLoc += 15;
					PutAlignedString(sX + 70, sX + szX, sY + iLoc, cStr3, 150, 150, 150 );
				}
				if( m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sLevelLimit != 0 && m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_dwAttribute & 0x00000001 )
				{
					iLoc += 15;
					wsprintf( G_cTxt, "%s: %d", DRAW_DIALOGBOX_SHOP24, m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sLevelLimit );
					PutAlignedString(sX + 70, sX + szX, sY + iLoc, G_cTxt, 150, 150, 150 );
				}

				if( (m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cEquipPos != DEF_EQUIPPOS_NONE) && (m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_wWeight>=1100) )
				{
					iLoc += 15;
					int		_wWeight = 0;
					if(m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_wWeight%100)				_wWeight = 1;
					wsprintf( G_cTxt, DRAW_DIALOGBOX_SHOP15, m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_wWeight/100 + _wWeight);

					PutAlignedString(sX + 70, sX + szX, sY + iLoc, G_cTxt, 150, 150, 150 );
				}

				cItemColor = m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cItemColor;
				if( cItemColor == 0 )
				{	 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSprite]->PutSpriteFast(sX+60, sY+68, m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSpriteFrame, m_dwCurTime);
				}else
				{	if (   (m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
						|| (m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cEquipPos == DEF_EQUIPPOS_RHAND)
						|| (m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
					{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSprite]->PutSpriteRGB(sX+60, sY+68, m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSpriteFrame,
																			m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
					}else m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSprite]->PutSpriteRGB(sX+60, sY+68, m_pBankList[i + m_stDialogBoxInfo[14].sView]->m_sSpriteFrame,
																			m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
				}
			}else
			{	if (m_bIsSpecial)
					PutAlignedString(sX, sX+szX, sY + 110 + i*15, cStr1, 0, 255, 50 );
				else
					PutAlignedString(sX, sX+szX, sY + 110 + i*15, cStr1, 0, 0, 0 );
		}	}

		iTotalLines = 0;
		for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pBankList[i] != NULL) iTotalLines++;
		if (iTotalLines > m_stDialogBoxInfo[14].sV1)
		{	d1 = (double)m_stDialogBoxInfo[14].sView;
			d2 = (double)(iTotalLines-m_stDialogBoxInfo[14].sV1);
			d3 = (274.0f * d1)/d2;
			iPointerLoc = (int)d3;
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX+242, sY + iPointerLoc + 35, 7);
		}
		else iPointerLoc = 0;
		if (cLB != 0 && (iGetTopDialogBoxIndex() == 14) && iTotalLines > m_stDialogBoxInfo[14].sV1) {
			if ((msX >= sX + 230) && (msX <= sX + 260) && (msY >= sY + 40) && (msY <= sY + 320)) {
				d1 = (double)(msY -(sY+35));
				d2 = (double)(iTotalLines-m_stDialogBoxInfo[14].sV1);
				d3 = (d1 * d2)/274.0f;
				m_stDialogBoxInfo[14].sView = (int)(d3+0.5);
			}
			else if ((msX >= sX + 230) && (msX <= sX + 260) && (msY > sY + 10) && (msY < sY + 40)) m_stDialogBoxInfo[14].sView = 0;
		}
		else m_stDialogBoxInfo[14].bIsScrollSelected = FALSE;
		if( iGetTopDialogBoxIndex() == 14 && msZ != 0 )
		{
			if( iTotalLines > 50 ) m_stDialogBoxInfo[14].sView = m_stDialogBoxInfo[14].sView - msZ/30;
			else {//
				if( msZ > 0 ) m_stDialogBoxInfo[14].sView--;
				if( msZ < 0 ) m_stDialogBoxInfo[14].sView++;
			}
			m_DInput.m_sZ = 0;
		}
		if( iTotalLines > m_stDialogBoxInfo[14].sV1 && m_stDialogBoxInfo[14].sView > iTotalLines-m_stDialogBoxInfo[14].sV1 ) m_stDialogBoxInfo[14].sView = iTotalLines-m_stDialogBoxInfo[14].sV1;
		if( iTotalLines <= m_stDialogBoxInfo[14].sV1 ) m_stDialogBoxInfo[14].sView = 0;
		if( m_stDialogBoxInfo[14].sView < 0 ) m_stDialogBoxInfo[14].sView = 0;
		if( bFlag == FALSE )
		{
			PutAlignedString(sX, sX+szX, sY + 45, DRAW_DIALOGBOX_BANK3);
			PutAlignedString(sX, sX+szX, sY + 60, DRAW_DIALOGBOX_BANK4);
			PutAlignedString(sX, sX+szX, sY + 75, DRAW_DIALOGBOX_BANK5);
		}
		break;
	}
}

void CGame::DrawDialogBox_FeedBackCard(short msX, short msY)
{}

void CGame::DrawDialogBox_Character(short msX, short msY)
{short sX, sY, sSprH, sFrame;
 int i, iR, iG, iB, iSkirtDraw = 0;
 char cTxt2[120], cEquipPoiStatus[DEF_MAXITEMEQUIPPOS];
 char  cItemColor, cCollison;

	sX = m_stDialogBoxInfo[1].sX;
	sY = m_stDialogBoxInfo[1].sY;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 0, FALSE, m_bDialogTrans);

	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	strcpy(G_cTxt, m_cPlayerName);
	strcat(G_cTxt, " : ");

	if (m_iPKCount > 0) {
		ZeroMemory(cTxt2, sizeof(cTxt2));
		wsprintf(cTxt2, DRAW_DIALOGBOX_CHARACTER1, m_iPKCount);
		strcat(G_cTxt, cTxt2);
	}

	ZeroMemory(cTxt2, sizeof(cTxt2));
	wsprintf(cTxt2, DRAW_DIALOGBOX_CHARACTER2, m_iContribution);
	strcat(G_cTxt, cTxt2);
	PutAlignedString(sX +24, sX +252, sY+52, G_cTxt, 45,20,20);
	ZeroMemory(G_cTxt, sizeof(G_cTxt));

#ifdef DEF_EQUILIBRIUM_PROJECT // executor on F5 menu
	if( m_bCitizen == FALSE )
	{	if  (m_bHunter)
			 strcpy( G_cTxt, DRAW_DIALOGBOX_CHARACTER7); // "Traveller"
		else
		{	strcpy( G_cTxt, "Executor");
			if( m_iGuildRank >= 0 )
			{	strcat( G_cTxt, "(" );
				strcat( G_cTxt, m_cGuildName );
				if( m_iGuildRank == 0 ) strcat( G_cTxt, DEF_MSG_GUILDMASTER1 );
				else strcat( G_cTxt, DEF_MSG_GUILDSMAN1 ); // " Guildsman)"
		}	}
	}else
#else
	if( m_bCitizen == FALSE )
	{	strcpy( G_cTxt, DRAW_DIALOGBOX_CHARACTER7); // "Traveller"
	}else
#endif
	{	if(m_bHunter)
		{	if (m_bAresden)
				 strcat(G_cTxt, DEF_MSG_ARECIVIL); //
			else strcat(G_cTxt, DEF_MSG_ELVCIVIL); // "Elvine Civilian"
		}else
		{	if (m_bAresden)
				 strcat(G_cTxt, DEF_MSG_ARESOLDIER); //
			else strcat(G_cTxt, DEF_MSG_ELVSOLDIER); //
		}
		if( m_iGuildRank >= 0 )
		{	strcat( G_cTxt, "(" );
			strcat( G_cTxt, m_cGuildName );
			if( m_iGuildRank == 0 ) strcat( G_cTxt, DEF_MSG_GUILDMASTER1 );
			else strcat( G_cTxt, DEF_MSG_GUILDSMAN1 ); // " Guildsman)"
	}	}

	PutAlignedString(sX, sX+275, sY+69, G_cTxt, 45,25,25);

	int iTemp;
	// Level
	wsprintf(G_cTxt, "%d", m_iLevel);
	PutAlignedString(sX+180, sX+250, sY + 106, G_cTxt, 45,25,25);
	// Exp
	wsprintf(G_cTxt, "%d", m_iExp);
	PutAlignedString(sX+180, sX+250, sY + 125, G_cTxt, 45,25,25);
	// Next.Exp
	wsprintf(G_cTxt, "%d", iGetLevelExp(m_iLevel+1));
	PutAlignedString(sX+180, sX+250, sY + 142, G_cTxt, 45,25,25);

	// Hp
	iTemp = m_iHP;
#ifdef DEF_EQUILIBRIUM_PROJECT // HPs formula
	wsprintf(G_cTxt, "%d/%d", iTemp, m_iVit*3 + (m_iLevel*3 + (m_iStr + m_iAngelicStr))/2);
#else
	wsprintf(G_cTxt, "%d/%d", iTemp, m_iVit*3 + m_iLevel*2 + (m_iStr + m_iAngelicStr)/2);
#endif
	PutAlignedString(sX+180, sX+250, sY + 173, G_cTxt, 45,25,25);

	// Mp
	iTemp = m_iMP;
	wsprintf(G_cTxt, "%d/%d", iTemp, (m_iMag + m_iAngelicMag)*2 + m_iLevel*2 + (m_iInt + m_iAngelicInt)/2);
	PutAlignedString(sX+180, sX+250, sY + 191, G_cTxt, 45,25,25);

	// Sp
	iTemp = m_iSP;
	wsprintf(G_cTxt, "%d/%d", iTemp, m_iLevel*2 + (m_iStr + m_iAngelicStr)*2);
	PutAlignedString(sX+180, sX+250, sY + 208, G_cTxt, 45,25,25);

	// Max.Load
	wsprintf(G_cTxt, "%d/%d", (_iCalcTotalWeight()/100), ((m_iStr + m_iAngelicStr)*5 + m_iLevel*5));
	PutAlignedString(sX+180, sX+250, sY + 240, G_cTxt, 45,25,25);

	// Enemy Kills
	wsprintf(G_cTxt, "%d", m_iEnemyKillCount);
	PutAlignedString(sX+180, sX+250, sY + 257, G_cTxt, 45,25,25);

	// Str
	if (m_iAngelicStr == 0)
	{	wsprintf(G_cTxt, "%d", m_iStr);
		PutAlignedString(sX+48, sX+82, sY + 285, G_cTxt, 45,25,25);
	}else
	{	wsprintf(G_cTxt, "%d", m_iStr + m_iAngelicStr);
		PutAlignedString(sX+48, sX+82, sY + 285, G_cTxt, 0,0,192);
	}

	// Vit
	wsprintf(G_cTxt, "%d", m_iVit);
	PutAlignedString(sX+218, sX+251, sY + 285, G_cTxt, 45,25,25);

	// Dex
	if (m_iAngelicDex == 0)
	{	wsprintf(G_cTxt, "%d", m_iDex);
		PutAlignedString(sX+48, sX+82, sY +302, G_cTxt, 45,25,25);
	}else
	{	wsprintf(G_cTxt, "%d", m_iDex + m_iAngelicDex);
		PutAlignedString(sX+48, sX+82, sY +302, G_cTxt, 0,0,192);
	}

	// Int
	if (m_iAngelicInt == 0)
	{	wsprintf(G_cTxt, "%d", m_iInt);
		PutAlignedString(sX+135, sX+167, sY +285, G_cTxt, 45,25,25);
	}else
	{	wsprintf(G_cTxt, "%d", m_iInt + m_iAngelicInt);
		PutAlignedString(sX+135, sX+167, sY +285, G_cTxt, 0,0,192);
	}

	// Mag
	if (m_iAngelicMag == 0)
	{	wsprintf(G_cTxt, "%d", m_iMag);
		PutAlignedString(sX+135, sX+167, sY +302, G_cTxt, 45,25,25);
	}else
	{	wsprintf(G_cTxt, "%d", m_iMag + m_iAngelicMag);
		PutAlignedString(sX+135, sX+167, sY +302, G_cTxt, 0,0,192);
	}

	// Chr
	wsprintf(G_cTxt, "%d", m_iCharisma);
	PutAlignedString(sX+218, sX+251, sY +302, G_cTxt, 45,25,25);

	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
		cEquipPoiStatus[i] = -1;

	for (i = 0; i < DEF_MAXITEMS; i++)
	{	if ((m_pItemList[i] != NULL) && (m_bIsItemEquipped[i] == TRUE))	cEquipPoiStatus[ m_pItemList[i]->m_cEquipPos ] = i;
	}
	if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3))
	{	cCollison = -1;
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 0]->PutSpriteFast(sX + 171, sY + 290, m_sPlayerType-1, m_dwCurTime);
		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] == -1)
		{	_GetHairColorRGB(((m_sPlayerAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18]->PutSpriteRGB(sX + 171, sY + 290, (m_sPlayerAppr1 & 0x0F00) >> 8, iR, iG, iB, m_dwCurTime);
		}

		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19]->PutSpriteFast(sX + 171, sY + 290, (m_sPlayerAppr1 & 0x000F), m_dwCurTime);

		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_BACK] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 41, sY + 137, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 41, sY + 137, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 41, sY + 137, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 41, sY + 137, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison( sX + 41, sY + 137, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BACK;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_PANTS] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_PANTS;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_ARMS] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_ARMS;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BOOTS;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1) 
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_BODY] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BODY;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_FULLBODY;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_LHAND] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 90, sY + 170, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 90, sY + 170, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 90, sY + 170, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 90, sY + 170, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 90, sY + 170, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_LHAND;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_RHAND] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 57, sY + 186, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 57, sY + 186, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 57, sY + 186, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 57, sY + 186, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_RHAND;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 57, sY + 186, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 57, sY + 186, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 57, sY + 186, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 57, sY + 186, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_TWOHAND;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_NECK] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 35, sY + 120, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 35, sY + 120, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 35, sY + 120, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 35, sY + 120, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_NECK;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 32, sY + 193, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 32, sY + 193, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 32, sY + 193, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 32, sY + 193, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_RFINGER;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 98, sY + 182, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 98, sY + 182, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 98, sY + 182, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 98, sY + 182, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 98, sY + 182, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_LFINGER;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1)
		{	sSprH      = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_HEAD] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteFast(sX + 72, sY + 135, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 72, sY + 135, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite2(sX + 72, sY + 135, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 72, sY + 135, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 72, sY + 135, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_HEAD;
		}
		if( cCollison != -1 )
		{
			sSprH      = m_pItemList[cEquipPoiStatus[cCollison]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[cCollison]]->m_sSpriteFrame;
			if( cCollison == DEF_EQUIPPOS_HEAD )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 72, sY + 135, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_RFINGER )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 32, sY + 193, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_LFINGER )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 98, sY + 182, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_NECK )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 35, sY + 120, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_TWOHAND )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 57, sY + 186, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_RHAND )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 57, sY + 186, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_LHAND )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 90, sY + 170, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_BODY )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_FULLBODY )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_BOOTS )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_ARMS )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_PANTS )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_BACK )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 41, sY + 137, sFrame, m_dwCurTime);
		}
	}else if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6))
	{	cCollison = -1;
		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 40]->PutSpriteFast(sX + 171, sY + 290, m_sPlayerType-4, m_dwCurTime);

		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] == -1)
		{	_GetHairColorRGB(((m_sPlayerAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 18 +40]->PutSpriteRGB(sX + 171, sY + 290, (m_sPlayerAppr1 & 0x0F00) >> 8, iR, iG, iB, m_dwCurTime);
		}

		m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + 19 +40]->PutSpriteFast(sX + 171, sY + 290, (m_sPlayerAppr1 & 0x000F), m_dwCurTime);

		if ((cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1))
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if ((sSprH == 12) && (sFrame == 0)) iSkirtDraw = 1;
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_BACK] != -1)
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BACK]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_BACK] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 45, sY + 143, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 45, sY + 143, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 45, sY + 143, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 45, sY + 143, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 45, sY + 143, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BACK;
		}

		if ((cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1) && (iSkirtDraw == 1))
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BOOTS;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_PANTS] != -1)
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_PANTS]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_PANTS] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_PANTS;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_ARMS] != -1)
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_ARMS]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_ARMS] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_ARMS;
		}

		if ((cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] != -1) && (iSkirtDraw == 0))
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BOOTS]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_BOOTS] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BOOTS;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_BODY] != -1)
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_BODY]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_BODY] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_BODY;
		}
		if (cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] != -1)
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_FULLBODY] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 171, sY + 290, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_FULLBODY;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_LHAND] != -1)
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LHAND]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_LHAND] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 84, sY + 175, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 84, sY + 175, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 84, sY + 175, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 84, sY + 175, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 84, sY + 175, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_LHAND;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_RHAND] != -1)
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RHAND]]->m_cItemColor;
			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_RHAND] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 60, sY + 191, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 60, sY + 191, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 60, sY + 191, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 60, sY + 191, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_RHAND;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] != -1)
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND]]->m_cItemColor;
			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_TWOHAND] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 60, sY + 191, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 60, sY + 191, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 60, sY + 191, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 60, sY + 191, sFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_TWOHAND;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_NECK] != -1)
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_NECK]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_NECK] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 35, sY + 120, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 35, sY + 120, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 35, sY + 120, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 35, sY + 120, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_NECK;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] != -1)
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_RFINGER]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_RFINGER] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 32, sY + 193, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 32, sY + 193, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 32, sY + 193, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 32, sY + 193, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_RFINGER;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] != -1)
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_LFINGER]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_LFINGER] ] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 98, sY + 182, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 98, sY + 182, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 98, sY + 182, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 98, sY + 182, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 98, sY + 182, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_LFINGER;
		}

		if (cEquipPoiStatus[DEF_EQUIPPOS_HEAD] != -1)
		{	sSprH  = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_sSpriteFrame;
			cItemColor = m_pItemList[cEquipPoiStatus[DEF_EQUIPPOS_HEAD]]->m_cItemColor;

			if (m_bIsItemDisabled[ cEquipPoiStatus[DEF_EQUIPPOS_HEAD]] == FALSE)
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteFast(sX + 72, sY +139, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutSpriteRGB(sX + 72, sY +139, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}else
			{	if (cItemColor == 0)
					 m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite2(sX + 72, sY +139, sFrame, m_dwCurTime);
				else m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSpriteRGB(sX + 72, sY +139, sFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], m_dwCurTime);
			}
			if( m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->_bCheckCollison(sX + 72, sY + 139, sFrame, msX, msY ) )
				cCollison = DEF_EQUIPPOS_HEAD;
		}
		if( cCollison != -1 )
		{	sSprH      = m_pItemList[cEquipPoiStatus[cCollison]]->m_sSprite;
			sFrame     = m_pItemList[cEquipPoiStatus[cCollison]]->m_sSpriteFrame;
			if( cCollison == DEF_EQUIPPOS_HEAD )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 72, sY + 139, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_RFINGER )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 32, sY + 193, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_LFINGER )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 98, sY + 182, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_NECK )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 35, sY + 120, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_TWOHAND )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 60, sY + 191, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_RHAND )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 60, sY + 191, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_LHAND )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 84, sY + 175, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_BODY )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_FULLBODY )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_BOOTS )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_ARMS )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_PANTS )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if( cCollison == DEF_EQUIPPOS_BACK )
				m_pSprite[DEF_SPRID_ITEMEQUIP_PIVOTPOINT + sSprH +40]->PutTransSprite(sX + 45, sY + 143, sFrame, m_dwCurTime);
		}
	}

	// v2.05
	if ((msX >= sX + 15) && (msX <= sX + 15 + DEF_BTNSZX) && (msY >= sY + 340) && (msY <= sY + 340 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 15, sY +340, 5, FALSE, m_bDialogTrans);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 15, sY +340, 4, FALSE, m_bDialogTrans);

	if ((msX >= sX + 98) && (msX <= sX + 98 + DEF_BTNSZX) && (msY >= sY + 340) && (msY <= sY + 340 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 98, sY +340, 45, FALSE, m_bDialogTrans);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 98, sY +340, 44, FALSE, m_bDialogTrans);

	if ((msX >= sX + 180) && (msX <= sX + 180 + DEF_BTNSZX) && (msY >= sY + 340) && (msY <= sY + 340 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 180, sY +340, 11, FALSE, m_bDialogTrans);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 180, sY +340, 10, FALSE, m_bDialogTrans);
}

// 3.51 Level Up Dialog - Diuuude
void CGame::DrawDialogBox_LevelUpSetting(short msX, short msY)
{
 short sX, sY, szX;
 DWORD dwTime = m_dwCurTime;
 char cTxt[120];
 int iStats;
	sX = m_stDialogBoxInfo[12].sX;
	sY = m_stDialogBoxInfo[12].sY;
	szX = m_stDialogBoxInfo[12].sSizeX;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, sX+16, sY+100, 4);

	PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_LEVELUP_SETTING1);
	PutAlignedString(sX, sX + szX, sY + 65, DRAW_DIALOGBOX_LEVELUP_SETTING2);

	// Points Left - Display in green if > 0
	PutString(sX + 20,  sY + 85, DRAW_DIALOGBOX_LEVELUP_SETTING3, RGB(0,0,0));
	wsprintf(cTxt, "%d", m_iLU_Point);
	if (m_iLU_Point > 0)
	{	PutString(sX + 73,  sY + 102, cTxt, RGB(0,255,0));
	}else
	{	PutString(sX + 73,  sY + 102, cTxt, RGB(0,0,0));
	}
	// Strength
	PutString(sX + 24, sY + 125, DRAW_DIALOGBOX_LEVELUP_SETTING4, RGB(5,5,5));
	wsprintf(cTxt, "%d", m_iStr);
	PutString(sX + 109, sY + 125, cTxt, RGB(25,35,25));
	iStats = m_iStr + m_cLU_Str;
	wsprintf(cTxt, "%d", iStats);
	if (iStats != m_iStr)
	{	PutString(sX + 162, sY + 125, cTxt, RGB(255,0,0));
	}else
	{	PutString(sX + 162, sY + 125, cTxt, RGB(25,35,25));
	}
	if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 127) && (msY <= sY + 133) && (m_iStr < DEF_MAX_STATS))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 127, 5, dwTime);
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 127) && (msY <= sY + 133) && (m_cLU_Str > 0))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 127, 6, dwTime);

	// Vitality
	PutString(sX + 24, sY + 144, DRAW_DIALOGBOX_LEVELUP_SETTING5, RGB(5,5,5));
	wsprintf(cTxt, "%d", m_iVit);
	PutString(sX + 109, sY + 144, cTxt, RGB(25,35,25));
	iStats = m_iVit + m_cLU_Vit;
	wsprintf(cTxt, "%d", iStats);
	if (iStats != m_iVit)
	{	PutString(sX + 162, sY + 144, cTxt, RGB(255,0,0));
	}else
	{	PutString(sX + 162, sY + 144, cTxt, RGB(25,35,25));
	}
	if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 146) && (msY <= sY + 152) && (m_iVit < DEF_MAX_STATS))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 146, 5, dwTime);
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 146) && (msY <= sY + 152) && (m_cLU_Vit > 0))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 146, 6, dwTime);

	// Dexterity
	PutString(sX + 24, sY + 163, DRAW_DIALOGBOX_LEVELUP_SETTING6, RGB(5,5,5));
	wsprintf(cTxt, "%d", m_iDex);
	PutString(sX + 109, sY + 163, cTxt, RGB(25,35,25));
	iStats = m_iDex + m_cLU_Dex;
	wsprintf(cTxt, "%d", iStats);
	if (iStats != m_iDex)
	{	PutString(sX + 162, sY + 163, cTxt, RGB(255,0,0));
	}else
	{	PutString(sX + 162, sY + 163, cTxt, RGB(25,35,25));
	}
	if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 165) && (msY <= sY + 171) && (m_iDex < DEF_MAX_STATS))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 165, 5, dwTime);
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 165) && (msY <= sY + 171) && (m_cLU_Dex > 0))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 165, 6, dwTime);

	// Intelligence
	PutString(sX + 24, sY + 182, DRAW_DIALOGBOX_LEVELUP_SETTING7, RGB(5,5,5));
	wsprintf(cTxt, "%d", m_iInt);
	PutString(sX + 109, sY + 182, cTxt, RGB(25,35,25));
	iStats = m_iInt + m_cLU_Int;
	wsprintf(cTxt, "%d", iStats);
	if (iStats != m_iInt)
	{	PutString(sX + 162, sY + 182, cTxt, RGB(255,0,0));
	}else
	{	PutString(sX + 162, sY + 182, cTxt, RGB(25,35,25));
	}
	if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 184) && (msY <= sY + 190) && (m_iInt < DEF_MAX_STATS))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 184, 5, dwTime);
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 184) && (msY <= sY + 190) && (m_cLU_Int > 0))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 184, 6, dwTime);

	// Magic
	PutString(sX + 24, sY + 201, DRAW_DIALOGBOX_LEVELUP_SETTING8, RGB(5,5,5));
	wsprintf(cTxt, "%d", m_iMag);
	PutString(sX + 109, sY + 201, cTxt, RGB(25,35,25));
	iStats = m_iMag + m_cLU_Mag;
	wsprintf(cTxt, "%d", iStats);
	if (iStats != m_iMag)
	{	PutString(sX + 162, sY + 201, cTxt, RGB(255,0,0));
	}else
	{	PutString(sX + 162, sY + 201, cTxt, RGB(25,35,25));
	}
	if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 203) && (msY <= sY + 209) && (m_iMag < DEF_MAX_STATS))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 203, 5, dwTime);
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 203) && (msY <= sY + 209) && (m_cLU_Mag > 0))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 203, 6, dwTime);

	// Charisma
	PutString(sX + 24, sY + 220, DRAW_DIALOGBOX_LEVELUP_SETTING9, RGB(5,5,5));
	wsprintf(cTxt, "%d", m_iCharisma);
	PutString(sX + 109, sY + 220, cTxt, RGB(25,35,25));
	iStats = m_iCharisma + m_cLU_Char;
	wsprintf(cTxt, "%d", iStats);
	if (iStats != m_iCharisma)
	{	PutString(sX + 162, sY + 220, cTxt, RGB(255,0,0));
	}else
	{	PutString(sX + 162, sY + 220, cTxt, RGB(25,35,25));
	}
	if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 222) && (msY <= sY + 228) && (m_iCharisma < DEF_MAX_STATS))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 222, 5, dwTime);
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 222) && (msY <= sY + 228) && (m_cLU_Char > 0))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 222, 6, dwTime);

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
	if ((m_cLU_Str == 0)&&(m_cLU_Vit == 0)&&(m_cLU_Dex == 0)&&(m_cLU_Int == 0)&&(m_cLU_Mag == 0)&&(m_cLU_Char == 0))
	{	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	if (m_iLU_Point <= 0) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 21);
		}else
		{	if (m_iLU_Point <= 0) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 20);
	}	}
}

void CGame::DrawDialogBox_CityHallMenu(short msX, short msY)
{
 short sX, sY, szX;
 char cTxt[120];

	sX = m_stDialogBoxInfo[13].sX;
	sY = m_stDialogBoxInfo[13].sY;
	szX = m_stDialogBoxInfo[13].sSizeX;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 18);//CityHall Menu Text

	switch (m_stDialogBoxInfo[13].cMode) {
	case 0:
		// citizenship req
		if (m_bCitizen == FALSE)
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 70) && (msY < sY + 95))
				 PutAlignedString(sX, sX + szX, sY + 70, DRAW_DIALOGBOX_CITYHALL_MENU1, 255,255,255);	//"
			else PutAlignedString(sX, sX + szX, sY + 70, DRAW_DIALOGBOX_CITYHALL_MENU1, 4,0,50);		//"
		}else    PutAlignedString(sX, sX + szX, sY + 70, DRAW_DIALOGBOX_CITYHALL_MENU1, 65,65,65);			//"

		if (m_iRewardGold > 0)
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 95) && (msY < sY + 120))
				 PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU4, 255,255,255);	//"
			else PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU4, 4,0,50);		//"
		}else    PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU4, 65,65,65);			//"

		// 3.51 Cityhall Menu - Request Hero's Items - Diuuude
		if ((m_iEnemyKillCount >= 100) && (m_iContribution >= 10))
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 120) && (msY < sY + 145))
				 PutAlignedString(sX, sX + szX, sY + 120, DRAW_DIALOGBOX_CITYHALL_MENU8, 255,255,255);
			else PutAlignedString(sX, sX + szX, sY + 120, DRAW_DIALOGBOX_CITYHALL_MENU8, 4,0,50);
		}else    PutAlignedString(sX, sX + szX, sY + 120, DRAW_DIALOGBOX_CITYHALL_MENU8, 65,65,65);

		// Cancel quest
		if (m_stQuest.sQuestType != NULL)
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 145) && (msY < sY + 170))
				 PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_CITYHALL_MENU11, 255,255,255);//"
			else PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_CITYHALL_MENU11, 4,0,50);//"
		}else    PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_CITYHALL_MENU11, 65,65,65);//"

		// change playmode
		if ( (m_bIsCrusadeMode==FALSE) && m_bCitizen && (m_iPKCount==0))
		{	if (m_bHunter==TRUE)
			{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 170) && (msY < sY + 195))
					PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU56, 255,255,255);
				else
					PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU56, 4,0,50);
			}else if(m_iLevel < 100)
			{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 170) && (msY < sY + 195))
					 PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU56, 255,255,255);
				else
					PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU56, 4,0,50);
			}else // Disable...
					PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU56, 65,65,65);
		}else       PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU56, 65,65,65);

		// Teleport menu
#ifdef DEF_EQUILIBRIUM_PROJECT // TP for all
		if (m_bIsCrusadeMode==FALSE)
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 195) && (msY < sY + 220))
				 PutAlignedString(sX, sX + szX, sY + 195, "Direct teleporting service", 255,255,255);
			else PutAlignedString(sX, sX + szX, sY + 195, "Direct teleporting service", 4,0,50);
		}else    PutAlignedString(sX, sX + szX, sY + 195, "Direct teleporting service", 65,65,65);
#else
		if ( (m_bIsCrusadeMode==FALSE) && m_bCitizen && (m_iPKCount==0))
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 195) && (msY < sY + 220))
				 PutAlignedString(sX, sX + szX, sY + 195, DRAW_DIALOGBOX_CITYHALL_MENU69, 255,255,255);//"Teleporting to dungeon level 2."
			else PutAlignedString(sX, sX + szX, sY + 195, DRAW_DIALOGBOX_CITYHALL_MENU69, 4,0,50);
		}else    PutAlignedString(sX, sX + szX, sY + 195, DRAW_DIALOGBOX_CITYHALL_MENU69, 65,65,65);
#endif

		//Change crusade role
		if ( m_bIsCrusadeMode && m_bCitizen )
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 220) && (msY < sY + 220))
				 PutAlignedString(sX, sX + szX, sY + 220, DRAW_DIALOGBOX_CITYHALL_MENU14, 255,255,255);//"Change the crusade assignment."
			else PutAlignedString(sX, sX + szX, sY + 220, DRAW_DIALOGBOX_CITYHALL_MENU14, 4,0,50);//"
		}else    PutAlignedString(sX, sX + szX, sY + 220, DRAW_DIALOGBOX_CITYHALL_MENU14, 65,65,65);//"

		PutAlignedString(sX, sX + szX, sY + 270, DRAW_DIALOGBOX_CITYHALL_MENU17);//"Select an Item you want."

		break;

	case 1: // become citizen warning
		PutAlignedString(sX, sX + szX, sY + 80, DRAW_DIALOGBOX_CITYHALL_MENU18, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU19, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_CITYHALL_MENU20, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU21, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 140,DRAW_DIALOGBOX_CITYHALL_MENU22, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 155,DRAW_DIALOGBOX_CITYHALL_MENU23, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 170,DRAW_DIALOGBOX_CITYHALL_MENU24, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 200,DRAW_DIALOGBOX_CITYHALL_MENU25, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 215,DRAW_DIALOGBOX_CITYHALL_MENU26, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 230,DRAW_DIALOGBOX_CITYHALL_MENU27, 55,25,25);//"

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;

	case 2: // Offering Citizenship.
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_CITYHALL_MENU28, 55,25,25);//"
		break;

	case 3: //Congratulations!! You acquired Citizenship"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_CITYHALL_MENU29, 55,25,25);//"

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 4: //Failed on acquiring citizenship!"
		PutAlignedString(sX, sX + szX, sY + 80,  DRAW_DIALOGBOX_CITYHALL_MENU30, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 100, DRAW_DIALOGBOX_CITYHALL_MENU31, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 115, DRAW_DIALOGBOX_CITYHALL_MENU32, 55,25,25);//"

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 5: //The prize gold for your"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU33, 55,25,25);//"
		wsprintf(cTxt, DRAW_DIALOGBOX_CITYHALL_MENU34, m_iRewardGold);//"
		PutAlignedString(sX, sX + szX, sY + 140, cTxt, 55,25,25);
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_CITYHALL_MENU35, 55,25,25);//"

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;

	case 7:// 3.51 Cityhall Menu - Request Hero's Items - Diuuude
		PutAlignedString(sX, sX + szX, sY + 60,  DRAW_DIALOGBOX_CITYHALL_MENU46, 255,255,255);// Here are the Hero's Item aivable :
		// Hero's Cape (EK 300)
		if (m_iEnemyKillCount >= 300)
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 95) && (msY < sY + 110))
				 PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU47, 255,255,255);// On mouse over Mode
			else PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU47, 4,0,50);// Normal Mode
		}
		else PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU47, 65,65,65);// Disabled Mode
		// Hero's Helm (EK 150 - Contrib 20)
		if ((m_iEnemyKillCount >= 150) && (m_iContribution >= 20)) 
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 125) && (msY < sY + 140))
				 PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU48, 255,255,255);// On mouse over Mode
			else PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU48, 4,0,50);// Normal Mode
		}
		else PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU48, 65,65,65);// Disabled Mode
		// Hero's Cap (EK 100 - Contrib 20)
		if ((m_iEnemyKillCount >= 100) && (m_iContribution >= 20)) 
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 155) && (msY < sY + 170))
				 PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_CITYHALL_MENU49, 255,255,255);// On mouse over Mode
			else PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_CITYHALL_MENU49, 4,0,50);// Normal Mode
		}
		else PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_CITYHALL_MENU49, 65,65,65);// Disabled Mode
		// Hero's Armor (EK 300 - Contrib 30)
		if ((m_iEnemyKillCount >= 300) && (m_iContribution >= 30)) 
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 185) && (msY < sY + 200))
				 PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_CITYHALL_MENU50, 255,255,255);// On mouse over Mode
			else PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_CITYHALL_MENU50, 4,0,50);// Normal Mode
		}
		else PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_CITYHALL_MENU50, 65,65,65);// Disabled Mode
		// Hero's Robe (EK 200 - Contrib 20)
		if ((m_iEnemyKillCount >= 200) && (m_iContribution >= 20)) 
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 215) && (msY < sY + 230))
				 PutAlignedString(sX, sX + szX, sY + 215, DRAW_DIALOGBOX_CITYHALL_MENU51, 255,255,255);// On mouse over Mode
			else PutAlignedString(sX, sX + szX, sY + 215, DRAW_DIALOGBOX_CITYHALL_MENU51, 4,0,50);// Normal Mode
		}
		else PutAlignedString(sX, sX + szX, sY + 215, DRAW_DIALOGBOX_CITYHALL_MENU51, 65,65,65);// Disabled Mode
		// Hero's Hauberk (EK 100 - Contrib 10)
		if ((m_iEnemyKillCount >= 100) && (m_iContribution >= 10)) 
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 245) && (msY < sY + 260))
				 PutAlignedString(sX, sX + szX, sY + 245, DRAW_DIALOGBOX_CITYHALL_MENU52, 255,255,255);// On mouse over Mode
			else PutAlignedString(sX, sX + szX, sY + 245, DRAW_DIALOGBOX_CITYHALL_MENU52, 4,0,50);// Normal Mode
		}
		else PutAlignedString(sX, sX + szX, sY + 245, DRAW_DIALOGBOX_CITYHALL_MENU52, 65,65,65);// Disabled Mode
		// Hero's Leggings (EK 150 - Contrib 15)
		if ((m_iEnemyKillCount >= 150) && (m_iContribution >= 15)) 
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 275) && (msY < sY + 290))
				 PutAlignedString(sX, sX + szX, sY + 275, DRAW_DIALOGBOX_CITYHALL_MENU53, 255,255,255);// On mouse over Mode
			else PutAlignedString(sX, sX + szX, sY + 275, DRAW_DIALOGBOX_CITYHALL_MENU53, 4,0,50);// Normal Mode
		}
		else PutAlignedString(sX, sX + szX, sY + 275, DRAW_DIALOGBOX_CITYHALL_MENU53, 65,65,65);// Disabled Mode
		break;

	case 8: // cancel current quest?
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU54, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_CITYHALL_MENU55, 55,25,25);//"

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;

	case 9: // You are civilian/ combatant now
		if( m_bHunter )
		{	PutAlignedString(sX, sX + szX, sY +  53, DRAW_DIALOGBOX_CITYHALL_MENU57, 200,200,25);//"
		}else
		{	PutAlignedString(sX, sX + szX, sY +  53, DRAW_DIALOGBOX_CITYHALL_MENU58, 200,200,25);//"
		}
		PutAlignedString(sX, sX + szX, sY +  78, DRAW_DIALOGBOX_CITYHALL_MENU59, 55,25,25);//"

		PutString(sX + 35, sY + 108, DRAW_DIALOGBOX_CITYHALL_MENU60, RGB(220,130,45));//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU61, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_CITYHALL_MENU62, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_CITYHALL_MENU63, 55,25,25);//"
		PutString(sX + 35, sY +  177, DRAW_DIALOGBOX_CITYHALL_MENU64, RGB(220,130,45));//"
		PutAlignedString(sX, sX + szX, sY + 194, DRAW_DIALOGBOX_CITYHALL_MENU65, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 209, DRAW_DIALOGBOX_CITYHALL_MENU66, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 224, DRAW_DIALOGBOX_CITYHALL_MENU67, 55,25,25);//"

		PutAlignedString(sX, sX + szX, sY + 252, DRAW_DIALOGBOX_CITYHALL_MENU68, 55,25,25);//"
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;

	case 10: // TP 2nd screen
		if( m_iTeleportMapCount > 0 )

#ifdef DEF_EQUILIBRIUM_PROJECT
		{	PutAlignedString(sX, sX + szX, sY + 50, "Direct teleporting service", 55,25,25);
			PutAlignedString(sX, sX + szX, sY + 80, "Possible destinations:", 55,25,25);
			PutAlignedString(sX, sX + szX, sY + 95, "(a fare may be required)", 55,25,25);
			PutAlignedString(sX, sX + szX, sY + 110,"Would you like to teleport?", 55,25,25);
#else
		{	PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_CITYHALL_MENU69, 55,25,25);//"Teleporting to dungeon level 2."
			PutAlignedString(sX, sX + szX, sY + 80, DRAW_DIALOGBOX_CITYHALL_MENU70, 55,25,25);//"5000Gold is required"
			PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU71, 55,25,25);//"to teleport to dungeon level 2."
			PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_CITYHALL_MENU72, 55,25,25);//"Would you like to teleport?"
			PutString2(sX + 35, sY + 250, DRAW_DIALOGBOX_CITYHALL_MENU72_1, 55,25,25);//"Civilians cannot go some area."
#endif
			for( int i=0 ; i<m_iTeleportMapCount ; i++ )
			{	ZeroMemory( cTxt, sizeof(cTxt) );
				GetOfficialMapName( m_stTeleportList[i].mapname, cTxt );
				wsprintf( G_cTxt, DRAW_DIALOGBOX_CITYHALL_MENU77, cTxt, m_stTeleportList[i].iCost );
				if( (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 130 + i*15) && (msY <= sY + 144 + i*15) )
					 PutAlignedString(sX, sX + szX, sY + 130 + i*15, G_cTxt, 255, 255, 255);
				else PutAlignedString(sX, sX + szX, sY + 130 + i*15, G_cTxt,  250,  250,  0);
			}
		}else if( m_iTeleportMapCount == -1 )
		{	PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU73, 55,25,25);//"Now it's searching for possible area"
			PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_CITYHALL_MENU74, 55,25,25);//"to teleport."
			PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_CITYHALL_MENU75, 55,25,25);//"Please wait for a moment."
		}else
		{	PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_CITYHALL_MENU76, 55,25,25);//"There is no area that you can teleport."
		}
		break;

	case 11: //drajwer - ask for tooking hero mantle
		PutAlignedString(sX,sX+szX-1,sY+125,m_cTakeHeroItemName, 55,25,25);
		PutAlignedString(sX+1,sX+szX,sY+125,m_cTakeHeroItemName, 55,25,25);
		PutAlignedString(sX,sX+szX,sY+260,DRAW_DIALOGBOX_CITYHALL_MENU46A, 55,25,25); // would you like..
		if (   (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX)
			&& (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		   DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);
		if (   (msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX)
			&& (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		   DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
 	break;
	}
}
/*********************************************************************************************************************
**  void CGame::DrawDialogBox_ConfirmExchange(short msX, short msY)	(snoopy)										**
**  description			:: paints the trade windows	Added confirmation window in v3.51								**
**********************************************************************************************************************/
void CGame::DrawDialogBox_ConfirmExchange(short msX, short msY)
{short sX, sY;
	sX = m_stDialogBoxInfo[41].sX;
	sY = m_stDialogBoxInfo[41].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME1, sX, sY, 2);
	switch (m_stDialogBoxInfo[41].cMode) {
	case 1: // Question
		PutString(sX + 35, sY + 30, "Do you really want to exchange?", RGB(4,0,50));
		PutString(sX + 36, sY + 30, "Do you really want to exchange?", RGB(4,0,50));

		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + 55) && (msY <= sY + 55 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 55 , 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 55 , 18);

		if ((msX >= sX + 170 ) && (msX <= sX + 170 + DEF_BTNSZX ) && (msY >= sY + 55 ) && (msY <= sY + 55 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 170, sY + 55 , 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 170, sY + 55 , 2);
		break;

	case 2: // Waiting for response
		PutString(sX + 45, sY + 36, "Waiting for response...", RGB(4,0,50));
		PutString(sX + 46, sY + 36, "Waiting for response...", RGB(4,0,50));
		break;
	}
}

/*********************************************************************************************************************
**  void CGame::DrawDialogBox_Exchange(short msX, short msY)	(snoopy)											**
**  description			:: paints the trade windows																	**
**********************************************************************************************************************/
void CGame::DrawDialogBox_Exchange(short msX, short msY)
{
 short sX, sY, szX, sXadd;
 DWORD dwTime = m_dwCurTime;
 char cItemColor, cTxt[120], cTxt2[128];
 char cNameStr[120], cSubStr1[120], cSubStr2[120];
 int iLoc, i;

	sX = m_stDialogBoxInfo[27].sX;
	sY = m_stDialogBoxInfo[27].sY ;
	szX = m_stDialogBoxInfo[27].sSizeX;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_NEWEXCHANGE, sX, sY, 0);
	switch (m_stDialogBoxInfo[27].cMode) {
	case 1: // Not yet confirmed exchange
		PutAlignedString(sX + 80, sX + 180, sY + 38, m_cPlayerName, 35,55,35); // my name
		if (m_stDialogBoxExchangeInfo[4].sV1 != -1) // Other name if applicable
			PutAlignedString(sX + 250, sX + 540, sY + 38, m_stDialogBoxExchangeInfo[4].cStr2, 35,55,35);
		for (i=0; i<8; i++) // draw items
		{	sXadd = (58 * i) + 48; if (i>3) sXadd += 20;
			if ( m_stDialogBoxExchangeInfo[i].sV1 != -1)
			{	cItemColor = m_stDialogBoxExchangeInfo[i].sV4;
				if (cItemColor == 0)
				{	 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteFast(sX + sXadd, sY + 130, m_stDialogBoxExchangeInfo[i].sV2, dwTime);
				}else
				{	switch (m_stDialogBoxExchangeInfo[i].sV1) {//sV1 : Sprite
					case 1: //  Swds
					case 2: //  Bows
					case 3: //  Shields
					case 15: // Axes hammers
					case 17: // Wands
							m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteRGB(sX + sXadd, sY + 130
								, m_stDialogBoxExchangeInfo[i].sV2,	 m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
							break;
					default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteRGB(sX + sXadd, sY + 130
								 , m_stDialogBoxExchangeInfo[i].sV2,  m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
						break;
				}	}
				GetItemName(m_stDialogBoxExchangeInfo[i].cStr1, m_stDialogBoxExchangeInfo[i].dwV1, cNameStr, cSubStr1, cSubStr2);
				// If pointer over item then show this item data
				if ( (msX >= sX + sXadd - 6) && (msX <= sX + sXadd + 42)
					&& (msY >= sY + 61) && (msY <= sY + 200) )
				{	wsprintf(cTxt, "%s", cNameStr);
					if (m_bIsSpecial)
					{	PutAlignedString(sX + 15, sX + 155, sY + 215, cTxt, 0,255,50);
						PutAlignedString(sX + 16, sX + 156, sY + 215, cTxt, 0,255,50);
					}else
					{	PutAlignedString(sX + 15, sX + 155, sY + 215, cTxt, 35,35,35);
						PutAlignedString(sX + 16, sX + 156, sY + 215, cTxt, 35,35,35);
					}
					iLoc = 0;
					if (strlen(cSubStr1) != 0)
					{	PutAlignedString(sX + 16, sX + 155, sY + 235 +iLoc, cSubStr1, 0,0,0);
						iLoc += 15;
					}
					if (strlen(cSubStr2) != 0)
					{	PutAlignedString(sX + 16, sX + 155, sY + 235 +iLoc, cSubStr2, 0,0,0);
						iLoc += 15;
					}
					if (m_stDialogBoxExchangeInfo[i].sV3 != 1) // Item avec Quantity
					{	if(m_stDialogBoxExchangeInfo[i].sV3 > 1)
						{	DisplayCommaNumber_G_cTxt(m_stDialogBoxExchangeInfo[i].sV3);
							strcpy(cTxt2, G_cTxt);
						}else wsprintf(cTxt2, DRAW_DIALOGBOX_EXCHANGE2, m_stDialogBoxExchangeInfo[i].sV3);
						PutAlignedString(sX + 16, sX + 155, sY +235 +iLoc, cTxt2, 35,35,35);
						iLoc += 15;
					}
					if (m_stDialogBoxExchangeInfo[i].sV5 != -1) // completion
					{	// Crafting Magins completion fix
						if (m_stDialogBoxExchangeInfo[i].sV1 == 22)
						{	if (   (m_stDialogBoxExchangeInfo[i].sV2 > 5)
								&& (m_stDialogBoxExchangeInfo[i].sV2 < 10))
							{	wsprintf(cTxt, GET_ITEM_NAME2, (m_stDialogBoxExchangeInfo[i].sV7 - 100)); //Completion - 100
							}
						}else if (m_stDialogBoxExchangeInfo[i].sV1 == 6)
						{	wsprintf(cTxt, GET_ITEM_NAME1, (m_stDialogBoxExchangeInfo[i].sV7 - 100)); //Purity
						}else
						{	wsprintf(cTxt, GET_ITEM_NAME2, m_stDialogBoxExchangeInfo[i].sV7); //Completion
						}
						PutAlignedString(sX + 16, sX + 155, sY + 235 +iLoc, cTxt, 35,35,35);
						iLoc += 15;
					}
					if (iLoc < 45) // Endurance
					{	wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE3, m_stDialogBoxExchangeInfo[i].sV5, m_stDialogBoxExchangeInfo[i].sV6);
						PutAlignedString(sX + 16, sX + 155, sY + 235 +iLoc, cTxt, 35,35,35);
						iLoc += 15;
		}	}	}	}
		if ((m_stDialogBoxExchangeInfo[0].sV1 != -1) && (m_stDialogBoxExchangeInfo[4].sV1 == -1))
		{	PutAlignedString(sX, sX + szX, sY + 235 +10, DRAW_DIALOGBOX_EXCHANGE9, 55,25,25); // Please wait until other player decides
			PutAlignedString(sX, sX + szX, sY + 250 +10, DRAW_DIALOGBOX_EXCHANGE10, 55,25,25);// to exchange. If you want to cancel the
			PutAlignedString(sX, sX + szX, sY + 265 +10, DRAW_DIALOGBOX_EXCHANGE11, 55,25,25);// exchange press the CANCEL button now.
			PutString_SprFont(sX + 220,  sY + 310, "Exchange", 15,15,15);
		}else if ((m_stDialogBoxExchangeInfo[0].sV1 == -1) && (m_stDialogBoxExchangeInfo[4].sV1 != -1))
		{	PutAlignedString(sX, sX + szX, sY + 205 +10, DRAW_DIALOGBOX_EXCHANGE12, 55,25,25);// Other player offered an item exchange
			PutAlignedString(sX, sX + szX, sY + 220 +10, DRAW_DIALOGBOX_EXCHANGE13, 55,25,25);// Select an item which you want to exc-
			PutAlignedString(sX, sX + szX, sY + 235 +10, DRAW_DIALOGBOX_EXCHANGE14, 55,25,25);// hange with above item, drag it to the
			PutAlignedString(sX, sX + szX, sY + 250 +10, DRAW_DIALOGBOX_EXCHANGE15, 55,25,25);// blank and press the EXCHANGE button.
			PutAlignedString(sX, sX + szX, sY + 265 +10, DRAW_DIALOGBOX_EXCHANGE16, 55,25,25);// And you can also reject an offer by
			PutAlignedString(sX, sX + szX, sY + 280 +10, DRAW_DIALOGBOX_EXCHANGE17, 55,25,25);// pressing the CANCEL button.
			PutString_SprFont(sX + 220,  sY + 310, "Exchange", 15,15,15);
		}else if ((m_stDialogBoxExchangeInfo[0].sV1 != -1) && (m_stDialogBoxExchangeInfo[4].sV1 != -1))
		{	PutAlignedString(sX, sX + szX, sY + 205 +10, DRAW_DIALOGBOX_EXCHANGE18, 55,25,25);// The preparation for item exchange
			PutAlignedString(sX, sX + szX, sY + 220 +10, DRAW_DIALOGBOX_EXCHANGE19, 55,25,25);// has been finished. Press the EXCHANGE
			PutAlignedString(sX, sX + szX, sY + 235 +10, DRAW_DIALOGBOX_EXCHANGE20, 55,25,25);// button to exchange as above. Press the
			PutAlignedString(sX, sX + szX, sY + 250 +10, DRAW_DIALOGBOX_EXCHANGE21, 55,25,25);// CANCEL button to cancel. Occasionally
			PutAlignedString(sX, sX + szX, sY + 265 +10, DRAW_DIALOGBOX_EXCHANGE22, 55,25,25);// when you press the EXCHANGE button, you
			PutAlignedString(sX, sX + szX, sY + 280 +10, DRAW_DIALOGBOX_EXCHANGE23, 55,25,25);// will not be able to cancel the exchange.
			if ( (msX >= sX + 200) && (msX <= sX + 200 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY) )
				 PutString_SprFont(sX + 220,  sY + 310, "Exchange", 6,6,20);
			else PutString_SprFont(sX + 220,  sY + 310, "Exchange", 0,0,7);
		}
		if (   (msX >= sX + 450) && (msX <= sX + 450 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY)
			&& (m_bIsDialogEnabled[41] == FALSE))
			 PutString_SprFont(sX + 450, sY + 310, "Cancel", 6,6,20);
		else PutString_SprFont(sX + 450, sY + 310, "Cancel", 0,0,7);
		break;

	case 2: // You have confirmed the exchange
		PutAlignedString(sX + 80, sX + 180, sY + 38, m_cPlayerName, 35,55,35); // my name
		if (m_stDialogBoxExchangeInfo[4].sV1 != -1) // Other name if applicable
			PutAlignedString(sX + 250, sX + 540, sY + 38, m_stDialogBoxExchangeInfo[4].cStr2, 35,55,35);
		for (i=0; i<8; i++) // draw items
		{	sXadd = (58 * i) + 48; if (i>3) sXadd += 20;
			if ( m_stDialogBoxExchangeInfo[i].sV1 != -1)
			{	cItemColor = m_stDialogBoxExchangeInfo[i].sV4;
				if (cItemColor == 0)
				{	 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteFast(sX + sXadd, sY + 130, m_stDialogBoxExchangeInfo[i].sV2, dwTime);
				}else
				{	switch (m_stDialogBoxExchangeInfo[i].sV1) {
					case 1: // Swds
					case 2: // Bows
					case 3: // Shields
					case 15: // Axes hammers
					case 17: // Wands
					m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteRGB(sX + sXadd, sY + 130
						, m_stDialogBoxExchangeInfo[i].sV2, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
						break;
					default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteRGB(sX + sXadd, sY + 130
								 , m_stDialogBoxExchangeInfo[i].sV2, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
						break;
				}	}
				GetItemName(m_stDialogBoxExchangeInfo[i].cStr1, m_stDialogBoxExchangeInfo[i].dwV1, cNameStr, cSubStr1, cSubStr2);
				// If pointer over item then show this item data
				if ( (msX >= sX + sXadd - 6) && (msX <= sX + sXadd + 42)
					&& (msY >= sY + 61) && (msY <= sY + 200) )
				{	wsprintf(cTxt, "%s", cNameStr);
					if (m_bIsSpecial)
					{	PutAlignedString(sX + 15, sX + 155, sY + 215, cTxt, 0,255,50);
						PutAlignedString(sX + 16, sX + 156, sY + 215, cTxt, 0,255,50);
					}else
					{	PutAlignedString(sX + 15, sX + 155, sY + 215, cTxt, 35,35,35);
						PutAlignedString(sX + 16, sX + 156, sY + 215, cTxt, 35,35,35);
					}
					iLoc = 0;
					if (strlen(cSubStr1) != 0)
					{	PutAlignedString(sX + 16, sX + 155, sY + 235 +iLoc, cSubStr1, 0,0,0);
						iLoc += 15;
					}
					if (strlen(cSubStr2) != 0)
					{	PutAlignedString(sX + 16, sX + 155, sY + 235 +iLoc, cSubStr2, 0,0,0);
						iLoc += 15;
					}
					if (m_stDialogBoxExchangeInfo[i].sV3 != 1) // Item avec Quantity
					{	if(m_stDialogBoxExchangeInfo[i].sV3 > 1)
						{	DisplayCommaNumber_G_cTxt(m_stDialogBoxExchangeInfo[i].sV3);
							strcpy(cTxt2, G_cTxt);
						}else wsprintf(cTxt2, DRAW_DIALOGBOX_EXCHANGE2, m_stDialogBoxExchangeInfo[i].sV3);
						PutAlignedString(sX + 16, sX + 155, sY +235 +iLoc, cTxt2, 35,35,35);
						iLoc += 15;
					}
					if (m_stDialogBoxExchangeInfo[i].sV5 != -1) // completion
					{	// Crafting Magins completion fix
						if (m_stDialogBoxExchangeInfo[i].sV1 == 22)
						{	if (   (m_stDialogBoxExchangeInfo[i].sV2 > 5)
								&& (m_stDialogBoxExchangeInfo[i].sV2 < 10))
							{	wsprintf(cTxt, GET_ITEM_NAME2, (m_stDialogBoxExchangeInfo[i].sV7 - 100)); //Completion - 100
							}
						}else if (m_stDialogBoxExchangeInfo[i].sV1 == 6)
						{	wsprintf(cTxt, GET_ITEM_NAME1, (m_stDialogBoxExchangeInfo[i].sV7 - 100)); //Purity
						}else
						{	wsprintf(cTxt, GET_ITEM_NAME2, m_stDialogBoxExchangeInfo[i].sV7); //Completion
						}
						PutAlignedString(sX + 16, sX + 155, sY + 235 +iLoc, cTxt, 35,35,35);
						iLoc += 15;
					}
					if (iLoc < 45) // Endurance
					{	wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE3, m_stDialogBoxExchangeInfo[i].sV5, m_stDialogBoxExchangeInfo[i].sV6);
						PutAlignedString(sX + 16, sX + 155, sY + 235 +iLoc, cTxt, 35,35,35);
						iLoc += 15;
		}	}	}	}
		wsprintf(cTxt, DRAW_DIALOGBOX_EXCHANGE33, m_stDialogBoxExchangeInfo[4].cStr2);
		PutAlignedString(sX, sX + szX, sY + 205 +10, cTxt, 55,25,25);                     // Please wait until %s agrees to
		PutAlignedString(sX, sX + szX, sY + 220 +10, DRAW_DIALOGBOX_EXCHANGE34, 55,25,25);// exchange. The exchange can't be achieved
		PutAlignedString(sX, sX + szX, sY + 235 +10, DRAW_DIALOGBOX_EXCHANGE35, 55,25,25);// unless both people agree.
		PutAlignedString(sX, sX + szX, sY + 250 +10, DRAW_DIALOGBOX_EXCHANGE36, 55,25,25);//  If other player does not decide to exchange
		PutAlignedString(sX, sX + szX, sY + 265 +10, DRAW_DIALOGBOX_EXCHANGE37, 55,25,25);// you can cancel the exchange by pressing the
		PutAlignedString(sX, sX + szX, sY + 280 +10, DRAW_DIALOGBOX_EXCHANGE38, 55,25,25);// CANCEL button. But if other player already
		PutAlignedString(sX, sX + szX, sY + 295 +10, DRAW_DIALOGBOX_EXCHANGE39, 55,25,25);// decided to exchange, you can't cancel anymore

	/*	if ( (msX >= sX + 450) && (msX <= sX + 450 + DEF_BTNSZX) && (msY >= sY + 310) && (msY <= sY + 310 + DEF_BTNSZY) )
			 PutString_SprFont(sX + 450, sY + 310, "Cancel", 6,6,20);
		else PutString_SprFont(sX + 450, sY + 310, "Cancel", 0,0,7);*/
		break;
	}
}

void CGame::DrawDialogBox_Fishing(short msX, short msY)
{

 short sX, sY;
 DWORD dwTime = m_dwCurTime;
 char  cTxt[120];

	sX = m_stDialogBoxInfo[24].sX;
	sY = m_stDialogBoxInfo[24].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME1, sX, sY, 2);

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_stDialogBoxInfo[24].cStr, NULL, cStr1, cStr2, cStr3);

	switch (m_stDialogBoxInfo[24].cMode) {
	case 0:
		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxInfo[24].sV3]->PutSpriteFast(sX + 18 + 35, sY + 18 + 17, m_stDialogBoxInfo[24].sV4, dwTime);
		wsprintf(cTxt, "%s", cStr1);
		PutString(sX + 98, sY + 14, cTxt, RGB(255,255,255));
		wsprintf(cTxt, DRAW_DIALOGBOX_FISHING1, m_stDialogBoxInfo[24].sV2);
		PutString(sX + 98, sY + 28, cTxt, RGB(0,0,0));
		PutString(sX + 97, sY + 43, DRAW_DIALOGBOX_FISHING2, RGB(0,0,0));
		wsprintf(cTxt, "%d %%", m_stDialogBoxInfo[24].sV1);
		PutString_SprFont(sX + 157,  sY + 40, cTxt, 10,0,0);
		if ((msX >= sX + 160) && (msX <= sX + 253) && (msY >= sY + 70) && (msY <= sY + 90))
			 PutString_SprFont(sX + 160, sY + 70, "Try Now!", 6,6,20);
		else PutString_SprFont(sX + 160, sY + 70, "Try Now!", 0, 0, 7);
		break;
	}

}

void CGame::DrawDialogBox_GuildMenu(short msX, short msY)
{
 short sX, sY, szX;
 int iAdjX, iAdjY ;

	sX = m_stDialogBoxInfo[7].sX;
	sY = m_stDialogBoxInfo[7].sY;
	szX = m_stDialogBoxInfo[7].sSizeX;

	iAdjX = - 13 ;
	iAdjY =  30 ;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 19);

	switch (m_stDialogBoxInfo[7].cMode) {
	case 0:
		if ( (m_iGuildRank == -1) && (m_iCharisma >= 20) && (m_iLevel >= 20) ) {
			if ((msX > sX + iAdjX +80) && (msX < sX + iAdjX +210) && (msY > sY + iAdjY + 63) && (msY < sY + iAdjY + 78))
				 PutAlignedString(sX, sX + szX, sY + iAdjY + 65, DRAW_DIALOGBOX_GUILDMENU1, 255,255,255);//"
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 65, DRAW_DIALOGBOX_GUILDMENU1, 4,0,50);//"
		}
		else PutAlignedString(sX, sX + szX, sY + iAdjY + 65, DRAW_DIALOGBOX_GUILDMENU1, 65,65,65);//"

		if (m_iGuildRank == 0) {
			if ((msX > sX + iAdjX +72) && (msX < sX + iAdjX +222) && (msY > sY + iAdjY + 82) && (msY < sY + iAdjY + 99))
				 PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU4, 255,255,255);//"
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU4, 4,0,50);//"
		}
		else PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU4, 65,65,65);//"

		if ((msX > sX + iAdjX +61) && (msX < sX + iAdjX +226) && (msY > sY + iAdjY + 103) && (msY < sY + iAdjY + 120))
			 PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU7, 255,255,255);//"
		else PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU7, 4,0,50);//"

		if ((msX > sX + iAdjX +60) && (msX < sX + iAdjX +227) && (msY > sY + iAdjY + 123) && (msY < sY + iAdjY + 139))
			 PutAlignedString(sX, sX + szX, sY + iAdjY + 125, DRAW_DIALOGBOX_GUILDMENU9, 255,255,255);//"
		else PutAlignedString(sX, sX + szX, sY + iAdjY + 125, DRAW_DIALOGBOX_GUILDMENU9, 4,0,50);//"

		if (m_iGuildRank == 0 && m_iFightzoneNumber == 0) {
			if ((msX > sX + iAdjX +72) && (msX < sX + iAdjX +228) && (msY > sY + iAdjY + 143) && (msY < sY + iAdjY + 169))
				 PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU11, 255,255,255);//"
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU11, 4,0,50);//"

		} else if (m_iGuildRank == 0 && m_iFightzoneNumber > 0) {
			if ((msX > sX + iAdjX +72) && (msX < sX + iAdjX +216) && (msY > sY + iAdjY + 143) && (msY < sY + iAdjY + 169))
				 PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU13, 255,255,255);//"
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU13, 4,0,50);//"

		} else if (m_iFightzoneNumber < 0) {
			PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU13, 65,65,65);//"
		} else PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU11, 65,65,65);//"

		PutAlignedString(sX, sX + szX, sY + iAdjY + 205, DRAW_DIALOGBOX_GUILDMENU17);//"
		break;

	case 1:
		PutAlignedString(sX + 24, sX + 239, sY + 125, DRAW_DIALOGBOX_GUILDMENU18, 55,25,25);//"
		PutString(sX + 75, sY + 144, "____________________", RGB(25,35,25));

		if (iGetTopDialogBoxIndex() != 7)
			PutString(sX + 75, sY + 140, m_cGuildName, RGB(255,255,255), 16, FALSE, 2);

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)) {
			if ((strcmp(m_cGuildName, "NONE") == 0) || (strlen(m_cGuildName) == 0)) {
				 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 24);//Create Gray Button
			}
			else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 25);//Create Highlight Button
		}
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 24);//Create Gray Button

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);//Red Cancel Button
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);//Gray Cancel Button
	   	break;

	case 2:
		PutAlignedString(sX, sX + szX, sY +140, DRAW_DIALOGBOX_GUILDMENU19, 55,25,25);//"
		break;
	case 3:
		PutAlignedString(sX, sX + szX,  sY + 125, DRAW_DIALOGBOX_GUILDMENU20, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 140, m_cGuildName, 55,25,25);
		PutAlignedString(sX, sX + szX, sY + 144, "____________________", 25,35,25);
		PutAlignedString(sX, sX + szX, sY + 160, DRAW_DIALOGBOX_GUILDMENU21, 55,25,25);//"

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	case 4:
		PutAlignedString(sX, sX + szX, sY + 135, DRAW_DIALOGBOX_GUILDMENU22, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_GUILDMENU23, 55,25,25);//"

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	case 5:
		PutAlignedString(sX, sX + szX, sY + 90, DRAW_DIALOGBOX_GUILDMENU24);
		PutAlignedString(sX, sX + szX, sY + 105, m_cGuildName, 35,35,35);
		PutAlignedString(sX, sX + szX, sY + 109, "____________________", 0,0,0);
		PutAlignedString(sX, sX + szX, sY + 130, DRAW_DIALOGBOX_GUILDMENU25);//"
		PutAlignedString(sX, sX + szX, sY + 145,DRAW_DIALOGBOX_GUILDMENU26);//"
		PutAlignedString(sX, sX + szX, sY + 160,DRAW_DIALOGBOX_GUILDMENU27);//"
		PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_GUILDMENU28, 55,25,25);//"

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;
	case 6:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU29, 55,25,25);//"
		break;
	case 7:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU30, 55,25,25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	case 8:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU31, 55,25,25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	case 9:
		PutAlignedString(sX, sX + szX, sY + iAdjY + 60,  DRAW_DIALOGBOX_GUILDMENU32);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 75,  DRAW_DIALOGBOX_GUILDMENU33);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 90,  DRAW_DIALOGBOX_GUILDMENU34);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU35);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 130, DRAW_DIALOGBOX_GUILDMENU36);//"
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 31);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 30);
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;
	case 10:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU37, 55,25,25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	case 11:
		PutAlignedString(sX, sX + szX, sY + iAdjY + 60,  DRAW_DIALOGBOX_GUILDMENU38);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 75,  DRAW_DIALOGBOX_GUILDMENU39);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 90, DRAW_DIALOGBOX_GUILDMENU40);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU41);//
		PutAlignedString(sX, sX + szX, sY + iAdjY + 130, DRAW_DIALOGBOX_GUILDMENU42);//"
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 31);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 30);
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;
	case 12:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU43, 55,25,25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 13:
		PutAlignedString(sX, sX + szX, sY + iAdjY + 40,  DRAW_DIALOGBOX_GUILDMENU44);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 55,  DRAW_DIALOGBOX_GUILDMENU45);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 70,  DRAW_DIALOGBOX_GUILDMENU46);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU47);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 100, DRAW_DIALOGBOX_GUILDMENU48);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 115, DRAW_DIALOGBOX_GUILDMENU49);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 130, DRAW_DIALOGBOX_GUILDMENU50);//"

		if ((msX > sX + iAdjX +65) && (msX < sX + iAdjX +137) && (msY > sY + iAdjY + 168) && (msY < sY + iAdjY + 185))
			 PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU51, RGB(255,255,255));
		else PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU51, RGB(4,0,50));

		if ((msX > sX + iAdjX +150) && (msX < sX + iAdjX +222) && (msY > sY + iAdjY + 168) && (msY < sY + iAdjY + 185))
			 PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU53, RGB(255,255,255));
		else PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU53, RGB(4,0,50));

		if ((msX > sX + iAdjX +65) && (msX < sX + iAdjX +137) && (msY > sY + iAdjY + 188) && (msY < sY + iAdjY + 205))
			 PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU55, RGB(255,255,255));
		else PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU55, RGB(4,0,50));

		if ((msX > sX + iAdjX +150) && (msX < sX + iAdjX +222) && (msY > sY + iAdjY + 188) && (msY < sY + iAdjY + 205))
			 PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU57, RGB(255,255,255));
		else PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU57, RGB(4,0,50));

		if ((msX > sX + iAdjX +65) && (msX < sX + iAdjX +137) && (msY > sY + iAdjY + 208) && (msY < sY + iAdjY + 225))
			 PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU59, RGB(255,255,255));
		else PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU59, RGB(4,0,50));

		if ((msX > sX + iAdjX +150) && (msX < sX + iAdjX +222) && (msY > sY + iAdjY + 208) && (msY < sY + iAdjY + 225))
			 PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU61, RGB(255,255,255));
		else PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU61, RGB(4,0,50));

		if ((msX > sX + iAdjX +65) && (msX < sX + iAdjX +137) && (msY > sY + iAdjY + 228) && (msY < sY + iAdjY + 245))
			 PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU63, RGB(255,255,255));
		else PutString(sX + iAdjX +65 + 25 -23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU63, RGB(4,0,50));

		if ((msX > sX + iAdjX +150) && (msX < sX + iAdjX +222) && (msY > sY + iAdjY + 228) && (msY < sY + iAdjY + 245))
			 PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU65, RGB(255,255,255));
		else PutString(sX + iAdjX +150 + 25 -23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU65, RGB(4,0,50));

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 14:
		PutAlignedString(sX, sX + szX, sY + 130, DRAW_DIALOGBOX_GUILDMENU66, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_GUILDMENU67, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 160, DRAW_DIALOGBOX_GUILDMENU68, 55,25,25);//
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 15:
		PutAlignedString(sX, sX + szX, sY + 135, DRAW_DIALOGBOX_GUILDMENU69, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_GUILDMENU70, 55,25,25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 16:
		PutAlignedString(sX, sX + szX, sY + 135, DRAW_DIALOGBOX_GUILDMENU71, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_GUILDMENU72, 55,25,25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 17:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU73, 55,25,25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 18:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU74, 55,25,25);//"
		break;

	case 19:
		if( m_iFightzoneNumber >0 )
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETFIGHTZONETICKET, NULL, NULL, NULL, NULL, NULL);
		m_stDialogBoxInfo[7].cMode = 0;
		break;

	case 20:
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_GUILDMENU75, 55,25,25);//"
		PutString(sX + 75, sY + 144, "____________________", RGB(25,35,25));
		PutString(sX + 75, sY + 140, m_cGuildName, RGB(255,255,255), FALSE, 2);
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 25);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 24);
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 21:
		PutAlignedString(sX, sX + szX, sY + iAdjY + 95,  DRAW_DIALOGBOX_GUILDMENU76, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 110, DRAW_DIALOGBOX_GUILDMENU77, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 135, DRAW_DIALOGBOX_GUILDMENU78, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 150, DRAW_DIALOGBOX_GUILDMENU79, 55,25,25);//"
		PutAlignedString(sX, sX + szX, sY + iAdjY + 165, DRAW_DIALOGBOX_GUILDMENU80, 55,25,25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 22:
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU81, 55,25,25);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	}
}

void CGame::DrawDialogBox_GuildOperation(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[8].sX;
	sY = m_stDialogBoxInfo[8].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 19);

	switch (m_stGuildOpList[0].cOpMode) {
	case 1:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION1);
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35,35,35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0,0,0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION2);
		PutAlignedString(sX + 24, sX + 248, sY + 105,DRAW_DIALOGBOX_GUILD_OPERATION3);
		PutAlignedString(sX + 24, sX + 248, sY + 120,DRAW_DIALOGBOX_GUILD_OPERATION4);
		PutAlignedString(sX + 24, sX + 248, sY + 160, DRAW_DIALOGBOX_GUILD_OPERATION5, 55,25,25);

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 33);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 32);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 35);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 34);
		break;

	case 2:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION6);
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35,35,35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0,0,0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION7);
		PutAlignedString(sX + 24, sX + 248, sY + 105,DRAW_DIALOGBOX_GUILD_OPERATION8);
		PutAlignedString(sX + 24, sX + 248, sY + 120,DRAW_DIALOGBOX_GUILD_OPERATION9);
		PutAlignedString(sX + 24, sX + 248, sY + 160, DRAW_DIALOGBOX_GUILD_OPERATION10, 55,25,25);

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 33);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 32);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 35);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 34);
		break;

	case 3:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION11);
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35,35,35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0,0,0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION12);
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION13);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 4:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION14);
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35,35,35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0,0,0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION15);
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION16);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 5:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION17);
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35,35,35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0,0,0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION18);
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION19);
		PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_GUILD_OPERATION20);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 6:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION21);
		PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35,35,35);
		PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0,0,0);
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION22);
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION23);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 7:
		PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION24);
		//PutString(sX + 60, sY + 65, m_stGuildOpList[0].cName, RGB(35,35,35));
		//PutString(sX + 60, sY + 69, "____________________", RGB(0,0,0));
		PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION25);
		PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION26);
		PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_GUILD_OPERATION27);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	}
}

int  _tmp_iMCProb[]        = {0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40};
int  _tmp_iMLevelPenalty[] = {0,   5,   5,   8,   8,   10, 14, 28, 32, 36, 40};

void CGame::DrawDialogBox_Magic(short msX, short msY, short msZ)
{
	short sX, sY, sMagicCircle, sLevelMagic;
	int  iCPivot, i, iYloc, iResult, iManaCost;
	char cTxt[120], cMana[10];
	DWORD dwTime = m_dwCurTime;
	double dV1, dV2, dV3, dV4;

	sX = m_stDialogBoxInfo[3].sX;
	sY = m_stDialogBoxInfo[3].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME1, sX, sY, 1, FALSE, m_bDialogTrans);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 7, FALSE, m_bDialogTrans);

	if( iGetTopDialogBoxIndex() == 3 && msZ != 0 )
	{
		if( msZ > 0 ) m_stDialogBoxInfo[3].sView--;
		if( msZ < 0 ) m_stDialogBoxInfo[3].sView++;
		m_DInput.m_sZ = 0;
	}
	if( m_stDialogBoxInfo[3].sView < 0 ) m_stDialogBoxInfo[3].sView = 9;
	if( m_stDialogBoxInfo[3].sView > 9 ) m_stDialogBoxInfo[3].sView = 0;

	//Circle
	ZeroMemory(cTxt, sizeof(cTxt));
	switch (m_stDialogBoxInfo[3].sView) {
	case 0: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC1);  break;//"Circle One"
	case 1: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC2);  break;//"Circle Two"
	case 2: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC3);  break;//"Circle Three"
	case 3: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC4);  break;//"Circle Four"
	case 4: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC5);  break;//"Circle Five"
	case 5: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC6);  break;//"Circle Six"
	case 6: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC7);  break;//"Circle Seven"
	case 7: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC8);  break;//"Circle Eight"
	case 8: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC9);  break;//"Circle Nine"
	case 9: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC10); break;//"Circle Ten"
	}
	PutAlignedString(sX + 3, sX + 256, sY + 50, cTxt);
	PutAlignedString(sX + 4, sX + 257, sY + 50, cTxt);
	iCPivot = m_stDialogBoxInfo[3].sView*10;
	iYloc = 0;

	for (i = 0; i < 9; i++) {
		if ((m_cMagicMastery[iCPivot + i] != NULL) && (m_pMagicCfgList[iCPivot + i] != NULL)) {
			wsprintf(cTxt, "%s", m_pMagicCfgList[iCPivot + i]->m_cName);

			m_Misc.ReplaceString(cTxt, '-', ' ');
			iManaCost = iGetManaCost(iCPivot+i);
			if (iManaCost > m_iMP)
			{
				if( m_Misc.bCheckIMEString( cTxt ) == FALSE )
				{
					PutString(sX + 30, sY + 73 + iYloc, cTxt, RGB(41, 16, 41));
					PutString(sX + 31, sY + 73 + iYloc, cTxt, RGB(41, 16, 41));
				}
				else PutString_SprFont(sX + 30, sY + 70 + iYloc, cTxt, 5, 5, 5);
				wsprintf(cMana, "%3d", iManaCost);
				PutString_SprFont(sX + 206, sY + 70 + iYloc, cMana, 5, 5, 5);
			}
			else
			if ((msX >= sX + 30) && (msX <= sX + 240) && (msY >= sY + 70 + iYloc) && (msY <= sY + 70 + 14 + iYloc))
			{
				if( m_Misc.bCheckIMEString( cTxt ) == FALSE )
				{
					PutString(sX + 30, sY + 73 + iYloc, cTxt, RGB(255,255,255));
					PutString(sX + 31, sY + 73 + iYloc, cTxt, RGB(255,255,255));
				}
				else PutString_SprFont(sX + 30, sY + 70 + iYloc, cTxt, 250, 250, 250);
				wsprintf(cMana, "%3d", iManaCost);
				PutString_SprFont(sX + 206, sY + 70 + iYloc, cMana, 250, 250, 250);
			}
			else
			{
				if( m_Misc.bCheckIMEString( cTxt ) == FALSE )
				{
					PutString(sX + 30, sY + 73 + iYloc, cTxt, RGB(8,0,66));
					PutString(sX + 31, sY + 73 + iYloc, cTxt, RGB(8,0,66));
				}
				else PutString_SprFont(sX + 30, sY + 70 + iYloc, cTxt, 1, 1, 8);
				wsprintf(cMana, "%3d", iManaCost);
				PutString_SprFont(sX + 206, sY + 70 + iYloc, cMana, 1, 1, 8);
			}

			iYloc += 18;
		}

	}

	if (iYloc == 0) {
		PutAlignedString(sX + 3, sX +256, sY + 100, DRAW_DIALOGBOX_MAGIC11);//"
		PutAlignedString(sX + 3, sX +256, sY + 115, DRAW_DIALOGBOX_MAGIC12);//"
		PutAlignedString(sX + 3, sX +256, sY + 130, DRAW_DIALOGBOX_MAGIC13);//"
		PutAlignedString(sX + 3, sX +256, sY + 145, DRAW_DIALOGBOX_MAGIC14);//"
		PutAlignedString(sX + 3, sX +256, sY + 160, DRAW_DIALOGBOX_MAGIC15);//"
	}

	m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 30, sY + 250, 19, dwTime);

	switch (m_stDialogBoxInfo[3].sView) {
	case 0: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 30, sY + 250, 20, dwTime); break;
	case 1: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 43, sY + 250, 21, dwTime); break;
	case 2: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 61, sY + 250, 22, dwTime); break;
	case 3: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 86, sY + 250, 23, dwTime); break;
	case 4: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 106, sY + 250, 24, dwTime); break;
	case 5: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 121, sY + 250, 25, dwTime); break;
	case 6: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 142, sY + 250, 26, dwTime); break;
	case 7: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 169, sY + 250, 27, dwTime); break;
	case 8: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 202, sY + 250, 28, dwTime); break;
	case 9: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 222, sY + 250, 29, dwTime); break;
	}

	sMagicCircle = m_stDialogBoxInfo[3].sView + 1;
	if (m_cSkillMastery[4] == 0)
		 dV1 = 1.0f;
	else dV1 = (double)m_cSkillMastery[4];
	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];
	dV1 = dV2 * dV3;
	iResult = (int)dV1;
	if ((m_iInt + m_iAngelicInt) > 50) iResult += ((m_iInt + m_iAngelicInt) - 50)/2;
	sLevelMagic = (m_iLevel / 10);
	if (sMagicCircle != sLevelMagic)
	{	if (sMagicCircle > sLevelMagic)
		{	dV1 = (double)(m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;
			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}else
		{	iResult += 5*abs(sMagicCircle - sLevelMagic);
	}	}

	switch (m_cWhetherStatus) {
	case 0: break;
	case 1: iResult = iResult - (iResult / 24); break;
	case 2:	iResult = iResult - (iResult / 12); break;
	case 3: iResult = iResult - (iResult / 5);  break;
	}
	for( i=0; i<DEF_MAXITEMS ; i++ )
	{	if( m_pItemList[i] == NULL ) continue;
		if( m_bIsItemEquipped[i] == TRUE )
		{	if( ((m_pItemList[i]->m_dwAttribute & 0x00F00000) >> 20) == 10 )
			{	dV1 = (double)iResult;
				dV2 = (double)(( (m_pItemList[i]->m_dwAttribute & 0x000F0000) >> 16) * 3 );
				dV3 = dV1 + dV2;
				iResult = (int)dV3;
				break;
	}	}	}

	if (iResult > 100) iResult = 100;
	if (m_iSP < 1) iResult = iResult*9/10;
	if (iResult < 1 ) iResult = 1;

	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, DRAW_DIALOGBOX_MAGIC16, iResult);//"
	PutAlignedString(sX, sX + 256, sY + 267, cTxt);
	PutAlignedString(sX+1, sX + 257, sY + 267, cTxt);

	// v2.15
	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 285) && (msY <= sY + 285 + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + 285, 49, FALSE, m_bDialogTrans);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + 285, 48, FALSE, m_bDialogTrans);
}

void CGame::DrawDialogBox_MagicShop(short msX, short msY, short msZ)
{
 short sX, sY;
 DWORD dwTime = m_dwCurTime;
 int  i;

 int  iCPivot, iYloc;
 char cTxt[120], cMana[10];

	sX = m_stDialogBoxInfo[16].sX;
	sY = m_stDialogBoxInfo[16].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, sX, sY, 1);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 14);

	if( iGetTopDialogBoxIndex() == 16 && msZ != 0 )
	{
		if( msZ > 0 ) m_stDialogBoxInfo[16].sView--;
		if( msZ < 0 ) m_stDialogBoxInfo[16].sView++;
		m_DInput.m_sZ = 0;
	}
	if( m_stDialogBoxInfo[16].sView < 0 ) m_stDialogBoxInfo[16].sView = 9;
	if( m_stDialogBoxInfo[16].sView > 9 ) m_stDialogBoxInfo[16].sView = 0;

	PutString(sX -20 + 60 -17, sY - 35 + 90, DRAW_DIALOGBOX_MAGICSHOP11, RGB(45,25,25));//"Spell Name"
	PutString(sX -20 + 232 -20, sY - 35 + 90, DRAW_DIALOGBOX_MAGICSHOP12, RGB(45,25,25));//"Req.Int"
	PutString(sX -20 + 270, sY - 35 + 90, DRAW_DIALOGBOX_MAGICSHOP13, RGB(45,25,25));//"Cost"

	iCPivot = m_stDialogBoxInfo[16].sView*10;

	iYloc = 0;
	for (i = 0; i < 9; i++) {
		if ((m_pMagicCfgList[iCPivot + i] != NULL) && (m_pMagicCfgList[iCPivot + i]->m_bIsVisible)) {
			wsprintf(cTxt, "%s", m_pMagicCfgList[iCPivot + i]->m_cName);

			m_Misc.ReplaceString(cTxt, '-', ' ');
			if (m_cMagicMastery[iCPivot + i] != 0) {
				if( m_Misc.bCheckIMEString( cTxt ) == FALSE )
				{
					PutString(sX + 24, sY + 73 + iYloc, cTxt, RGB(41,16,41));
					PutString(sX + 25, sY + 73 + iYloc, cTxt, RGB(41,16,41));
				}
				else PutString_SprFont(sX + 24, sY + 70 + iYloc, cTxt, 5, 5, 5);
				wsprintf(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue2);
				PutString_SprFont(sX + 200, sY + 70 + iYloc, cMana, 5, 5, 5);
				wsprintf(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue3);
				PutString_SprFont(sX + 241, sY + 70 + iYloc, cMana, 5, 5, 5);
			}
			else
			if ((msX >= sX + 24) && (msX <= sX + 24 + 135) && (msY >= sY + 70 + iYloc) && (msY <= sY + 70 + 14 + iYloc)) {
				if( m_Misc.bCheckIMEString( cTxt ) == FALSE )
				{
					PutString(sX + 24, sY + 73 + iYloc, cTxt, RGB(255,255,255));
					PutString(sX + 25, sY + 73 + iYloc, cTxt, RGB(255,255,255));
				}
				else PutString_SprFont(sX -20 + 44, sY + 70 + iYloc, cTxt, 250, 250, 250);
				wsprintf(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue2);
				PutString_SprFont(sX -20 + 220, sY + 70 + iYloc, cMana, 250, 250, 250);
				wsprintf(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue3);
				PutString_SprFont(sX -20 + 261, sY + 70 + iYloc, cMana, 250, 250, 250);
			}
			else {
				if( m_Misc.bCheckIMEString( cTxt ) == FALSE )
				{
					PutString(sX + 24, sY + 73 + iYloc, cTxt, RGB(8,0,66));
					PutString(sX + 25, sY + 73 + iYloc, cTxt, RGB(8,0,66));
				}
				else PutString_SprFont(sX -20 + 44, sY + 70 + iYloc, cTxt, 1, 1, 8);
				wsprintf(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue2);
				PutString_SprFont(sX -20 + 220, sY + 70 + iYloc, cMana, 1, 1, 8);
				wsprintf(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue3);
				PutString_SprFont(sX -20 + 261, sY + 70 + iYloc, cMana, 1, 1, 8);
			}
			iYloc += 18;
		}
	}

	m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 55, sY + 250, 19, dwTime);

	switch (m_stDialogBoxInfo[16].sView) {
	case 0: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 44  +31, sY + 250, 20, dwTime); break;
	case 1: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 57  +31, sY + 250, 21, dwTime); break;
	case 2: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 75  +31, sY + 250, 22, dwTime); break;
	case 3: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 100 +31, sY + 250, 23, dwTime); break;
	case 4: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 120 +31, sY + 250, 24, dwTime); break;
	case 5: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 135 +31, sY + 250, 25, dwTime); break;
	case 6: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 156 +31, sY + 250, 26, dwTime); break;
	case 7: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 183 +31, sY + 250, 27, dwTime); break;
	case 8: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 216 +31, sY + 250, 28, dwTime); break;
	case 9: m_pSprite[DEF_SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX -20 + 236 +31, sY + 250, 29, dwTime); break;
	}

	PutAlignedString(sX, sX+m_stDialogBoxInfo[16].sSizeX, sY + 275, DRAW_DIALOGBOX_MAGICSHOP14, 45,25,25);
}

void CGame::DrawDialogBox_ShutDownMsg(short msX, short msY)
{
 short sX, sY, szX;

	sX = m_stDialogBoxInfo[25].sX;
	sY = m_stDialogBoxInfo[25].sY;
	szX = m_stDialogBoxInfo[25].sSizeX;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, sX, sY,2);

	switch (m_stDialogBoxInfo[25].cMode) {
	case 1:
		ZeroMemory(G_cTxt, sizeof(G_cTxt));
		if (m_stDialogBoxInfo[25].sV1 != 0) wsprintf(G_cTxt, DRAW_DIALOGBOX_NOTICEMSG1, m_stDialogBoxInfo[25].sV1);
		else strcpy(G_cTxt, DRAW_DIALOGBOX_NOTICEMSG2);
		PutAlignedString(sX, sX + szX, sY + 31, G_cTxt, 100,10,10);
		PutAlignedString(sX, sX + szX, sY + 48, DRAW_DIALOGBOX_NOTICEMSG3);
		PutAlignedString(sX, sX + szX, sY + 65, DRAW_DIALOGBOX_NOTICEMSG4);
		PutAlignedString(sX, sX + szX, sY + 82, DRAW_DIALOGBOX_NOTICEMSG5);
		PutAlignedString(sX, sX + szX, sY + 99, DRAW_DIALOGBOX_NOTICEMSG6);
		if ((msX >= sX + 210) && (msX <= sX + 210 + DEF_BTNSZX) && (msY > sY + 127) && (msY < sY + 127 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 210, sY + 127, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 210, sY + 127, 0);
		break;

	case 2:
		PutAlignedString(sX, sX + szX, sY + 31, DRAW_DIALOGBOX_NOTICEMSG7, 100,10,10);
		PutAlignedString(sX, sX + szX, sY + 48, DRAW_DIALOGBOX_NOTICEMSG8);
		PutAlignedString(sX, sX + szX, sY + 65,  DRAW_DIALOGBOX_NOTICEMSG9);
		PutAlignedString(sX, sX + szX, sY + 82, DRAW_DIALOGBOX_NOTICEMSG10);
		PutAlignedString(sX, sX + szX, sY + 99, DRAW_DIALOGBOX_NOTICEMSG11);
		if ((msX >= sX + 210) && (msX <= sX + 210 + DEF_BTNSZX) && (msY > sY + 127) && (msY < sY + 127 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 210, sY + 127, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 210, sY + 127, 0);
		break;
	}
}

void CGame::DrawDialogBox_NpcActionQuery(short msX, short msY)
{
 short sX, sY, szX;

 char cTxt[120], cTxt2[120],  cStr1[64], cStr2[64], cStr3[64];

	ZeroMemory(cStr1, sizeof(cStr1));
	ZeroMemory(cStr2, sizeof(cStr2));
	ZeroMemory(cStr3, sizeof(cStr3));

	sX = m_stDialogBoxInfo[20].sX;
	sY = m_stDialogBoxInfo[20].sY;
	szX = m_stDialogBoxInfo[20].sSizeX;

	//DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 5); //5
	//DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 6); //6

	switch (m_stDialogBoxInfo[20].cMode) {
	case 0: // npc
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 5);
		switch (m_stDialogBoxInfo[20].sV3) {
		case 15:
			PutString(sX +33, sY +23, NPC_NAME_SHOP_KEEPER, RGB(45,25,25));
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_SHOP_KEEPER, RGB(255,255,255));
			break;
		case 19:
			PutString(sX +33, sY +23, NPC_NAME_MAGICIAN, RGB(45,25,25));
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_MAGICIAN, RGB(255,255,255));
			break;
		case 20:
			PutString(sX +33, sY +23, NPC_NAME_WAREHOUSE_KEEPER, RGB(45,25,25));
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_WAREHOUSE_KEEPER, RGB(255,255,255));
			break;
		case 24:
			PutString(sX +33, sY +23, NPC_NAME_BLACKSMITH_KEEPER, RGB(45,25,25));
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_BLACKSMITH_KEEPER, RGB(255,255,255));
			break;
		case 25:
			PutString(sX +33, sY +23, NPC_NAME_CITYHALL_OFFICER, RGB(45,25,25));
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_CITYHALL_OFFICER, RGB(255,255,255));
			break;
		case 26: // "Guildhall Officer"
			PutString(sX +33, sY +23, NPC_NAME_GUILDHALL_OFFICER, RGB(45,25,25));
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_GUILDHALL_OFFICER, RGB(255,255,255));
			break;
		case 90: //Gail
			PutString(sX +33, sY +23, "Heldenian staff officer", RGB(45,25,25));
			PutString(sX +33 -1, sY +23 -1, "Heldenian staff officer", RGB(255,255,255));
			break;
		}

		if ( m_stDialogBoxInfo[20].sV3 == 25 )
		{   // OFFER
			if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY13, RGB(255,255,255)); // "Offer"
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY13, RGB(255,255,255));
			}
			else {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY13, RGB(4,0,50));
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY13, RGB(4,0,50));
			}
		}else if ( m_stDialogBoxInfo[20].sV3 == 20 )
		{   // WITHDRAW
			if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY17, RGB(255,255,255)); // "Withdraw"
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY17, RGB(255,255,255));
			}
			else {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY17, RGB(4,0,50));
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY17, RGB(4,0,50));
			}
		}else if ( m_stDialogBoxInfo[20].sV3 == 19 ) // CLEROTH: MAGICIAN
		{   // LEARN
			if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY19, RGB(255,255,255)); // "Learn"
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY19, RGB(255,255,255));
			}
			else {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY19, RGB(4,0,50));
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY19, RGB(4,0,50));
			}
		}else
		{   // TRADE
			if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(255,255,255)); // "Trade"
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(255,255,255));
			}
			else {
				PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(4,0,50));
				PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(4,0,50));
		}	}

		if (m_bIsDialogEnabled[21] == FALSE)
		{	if ((msX > sX + 125) && (msX < sX + 180) && (msY > sY + 55) && (msY < sY + 70)) {
				PutString(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(255,255,255)); // "Talk"
				PutString(sX + 126, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(255,255,255));
			}
			else {
				PutString(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(4,0,50));
				PutString(sX + 126, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(4,0,50));
			}
		}
		break;

	case 1: // Other char
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 6);
		GetItemName(m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_dwAttribute, cStr1, cStr2, cStr3);
		wsprintf(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29, m_stDialogBoxInfo[20].sV3, cStr1); //"%d %s to"
		wsprintf(cTxt2, DRAW_DIALOGBOX_NPCACTION_QUERY29_1, m_stDialogBoxInfo[20].cStr); // "%s"

		PutString(sX+24, sY+25, cTxt, RGB(45,25,25));
		PutString(sX+24, sY+40, cTxt2, RGB(45,25,25));

		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
			PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY30, RGB(255,255,255));//"Give"
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY30, RGB(255,255,255));
		}
		else {
			PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY30, RGB(4,0,50));
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY30, RGB(4,0,50));
		}

		if ((msX > sX + 155) && (msX < sX + 210) && (msY > sY + 55) && (msY < sY + 70)) {
			PutString(sX + 155, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY34, RGB(255,255,255));//"Exchange"
			PutString(sX + 156, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY34, RGB(255,255,255));
		}
		else {
			PutString(sX + 155, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY34, RGB(4,0,50));
			PutString(sX + 156, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY34, RGB(4,0,50));
		}
		break;

	case 2: // Shop / BS
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 5);
		GetItemName(m_pItemList[ m_stDialogBoxInfo[20].sV1 ]->m_cName, m_pItemList[ m_stDialogBoxInfo[20].sV1 ]->m_dwAttribute, cStr1, cStr2, cStr3);

		wsprintf(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29, m_stDialogBoxInfo[20].sV3, cStr1);//"%d %s to"
		wsprintf(cTxt2, DRAW_DIALOGBOX_NPCACTION_QUERY29_1, m_stDialogBoxInfo[20].cStr);//"%s"

		PutString(sX+24, sY+20, cTxt, RGB(45,25,25));
		PutString(sX+24, sY+35, cTxt2, RGB(45,25,25));

		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70))
		{	PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(255,255,255));//"Sell"
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(255,255,255));
		}else
		{	PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(4,0,50));
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(4,0,50));
		}

		if ((m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cItemType == DEF_ITEMTYPE_ARROW))
		{}else
		{	if ((msX > sX + 125) && (msX < sX + 180) && (msY > sY + 55) && (msY < sY + 70))
			{	PutString(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY43, RGB(255,255,255));//"Repair"
				PutString(sX + 126, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY43, RGB(255,255,255));
			}else
			{	PutString(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY43, RGB(4,0,50));
				PutString(sX + 126, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY43, RGB(4,0,50));
		}	}
		break;

	case 3: // WH
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 6);
		GetItemName(m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_dwAttribute, cStr1, cStr2, cStr3);

		wsprintf(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29, m_stDialogBoxInfo[20].sV3, cStr1);//"%d %s to"
		wsprintf(cTxt2, DRAW_DIALOGBOX_NPCACTION_QUERY29_1, m_stDialogBoxInfo[20].cStr);//"%s"

		PutAlignedString(sX, sX+240, sY+20, cTxt, 45,25,25);
		PutAlignedString(sX, sX+240, sY+35, cTxt2, 45,25,25);

		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70)) {
			PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY48, RGB(255,255,255));//"Deposit"
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY48, RGB(255,255,255));
		}else
		{	PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY48, RGB(4,0,50));
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY48, RGB(4,0,50));
		}
		break;

	case 4: // talk to npc or unicorn
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 5);
		switch (m_stDialogBoxInfo[20].sV3) {
		case 21:
			PutString(sX +35, sY + 25, NPC_NAME_GUARD, RGB(45,25,25));//
			PutString(sX +35 -1, sY + 25 -1, NPC_NAME_GUARD, RGB(255,255,255));
			break;
		case 32:
			PutString(sX +35, sY + 25, NPC_NAME_UNICORN, RGB(45,25,25));//"
			PutString(sX +35 -1, sY + 25 -1, NPC_NAME_UNICORN, RGB(255,255,255));//"
			break;
		case 67:
			PutString(sX +35, sY + 25, NPC_NAME_MCGAFFIN, RGB(45,25,25));
			PutString(sX +35 -1, sY + 25 -1, NPC_NAME_MCGAFFIN, RGB(255,255,255));
			break;
		case 68:
			PutString(sX +35, sY + 25, NPC_NAME_PERRY, RGB(45,25,25));
			PutString(sX +35 -1, sY + 25 -1, NPC_NAME_PERRY, RGB(255,255,255));
			break;
		case 69:
			PutString(sX +35, sY + 25, NPC_NAME_DEVLIN, RGB(45,25,25));
			PutString(sX +35 -1, sY + 25 -1, NPC_NAME_DEVLIN, RGB(255,255,255));
			break;

		}

		if (m_bIsDialogEnabled[21] == FALSE) {
			if ((msX > sX + 125) && (msX < sX + 180) && (msY > sY + 55) && (msY < sY + 70)) {
				PutString(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(255,255,255));
				PutString(sX + 126, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(255,255,255));
			}
			else {
				PutString(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(4,0,50));
				PutString(sX + 126, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(4,0,50));
			}
		}
		break;

	case 5: // Shop / BS
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 6);
		switch (m_stDialogBoxInfo[20].sV3) {
		case 15:
			PutString(sX +33, sY +23, NPC_NAME_SHOP_KEEPER, RGB(45,25,25));//Shop Keeper"
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_SHOP_KEEPER, RGB(255,255,255));
			break;
		case 24:
			PutString(sX +33, sY +23, NPC_NAME_BLACKSMITH_KEEPER, RGB(45,25,25));//"BlackSmith Keeper"
			PutString(sX +33 -1, sY +23 -1, NPC_NAME_BLACKSMITH_KEEPER, RGB(255,255,255));//"
			break;
		}

		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70))
		{	PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(255,255,255));//"Trade"
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(255,255,255));
		}else
		{	PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(4,0,50));
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(4,0,50));
		}

		if ((msX > sX + 25 +79) && (msX < sX + 80 +75) && (msY > sY + 55) && (msY < sY + 70))
		{	PutString(sX + 28 +75, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(255,255,255));//"Sell"
			PutString(sX + 29 +75, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(255,255,255));
		}else
		{	PutString(sX + 28 +75, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(4,0,50));
			PutString(sX + 29 +75, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, RGB(4,0,50));
		}
		if (m_bIsDialogEnabled[21] == FALSE)
		{	if ((msX > sX + 155) && (msX < sX + 210) && (msY > sY + 55) && (msY < sY + 70))
			{	PutString(sX + 155, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(255,255,255));//"Talk"
				PutString(sX + 156, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(255,255,255));
			}else
			{	PutString(sX + 155, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(4,0,50));
				PutString(sX + 156, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, RGB(4,0,50));
		}	}
		break;

	case 6: //Gail
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 5);
		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70))
		{	PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(255,255,255)); // "Trade"
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(255,255,255));
		}else
		{	PutString(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(4,0,50));
			PutString(sX + 29, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, RGB(4,0,50));
		}
		PutString(sX +33, sY +23, "Heldenian staff officer", RGB(45,25,25));
		PutString(sX +33 -1, sY +23 -1, "Heldenian staff officer", RGB(255,255,255));
		break;
	}
}

void CGame::DrawDialogBox_Party(short msX, short msY)
{short sX, sY, szX;
 int  i, iNth;
	sX = m_stDialogBoxInfo[32].sX;
	sY = m_stDialogBoxInfo[32].sY;
	szX = m_stDialogBoxInfo[32].sSizeX;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 3);

	switch (m_stDialogBoxInfo[32].cMode) {
	case 0:
		if (m_iPartyStatus == 0) {
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 80) && (msY < sY + 100))
				 PutAlignedString(sX, sX + szX, sY + 85, DRAW_DIALOGBOX_PARTY1, 255,255,255);//"
			else PutAlignedString(sX, sX + szX, sY + 85, DRAW_DIALOGBOX_PARTY1, 4,0,50);//"
		}
		else PutAlignedString(sX, sX + szX, sY + 85, DRAW_DIALOGBOX_PARTY1, 65,65,65);//"

		if (m_iPartyStatus != 0) {
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 100) && (msY < sY + 120))
				 PutAlignedString(sX, sX + szX, sY + 105, DRAW_DIALOGBOX_PARTY4, 255,255,255);//"
			else PutAlignedString(sX, sX + szX, sY + 105, DRAW_DIALOGBOX_PARTY4, 4,0,50);//"
		}
		else PutAlignedString(sX, sX + szX, sY + 105, DRAW_DIALOGBOX_PARTY4, 65,65,65);//"

		if (m_iPartyStatus != 0) {
			if ((msX > sX + 80) && (msX < sX + 195) && (msY > sY + 120) && (msY < sY + 140))
				 PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 255,255,255);//"
			else PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 4,0,50);//"
		}
		else PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 65,65,65);//"


		switch (m_iPartyStatus) {
		case 0:
			PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY10);//"
			PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY11);//"
			PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_PARTY12);//"
			break;

		case 1:
		case 2:
			PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY13);//"
			PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY14);//"
			PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_PARTY15);//"
			break;
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
		break;

	case 1: //
		wsprintf(G_cTxt, DRAW_DIALOGBOX_PARTY16,  m_stDialogBoxInfo[32].cStr);
		PutAlignedString(sX, sX + szX, sY + 95, G_cTxt);
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY17);//"join the party. You can"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY18);//"share the experience by"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY19);//"the ratio of level if"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY20);//"you join the party."
		PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_PARTY21);//"Would you like to join party?"

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;

	case 2:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY22);//"Click the character which"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY23);//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY24);//"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY25);//"

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 3:
		wsprintf(G_cTxt, DRAW_DIALOGBOX_PARTY26, m_stDialogBoxInfo[32].cStr);//"
		PutAlignedString(sX, sX + szX, sY + 95, G_cTxt);
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY27);//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY28);//"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY29);//"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY30);//"

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 4:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY31);//"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY32);//"

		iNth = 0;
		for (i = 0; i <= DEF_MAXPARTYMEMBERS; i++)
		if (strlen(m_stPartyMemberNameList[i].cName) != 0) {
			wsprintf(G_cTxt, "%s", m_stPartyMemberNameList[i].cName);
			PutAlignedString(sX +17, sX +270, sY + 140 +15*(iNth), G_cTxt);
			iNth++;
		}

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 5:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY33);//"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY34);//"
		break;

	case 6:
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY35);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 7:
		PutAlignedString(sX, sX + szX, sY + 95,  DRAW_DIALOGBOX_PARTY36);//"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY37);//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY38);//"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY39);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 8:
		PutAlignedString(sX, sX + szX, sY + 95,  DRAW_DIALOGBOX_PARTY40);//"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY41);//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY42);//"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY43);//"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY44);//"
		PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY45);//"


		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 9:
		PutAlignedString(sX, sX + szX, sY + 95,  DRAW_DIALOGBOX_PARTY46);//"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY47);//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY48);//"
		PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY49);//"
		PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY50);//"
		PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY51);//"

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 10:
		PutAlignedString(sX, sX + szX, sY + 95,  DRAW_DIALOGBOX_PARTY52);//"
		PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY53);//"
		PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY54);//"
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 11: //
		PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY55);//"
		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 19);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 18);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 3);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 2);
		break;
	}
}

void CGame::DrawDialogBox_QueryDropItemAmount()
{
 short sX, sY;
 char cTxt[120], cStr1[64], cStr2[64], cStr3[64];

	sX = m_stDialogBoxInfo[17].sX;
	sY = m_stDialogBoxInfo[17].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 5);

	switch (m_stDialogBoxInfo[17].cMode) {
	case 1:
		GetItemName( m_pItemList[m_stDialogBoxInfo[17].sView]->m_cName, m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwAttribute, cStr1, cStr2, cStr3 );
		if (strlen(m_stDialogBoxInfo[17].cStr) == 0)
			 wsprintf(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT1, cStr1);
		else wsprintf(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT2, cStr1, m_stDialogBoxInfo[17].cStr);//"%s:

		if (m_stDialogBoxInfo[17].sV3 < 1000)
			PutString(sX + 30, sY + 20, cTxt, RGB(55,25,25));

		PutString(sX + 30, sY + 35, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT3, RGB(55,25,25));//"
		if (iGetTopDialogBoxIndex() != 17)
			PutString(sX + 40, sY + 57, m_cAmountString, RGB(255,255,255), FALSE, 2);
		wsprintf(cTxt, "__________ (0 ~ %d)", m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwCount);
		PutString(sX + 38, sY + 62, cTxt, RGB(25,35,25));
		break;

	case 20:
		GetItemName( m_pItemList[m_stDialogBoxInfo[17].sView]->m_cName, m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwAttribute, cStr1, cStr2, cStr3 );
		if (strlen(m_stDialogBoxInfo[17].cStr) == 0) // v1.4
			 wsprintf(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT1, cStr1);//"%s:
		else wsprintf(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT2, cStr1, m_stDialogBoxInfo[17].cStr);//"%s:

		if (m_stDialogBoxInfo[17].sV3 < 1000) // v1.4
			PutString(sX + 30, sY + 20, cTxt, RGB(55,25,25));

		PutString(sX + 30, sY + 35, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT3, RGB(55,25,25));//"
		PutString(sX + 40, sY + 57, m_cAmountString, RGB(255,255,255), FALSE, 2);
		wsprintf(cTxt, "__________ (0 ~ %d)", m_pItemList[m_stDialogBoxInfo[17].sView]->m_dwCount);
		PutString(sX + 38, sY + 62, cTxt, RGB(25,35,25));
		break;
	}
}


void CGame::DrawDialogBox_Quest(int msX, int msY)
{
 short sX, sY, szX;
 char cTxt[120], cTemp[21];

	sX = m_stDialogBoxInfo[28].sX;
	sY = m_stDialogBoxInfo[28].sY;
	szX = m_stDialogBoxInfo[28].sSizeX;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT , sX, sY, 4);

	switch (m_stDialogBoxInfo[28].cMode) {
	case 1:
		switch (m_stQuest.sQuestType) {
		case NULL:
			PutAlignedString(sX, sX + szX, sY + 50 +115 -30, DRAW_DIALOGBOX_QUEST1, 55,25,25); // " You are not on a quest."
			break;

		case 1:	//  Hunt
			if (m_stQuest.bIsQuestCompleted == FALSE)
				 PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST2, 55,25,25); // "You are on a monster conquering quest."
			else PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST3, 55,25,25); // "You accomplished the monster conquering quest."

			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "Rest Monster : %d", m_stQuest.sCurrentCount); // Snoopy: "Rest Monster : %s"
			PutAlignedString(sX, sX + szX, sY + 50 +20, cTxt, 55,25,25);  // m_stQuest.sCurrentCount

			ZeroMemory(cTemp, sizeof(cTemp));
			switch (m_stQuest.sWho) {
			case 1:
			case 2:
			case 3: break;
			case 4: strcpy(cTemp, NPC_NAME_CITYHALL_OFFICER); break;
			case 5:
			case 6:
			case 7: break;
			}
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt,  DRAW_DIALOGBOX_QUEST5, cTemp); // "Client: %s"
			PutAlignedString(sX, sX + szX, sY + 50 +45, cTxt, 55,25,25);

			ZeroMemory(cTemp, sizeof(cTemp));
			GetNpcName(m_stQuest.sTargetType, cTemp);
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, NPC_TALK_HANDLER16, m_stQuest.sTargetCount, cTemp);
			PutAlignedString(sX, sX + szX, sY + 50 +60, cTxt, 55,25,25);

			ZeroMemory(cTxt, sizeof(cTxt));
			if (memcmp(m_stQuest.cTargetName, "NONE", 4) == 0)
			{	strcpy(cTxt, DRAW_DIALOGBOX_QUEST31); // "Location : Anywhere"
				PutAlignedString(sX, sX + szX, sY + 50 +75, cTxt, 55,25,25);
			}else
			{	ZeroMemory(cTemp, sizeof(cTemp));
				GetOfficialMapName(m_stQuest.cTargetName, cTemp);
				wsprintf(cTxt,  DRAW_DIALOGBOX_QUEST32, cTemp); // "Map : %s"
				PutAlignedString(sX, sX + szX, sY + 50 +75, cTxt, 55,25,25);

				if (m_stQuest.sX != 0) {
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, DRAW_DIALOGBOX_QUEST33, m_stQuest.sX, m_stQuest.sY, m_stQuest.sRange); // "Position: %d, %d Range: %d block"
					PutAlignedString(sX, sX + szX, sY + 50 +90, cTxt, 55,25,25);
				}
			}

			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, DRAW_DIALOGBOX_QUEST34, m_stQuest.sContribution); // "Contribution: %d"
			PutAlignedString(sX, sX + szX, sY + 50 +105, cTxt, 55,25,25);
			break;

		case 7: //
			if (m_stQuest.bIsQuestCompleted == FALSE)
				 PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST26, 55,25,25);
			else PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST27, 55,25,25);

			ZeroMemory(cTemp, sizeof(cTemp));
			switch (m_stQuest.sWho) {
			case 1:
			case 2:
			case 3: break;
			case 4: strcpy(cTemp, NPC_NAME_CITYHALL_OFFICER); break;
			case 5:
			case 6:
			case 7: break;
			}
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, DRAW_DIALOGBOX_QUEST29, cTemp);
			PutAlignedString(sX, sX + szX, sY + 50 +45, cTxt, 55,25,25);

			PutAlignedString(sX, sX + szX, sY + 50 +60, DRAW_DIALOGBOX_QUEST30, 55,25,25);

			ZeroMemory(cTxt, sizeof(cTxt));
			if (memcmp(m_stQuest.cTargetName, "NONE", 4) == 0) {
				strcpy(cTxt, DRAW_DIALOGBOX_QUEST31);
				PutAlignedString(sX, sX + szX, sY + 50 +75, cTxt, 55,25,25);
			}
			else {
				ZeroMemory(cTemp, sizeof(cTemp));
				GetOfficialMapName(m_stQuest.cTargetName, cTemp);
				wsprintf(cTxt, DRAW_DIALOGBOX_QUEST32, cTemp);
				PutAlignedString(sX, sX + szX, sY + 50 +75, cTxt, 55,25,25);

				if (m_stQuest.sX != 0) {
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, DRAW_DIALOGBOX_QUEST33, m_stQuest.sX, m_stQuest.sY, m_stQuest.sRange);
					PutAlignedString(sX, sX + szX, sY + 50 +90, cTxt, 55,25,25);
				}
			}

			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, DRAW_DIALOGBOX_QUEST34, m_stQuest.sContribution);//" %dPoint"
			PutAlignedString(sX, sX + szX, sY + 50 +105, cTxt, 55,25,25);
			break;
		}
		break;

	case 2:
		PutAlignedString(sX, sX + szX, sY + 50 +115 -30, DRAW_DIALOGBOX_QUEST35, 55,25,25);
		break;
	}

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
}

void CGame::DrawDialogBox_SellList(short msX, short msY)
{
 short sX, sY, szX;
 int  i, iItem;
 char cTemp[255], cStr1[64], cStr2[64], cStr3[64];

	sX = m_stDialogBoxInfo[31].sX;
	sY = m_stDialogBoxInfo[31].sY;
	szX = m_stDialogBoxInfo[31].sSizeX;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 11);

	iItem = 0;
	for (i = 0; i < DEF_MAXSELLLIST; i++)
	if (m_stSellItemList[i].iIndex != -1)
	{
		ZeroMemory(cTemp, sizeof(cTemp));
		GetItemName(m_pItemList[m_stSellItemList[i].iIndex]->m_cName, m_pItemList[m_stSellItemList[i].iIndex]->m_dwAttribute, cStr1, cStr2, cStr3);
		if (m_stSellItemList[i].iAmount > 1 )
		{	wsprintf(cTemp, DRAW_DIALOGBOX_SELL_LIST1, m_stSellItemList[i].iAmount, cStr1);
			if ((msX > sX + 25) && (msX < sX + 250) && (msY >= sY + 55 + i*15) && (msY <= sY + 55 + 14 + i*15))
				 PutAlignedString(sX, sX+szX, sY + 55 + i*15, cTemp, 255,255,255);
			else
			{
				if(m_bIsSpecial)
					PutAlignedString(sX, sX+szX, sY + 55 + i*15, cTemp, 0,255,50);
				else
					PutAlignedString(sX, sX+szX, sY + 55 + i*15, cTemp, 45,25,25);
			}
		}
		else
		{
			if ((msX > sX + 25) && (msX < sX + 250) && (msY >= sY + 55 + i*15) && (msY <= sY + 55 + 14 + i*15))
			{
				if( (strlen(cStr2)==0) && (strlen(cStr3)==0) ) PutAlignedString(sX, sX+szX, sY + 55 + i*15, cStr1, 255,255,255);
				else
				{
					ZeroMemory( G_cTxt, sizeof(G_cTxt) );
					if( (strlen(cStr1)+strlen(cStr2)+strlen(cStr3)) < 36 )
					{
						if( (strlen(cStr2)>0) && (strlen(cStr3)>0) ) wsprintf( G_cTxt, "%s(%s, %s)", cStr1, cStr2, cStr3 );
						else wsprintf( G_cTxt, "%s(%s%s)", cStr1, cStr2, cStr3 );
						PutAlignedString(sX, sX+szX, sY + 55 + i*15, G_cTxt, 255,255,255);

					}
					else
					{
						if( (strlen(cStr2)>0) && (strlen(cStr3)>0) ) wsprintf( G_cTxt, "(%s, %s)", cStr2, cStr3 );
						else wsprintf( G_cTxt, "(%s%s)", cStr2, cStr3 );
						PutAlignedString(sX, sX+szX, sY + 55 + i*15, cStr1, 255,255,255);
						PutAlignedString(sX, sX+szX, sY + 55 + i*15 + 15, G_cTxt, 200,200,200);
						i++;
					}
				}
			}else
			{	if( (strlen(cStr2)==0) && (strlen(cStr3)==0) )
				{	if(m_bIsSpecial)
						PutAlignedString(sX, sX+szX, sY + 55 + i*15, cStr1, 0,255,50);
					else
						PutAlignedString(sX, sX+szX, sY + 55 + i*15, cStr1, 45,25,25);
				}else
				{	ZeroMemory( G_cTxt, sizeof(G_cTxt) );
					if( (strlen(cStr1)+strlen(cStr2)+strlen(cStr3)) < 36 )
					{
						if( (strlen(cStr2)>0) && (strlen(cStr3)>0) ) wsprintf( G_cTxt, "%s(%s, %s)", cStr1, cStr2, cStr3 );
						else wsprintf( G_cTxt, "%s(%s%s)", cStr1, cStr2, cStr3 );

						if(m_bIsSpecial)
							PutAlignedString(sX, sX+szX, sY + 55 + i*15, G_cTxt, 0,255,50);
						else
							PutAlignedString(sX, sX+szX, sY + 55 + i*15, G_cTxt, 45,25,25);

					}
					else
					{	if(m_bIsSpecial)
							PutAlignedString(sX, sX+szX, sY + 55 + i*15, cStr1, 0,255,50);
						else
							PutAlignedString(sX, sX+szX, sY + 55 + i*15, cStr1, 45,25,25);
					}
				}
			}
		}
	}
	else iItem++;

	if (iItem == DEF_MAXSELLLIST) {
		PutAlignedString(sX, sX+szX, sY + 55 + 30 + 282 -117 -170, DRAW_DIALOGBOX_SELL_LIST2);//"
		PutAlignedString(sX, sX+szX, sY + 55 + 45 + 282 -117 -170, DRAW_DIALOGBOX_SELL_LIST3);//"
		PutAlignedString(sX, sX+szX, sY + 55 + 60 + 282 -117 -170, DRAW_DIALOGBOX_SELL_LIST4);//"
		PutAlignedString(sX, sX+szX, sY + 55 + 75 + 282 -117 -170, DRAW_DIALOGBOX_SELL_LIST5);//"
		PutAlignedString(sX, sX+szX, sY + 55 + 95 + 282 -117 -170, DRAW_DIALOGBOX_SELL_LIST6);//"
		PutAlignedString(sX, sX+szX, sY + 55 + 110 + 282 -117 -170,DRAW_DIALOGBOX_SELL_LIST7);//"
		PutAlignedString(sX, sX+szX, sY + 55 + 125 + 282 -117 -170,DRAW_DIALOGBOX_SELL_LIST8);//"
		PutAlignedString(sX, sX+szX, sY + 55 + 155 + 282 -117 -170,DRAW_DIALOGBOX_SELL_LIST9);//"

	}

	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY) && (iItem < DEF_MAXSELLLIST) )
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 39);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 38);

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
}

void CGame::DrawDialogBox_SellorRepairItem(short msX, short msY)
{
 short sX, sY;
 DWORD dwTime = m_dwCurTime;
 char cItemID, cItemColor, cTxt[120], cTemp[120], cStr2[120], cStr3[120];

	sX = m_stDialogBoxInfo[23].sX;
	sY = m_stDialogBoxInfo[23].sY;

	switch (m_stDialogBoxInfo[23].cMode) {
	case 1:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 11);

		cItemID = m_stDialogBoxInfo[23].sV1;

		cItemColor = m_pItemList[cItemID]->m_cItemColor;
		if (cItemColor == 0)
			 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteFast(sX + 62 + 15, sY + 84 + 30,
	                                                                                                   m_pItemList[cItemID]->m_sSpriteFrame, dwTime);
		else
		{	switch (m_pItemList[cItemID]->m_sSprite) {
			case 1: // Swds
			case 2: // Bows
			case 3: // Shields
			case 15: // Axes hammers
#ifdef DEF_EQUILIBRIUM_PROJECT
			case 17: // Wands
#endif
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30
						, m_pItemList[cItemID]->m_sSpriteFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
				break;
			default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30
					 	, m_pItemList[cItemID]->m_sSpriteFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
				break;
			}
		}
		ZeroMemory(cTemp, sizeof(cTemp));
		ZeroMemory(cStr2, sizeof(cStr2));
		ZeroMemory(cStr3, sizeof(cStr3));

		GetItemName(m_pItemList[cItemID]->m_cName, m_pItemList[cItemID]->m_dwAttribute, cTemp, cStr2, cStr3);
		if( m_stDialogBoxInfo[23].sV4 == 1 ) strcpy( cTxt, cTemp );
		else wsprintf(cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM1, m_stDialogBoxInfo[23].sV4, cTemp);

		if(m_bIsSpecial)
		{
			PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 0,255,50);
			PutAlignedString(sX + 25 +1, sX + 240 +1, sY + 60, cTxt, 0,255,50);
		}
		else
		{
			PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 45,25,25);
			PutAlignedString(sX + 25 +1, sX + 240 +1, sY + 60, cTxt, 45,25,25);
		}

		wsprintf(cTxt,  DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM2, m_stDialogBoxInfo[23].sV2);
		PutString(sX + 95 + 15, sY + 53 + 60, cTxt, RGB(45,25,25));
		wsprintf(cTxt,  DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM3, m_stDialogBoxInfo[23].sV3);
		PutString(sX + 95 + 15, sY + 53 + 75, cTxt, RGB(45,25,25));
		PutString(sX + 55, sY + 190, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM4, RGB(45,25,25));

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX +DEF_LBTNPOSX, sY + DEF_BTNPOSY, 39);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX +DEF_LBTNPOSX, sY + DEF_BTNPOSY, 38);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX +DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX +DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 2:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 10);
		cItemID = m_stDialogBoxInfo[23].sV1;
		cItemColor = m_pItemList[cItemID]->m_cItemColor; // v1.4
		if (cItemColor == 0)
			 m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteFast(sX + 62 + 15, sY + 84 + 30,
			                                                                                           m_pItemList[cItemID]->m_sSpriteFrame, dwTime);
		else
		{	switch (m_pItemList[cItemID]->m_sSprite) {
			case 1: // Swds
			case 2: // Bows
			case 3: // Shields
			case 15: // Axes hammers
#ifdef DEF_EQUILIBRIUM_PROJECT
			case 17: // Wands
#endif
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30
					, m_pItemList[cItemID]->m_sSpriteFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
				break;

			default: m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30
						 , m_pItemList[cItemID]->m_sSpriteFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
				break;
			}
		}
		ZeroMemory(cTemp, sizeof(cTemp));
		ZeroMemory(cStr2, sizeof(cStr2));
		ZeroMemory(cStr3, sizeof(cStr3));
		GetItemName(m_pItemList[cItemID], cTemp, cStr2, cStr3);
		wsprintf(cTxt, "%s", cTemp);
//		PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 45,25,25);
//		PutAlignedString(sX + 25 +1, sX + 240 +1, sY + 60, cTxt, 45,25,25);
		if(m_bIsSpecial)
		{	PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 0,255,50);
			PutAlignedString(sX + 25 +1, sX + 240 +1, sY + 60, cTxt, 0,255,50);
		}else
		{	PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 45,25,25);
			PutAlignedString(sX + 25 +1, sX + 240 +1, sY + 60, cTxt, 45,25,25);
		}
		wsprintf(cTxt,  DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM2, m_stDialogBoxInfo[23].sV2);
		PutString(sX + 95 + 15, sY + 53 + 60, cTxt, RGB(45,25,25));
		wsprintf(cTxt,  DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM6, m_stDialogBoxInfo[23].sV3);
		PutString(sX + 95 + 15, sY + 53 + 75, cTxt, RGB(45,25,25));
		PutString(sX + 55, sY + 190, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM7, RGB(45,25,25));

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 43);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 42);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 3:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 11);

		PutString(sX + 55, sY + 100, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM8, RGB(45,25,25));//"
		PutString(sX + 55, sY + 120, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM9, RGB(45,25,25));//"
		PutString(sX + 55, sY + 135, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM10, RGB(45,25,25));//"
		break;

	case 4:
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 10);

		PutString(sX + 55, sY + 100, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM11, RGB(45,25,25));//"
		PutString(sX + 55, sY + 120, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM9, RGB(45,25,25));//"
		PutString(sX + 55, sY + 135, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM10, RGB(45,25,25));//"
		break;
	}
}

void CGame::DrawDialogBox_Shop(short msX, short msY, short msZ, char cLB)
{short sX, sY;
 DWORD dwTime = m_dwCurTime;
 int  i, iTemp;
 char cTemp[255], cStr2[255], cStr3[255];

#ifdef DEF_EQUILIBRIUM_PROJECT // Prices /charisma
 int  iCost, iMsgLoc;
#else
 int  iCost, iDiscountCost, iDiscountRatio;
#endif

 double dTmp1, dTmp2, dTmp3;
 int  iTotalLines, iPointerLoc;
 BOOL bFlagStatLow = FALSE;
 BOOL bFlagRedShown = FALSE;
 double d1, d2, d3;

	sX = m_stDialogBoxInfo[11].sX;
	sY = m_stDialogBoxInfo[11].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 11);

	switch (m_stDialogBoxInfo[11].cMode) {
	case 0:
		iTotalLines = 0;
		for (i = 0; i < DEF_MAXMENUITEMS; i++)
		if (m_pItemForSaleList[i] != NULL) iTotalLines++;
		if (iTotalLines > 13) 
		{	d1 = (double)m_stDialogBoxInfo[11].sView;
			d2 = (double)(iTotalLines-13);
			d3 = (274.0f * d1)/d2;
			iPointerLoc = (int)(d3);
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX+242, sY + iPointerLoc + 35, 7);
		}else iPointerLoc = 0;

		if (cLB != 0 && iTotalLines > 13)
		{	if ((iGetTopDialogBoxIndex() == 11))
			{	if ((msX >= sX + 235) && (msX <= sX + 260) && (msY >= sY + 10) && (msY <= sY + 330))
				{ 	d1 = (double)(msY -(sY+35));
					d2 = (double)(iTotalLines-13);
					d3 = (d1 * d2)/274.0f;
					m_stDialogBoxInfo[11].sView = (int)(d3+0.5);
			}	}
		}else m_stDialogBoxInfo[11].bIsScrollSelected = FALSE;
		if( iGetTopDialogBoxIndex() == 11 && msZ != 0 )
		{	m_stDialogBoxInfo[11].sView = m_stDialogBoxInfo[11].sView - msZ/60;
			m_DInput.m_sZ = 0;
		}
		if( iTotalLines > 13 && m_stDialogBoxInfo[11].sView > iTotalLines-13 ) m_stDialogBoxInfo[11].sView = iTotalLines-13;
		if( m_stDialogBoxInfo[11].sView < 0 || iTotalLines < 13 ) m_stDialogBoxInfo[11].sView = 0;
		PutAlignedString(sX + 22, sX +165, sY + 45, DRAW_DIALOGBOX_SHOP1); // "ITEM"
		PutAlignedString(sX + 23, sX +166, sY + 45, DRAW_DIALOGBOX_SHOP1);
		PutAlignedString(sX +153, sX +250, sY + 45, DRAW_DIALOGBOX_SHOP3);
		PutAlignedString(sX +154, sX +251, sY + 45, DRAW_DIALOGBOX_SHOP3);

		for (i = 0; i < 13; i++)
		if (((i+ m_stDialogBoxInfo[11].sView) < DEF_MAXMENUITEMS) && (m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView] != NULL))
		{	ZeroMemory(cTemp, sizeof(cTemp));
			GetItemName(m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView], cTemp, cStr2, cStr3);
			if ((msX >= sX + 20) && (msX <= sX + 220) && (msY >= sY + i*18 + 65) && (msY <= sY + i*18 + 79))
			{	  PutAlignedString(sX +10, sX +190, sY + i*18 + 65, cTemp, 255, 255, 255);
			}else PutAlignedString(sX +10, sX +190, sY + i*18 + 65, cTemp, 4,0,50);
		}

		for (i = 0; i < 13; i++)
		if (((i+ m_stDialogBoxInfo[11].sView) < DEF_MAXMENUITEMS) && (m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView] != NULL))
		{

#ifdef DEF_EQUILIBRIUM_PROJECT // Prices charisma
			iCost = (int)(m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView]->m_wPrice * ((100 + m_cDiscount)/100.) );
#else
			iDiscountRatio = ((m_iCharisma - 10)  / 4) ;
			dTmp1 = (double)iDiscountRatio;
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double)m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView]->m_wPrice;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int)dTmp3;
			iCost = (int)(m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView]->m_wPrice * ((100 + m_cDiscount)/100.) );
			iCost = iCost - iDiscountCost;
#endif

			if (iCost < (m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView]->m_wPrice/2))
				iCost = (m_pItemForSaleList[i + m_stDialogBoxInfo[11].sView]->m_wPrice/2) - 1;
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%6d", iCost);
			if ((msX >= sX+20) && (msX <= sX+220) && (msY >= sY+i*18+65) && (msY <= sY+i*18+79))
					PutAlignedString(sX+148, sX+260, sY+i*18+65, cTemp, 255, 255, 255);
			else	PutAlignedString(sX+148, sX+260, sY+i*18+65, cTemp, 4,0,50);
		}
		break;

	default:
		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sSprite]->PutSpriteFast(sX + 62 + 30 -35, sY + 84 + 30 -10,
		          m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sSpriteFrame, dwTime);

		ZeroMemory(cTemp, sizeof(cTemp));
		GetItemName(m_pItemForSaleList[m_stDialogBoxInfo[11].cMode-1], cTemp, cStr2, cStr3);

		PutAlignedString(sX +25, sX+240, sY+50, cTemp, 255,255,255);
		PutAlignedString(sX +26, sX+241, sY+50, cTemp, 255,255,255);

		strcpy(cTemp, DRAW_DIALOGBOX_SHOP3); //"PRICE"
		PutString(sX + 90, sY + 78 + 30 -10, cTemp, RGB(40,10,10));
		PutString(sX + 91, sY + 78 + 30 -10, cTemp, RGB(40,10,10));
		strcpy(cTemp, DRAW_DIALOGBOX_SHOP6); // "Weight"
		PutString(sX + 90, sY + 93 + 30 -10, cTemp, RGB(40,10,10));
		PutString(sX + 91, sY + 93 + 30 -10, cTemp, RGB(40,10,10));

#ifdef DEF_EQUILIBRIUM_PROJECT // Prices charisma
		iCost = (int)(m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wPrice * ((100 +m_cDiscount)/100.) );
#else
		iDiscountRatio = ((m_iCharisma -10) / 4) ;
		dTmp1 = (double)iDiscountRatio;
		dTmp2 = dTmp1 / 100.0f;
		dTmp1 = (double)m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wPrice;
		dTmp3 = dTmp1 * dTmp2;
		iDiscountCost = (int)dTmp3;
		iCost = (int)(m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wPrice * ((100 +m_cDiscount)/100.) );
		iCost = iCost - iDiscountCost;
#endif

		if (iCost < (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wPrice/2))
				iCost = (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wPrice/2) - 1;

		wsprintf(cTemp, DRAW_DIALOGBOX_SHOP7, iCost );
		                //": %d Gold"
		PutString(sX + 140, sY + 98, cTemp, RGB(45,25,25));

		iTemp = m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100;
		wsprintf(cTemp, DRAW_DIALOGBOX_SHOP8, iTemp);
		               //": %d Stone"
		PutString(sX + 140, sY + 113, cTemp, RGB(45,25,25));

		switch (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cEquipPos) {
		case DEF_EQUIPPOS_RHAND:
		case DEF_EQUIPPOS_TWOHAND:
			strcpy(cTemp, DRAW_DIALOGBOX_SHOP9);  // Damage
			PutString(sX + 90, sY + 145, cTemp, RGB(40,10,10));
			PutString(sX + 91, sY + 145, cTemp, RGB(40,10,10));
			strcpy(cTemp, DRAW_DIALOGBOX_SHOP10); //"Speed(Min.~Max.)"
			PutString(sX + 40, sY + 175, cTemp, RGB(40,10,10));
			PutString(sX + 41, sY + 175, cTemp, RGB(40,10,10));

			if (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue3 != 0)
			{	wsprintf(cTemp, ": %dD%d+%d (S-M)", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue1,
					                                m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue2,
								                    m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue3);
			}else
			{	wsprintf(cTemp, ": %dD%d (S-M)", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue1,
					                             m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue2);
			}
			PutString(sX + 140, sY + 145, cTemp, RGB(45,25,25));
			if (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue6 != 0)
			{	wsprintf(cTemp, ": %dD%d+%d (L)", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue4,
					                              m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5,
								                  m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue6);
			}else
			{	wsprintf(cTemp, ": %dD%d (L)", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue4,
					                           m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
			}
			PutString(sX + 140, sY + 160, cTemp, RGB(45,25,25));
			if (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cSpeed == 0)   wsprintf(cTemp, ": 0(10~10)");
			else wsprintf(cTemp, ": %d(%d ~ %d)",m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cSpeed, iTemp,m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cSpeed*13);
			PutString(sX + 140, sY + 175, cTemp, RGB(45,25,25));

			if ((m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100) > m_iStr)
			{	wsprintf(cTemp,DRAW_DIALOGBOX_SHOP11, (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100)) ;
				PutAlignedString(sX +25, sX+240, sY + 258, cTemp, 195,25,25);
				PutAlignedString(sX +26, sX+241, sY + 258, cTemp, 195,25,25); // *Your STR should be at least %d to use this item."
				bFlagRedShown = TRUE;
			}
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT	// Stats at BS -> Shields
		case DEF_EQUIPPOS_LHAND:
		case DEF_EQUIPPOS_HEAD:
		case DEF_EQUIPPOS_BODY:
		case DEF_EQUIPPOS_BOOTS:
		case DEF_EQUIPPOS_ARMS:
		case DEF_EQUIPPOS_PANTS:
		case DEF_EQUIPPOS_BACK:
		case DEF_EQUIPPOS_NECK:
		case DEF_EQUIPPOS_RFINGER:
		case DEF_EQUIPPOS_LFINGER:
#else
		case DEF_EQUIPPOS_LHAND:
			strcpy(cTemp, DRAW_DIALOGBOX_SHOP12); // "Defence"
			PutString(sX + 90, sY + 145, cTemp, RGB(40,10,10));
			PutString(sX + 91, sY + 145, cTemp, RGB(40,10,10));
			wsprintf(cTemp, ": +%d%", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue1);
			PutString(sX + 140, sY + 145, cTemp, RGB(45,25,25));
			if ((m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100) > m_iStr)
			{	wsprintf(cTemp,DRAW_DIALOGBOX_SHOP11, (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100)) ;
				PutAlignedString(sX +25, sX+240, sY + 258, cTemp, 195,25,25); // "*Your STR should be at least %d to use this item."
				PutAlignedString(sX +26, sX+241, sY + 258, cTemp, 195,25,25);
				bFlagRedShown = TRUE;
			}
			break;

		case DEF_EQUIPPOS_HEAD:
		case DEF_EQUIPPOS_BODY:
		case DEF_EQUIPPOS_BOOTS:
		case DEF_EQUIPPOS_ARMS:
		case DEF_EQUIPPOS_PANTS:
#endif

			strcpy(cTemp, DRAW_DIALOGBOX_SHOP12); // "Defence"
			PutString(sX + 90, sY + 145, cTemp, RGB(40,10,10));
			PutString(sX + 91, sY + 145, cTemp, RGB(40,10,10));
			wsprintf(cTemp, ": +%d%", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue1);
			PutString(sX + 140, sY + 145, cTemp, RGB(45,25,25));
			bFlagStatLow = FALSE;
			switch(m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue4) {
			case 10://"Available for above Str %d"
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP15, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iStr >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
					bFlagStatLow = TRUE; // Means some red msg need to be shown at the bottom
				}
				break;
			case 11: // "Available for above Dex %d"
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP16, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iDex >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
					bFlagStatLow = TRUE; // Means some red msg need to be shown at the bottom
				}
				break;
			case 12: // "Available for above Vit %d"
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP17, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iVit >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
					bFlagStatLow = TRUE; // Means some red msg need to be shown at the bottom
				}
				break;
			case 13: // "Available for above Int %d"
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP18, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iInt >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
					bFlagStatLow = TRUE; // Means some red msg need to be shown at the bottom
				}
				break;
			case 14: // "Available for above Mag %d"
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP19, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iMag >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
					bFlagStatLow = TRUE; // Means some red msg need to be shown at the bottom
				}
				break;
			case 15: // "Available for above Chr %d"
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP20, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iCharisma >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
					bFlagStatLow = TRUE; // Means some red msg need to be shown at the bottom
				}
				break;

#ifdef DEF_EQUILIBRIUM_PROJECT	// New items limitations
			case 16: // mini contrib
				wsprintf(cTemp, "Mini Contribution %d", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iContribution >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
				}
				break;

			case 17: // mini EKs
				wsprintf(cTemp, "Available for more than %d EKs", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iEnemyKillCount >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
				}
				break;

			case 18: // mini reputation
				wsprintf(cTemp, "Mini reputation %d ", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iRating >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
				}
				break;

			case 19: // mini reputation
				wsprintf(cTemp, "Mini reputation %d ", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iRating >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
				}
				break;

			case 20:// max str
				wsprintf(cTemp, "Available for max Str %d", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iStr <= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
				}
				break;
			case 21: // max dext
				wsprintf(cTemp, "Available for max Dex %d", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iDex <= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
				}
				break;
			case 22: // max vit
				wsprintf(cTemp, "Available for max Vit %d", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iVit<= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
				}
				break;
			case 23: // max int
				wsprintf(cTemp, "Available for max Int %d", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iInt <= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
				}
				break;
			case 24: // max mag
				wsprintf(cTemp, "Available for max Mag %d", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iMag <= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
				}
				break;
			case 25: // max charisma
				wsprintf(cTemp, "Available for max Chr %d", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iCharisma <= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
				}
				break;

			case 27: // max EKs
				wsprintf(cTemp, "Forbidden if more than %d EKs", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (m_iEnemyKillCount <= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5)
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
				}
				break;

			case 66: // max EKs
				wsprintf(cTemp, "Available for blackest hearts only!", m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sItemEffectValue5);
				if (   (m_iPKCount > 0)
					|| (memcmp(m_cLocation, "executor", 8) == 0)
					|| (memcmp(m_cLocation, "evil", 4) == 0))
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 45,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 45,25,25);
				}else
				{	PutAlignedString(sX +25, sX+240, sY + 160, cTemp, 125,25,25);
					PutAlignedString(sX +26, sX+241, sY + 160, cTemp, 125,25,25);
				}
				break;

#endif

			default:
				break;
			}
			if ((m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100) > m_iStr)
			{	wsprintf(cTemp,DRAW_DIALOGBOX_SHOP11, (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_wWeight/100)) ;
				PutAlignedString(sX +25, sX+240, sY + 288, cTemp, 195,25,25);
				PutAlignedString(sX +26, sX+241, sY + 288, cTemp, 195,25,25); // "*Your STR should be at least %d to use this item."
				bFlagRedShown = TRUE;
			}else if (bFlagStatLow == TRUE) // Means some stat is too low
			{	strcpy(cTemp, DRAW_DIALOGBOX_SHOP21); // "(Warning!) Your stat is too low for this item."
				PutAlignedString(sX +25, sX+240, sY + 258, cTemp, 195,25,25);
				PutAlignedString(sX +26, sX+241, sY + 258, cTemp, 195,25,25);
				bFlagRedShown = TRUE;
			}else if ( (strstr(m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cName, "(M)") != NULL)
					&& (m_sPlayerType > 3))
			{	strcpy(cTemp, DRAW_DIALOGBOX_SHOP22); // "(Warning!) only for male."
				PutAlignedString(sX +25, sX+240, sY + 258, cTemp, 195,25,25);
				PutAlignedString(sX +26, sX+241, sY + 258, cTemp, 195,25,25);
				bFlagRedShown = TRUE;
			}else if ( (strstr(m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cName, "(W)") != NULL)
					&& (m_sPlayerType <= 3))
			{	strcpy(cTemp, DRAW_DIALOGBOX_SHOP23); // "(Warning!) only for female."
				PutAlignedString(sX +25, sX+240, sY + 258, cTemp, 195,25,25);
				PutAlignedString(sX +26, sX+241, sY + 258, cTemp, 195,25,25);
				bFlagRedShown = TRUE;
			}
			break;

		case DEF_EQUIPPOS_NONE:
			break;
		}

		if (m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sLevelLimit != 0)
		{	strcpy(cTemp, DRAW_DIALOGBOX_SHOP24); // "Level"
			if (m_iLevel >= m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sLevelLimit)
			{	PutString(sX + 90, sY + 190, cTemp, RGB(40,10,10));
				PutString(sX + 91, sY + 190, cTemp, RGB(40,10,10));
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP25, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sLevelLimit);
				PutString(sX + 140, sY + 190, cTemp, RGB(45,25,25));// ": above %d"
			}else
			{	PutString(sX + 90, sY + 190, cTemp, RGB(40,10,10));
				PutString(sX + 91, sY + 190, cTemp, RGB(40,10,10));
				wsprintf(cTemp, DRAW_DIALOGBOX_SHOP25, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_sLevelLimit);
				PutString(sX + 140, sY + 190, cTemp, RGB(125,25,25));// ": above %d"
				if (bFlagRedShown == FALSE)
				{	strcpy(cTemp, DRAW_DIALOGBOX_SHOP26); // "(Warning!) Your level is too low for this item."
					PutAlignedString(sX +25	  , sX+240   , sY + 258, cTemp, 195,25,25);
					PutAlignedString(sX +25 +1, sX+240 +1, sY + 258, cTemp, 195,25,25);
					bFlagRedShown = TRUE;
		}	}	}

		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 156, sY + 219, 19, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 170, sY + 219, 19, dwTime);
		PutString(sX + 123 -35, sY + 237 -10, DRAW_DIALOGBOX_SHOP27, RGB(40,10,10)); // "Quantity:"
		PutString(sX + 124 -35, sY + 237 -10, DRAW_DIALOGBOX_SHOP27, RGB(40,10,10));
		if( iGetTopDialogBoxIndex() == 11 && msZ != 0 )
		{	m_stDialogBoxInfo[11].sV3 = m_stDialogBoxInfo[11].sV3 + msZ/60;
			m_DInput.m_sZ = 0;
		}
		if (m_stDialogBoxInfo[11].sV3 > (50 - _iGetTotalItemNum())) m_stDialogBoxInfo[11].sV3 = (50 - _iGetTotalItemNum());
		if (m_stDialogBoxInfo[11].sV3 < 1) m_stDialogBoxInfo[11].sV3 = 1;

		if (m_stDialogBoxInfo[11].sV3 >= 10)
		{	ZeroMemory(cTemp, sizeof(cTemp));
			_itoa(m_stDialogBoxInfo[11].sV3, cTemp, 10);
			cTemp[1] = NULL;
			PutString(sX -35 + 186, sY -10 + 237, cTemp, RGB(40,10,10));
			PutString(sX -35 + 187, sY -10 + 237, cTemp, RGB(40,10,10));
			ZeroMemory(cTemp, sizeof(cTemp));
			_itoa(m_stDialogBoxInfo[11].sV3, cTemp, 10);
			PutString(sX -35 + 200, sY -10 + 237, (cTemp+1), RGB(40,10,10));
			PutString(sX -35 + 201, sY -10 + 237, (cTemp+1), RGB(40,10,10));
		}else
		{	PutString(sX -35 + 186, sY -10 + 237, "0", RGB(40,10,10));
			PutString(sX -35 + 187, sY -10 + 237, "0", RGB(40,10,10));
			ZeroMemory(cTemp, sizeof(cTemp));
			_itoa(m_stDialogBoxInfo[11].sV3, cTemp, 10);
			PutString(sX -35 + 200, sY -10 + 237, (cTemp), RGB(40,10,10));
			PutString(sX -35 + 201, sY -10 + 237, (cTemp), RGB(40,10,10));
		}
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX +156, sY + 244, 20, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX +170, sY + 244, 20, dwTime);

		if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 31);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 30);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;
	}
}

void CGame::DrawDialogBox_Skill(short msX, short msY, short msZ, char cLB)
{
 short sX, sY;
 int  i, iTotalLines, iPointerLoc;
 char cTemp[255], cTemp2[255];
 double d1,d2,d3;

	sX = m_stDialogBoxInfo[15].sX;
	sY = m_stDialogBoxInfo[15].sY;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0); // Normal Dialog
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 1); // Skill Dialog Title Bar

	switch (m_stDialogBoxInfo[15].cMode) {
	case 0:
		for (i = 0; i < 17; i++)
		if ((i < DEF_MAXSKILLTYPE) && (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView] != NULL))
		{	ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%s", m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_cName);
			m_Misc.ReplaceString(cTemp, '-', ' ');
			ZeroMemory(cTemp2, sizeof(cTemp2));
			wsprintf(cTemp2, "%3d%%", m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_iLevel);
			if ((msX >= sX + 25) && (msX <= sX + 166) && (msY >= sY + 45 + i*15) && (msY <= sY + 59 + i*15))
			{	if (   (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_bIsUseable == TRUE)
					&& (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_iLevel != 0) )
				{	PutString(sX + 30,  sY + 45 + i*15, cTemp, RGB(255,255,255));
					PutString(sX + 183, sY + 45 + i*15, cTemp2, RGB(255,255,255));
				}else
				{	PutString(sX + 30,  sY + 45 + i*15, cTemp, RGB(5,5,5));
					PutString(sX + 183, sY + 45 + i*15, cTemp2, RGB(5,5,5));
				}
			}else
			{	if (   (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_bIsUseable == TRUE)
					&& (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_iLevel != 0) )
				{	PutString(sX + 30, sY + 45 + i*15, cTemp, RGB(34,30,120));
					PutString(sX + 183, sY + 45 + i*15, cTemp2, RGB(34,30,120));
			   	}else
				{	PutString(sX + 30, sY + 45 + i*15, cTemp, RGB(5,5,5));
					PutString(sX + 183, sY + 45 + i*15, cTemp2, RGB(5,5,5));
			}	}

			if (m_iDownSkillIndex == (i + m_stDialogBoxInfo[15].sView))
				 m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(sX + 215, sY + 47 + i*15, 21, 50,50,50, m_dwTime);
			else m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + 215, sY + 47 + i*15, 20, m_dwTime);
		}

		iTotalLines = 0;
		for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillCfgList[i] != NULL) iTotalLines++;

		if (iTotalLines > 17)
		{	d1 = (double)m_stDialogBoxInfo[15].sView;
			d2 = (double)(iTotalLines-17);
			d3 = (274.0f * d1)/d2;
			iPointerLoc = (int)d3;
		}
		else iPointerLoc = 0;
		if( iTotalLines > 17 )
		{	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 1);
			DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX+242, sY+iPointerLoc + 35, 7);
		}

		if (cLB != 0 && iTotalLines > 17)
		{	if ((iGetTopDialogBoxIndex() == 15))
			{	if ((msX >= sX + 240) && (msX <= sX + 260) && (msY >= sY + 30) && (msY <= sY + 320))
				{	d1 = (double)(msY -(sY+35));
					d2 = (double)(iTotalLines-17);
					d3 = (d1 * d2)/274.0f;
					iPointerLoc = (int)(d3+0.5);
					if (iPointerLoc > iTotalLines - 17) iPointerLoc = iTotalLines -17;
					m_stDialogBoxInfo[15].sView = iPointerLoc;
			}	}
		}else m_stDialogBoxInfo[15].bIsScrollSelected = FALSE;
		if( iGetTopDialogBoxIndex() == 15 && msZ != 0 )
		{	if( msZ > 0 ) m_stDialogBoxInfo[15].sView--;
			if( msZ < 0 ) m_stDialogBoxInfo[15].sView++;
			m_DInput.m_sZ = 0;
		}
		if( m_stDialogBoxInfo[15].sView < 0 ) m_stDialogBoxInfo[15].sView = 0;
		if( iTotalLines > 17 && m_stDialogBoxInfo[15].sView > iTotalLines-17 ) m_stDialogBoxInfo[15].sView = iTotalLines-17;
	   	break;
	}
}

void CGame::DrawDialogBox_SkillDlg(short msX, short msY, short msZ, char cLB)
{
 int i, iLoc ,iAdjX, iAdjY;
 char cTemp[120], cTemp2[120];
 short sX, sY, szX;
 char cStr1[64], cStr2[64], cStr3[64];
 DWORD dwTime = m_dwCurTime;

	iAdjX = 5 ;
	iAdjY = 8 ;

	switch (m_stDialogBoxInfo[26].cMode) {
	case 1: // Alchemy waiting incredients
		if (m_stDialogBoxInfo[26].cStr[0] != 0)
		{	sX = m_stDialogBoxInfo[26].sX + iAdjX + (m_stDialogBoxInfo[26].cStr[0] - (rand() % (m_stDialogBoxInfo[26].cStr[0]*2)));
			sY = m_stDialogBoxInfo[26].sY + iAdjY + (m_stDialogBoxInfo[26].cStr[0] - (rand() % (m_stDialogBoxInfo[26].cStr[0]*2)));
		}else
		{	sX = m_stDialogBoxInfo[26].sX;
			sY = m_stDialogBoxInfo[26].sY;
		}

		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX, sY, 1, dwTime);

		if (m_stDialogBoxInfo[26].sV1 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV2 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +45*1 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV3 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +45*2 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV4 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV5 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55+45*1 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV6 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55+45*2 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSpriteFrame, dwTime);

		if ((msX >= sX + iAdjX + 60) && (msX <= sX + iAdjX + 153) && (msY >= sY + iAdjY + 175) && (msY <= sY + iAdjY + 195))
			 PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 16,16,30);
		else PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 6, 6, 20);

		break;

	case 2: // Alchemy, creating a potion
		if (m_stDialogBoxInfo[26].cStr[0] != 0) {
			sX = m_stDialogBoxInfo[26].sX + iAdjX + (m_stDialogBoxInfo[26].cStr[0] - (rand() % (m_stDialogBoxInfo[26].cStr[0]*2)));
			sY = m_stDialogBoxInfo[26].sY + iAdjY + (m_stDialogBoxInfo[26].cStr[0] - (rand() % (m_stDialogBoxInfo[26].cStr[0]*2)));
		}else
		{	sX = m_stDialogBoxInfo[26].sX;
			sY = m_stDialogBoxInfo[26].sY;
		}
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX, sY, 1, dwTime);

		if (m_stDialogBoxInfo[26].sV1 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV2 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +45*1 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV3 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +45*2 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV4 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV5 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55+45*1 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV6 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55+45*2 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSpriteFrame, dwTime);

		PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Creating...", 20,6,6);


		if ((dwTime - m_stDialogBoxInfo[26].dwT1) > 1000)
		{	m_stDialogBoxInfo[26].dwT1 = dwTime;
			m_stDialogBoxInfo[26].cStr[0]++;
		}

		if (m_stDialogBoxInfo[26].cStr[0] >= 5)
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_CREATEPORTION, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(26);
			PlaySound('E', 42, 0);
		}
		break;

	case 3: // Manuf: Choose what you want to create
		sX = m_stDialogBoxInfo[26].sX;
		sY = m_stDialogBoxInfo[26].sY;
		szX = m_stDialogBoxInfo[26].sSizeX;
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
		PutString(sX + iAdjX + 44, sY + iAdjY + 38, "Name", RGB(0,0,0));
		PutString(sX + iAdjX +171, sY + iAdjY + 38, "Max.Skill", RGB(0,0,0));

		iLoc = 0;
		for (i = 0; i < 13; i++)
		if (m_pDispBuildItemList[i + m_stDialogBoxInfo[26].sView] != NULL) {

			ZeroMemory(cTemp, sizeof(cTemp));
			GetItemName( m_pDispBuildItemList[i + m_stDialogBoxInfo[26].sView]->m_cName, NULL, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			ZeroMemory(cTemp2, sizeof(cTemp2));
			wsprintf(cTemp2, "%d%%", m_pDispBuildItemList[i + m_stDialogBoxInfo[26].sView]->m_iMaxSkill);

			if ((msX >= sX + 30) && (msX <= sX + 180) && (msY >= sY + iAdjY + 55 + iLoc*15) && (msY <= sY + iAdjY + 69 + iLoc*15))
			{	PutString(sX + 30, sY + iAdjY + 55 + iLoc*15, cTemp, RGB(255,255,255));
				PutString(sX + 190, sY + iAdjY + 55 + iLoc*15, cTemp2, RGB(255,255,255));
			}else
			{	if (m_pDispBuildItemList[i + m_stDialogBoxInfo[26].sView]->m_bBuildEnabled == TRUE)
				{	 PutString(sX + 30, sY + iAdjY + 55 + iLoc*15, cTemp, RGB(34,30,120));
					 PutString(sX + 190, sY + iAdjY + 55 + iLoc*15, cTemp2, RGB(34,30,120));
				}else
				{	PutString(sX + 30, sY + iAdjY + 55 + iLoc*15, cTemp, RGB(45,25,25));
					PutString(sX + 190, sY + iAdjY + 55 + iLoc*15, cTemp2, RGB(45,25,25));
				}
			}

			iLoc++;
		}
		if ((m_stDialogBoxInfo[26].sView >= 1) && (m_pDispBuildItemList[m_stDialogBoxInfo[26].sView - 1] != NULL))
			 m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + iAdjX + 225, sY + iAdjY + 210, 23, dwTime);
		else m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutTransSpriteRGB(sX + iAdjX + 225, sY + iAdjY + 210, 23, 5,5,5, dwTime);

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].sView+13] != NULL)
			 m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + iAdjX + 225, sY + iAdjY + 230, 24, dwTime);
		else m_pSprite[DEF_SPRID_INTERFACE_ND_GAME2]->PutTransSpriteRGB(sX + iAdjX + 225, sY + iAdjY + 230, 24, 5,5,5, dwTime);

		if ((cLB != 0) && (iGetTopDialogBoxIndex() == 26)) {
			if ((msX >= sX + iAdjX + 225) && (msX <= sX + iAdjX + 245) && (msY >= sY + iAdjY + 210) && (msY <= sY + iAdjY + 230)) {
				m_stDialogBoxInfo[26].sView--;
			}

			if ((msX >= sX + iAdjX + 225) && (msX <= sX + iAdjX + 245) && (msY >= sY + iAdjY + 230) && (msY <= sY + iAdjY + 250)) {
				if (m_pDispBuildItemList[m_stDialogBoxInfo[26].sView + 13] != NULL)
					m_stDialogBoxInfo[26].sView++;
			}
		}
		if (( msZ != 0) && (iGetTopDialogBoxIndex() == 26)) {
			m_stDialogBoxInfo[26].sView = m_stDialogBoxInfo[26].sView - msZ/60;
			m_DInput.m_sZ = 0;
		}
		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].sView + 12] == NULL)
		{
			while(1)
			{
				m_stDialogBoxInfo[26].sView --;
				if( m_stDialogBoxInfo[26].sView < 1 ) break;
				if( m_pDispBuildItemList[m_stDialogBoxInfo[26].sView+12] != NULL ) break;
			}
		}
		if (m_stDialogBoxInfo[26].sView < 0) m_stDialogBoxInfo[26].sView = 0;

		PutAlignedString(sX, sX+m_stDialogBoxInfo[26].sSizeX, sY + 265, DRAW_DIALOGBOX_SKILLDLG2, 55,25,25);//" List of items which you can make with"
		PutAlignedString(sX, sX+m_stDialogBoxInfo[26].sSizeX, sY + 280, DRAW_DIALOGBOX_SKILLDLG3, 55,25,25);//"your current skill. The items you can"
		PutAlignedString(sX, sX+m_stDialogBoxInfo[26].sSizeX, sY + 295, DRAW_DIALOGBOX_SKILLDLG4, 55,25,25);//"make now with your current stuff will"
		PutAlignedString(sX, sX+m_stDialogBoxInfo[26].sSizeX, sY + 310, DRAW_DIALOGBOX_SKILLDLG5, 55,25,25);//"be displayed in blue. "
		PutAlignedString(sX, sX+m_stDialogBoxInfo[26].sSizeX, sY + 340, DRAW_DIALOGBOX_SKILLDLG6, 55,25,25);//"Select an item you want to manufacture."
		break;

	case 4: // Manuf: Waiting for incredients
		sX = m_stDialogBoxInfo[26].sX;
		sY = m_stDialogBoxInfo[26].sY;
		szX = m_stDialogBoxInfo[26].sSizeX;
		iAdjX = -1;
		iAdjY = -7;
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSprH]->PutSpriteFast(sX + iAdjX + 62 + 5, sY + iAdjY + 84 + 17,
		          m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSprFrame, dwTime);

		ZeroMemory(cTemp, sizeof(cTemp));
		GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cName, 0, cStr1, cStr2, cStr3 );
		wsprintf(cTemp, "%s", cStr1);
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55, cTemp, RGB(255,255,255));

		wsprintf(cTemp,  DRAW_DIALOGBOX_SKILLDLG7 // "Skill level: %d/%d"
			, m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSkillLimit
			, m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iMaxSkill);
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55 +2*15, cTemp, RGB(45,25,25));
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55 +3*15 +5, DRAW_DIALOGBOX_SKILLDLG8, RGB(45,25,25));//"Ingredients Needed:"

		iLoc = 4;
		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[1] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName1, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[1] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(150,150,150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[2] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName2, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[2] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(150,150,150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[3] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName3, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[3] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(150,150,150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[4] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName4, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[4] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(150,150,150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[5] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName5, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[5] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(150,150,150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[6] != 0) {
			GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName6, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[6] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(150,150,150));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bBuildEnabled == TRUE)
		{	m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +13, sY + iAdjY +55 +180 , 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*1 +13, sY + iAdjY +55 +180, 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*2 +13, sY + iAdjY +55 +180, 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +13, sY + iAdjY +100 +180, 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*1 +13, sY + iAdjY +100 +180, 2, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*2 +13, sY + iAdjY +100 +180, 2, dwTime);

			if (m_stDialogBoxInfo[26].sV1 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +30 +13, sY + iAdjY + 55 +180,
				m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSpriteFrame, dwTime);

			if (m_stDialogBoxInfo[26].sV2 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +45*1 +30 +13, sY + iAdjY + 55 +180,
				m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSpriteFrame, dwTime);

			if (m_stDialogBoxInfo[26].sV3 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +45*2 +30 +13, sY + iAdjY + 55 +180,
				m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSpriteFrame, dwTime);

			if (m_stDialogBoxInfo[26].sV4 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +30 +13, sY + iAdjY + 100 +180,
				m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSpriteFrame, dwTime);

			if (m_stDialogBoxInfo[26].sV5 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55+45*1 +30 +13, sY + iAdjY + 100 +180,
				m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSpriteFrame, dwTime);

			if (m_stDialogBoxInfo[26].sV6 != -1)
				m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55+45*2 +30 +13, sY + iAdjY + 100 +180,
				m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSpriteFrame, dwTime);

			PutAlignedString(sX, sX + szX, sY + iAdjY + 230 +75, DRAW_DIALOGBOX_SKILLDLG15, 55,25,25);//" Click MANUFACTURE button after"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 245 +75, DRAW_DIALOGBOX_SKILLDLG16, 55,25,25);//"dragging ingredients in the blanks"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 260 +75, DRAW_DIALOGBOX_SKILLDLG17, 55,25,25);//"to manufacture above item."

			if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372))
				 PutString_SprFont(sX + iAdjX + 25,  sY + iAdjY + 330 +23, "Back", 6,6,20);
			else PutString_SprFont(sX + iAdjX + 25,  sY + iAdjY + 330 +23, "Back", 0,0,7);


			if ((msX >= sX + iAdjX + 160) && (msX <= sX + iAdjX + 255) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) {
				if (m_stDialogBoxInfo[26].cStr[4] == 1)
					 PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 +23, "Manufacture", 6,6,20);
				else PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 +23, "Manufacture", 10,10,10);
			}
			else {
				if (m_stDialogBoxInfo[26].cStr[4] == 1)
					 PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 +23, "Manufacture", 0, 0, 7);
				else PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 +23, "Manufacture", 10,10,10);
			}
		}
		else {
			PutAlignedString(sX, sX + szX, sY + iAdjY + 200 +75, DRAW_DIALOGBOX_SKILLDLG18, 55,25,25);//"There are not enough ingredients to"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 215 +75, DRAW_DIALOGBOX_SKILLDLG19, 55,25,25);//"manufacture. Needed materials are"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 230 +75, DRAW_DIALOGBOX_SKILLDLG20, 55,25,25);//"displayed in grey."
			if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372))
				 PutString_SprFont(sX + iAdjX + 25,  sY + iAdjY + 330 +23, "Back", 6,6,20);
			else PutString_SprFont(sX + iAdjX + 25,  sY + iAdjY + 330 +23, "Back", 0,0,7);
		}
		break;

	case 5: // Manuf: in progress
		sX = m_stDialogBoxInfo[26].sX;
		sY = m_stDialogBoxInfo[26].sY;
		iAdjX = -1;
		iAdjY = -7;

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSprH]->PutSpriteFast(sX + iAdjX + 62 + 5, sY + iAdjY + 84 + 17,
		          m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSprFrame, dwTime);

		ZeroMemory(cTemp, sizeof(cTemp));
		GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cName, 0, cStr1, cStr2, cStr3 );
		wsprintf(cTemp, "%s", cStr1);
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55, cTemp, RGB(255,255,255));

		wsprintf(cTemp,  DRAW_DIALOGBOX_SKILLDLG7 // "Skill level: %d/%d"
			, m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSkillLimit, m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iMaxSkill);//"½ºÅ³ ¼öÁØ: %d/%d"
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55 +2*15, cTemp, RGB(45,25,25));
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55 +3*15 +5, DRAW_DIALOGBOX_SKILLDLG8, RGB(45,25,25));//"Ingredients Needed:"

		iLoc = 4;
		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[1] != 0) 
		{	GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName1, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[1] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(120,120,120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[2] != 0) 
		{	GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName2, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[2] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(120,120,120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[3] != 0) 
		{	GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName3, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[3] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(120,120,120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[4] != 0) 
		{	GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName4, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[4] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(120,120,120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[5] != 0) 
		{	GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName5, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[5] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(120,120,120));
			iLoc++;
		}

		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iElementCount[6] != 0) 
		{	GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cElementName6, 0, cStr1, cStr2, cStr3 );
			wsprintf(cTemp, "%s", cStr1);
			if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bElementFlag[6] == TRUE)
				 PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(45,25,25));
			else PutString(sX + iAdjX + 44 +20 +60, sY + iAdjY + 55 +iLoc*15 +5, cTemp, RGB(120,120,120));
			iLoc++;
		}

		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +13, sY + iAdjY +55 +180 , 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*1 +13, sY + iAdjY +55 +180, 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*2 +13, sY + iAdjY +55 +180, 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +13, sY + iAdjY +100 +180, 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*1 +13, sY + iAdjY +100 +180, 2, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX +55 +30 +45*2 +13, sY + iAdjY +100 +180, 2, dwTime);

		if (m_stDialogBoxInfo[26].sV1 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +30 +13, sY + iAdjY + 55 +180,
					  m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV2 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +45*1 +30 +13, sY + iAdjY + 55 +180,
					  m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV3 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +45*2 +30 +13, sY + iAdjY + 55 +180,
					  m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV4 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +30 +13, sY + iAdjY + 100 +180,
					  m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV5 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55+45*1 +30 +13, sY + iAdjY + 100 +180,
					  m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV6 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55+45*2 +30 +13, sY + iAdjY + 100 +180,
					  m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSpriteFrame, dwTime);

		PutString(sX + iAdjX + 33, sY + iAdjY + 230 +75, DRAW_DIALOGBOX_SKILLDLG29, RGB(55,25,25));//" Manufacturing the items...."
		PutString(sX + iAdjX + 33, sY + iAdjY + 245 +75, DRAW_DIALOGBOX_SKILLDLG30, RGB(55,25,25));//"Please wait until manufacture finishes."

		if ((dwTime - m_stDialogBoxInfo[26].dwT1) > 1000) 
		{	m_stDialogBoxInfo[26].dwT1 = dwTime;
			m_stDialogBoxInfo[26].cStr[1]++;
			if (m_stDialogBoxInfo[26].cStr[1] >= 7) m_stDialogBoxInfo[26].cStr[1] = 7;
		}

		if (m_stDialogBoxInfo[26].cStr[1] == 4) 
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_BUILDITEM, NULL, NULL, NULL, NULL, m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cName);
			m_stDialogBoxInfo[26].cStr[1]++;
		}
		break;

	case 6: // Manuf: Done
		sX = m_stDialogBoxInfo[26].sX;
		sY = m_stDialogBoxInfo[26].sY;
		iAdjX = -1;
		iAdjY = -7;

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
		m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSprH]->PutSpriteFast(sX + iAdjX + 62 + 5, sY + iAdjY + 84 + 17,
		          m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_iSprFrame, dwTime);

		ZeroMemory(cTemp, sizeof(cTemp));
		GetItemName( m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_cName, 0, cStr1, cStr2, cStr3 );

		wsprintf(cTemp, "%s", cStr1);
		PutString(sX + iAdjX + 44 +10 +60, sY + iAdjY + 55, cTemp, RGB(255,255,255));

		if (m_stDialogBoxInfo[26].cStr[2] == 1) {
			PutString(sX + iAdjX + 33 +11, sY + iAdjY + 200 -45, DRAW_DIALOGBOX_SKILLDLG31, RGB(55,25,25));//" Success in manufacture!"

			if (m_stDialogBoxInfo[26].sV1 == DEF_ITEMTYPE_MATERIAL) {
				wsprintf(G_cTxt, DRAW_DIALOGBOX_SKILLDLG32, m_stDialogBoxInfo[26].cStr[3]);//"The purity of product is %d%%."
				PutString(sX + iAdjX + 33 +11, sY + iAdjY + 215 -45, G_cTxt, RGB(55,25,25));
			}
			else {
				wsprintf(G_cTxt, DRAW_DIALOGBOX_SKILLDLG33, (int)m_stDialogBoxInfo[26].cStr[3] +100);//"The completion of product is %d%%."
				PutString(sX + iAdjX + 33, sY + iAdjY + 215 -45, G_cTxt, RGB(55,25,25));
			}
		}
		else {
			PutString(sX + iAdjX + 33+11, sY + iAdjY + 200, DRAW_DIALOGBOX_SKILLDLG34, RGB(55,25,25));//"Failed on manufacture."
		}

		if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372))
			 PutString_SprFont(sX + iAdjX + 35,  sY + iAdjY + 330 +23, "Back", 6,6,20);
		else PutString_SprFont(sX + iAdjX + 35,  sY + iAdjY + 330 +23, "Back", 0,0,7);
		break;


	case 7: // Crafting, wait for incredients
		if (m_stDialogBoxInfo[26].cStr[0] != 0)
		{	sX = m_stDialogBoxInfo[26].sX + iAdjX + (m_stDialogBoxInfo[26].cStr[0] - (rand() % (m_stDialogBoxInfo[26].cStr[0]*2)));
			sY = m_stDialogBoxInfo[26].sY + iAdjY + (m_stDialogBoxInfo[26].cStr[0] - (rand() % (m_stDialogBoxInfo[26].cStr[0]*2)));
		}else
		{	sX = m_stDialogBoxInfo[26].sX;
			sY = m_stDialogBoxInfo[26].sY;		
		}
		m_pSprite[DEF_SPRID_INTERFACE_CRAFTING]->PutSpriteFast(sX, sY, 0, dwTime);

		if (m_stDialogBoxInfo[26].sV1 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV2 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 +45*1 +(1-(rand()%3)), sY + iAdjY + 40 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV3 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 +45*2 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV4 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV5 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65+45*1 +(1-(rand()%3)), sY + iAdjY + 115 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSpriteFrame, dwTime);

		if (m_stDialogBoxInfo[26].sV6 != -1)
			m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 75+45*2 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSpriteFrame, dwTime);
		if ((msX >= sX + iAdjX + 60) && (msX <= sX + iAdjX + 153) && (msY >= sY + iAdjY + 175) && (msY <= sY + iAdjY + 195))
			 PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 16,16,30);
		else PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 6, 6, 20);
		break;

	case 8: // Crafting in progress
		if (m_stDialogBoxInfo[26].cStr[0] != 0) 
		{	sX = m_stDialogBoxInfo[26].sX + iAdjX + (m_stDialogBoxInfo[26].cStr[0] - (rand() % (m_stDialogBoxInfo[26].cStr[0]*2)));
			sY = m_stDialogBoxInfo[26].sY + iAdjY + (m_stDialogBoxInfo[26].cStr[0] - (rand() % (m_stDialogBoxInfo[26].cStr[0]*2)));
		}else
		{	sX = m_stDialogBoxInfo[26].sX;
			sY = m_stDialogBoxInfo[26].sY;
		}
		m_pSprite[DEF_SPRID_INTERFACE_CRAFTING]->PutSpriteFast(sX, sY, 0, dwTime);

		if (m_stDialogBoxInfo[26].sV1 != -1)
		{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 +(1-(rand()%3)) +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV1]->m_sSpriteFrame, dwTime);
			if (   (m_pItemList[m_stDialogBoxInfo[26].sV1]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pItemList[m_stDialogBoxInfo[26].sV1]->m_cEquipPos == DEF_EQUIPPOS_NECK))
				m_iContributionPrice = 10;
		}
		if (m_stDialogBoxInfo[26].sV2 != -1)
		{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 +45*1 +(1-(rand()%3)), sY + iAdjY + 40 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV2]->m_sSpriteFrame, dwTime);
			if (   (m_pItemList[m_stDialogBoxInfo[26].sV2]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pItemList[m_stDialogBoxInfo[26].sV2]->m_cEquipPos == DEF_EQUIPPOS_NECK))
				m_iContributionPrice = 10;
		}
		if (m_stDialogBoxInfo[26].sV3 != -1)
		{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 +45*2 +(1-(rand()%3)), sY + iAdjY + 55 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV3]->m_sSpriteFrame, dwTime);
			if (   (m_pItemList[m_stDialogBoxInfo[26].sV3]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pItemList[m_stDialogBoxInfo[26].sV3]->m_cEquipPos == DEF_EQUIPPOS_NECK))
				m_iContributionPrice = 10;
		}
		if (m_stDialogBoxInfo[26].sV4 != -1)
		{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV4]->m_sSpriteFrame, dwTime);
			if (   (m_pItemList[m_stDialogBoxInfo[26].sV4]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pItemList[m_stDialogBoxInfo[26].sV4]->m_cEquipPos == DEF_EQUIPPOS_NECK))
				m_iContributionPrice = 10;
		}
		if (m_stDialogBoxInfo[26].sV5 != -1)
		{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65+45*1 +(1-(rand()%3)), sY + iAdjY + 115 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV5]->m_sSpriteFrame, dwTime);
			if (   (m_pItemList[m_stDialogBoxInfo[26].sV5]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pItemList[m_stDialogBoxInfo[26].sV5]->m_cEquipPos == DEF_EQUIPPOS_NECK))
				m_iContributionPrice = 10;
		}
		if (m_stDialogBoxInfo[26].sV6 != -1)
		{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT +
			          m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 75+45*2 +(1-(rand()%3)), sY + iAdjY + 100 +(1-(rand()%3)),
					  m_pItemList[m_stDialogBoxInfo[26].sV6]->m_sSpriteFrame, dwTime);
			if (   (m_pItemList[m_stDialogBoxInfo[26].sV6]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				&& (m_pItemList[m_stDialogBoxInfo[26].sV6]->m_cEquipPos == DEF_EQUIPPOS_NECK))
				m_iContributionPrice = 10;
		}
		PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Creating...", 20,6,6);

		if ((dwTime - m_stDialogBoxInfo[26].dwT1) > 1000)
		{	m_stDialogBoxInfo[26].dwT1 = dwTime;
			m_stDialogBoxInfo[26].cStr[1]++;
		}
		if (m_stDialogBoxInfo[26].cStr[1] >= 5)//m_pDispCraftItemList
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_CRAFTITEM, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(26);
			PlaySound('E', 42, 0);
		}	
		break;
	}
}

void CGame::DrawDialogBox_SysMenu(short msX, short msY, char cLB)
{short sX, sY;

	sX = m_stDialogBoxInfo[19].sX;
	sY = m_stDialogBoxInfo[19].sY;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME1, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 6);
	PutString(sX + 23, sY + 63, DRAW_DIALOGBOX_SYSMENU_DETAILLEVEL, RGB(45,25,25));
	PutString(sX + 24, sY + 63, DRAW_DIALOGBOX_SYSMENU_DETAILLEVEL, RGB(45,25,25));
	if (m_cDetailLevel == 0)
		 PutString(sX + 121, sY + 63, DRAW_DIALOGBOX_SYSMENU_LOW, RGB(255,255,255));
	else PutString(sX + 121, sY + 63, DRAW_DIALOGBOX_SYSMENU_LOW, RGB(45,25,25));
	if (m_cDetailLevel == 1)
		 PutString(sX + 153, sY + 63, DRAW_DIALOGBOX_SYSMENU_NORMAL, RGB(255,255,255));
	else PutString(sX + 153, sY + 63, DRAW_DIALOGBOX_SYSMENU_NORMAL, RGB(45,25,25));
	if (m_cDetailLevel == 2)
		 PutString(sX + 205, sY + 63, DRAW_DIALOGBOX_SYSMENU_HIGH, RGB(255,255,255));
	else PutString(sX + 205, sY + 63, DRAW_DIALOGBOX_SYSMENU_HIGH, RGB(45,25,25));

	PutString(sX + 23, sY + 84, DRAW_DIALOGBOX_SYSMENU_SOUND, RGB(45,25,25));
	PutString(sX + 24, sY + 84, DRAW_DIALOGBOX_SYSMENU_SOUND, RGB(45,25,25));
	if (m_bSoundFlag) {
		if (m_bSoundStat) PutString(sX + 85, sY + 85, DRAW_DIALOGBOX_SYSMENU_ON, RGB(255,255,255));
		else PutString(sX + 83, sY + 85, DRAW_DIALOGBOX_SYSMENU_OFF, RGB(200,200,200));
  	}
	else PutString(sX + 68, sY + 85, DRAW_DIALOGBOX_SYSMENU_DISABLED, RGB(100,100,100));

	PutString(sX + 123, sY + 84, DRAW_DIALOGBOX_SYSMENU_MUSIC, RGB(45,25,25));
	PutString(sX + 124, sY + 84, DRAW_DIALOGBOX_SYSMENU_MUSIC, RGB(45,25,25));
	if (m_bSoundFlag) {
		if (m_bMusicStat) PutString(sX + 180, sY + 85, DRAW_DIALOGBOX_SYSMENU_ON, RGB(255,255,255));
		else PutString(sX + 178, sY + 85, DRAW_DIALOGBOX_SYSMENU_OFF, RGB(200,200,200));
  	}
	else PutString(sX + 163, sY + 85, DRAW_DIALOGBOX_SYSMENU_DISABLED, RGB(100,100,100));

	PutString(sX + 23,  sY + 106, DRAW_DIALOGBOX_SYSMENU_WHISPER, RGB(45,25,25));
	PutString(sX + 24, sY + 106, DRAW_DIALOGBOX_SYSMENU_WHISPER, RGB(45,25,25));
	if (m_bWhisper) PutString(sX + 85, sY + 106, DRAW_DIALOGBOX_SYSMENU_ON, RGB(255,255,255));
	else PutString(sX + 82, sY + 106, DRAW_DIALOGBOX_SYSMENU_OFF, RGB(200,200,200));

	PutString(sX + 123, sY + 106, DRAW_DIALOGBOX_SYSMENU_SHOUT, RGB(45,25,25));
	PutString(sX + 124, sY + 106, DRAW_DIALOGBOX_SYSMENU_SHOUT, RGB(45,25,25));
	if (m_bShout) PutString(sX + 180, sY + 106, DRAW_DIALOGBOX_SYSMENU_ON, RGB(255,255,255));
	else PutString(sX + 177, sY + 106, DRAW_DIALOGBOX_SYSMENU_OFF, RGB(200,200,200));

	PutString(sX + 23, sY + 124, DRAW_DIALOGBOX_SYSMENU_SOUNDVOLUME, RGB(45,25,25));
	PutString(sX + 24, sY + 124, DRAW_DIALOGBOX_SYSMENU_SOUNDVOLUME, RGB(45,25,25));
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX + 130 + m_cSoundVolume, sY + 129, 8);

	PutString(sX + 23, sY + 141, DRAW_DIALOGBOX_SYSMENU_MUSICVOLUME, RGB(45,25,25));
	PutString(sX + 24, sY + 141, DRAW_DIALOGBOX_SYSMENU_MUSICVOLUME, RGB(45,25,25));
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX + 130 + m_cMusicVolume, sY + 145, 8);

	PutString(sX + 23, sY + 158, DRAW_DIALOGBOX_SYSMENU_TRANSPARENCY, RGB(45,25,25));
	PutString(sX + 24, sY + 158, DRAW_DIALOGBOX_SYSMENU_TRANSPARENCY, RGB(45,25,25));
	if (m_bDialogTrans) PutString(sX + 208, sY + 158, DRAW_DIALOGBOX_SYSMENU_ON, RGB(255,255,255));
	else PutString(sX + 207, sY + 158, DRAW_DIALOGBOX_SYSMENU_OFF, RGB(200,200,200));

	PutString(sX + 23, sY + 180, DRAW_DIALOGBOX_SYSMENU_GUIDEMAP, RGB(45,25,25));
	PutString(sX + 24, sY + 180, DRAW_DIALOGBOX_SYSMENU_GUIDEMAP, RGB(45,25,25));
	if (m_bIsDialogEnabled[9]) PutString(sX + 99, sY + 180, DRAW_DIALOGBOX_SYSMENU_ON, RGB(255,255,255));
	else PutString(sX + 98, sY + 180, DRAW_DIALOGBOX_SYSMENU_OFF, RGB(200,200,200));

	SYSTEMTIME SysTime;
	GetLocalTime(&SysTime);
	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	wsprintf(G_cTxt, "%d:%d:%d:%d:%d", SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute, SysTime.wSecond);
	PutString(sX + 23, sY + 204, G_cTxt, RGB(45,25,25));
	PutString(sX + 24, sY + 204, G_cTxt, RGB(45,25,25));

//v2.172
#ifdef _DEBUG
	PutString(sX + 23, sY + 41, UPDATE_SCREEN_ON_SELECT_CHARACTER36, RGB(45,25,25)); // "Test server"
	PutString(sX + 24, sY + 41, UPDATE_SCREEN_ON_SELECT_CHARACTER36, RGB(45,25,25)); // "Test server"
#else

#ifdef DEF_EQUILIBRIUM_PROJECT // Server name: Equilibrium Project
	PutString(sX + 23, sY + 41, "Equilibrium Project", RGB(45,25,25));
	PutString(sX + 24, sY + 41, "Equilibrium Project", RGB(45,25,25));
#else

	if (strcmp(m_cWorldServerName, NAME_WORLDNAME1) == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME1, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME1, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS2") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME2, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME2, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS3") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME3, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME3, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS4") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME4, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME4, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS5") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME5, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME5, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS6") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME6, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME6, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS7") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME7, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME7, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS8") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME8, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME8, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS9") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME9, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME9, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS10") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME10, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME10, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS11") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME11, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME11, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS12") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME12, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME12, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS13") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME13, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME13, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS14") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME14, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME14, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS15") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME15, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME15, RGB(45,25,25));
	}
	else if (strcmp(m_cWorldServerName, "WS16") == 0) {
		PutString(sX + 23, sY + 41, MSG_WORLDNAME16, RGB(45,25,25));
		PutString(sX + 24, sY + 41, MSG_WORLDNAME16, RGB(45,25,25));
	}
#endif
#endif

	if ( (cLB != 0) && (iGetTopDialogBoxIndex() == 19) )
	//  (msX >= sX + 120) && (msX <= sX + 242) && (msY >= sY +122) && (msY <= sY +138)
	{	if ((msX >= sX + 127) && (msX <= sX + 238) && (msY >= sY +122) && (msY <= sY +138))
		{	m_cSoundVolume = msX - (sX + 127);
			if( m_cSoundVolume > 100 ) m_cSoundVolume = 100;
			if( m_cSoundVolume < 0 ) m_cSoundVolume = 0;
		}
		if ((msX >= sX + 127) && (msX <= sX + 238) && (msY >= sY +139) && (msY <= sY +155))
		{	m_cMusicVolume = msX - (sX + 127);
			if( m_cMusicVolume > 100 ) m_cMusicVolume = 100;
			if( m_cMusicVolume < 0 ) m_cMusicVolume = 0;
			if (m_bSoundFlag) 
			{	SetBGMVolume();// Snoopy: mp3 support				
				int iVol;
				iVol = (m_cMusicVolume - 100)*20;
				if (iVol > 0) iVol = 0;
				if (iVol < -10000) iVol = -10000;
				if (m_pBGM != NULL)
				{	m_pBGM->bStop(TRUE);
					m_pBGM->Play(FALSE, 0, iVol);
		}	}	}
	}
	else m_stDialogBoxInfo[19].bIsScrollSelected = FALSE;

	// Log-Out
	if (m_cLogOutCount == -1)
	{	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + 225) && (msY <= sY + 225 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY +225, 9);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY +225, 8);
	}else  //Continue
	{	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + 225) && (msY <= sY + 225 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY +225, 7);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY +225, 6);
	}
	// Restart
	if ((m_iHP <= 0) && (m_cRestartCount == -1))
	{	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 225) && (msY <= sY + 225 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY +225, 37);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY +225, 36);
	}else if (m_cRestartCount == -1)
	{	// Of course it's easy to remove or change this...
		PutString(sX + 133, sY + 214, "Coded by Cleroth,", RGB(45,25,25));
		PutString(sX + 134, sY + 214, "Coded by Cleroth,", RGB(45,25,25));
		PutString(sX + 125, sY + 229, "Diuuude & Snoopy81", RGB(45,25,25));
		PutString(sX + 126, sY + 229, "Diuuude & Snoopy81", RGB(45,25,25));
	}
}

//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

void CGame::bItemDrop_Character()
{	ItemEquipHandler((char)m_stMCursor.sSelectedObjectID);
}

void CGame::bItemDrop_Inventory(short msX, short msY)
{ short sX, sY, dX, dY;
 char  cTxt[120];
	if (m_cCommand < 0) return;
	if (m_pItemList[m_stMCursor.sSelectedObjectID] == NULL) return;
	if ((m_bSkillUsingStatus == TRUE) && (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == TRUE))
	{	AddEventList(BITEMDROP_INVENTORY1, 10);
		return;
	}
	if (m_bIsItemDisabled[m_stMCursor.sSelectedObjectID] == TRUE) return;
	sY = m_stDialogBoxInfo[2].sY;
	sX = m_stDialogBoxInfo[2].sX;
	dX = msX - sX - 32 - m_stMCursor.sDistX;
	dY = msY - sY - 44 - m_stMCursor.sDistY;
	if (dY < -10) dY = -10;
	if (dX < 0)   dX = 0;
	if (dX > 170) dX = 170;
	if (dY > 95) dY = 95;

	m_pItemList[m_stMCursor.sSelectedObjectID]->m_sX = dX;
	m_pItemList[m_stMCursor.sSelectedObjectID]->m_sY = dY;

	short sTmpSpr, sTmpSprFrm;
	sTmpSpr = m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite;
	sTmpSprFrm = m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame;

	char cItemID;
	if (m_bShiftPressed)
	{	for (int i = 0; i < DEF_MAXITEMS; i++)
		{	if (m_cItemOrder[DEF_MAXITEMS - 1 - i] != -1)
			{	cItemID = m_cItemOrder[DEF_MAXITEMS - 1 - i];
				if (m_pItemList[cItemID] != NULL && memcmp(m_pItemList[cItemID]->m_cName, m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, 20) == 0 )
				{	m_pItemList[cItemID]->m_sX = dX;
					m_pItemList[cItemID]->m_sY = dY;
					bSendCommand(MSGID_REQUEST_SETITEMPOS, NULL, cItemID, dX, dY, NULL, NULL);
		}	}	}
    }else bSendCommand(MSGID_REQUEST_SETITEMPOS, NULL, (char)(m_stMCursor.sSelectedObjectID), dX, dY, NULL, NULL);

	if (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == TRUE)
	{	char cStr1[64], cStr2[64], cStr3[64];
		GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);
		wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
		AddEventList(cTxt, 10);

		if(memcmp(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, "AngelicPendant", 14) == 0) PlaySound('E', 53, 0);
		else PlaySound('E', 29, 0);

		// Remove Angelic Stats
		if (   (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos >= 11)
			&& (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cItemType == 1))
		{	char cItemID = m_stMCursor.sSelectedObjectID;
			if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(STR)", 19) == 0)
			{	m_iAngelicStr = 0;
			}else if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(DEX)", 19) == 0)
			{	m_iAngelicDex = 0;
			}else if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(INT)", 19) == 0)
			{	m_iAngelicInt = 0;
			}else if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(MAG)", 19) == 0)
			{	m_iAngelicMag = 0;
		}	}
		bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_RELEASEITEM, NULL, m_stMCursor.sSelectedObjectID, NULL, NULL, NULL);
		m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] = FALSE;
		m_sItemEquipmentStatus[	m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos ] = -1;
	}
}

void CGame::bItemDrop_SellList(short msX, short msY)
{
 int i;
 char cItemID;

	cItemID = (char)m_stMCursor.sSelectedObjectID;

	if (m_pItemList[cItemID] == NULL) return;
	if (m_bIsItemDisabled[cItemID] == TRUE) return;
	if (m_cCommand < 0) return;
		for (i = 0; i < DEF_MAXSELLLIST; i++)
	if (m_stSellItemList[i].iIndex == cItemID)
	{	AddEventList(BITEMDROP_SELLLIST1, 10);
		return;
	}
	if (strcmp(m_pItemList[cItemID]->m_cName, "Gold") == 0) {
		AddEventList(BITEMDROP_SELLLIST2, 10);
		return;
	}
	if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
	{
		ZeroMemory( G_cTxt, sizeof(G_cTxt) );
		char cStr1[64], cStr2[64], cStr3[64];
		GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
		wsprintf( G_cTxt, NOTIFYMSG_CANNOT_SELL_ITEM2, cStr1 );
		AddEventList( G_cTxt, 10 );
		return;
	}

	if ( ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
		 (m_pItemList[cItemID]->m_dwCount > 1) )
	{	m_stDialogBoxInfo[17].sX  = msX - 140;
		m_stDialogBoxInfo[17].sY  = msY - 70;
		if (m_stDialogBoxInfo[17].sY < 0) m_stDialogBoxInfo[17].sY = 0;
		m_stDialogBoxInfo[17].sV1 = m_sPlayerX+1;
		m_stDialogBoxInfo[17].sV2 = m_sPlayerY+1;
		m_stDialogBoxInfo[17].sV3 = 1001;
		m_stDialogBoxInfo[17].sV4 = cItemID;
		ZeroMemory(m_stDialogBoxInfo[17].cStr, sizeof(m_stDialogBoxInfo[17].cStr));
		EnableDialogBox(17, cItemID, m_pItemList[cItemID]->m_dwCount, NULL);
		m_bIsItemDisabled[cItemID] = TRUE;
	}else
	{	for (i = 0; i < DEF_MAXSELLLIST; i++)
		if (m_stSellItemList[i].iIndex == -1)
		{	m_stSellItemList[i].iIndex = cItemID;
			m_stSellItemList[i].iAmount = 1;
			m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		AddEventList(BITEMDROP_SELLLIST3, 10);
	}
}

void CGame::bItemDrop_ItemUpgrade()
{
 char cItemID;
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (m_bIsItemDisabled[cItemID] == TRUE) return;
	if (m_cCommand < 0) return;
#ifdef DEF_EQUILBRIUM_PROJECT // Allow enchant bars with Merien stones
	if (   (m_pItemList[cItemID]->m_cEquipPos == DEF_EQUIPPOS_NONE)
		&& (m_stDialogBoxInfo[34].cMode != 6)) return;
#else
	if (m_pItemList[cItemID]->m_cEquipPos == DEF_EQUIPPOS_NONE) return;
#endif

	switch (m_stDialogBoxInfo[34].cMode) {
	case 1:
		m_bIsItemDisabled[m_stDialogBoxInfo[34].sV1] = FALSE;
		m_stDialogBoxInfo[34].sV1 = cItemID;
		m_bIsItemDisabled[cItemID] = TRUE;
		PlaySound('E', 29, 0);
		break;

	case 6:
		m_bIsItemDisabled[m_stDialogBoxInfo[34].sV1] = FALSE;
		m_stDialogBoxInfo[34].sV1 = cItemID;
		m_bIsItemDisabled[cItemID] = TRUE;
		PlaySound('E', 29, 0);
		break;

#ifdef DEF_EQUILIBRIUM_PROJECT
	case 11: // Alchim
		m_bIsItemDisabled[m_stDialogBoxInfo[34].sV1] = FALSE;
		m_stDialogBoxInfo[34].sV1 = cItemID;
		m_bIsItemDisabled[cItemID] = TRUE;
		PlaySound('E', 29, 0);
		break;
#endif
	}
}

void CGame::bItemDrop_Bank(short msX, short msY)
{	m_stDialogBoxInfo[39].sV1 = m_stMCursor.sSelectedObjectID;
	if (m_cCommand < 0) return;
	if (m_pItemList[m_stDialogBoxInfo[39].sV1] == NULL) return;
	if (m_bIsItemDisabled[m_stDialogBoxInfo[39].sV1] == TRUE) return;
	if ( m_bIsDialogEnabled[17] == TRUE )
	{	AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if ( (m_bIsDialogEnabled[20] == TRUE) && ((m_stDialogBoxInfo[20].cMode == 1) || (m_stDialogBoxInfo[20].cMode == 2)) )
	{	AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if (m_bIsDialogEnabled[23] == TRUE)
	{	AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if (m_bIsDialogEnabled[4] == TRUE)
	{	AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if ( ((m_pItemList[m_stDialogBoxInfo[39].sV1]->m_cItemType == DEF_ITEMTYPE_CONSUME) || (m_pItemList[m_stDialogBoxInfo[39].sV1]->m_cItemType == DEF_ITEMTYPE_ARROW)) && (m_pItemList[m_stDialogBoxInfo[39].sV1]->m_dwCount > 1) )
	{	m_stDialogBoxInfo[17].sX  = msX - 140;
		m_stDialogBoxInfo[17].sY  = msY - 70;
		if (m_stDialogBoxInfo[17].sY < 0) m_stDialogBoxInfo[17].sY = 0;

		m_stDialogBoxInfo[17].sV1 = m_sPlayerX+1;
		m_stDialogBoxInfo[17].sV2 = m_sPlayerY+1;
		m_stDialogBoxInfo[17].sV3 = 1002;// NPC
		m_stDialogBoxInfo[17].sV4 = m_stDialogBoxInfo[39].sV1;

		ZeroMemory(m_stDialogBoxInfo[17].cStr, sizeof(m_stDialogBoxInfo[17].cStr));
		EnableDialogBox(17, m_stDialogBoxInfo[39].sV1, m_pItemList[m_stDialogBoxInfo[39].sV1]->m_dwCount, NULL);
	}else
	{	if (_iGetBankItemCount() >= (DEF_MAXBANKITEMS-1)) AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);
		else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, m_stDialogBoxInfo[39].sV1, 1, m_stDialogBoxInfo[39].sV5, m_stDialogBoxInfo[39].sV6, m_pItemList[m_stDialogBoxInfo[39].sV1]->m_cName, m_stDialogBoxInfo[39].sV4); //v1.4
	}
}

void CGame::bItemDrop_SkillDialog()
{
 int iConsumeNum;
 char cItemID;

	if (m_cCommand < 0) return;
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (m_pItemList[cItemID] == NULL) return;
	if (m_bIsItemDisabled[cItemID] == TRUE) return;

	if ( m_bIsDialogEnabled[17] == TRUE ) 
	{	AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if (   (m_bIsDialogEnabled[20] == TRUE) 
		&& ((m_stDialogBoxInfo[20].cMode == 1) || (m_stDialogBoxInfo[20].cMode == 2)) ) 
	{	AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if (m_bIsDialogEnabled[23] == TRUE) 
	{	AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	switch (m_stDialogBoxInfo[26].cMode) {
	case 1:
		if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) 
		{	iConsumeNum = 0;
			if (m_stDialogBoxInfo[26].sV1 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV2 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV3 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV4 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV5 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV6 == cItemID) iConsumeNum++;
			if (iConsumeNum >= (int)(m_pItemList[cItemID]->m_dwCount)) return;
		}
		if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EAT) ||
			(m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_NONE)) 
		{}else return;

		if (m_stDialogBoxInfo[26].sV1 == -1) 
		{	m_stDialogBoxInfo[26].sV1 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV2 == -1) 
		{	m_stDialogBoxInfo[26].sV2 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV3 == -1) 
		{	m_stDialogBoxInfo[26].sV3 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV4 == -1) 
		{	m_stDialogBoxInfo[26].sV4 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV5 == -1) 
		{	m_stDialogBoxInfo[26].sV5 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV6 == -1)
		{	m_stDialogBoxInfo[26].sV6 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		AddEventList(BITEMDROP_SKILLDIALOG4, 10);
		break;

	case 4:
		if (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) 
		{	iConsumeNum = 0;
			if (m_stDialogBoxInfo[26].sV1 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV2 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV3 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV4 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV5 == cItemID) iConsumeNum++;
			if (m_stDialogBoxInfo[26].sV6 == cItemID) iConsumeNum++;
			if (iConsumeNum >= (int)(m_pItemList[cItemID]->m_dwCount)) return;
		}

		if (m_stDialogBoxInfo[26].sV1 == -1) 
		{	m_stDialogBoxInfo[26].sV1 = cItemID;
			m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV2 == -1) 
		{	m_stDialogBoxInfo[26].sV2 = cItemID;
			m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV3 == -1) 
		{	m_stDialogBoxInfo[26].sV3 = cItemID;
			m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV4 == -1)
		{	m_stDialogBoxInfo[26].sV4 = cItemID;
			m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV5 == -1) 
		{
			m_stDialogBoxInfo[26].sV5 = cItemID;
			m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV6 == -1)
		{	m_stDialogBoxInfo[26].sV6 = cItemID;
			m_stDialogBoxInfo[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		AddEventList(BITEMDROP_SKILLDIALOG4, 10); // "There is no more space for ingredients."
		break;

	// Crafting
	case 7:
		if (   (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_NONE)			// Merien Stone
			|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_EQUIP)		// Necks XXXMagins
			|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME)		// stones
			|| (m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_MATERIAL))	// XXXwares
		{}else return;

		if (m_stDialogBoxInfo[26].sV1 == -1) 
		{	m_stDialogBoxInfo[26].sV1 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV2 == -1) 
		{	m_stDialogBoxInfo[26].sV2 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV3 == -1) 
		{	m_stDialogBoxInfo[26].sV3 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV4 == -1) 
		{	m_stDialogBoxInfo[26].sV4 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV5 == -1) 
		{	m_stDialogBoxInfo[26].sV5 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}else if (m_stDialogBoxInfo[26].sV6 == -1)
		{	m_stDialogBoxInfo[26].sV6 = cItemID;
			if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1)) 
			{}else m_bIsItemDisabled[cItemID] = TRUE;
			return;
		}
		AddEventList(BITEMDROP_SKILLDIALOG4, 10); // "There is no more space for ingredients."
		break;

	default:
		break;
	}
}

// Slates Item Drag&Drop - Diuuude
void CGame::bItemDrop_Slates()
{
 char cItemID;
	if (m_cCommand < 0) return;
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (m_pItemList[cItemID] == NULL) return;
	if (m_bIsItemDisabled[cItemID] == TRUE) return;
	if ( m_bIsDialogEnabled[17] == TRUE ) {
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if ( (m_bIsDialogEnabled[20] == TRUE) &&
		 ((m_stDialogBoxInfo[20].cMode == 1) || (m_stDialogBoxInfo[20].cMode == 2)) ) 
	{	AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if (m_bIsDialogEnabled[23] == TRUE) 
	{	AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	switch (m_stDialogBoxInfo[40].cMode) {
	case 1:
		if ((m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) && (m_pItemList[cItemID]->m_sSpriteFrame >= 151) && (m_pItemList[cItemID]->m_sSpriteFrame <= 154)) {
			char cItemIDText[20];
			switch(m_pItemList[cItemID]->m_sSpriteFrame){
				case 151:
					if (m_stDialogBoxInfo[40].sV1 == -1){
						m_bIsItemDisabled[cItemID] = TRUE;
						m_stDialogBoxInfo[40].sV1 = cItemID;
						wsprintf(cItemIDText, "Item ID : %d", cItemID);
						AddEventList(cItemIDText, 10);
					}
					break;
				case 152:
					if (m_stDialogBoxInfo[40].sV2 == -1){
						m_bIsItemDisabled[cItemID] = TRUE;
						m_stDialogBoxInfo[40].sV2 = cItemID;
						wsprintf(cItemIDText, "Item ID : %d", cItemID);
						AddEventList(cItemIDText, 10);
					}
					break;
				case 153:
					if (m_stDialogBoxInfo[40].sV3 == -1){
						m_bIsItemDisabled[cItemID] = TRUE;
						m_stDialogBoxInfo[40].sV3 = cItemID;
						wsprintf(cItemIDText, "Item ID : %d", cItemID);
						AddEventList(cItemIDText, 10);
					}
					break;
				case 154:
					if (m_stDialogBoxInfo[40].sV4 == -1){
						m_bIsItemDisabled[cItemID] = TRUE;
						m_stDialogBoxInfo[40].sV4 = cItemID;
						wsprintf(cItemIDText, "Item ID : %d", cItemID);
						AddEventList(cItemIDText, 10);
					}
					break;
			}
		}
		break;

	default:
		break;
	}
}

void CGame::DlgBoxClick_Bank(short msX, short msY)
{
 int i;
 short sX, sY;


	sX = m_stDialogBoxInfo[14].sX;
	sY = m_stDialogBoxInfo[14].sY;

	switch ( m_stDialogBoxInfo[14].cMode ) {
	case -1:
		break;

	case 0:
		for (i = 0; i < m_stDialogBoxInfo[14].sV1; i++)
		if ((msX > sX + 30) && (msX < sX + 210) && (msY >= sY + 110 + i*15) && (msY <= sY + 124 + i*15)) {
			if ((m_pBankList[m_stDialogBoxInfo[14].sView + i] != NULL) && ((m_stDialogBoxInfo[14].sView + i) < DEF_MAXBANKITEMS)) {
				if (_iGetTotalItemNum() >= 50) {
					AddEventList(DLGBOX_CLICK_BANK1, 10);
					return;
				}
				bSendCommand(MSGID_REQUEST_RETRIEVEITEM, NULL, NULL, (m_stDialogBoxInfo[14].sView + i), NULL, NULL, NULL);
				m_stDialogBoxInfo[14].cMode = -1;
				PlaySound('E', 14, 5);
			}
			return;
		}

		break;
	}
}

void CGame::DlgBoxClick_Fish(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[24].sX;
	sY = m_stDialogBoxInfo[24].sY;

	switch (m_stDialogBoxInfo[24].cMode) {
	case 0:
		if ((msX >= sX + 160) && (msX <= sX + 253) && (msY >= sY + 70) && (msY <= sY + 90)) {
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETFISHTHISTIME, NULL, NULL, NULL, NULL, NULL);
			AddEventList(DLGBOX_CLICK_FISH1, 10);
			DisableDialogBox(24);

			PlaySound('E', 14, 5);
		}
		break;
	}
}

void CGame::DlgBoxClick_Magic(short msX, short msY)
{
 int i, iCPivot, iYloc;
 short sX, sY;

	sX = m_stDialogBoxInfo[3].sX;
	sY = m_stDialogBoxInfo[3].sY;
	iCPivot = m_stDialogBoxInfo[3].sView*10;
	iYloc = 0;
	for (i = 0; i < 9; i++)
	{	if ((m_cMagicMastery[iCPivot + i] != NULL) && (m_pMagicCfgList[iCPivot + i] != NULL))
		{	if ((msX >= sX + 30) && (msX <= sX + 240) && (msY >= sY + 70 + iYloc) && (msY <= sY + 70 + 18 + iYloc))
			{	UseMagic(iCPivot + i);
				PlaySound('E', 14, 5);
		 		return;
			}
			iYloc += 18;
	}	}
	if ((msX >= sX + 16) && (msX <= sX + 38) && (msY >= sY + 240) && (msY <= sY + 268))
		m_stDialogBoxInfo[3].sView = 0;
	if ((msX >= sX + 39) && (msX <= sX + 56) && (msY >= sY + 240) && (msY <= sY + 268))
		m_stDialogBoxInfo[3].sView = 1;
	if ((msX >= sX + 57) && (msX <= sX + 81) && (msY >= sY + 240) && (msY <= sY + 268))
		m_stDialogBoxInfo[3].sView = 2;
	if ((msX >= sX + 82) && (msX <= sX + 101) && (msY >= sY + 240) && (msY <= sY + 268))
		m_stDialogBoxInfo[3].sView = 3;
	if ((msX >= sX + 102) && (msX <= sX + 116) && (msY >= sY + 240) && (msY <= sY + 268))
		m_stDialogBoxInfo[3].sView = 4;
	if ((msX >= sX + 117) && (msX <= sX + 137) && (msY >= sY + 240) && (msY <= sY + 268))
		m_stDialogBoxInfo[3].sView = 5;
	if ((msX >= sX + 138) && (msX <= sX + 165) && (msY >= sY + 240) && (msY <= sY + 268))
		m_stDialogBoxInfo[3].sView = 6;
	if ((msX >= sX + 166) && (msX <= sX + 197) && (msY >= sY + 240) && (msY <= sY + 268))
		m_stDialogBoxInfo[3].sView = 7;
	if ((msX >= sX + 198) && (msX <= sX + 217) && (msY >= sY + 240) && (msY <= sY + 268))
		m_stDialogBoxInfo[3].sView = 8;
	if ((msX >= sX + 218) && (msX <= sX + 239) && (msY >= sY + 240) && (msY <= sY + 268))
		m_stDialogBoxInfo[3].sView = 9;

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 285) && (msY <= sY + 285 + DEF_BTNSZY))
	{	if (m_cSkillMastery[12] == 0) AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY16, 10);
		else
		{	for (i = 0; i < DEF_MAXITEMS; i++)
			if ((m_pItemList[i] != NULL) && (m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) &&
				(m_pItemList[i]->m_sSpriteFrame == 55))
			{	EnableDialogBox(26, 1, NULL, NULL, NULL);
				AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY10, 10);
				PlaySound('E', 14, 5);
				return;
			}
			AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY15, 10);
		}
		PlaySound('E', 14, 5);
	}
}

void CGame::DlgBoxClick_NpcActionQuery(short msX, short msY)
{short sX, sY;
 int   absX, absY;
	if (m_bIsDialogEnabled[27] == TRUE)
	{	AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	sX = m_stDialogBoxInfo[20].sX;
	sY = m_stDialogBoxInfo[20].sY;

	switch (m_stDialogBoxInfo[20].cMode) {
	case 0: // Talk to npc
		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70))
		{	EnableDialogBox(m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV2, NULL, NULL);
			DisableDialogBox(20);
		}
		if ((m_bIsDialogEnabled[21] == FALSE) && (msX > sX + 125) && (msX < sX + 180) && (msY > sY + 55) && (msY < sY + 70))
		{	switch (m_stDialogBoxInfo[20].sV1) {
			case 7:	// Guild
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 1, NULL, NULL, NULL);
				AddEventList(TALKING_TO_GUILDHALL_OFFICER, 10);
				break;
			case 11: // BS or Shop
				switch (m_stDialogBoxInfo[20].sV2) {
				case 1:
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 2, NULL, NULL, NULL);
					AddEventList(TALKING_TO_SHOP_KEEPER, 10);
					break;
				case 2:
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 3, NULL, NULL, NULL);
					AddEventList(TALKING_TO_BLACKSMITH_KEEPER, 10);
					break;
				}
				break;
			case 13: // CityHall officer
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 4, NULL, NULL, NULL);
				AddEventList(TALKING_TO_CITYHALL_OFFICER, 10);
				break;
			case 14: // WH keeper
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 5, NULL, NULL, NULL);
				AddEventList(TALKING_TO_WAREHOUSE_KEEPER, 10);
				break;
			case 16: // Magicmerchant
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 6, NULL, NULL, NULL);
				AddEventList(TALKING_TO_MAGICIAN, 10);
				break;
			}
			DisableDialogBox(20);
		}
		break;

	case 1: // On other player
		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70))
		{	absX = abs(m_stDialogBoxInfo[20].sV5 - m_sPlayerX);
			absY = abs(m_stDialogBoxInfo[20].sV6 - m_sPlayerY);
			if ((absX <= 4) && (absY <= 4))
				 bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV3, m_stDialogBoxInfo[20].sV5, m_stDialogBoxInfo[20].sV6, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_stDialogBoxInfo[20].sV4); //v1.4
			else AddEventList(DLGBOX_CLICK_NPCACTION_QUERY7, 10); //"Too far to give the item."
			DisableDialogBox(20);
		}else if ((msX > sX + 155) && (msX < sX + 210) && (msY > sY + 55) && (msY < sY + 70))
		{	absX = abs(m_stDialogBoxInfo[20].sV5 - m_sPlayerX);
			absY = abs(m_stDialogBoxInfo[20].sV6 - m_sPlayerY);
			if ((absX <= 4) && (absY <= 4))
				 bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_EXCHANGEITEMTOCHAR, m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV3, m_stDialogBoxInfo[20].sV5, m_stDialogBoxInfo[20].sV6, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_stDialogBoxInfo[20].sV4); //v1.4
			else AddEventList(DLGBOX_CLICK_NPCACTION_QUERY8, 10); //"Too far to exchange item."
			DisableDialogBox(20);
		}
		break;

	case 2: // Item on Shop/BS
		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70))
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_SELLITEM, NULL, m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV2, m_stDialogBoxInfo[20].sV3, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_stDialogBoxInfo[20].sV4); // v1.4
			DisableDialogBox(20);
		}else if ((msX > sX + 125) && (msX < sX + 180) && (msY > sY + 55) && (msY < sY + 70))
		{	if (m_stDialogBoxInfo[20].sV3 == 1)
			{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_REPAIRITEM, NULL, m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV2, NULL, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_stDialogBoxInfo[20].sV4); // v1.4
				DisableDialogBox(20);
		}	}
		break;

	case 3: // Put item in the WH
		if ((msX > sX + 25) && (msX < sX + 105) && (msY > sY + 55) && (msY < sY + 70))
		{	absX = abs(m_stDialogBoxInfo[20].sV5 - m_sPlayerX);
			absY = abs(m_stDialogBoxInfo[20].sV6 - m_sPlayerY);
			if ((absX <= 8) && (absY <= 8))
			{	if (_iGetBankItemCount() >= (DEF_MAXBANKITEMS-1))
				{	AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);//"here is no empty space left in warehouse."
				}else bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_GIVEITEMTOCHAR, m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV3, m_stDialogBoxInfo[20].sV5, m_stDialogBoxInfo[20].sV6, m_pItemList[m_stDialogBoxInfo[20].sV1]->m_cName, m_stDialogBoxInfo[20].sV4); //v1.4
			}else AddEventList(DLGBOX_CLICK_NPCACTION_QUERY7, 10);//"Too far to give the item."

			DisableDialogBox(20);
		}
		break;

	case 4: // talk to npc or Unicorn
		if ((m_bIsDialogEnabled[21] == FALSE) && (msX > sX + 125) && (msX < sX + 180) && (msY > sY + 55) && (msY < sY + 70))
		{	switch (m_stDialogBoxInfo[20].sV3) {
			case 21: // Guard
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 21, NULL, NULL, NULL);
				AddEventList(TALKING_TO_GUARD, 10);//"Talking to Guard..."
				break;

			case 32: // Unicorn
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 32, NULL, NULL, NULL);
				AddEventList(TALKING_TO_UNICORN, 10);//"Talking to Unicorn..."
				break;
			case 67:
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 67, NULL, NULL, NULL);
				AddEventList(TALKING_TO_MCGAFFIN, 10);//"Talking to a town man..."
				break;
			case 68:
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 68, NULL, NULL, NULL);
				AddEventList(TALKING_TO_PERRY, 10);//"Talking to a town maiden..."
				break;
			case 69:
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 69, NULL, NULL, NULL);
				AddEventList(TALKING_TO_DEVLIN, 10);//"Talking to a town magician..."
				break;
		}	}
		DisableDialogBox(20);
		break;


	case 5: // Talk
		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70))
		{	EnableDialogBox(m_stDialogBoxInfo[20].sV1, m_stDialogBoxInfo[20].sV2, NULL, NULL);
			DisableDialogBox(20);
		}
		if ((msX > sX + 25 +75) && (msX < sX + 80 +75) && (msY > sY + 55) && (msY < sY + 70))
		{	EnableDialogBox(31, NULL, NULL, NULL);
			DisableDialogBox(20);
		}

		if ((m_bIsDialogEnabled[21] == FALSE) && (msX > sX + 155) && (msX < sX + 210) && (msY > sY + 55) && (msY < sY + 70))
		{	switch (m_stDialogBoxInfo[20].sV1) {
			case 7:	// Guild
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 1, NULL, NULL, NULL);
				AddEventList(TALKING_TO_GUILDHALL_OFFICER, 10);//"Talking to Guildhall Officer..."
				break;

			case 11: //
				switch (m_stDialogBoxInfo[20].sV2) {
				case 1:
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 2, NULL, NULL, NULL);
					AddEventList(TALKING_TO_SHOP_KEEPER, 10);//"Talking to Shop Keeper..."
					break;
				case 2:
					bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 3, NULL, NULL, NULL);
					AddEventList(TALKING_TO_BLACKSMITH_KEEPER, 10);//"
					break;
				}
				break;

			case 13: //
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 4, NULL, NULL, NULL);
				AddEventList(TALKING_TO_CITYHALL_OFFICER, 10);//"
				break;

			case 14: //
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 5, NULL, NULL, NULL);
				AddEventList(TALKING_TO_WAREHOUSE_KEEPER, 10);//
				break;

			case 16: //
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TALKTONPC, NULL, 6, NULL, NULL, NULL);
				AddEventList(TALKING_TO_MAGICIAN, 10);//"
				break;
			}
			DisableDialogBox(20);
		}
		break;

	case 6: // Snoopy: Added Gail
		if ((msX > sX + 25) && (msX < sX + 100) && (msY > sY + 55) && (msY < sY + 70))
		{	EnableDialogBox(51, 0, NULL, NULL);
			DisableDialogBox(20);
		}
	}
}


void CGame::DlgBoxClick_Shop(short msX, short msY)
{
 int i;
 short sX, sY;
 char cTemp[21];
	sX = m_stDialogBoxInfo[11].sX;
	sY = m_stDialogBoxInfo[11].sY;

	switch ( m_stDialogBoxInfo[11].cMode ) {
	case 0:
		for (i = 0; i < 13; i++)
		if ((msX >= sX + 20) && (msX <= sX + 220) && (msY >= sY + i*18 + 65) && (msY <= sY + i*18 + 79)) {
			if (_iGetTotalItemNum() >= 50) {
				AddEventList(DLGBOX_CLICK_SHOP1, 10);//"You cannot buy anything because your bag is full."
				return;
			}

			PlaySound('E', 14, 5);
			if (m_pItemForSaleList[m_stDialogBoxInfo[11].sView + i] != NULL)
				m_stDialogBoxInfo[11].cMode = m_stDialogBoxInfo[11].sView + i + 1;
			return;
		}
		break;

	default:
		if ((msX >= sX + 145) && (msX <= sX + 162) && (msY >= sY + 209) && (msY <= sY + 230))
		{	m_stDialogBoxInfo[11].sV3 += 10;
			if (m_stDialogBoxInfo[11].sV3 >= (50 - _iGetTotalItemNum()))
				m_stDialogBoxInfo[11].sV3 = (50 - _iGetTotalItemNum());
		}

		if ((msX >= sX + 145) && (msX <= sX + 162) && (msY >= sY + 234) && (msY <= sY + 251))
		{	m_stDialogBoxInfo[11].sV3 -= 10;
			if (m_stDialogBoxInfo[11].sV3 <= 1)
				m_stDialogBoxInfo[11].sV3 = 1;
		}

		if ((msX >= sX + 163) && (msX <= sX + 180) && (msY >= sY + 209) && (msY <= sY + 230))
		{	m_stDialogBoxInfo[11].sV3++;
			if (m_stDialogBoxInfo[11].sV3 >= (50 - _iGetTotalItemNum()))
				m_stDialogBoxInfo[11].sV3 = (50 - _iGetTotalItemNum());
		}

		if ((msX >= sX + 163) && (msX <= sX + 180) && (msY >= sY + 234) && (msY <= sY + 251))
		{	m_stDialogBoxInfo[11].sV3--;
			if (m_stDialogBoxInfo[11].sV3 <= 1)
				m_stDialogBoxInfo[11].sV3 = 1;
		}

		if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Purchase Click
			if ((50 - _iGetTotalItemNum()) < m_stDialogBoxInfo[11].sV3)
			{	AddEventList(DLGBOX_CLICK_SHOP1, 10);//"ou cannot buy anything because your bag is full."
			}else
			{	ZeroMemory(cTemp, sizeof(cTemp));
				strcpy(cTemp, m_pItemForSaleList[m_stDialogBoxInfo[11].cMode - 1]->m_cName);
				bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_PURCHASEITEM, NULL, m_stDialogBoxInfo[11].sV3, NULL, NULL, cTemp);
			}
			m_stDialogBoxInfo[11].cMode = 0;
			m_stDialogBoxInfo[11].sV3   = 1;
			PlaySound('E', 14, 5);
		}

		if ((msX >= sX + 154) && (msX <= sX + 154 + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Cancel Click
			m_stDialogBoxInfo[11].cMode = 0;
			m_stDialogBoxInfo[11].sV3   = 1;
			PlaySound('E', 14, 5);
		}
		break;
	}
}

void CGame::DlgBoxClick_Skill(short msX, short msY)
{int i;
 short sX, sY;
	sX = m_stDialogBoxInfo[15].sX;
	sY = m_stDialogBoxInfo[15].sY;
	switch ( m_stDialogBoxInfo[15].cMode ) {
	case -1:
		break;
	case 0:
		for (i = 0; i < 17; i++)
		if ((i < DEF_MAXSKILLTYPE) && (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView] != NULL))
		{	if ((msX >= sX + 44) && (msX <= sX + 135 + 44) && (msY >= sY + 45 + i*15) && (msY <= sY + 59 + i*15))
			{	if (    (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_bIsUseable == TRUE)
					 && (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_iLevel != 0) )
				{	if (m_bSkillUsingStatus == TRUE)
					{	AddEventList(DLGBOX_CLICK_SKILL1, 10); // "You are already using other skill."
						return;
					}
					if ((m_bCommandAvailable == FALSE) || (m_iHP <= 0))
					{	AddEventList(DLGBOX_CLICK_SKILL2, 10); // "You can't use a skill while you are moving."
						return;
					}
					if (m_bIsGetPointingMode == TRUE)
					{	return;
					}
					switch (m_pSkillCfgList[i + m_stDialogBoxInfo[15].sView]->m_cUseMethod) {
					case 0:
					case 2:
						bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_USESKILL, NULL, (i + m_stDialogBoxInfo[15].sView), NULL, NULL, NULL);
						m_bSkillUsingStatus = TRUE;
						DisableDialogBox(15);
						PlaySound('E', 14, 5);
						break;
					}
				}
			}else if ((msX >= sX + 215) && (msX <= sX + 240) && (msY >= sY + 45 + i*15) && (msY <= sY + 59 + i*15))
			{	if (m_stDialogBoxInfo[15].bFlag == FALSE)
				{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX, NULL, i + m_stDialogBoxInfo[15].sView, NULL, NULL, NULL);
					PlaySound('E', 14, 5);
					m_stDialogBoxInfo[15].bFlag = TRUE;
		}	}	}
		break;
	}
}

void CGame::DlgBoxClick_SkillDlg(short msX, short msY)
{
 int i, iAdjX, iAdjY;
 short sX, sY;

	sX = m_stDialogBoxInfo[26].sX;
	sY = m_stDialogBoxInfo[26].sY;

	iAdjX = 5 ;
	iAdjY = 8 ;


	switch (m_stDialogBoxInfo[26].cMode) {
	case 1:
		if ((msX >= sX + iAdjX + 60) && (msX <= sX + iAdjX + 153) && (msY >= sY + iAdjY + 175) && (msY <= sY + iAdjY + 195))
		{	m_stDialogBoxInfo[26].cMode = 2;
			m_stDialogBoxInfo[26].cStr[0] = 1;
			m_stDialogBoxInfo[26].dwT1 = m_dwCurTime;
			PlaySound('E', 14, 5);
			AddEventList(DLGBOX_CLICK_SKILLDLG1, 10); // "Mixing a potion..."
			PlaySound('E', 41, 0);
		}
		break;
	// Crafting
	case 7:
		if ((msX >= sX + iAdjX + 60) && (msX <= sX + iAdjX + 153) && (msY >= sY + iAdjY + 175) && (msY <= sY + iAdjY + 195))
		{	if (m_stDialogBoxInfo[26].sV1 == -1)
			{	AddEventList(DLGBOX_CLICK_SKILLDLG2, 10); // "There is not enough crafting materials. Please put in more materials."
				PlaySound('E', 14, 5);
			}else
			{	m_stDialogBoxInfo[26].cMode = 8;
				m_stDialogBoxInfo[26].dwT1 = m_dwCurTime;
				m_stDialogBoxInfo[26].cStr[1] = 1;
				PlaySound('E', 14, 5);
				AddEventList(DLGBOX_CLICK_SKILLDLG3, 10); // "Crafting the item in progress"
				PlaySound('E', 51, 0);
		}	}
		break;

	case 3:
		for (i = 0; i < 13; i++)
		if (m_pDispBuildItemList[i + m_stDialogBoxInfo[26].sView] != NULL)
		{	if ((msX >= sX + iAdjX + 44) && (msX <= sX + iAdjX + 135 + 44) && (msY >= sY + iAdjY + 55 + i*15) && (msY <= sY + iAdjY + 55 + 14 + i*15)) {
				m_stDialogBoxInfo[26].cMode = 4;
				m_stDialogBoxInfo[26].cStr[0] = i + m_stDialogBoxInfo[26].sView;
				PlaySound('E', 14, 5);		
		}	}
		break;

	case 4:
		iAdjX = -1 ;
		iAdjY = -7 ;
		if (m_pDispBuildItemList[m_stDialogBoxInfo[26].cStr[0]]->m_bBuildEnabled == TRUE)
		{	if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) {
				// Back
				m_stDialogBoxInfo[26].cMode = 3;
				PlaySound('E', 14, 5);

				if ((m_stDialogBoxInfo[26].sV1 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV1] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV1] = FALSE;
				if ((m_stDialogBoxInfo[26].sV2 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV2] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV2] = FALSE;
				if ((m_stDialogBoxInfo[26].sV3 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV3] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV3] = FALSE;
				if ((m_stDialogBoxInfo[26].sV4 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV4] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV4] = FALSE;
				if ((m_stDialogBoxInfo[26].sV5 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV5] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV5] = FALSE;
				if ((m_stDialogBoxInfo[26].sV6 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV6] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV6] = FALSE;

				m_stDialogBoxInfo[26].sV1   = -1;
				m_stDialogBoxInfo[26].sV2   = -1;
				m_stDialogBoxInfo[26].sV3   = -1;
				m_stDialogBoxInfo[26].sV4   = -1;
				m_stDialogBoxInfo[26].sV5   = -1;
				m_stDialogBoxInfo[26].sV6   = -1;
				m_stDialogBoxInfo[26].cStr[0] = 0;
				m_stDialogBoxInfo[26].cStr[1] = 0;
				m_stDialogBoxInfo[26].cStr[4] = 0;
			}

			if ((msX >= sX + iAdjX + 160) && (msX <= sX + iAdjX + 255) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372))
			{	// Manufacture
				if (m_stDialogBoxInfo[26].cStr[4] == 1)
				{	m_stDialogBoxInfo[26].cMode   = 5;
					m_stDialogBoxInfo[26].cStr[1] = 0;
					m_stDialogBoxInfo[26].dwT1    = m_dwCurTime;
					PlaySound('E', 14, 5);
					PlaySound('E', 44, 0);
			}	}
		}else
		{	if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) 	// Back
			{	m_stDialogBoxInfo[26].cMode = 3;
				PlaySound('E', 14, 5);

				if ((m_stDialogBoxInfo[26].sV1 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV1] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV1] = FALSE;
				if ((m_stDialogBoxInfo[26].sV2 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV2] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV2] = FALSE;
				if ((m_stDialogBoxInfo[26].sV3 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV3] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV3] = FALSE;
				if ((m_stDialogBoxInfo[26].sV4 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV4] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV4] = FALSE;
				if ((m_stDialogBoxInfo[26].sV5 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV5] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV5] = FALSE;
				if ((m_stDialogBoxInfo[26].sV6 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV6] != NULL))
					m_bIsItemDisabled[m_stDialogBoxInfo[26].sV6] = FALSE;

				m_stDialogBoxInfo[26].sV1   = -1;
				m_stDialogBoxInfo[26].sV2   = -1;
				m_stDialogBoxInfo[26].sV3   = -1;
				m_stDialogBoxInfo[26].sV4   = -1;
				m_stDialogBoxInfo[26].sV5   = -1;
				m_stDialogBoxInfo[26].sV6   = -1;
				m_stDialogBoxInfo[26].cStr[0] = 0;
				m_stDialogBoxInfo[26].cStr[1] = 0;
				m_stDialogBoxInfo[26].cStr[4] = 0;
			}
		}
		break;

	case 6:
		iAdjX = -1;
		iAdjY = -7;
		if ((msX >= sX + iAdjX + 32) && (msX <= sX + iAdjX + 95) && (msY >= sY + iAdjY + 353) && (msY <= sY + iAdjY + 372)) {
			// Back
			m_stDialogBoxInfo[26].cMode = 3;
			PlaySound('E', 14, 5);

			if ((m_stDialogBoxInfo[26].sV1 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV1] != NULL))
				m_bIsItemDisabled[m_stDialogBoxInfo[26].sV1] = FALSE;
			if ((m_stDialogBoxInfo[26].sV2 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV2] != NULL))
				m_bIsItemDisabled[m_stDialogBoxInfo[26].sV2] = FALSE;
			if ((m_stDialogBoxInfo[26].sV3 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV3] != NULL))
				m_bIsItemDisabled[m_stDialogBoxInfo[26].sV3] = FALSE;
			if ((m_stDialogBoxInfo[26].sV4 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV4] != NULL))
				m_bIsItemDisabled[m_stDialogBoxInfo[26].sV4] = FALSE;
			if ((m_stDialogBoxInfo[26].sV5 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV5] != NULL))
				m_bIsItemDisabled[m_stDialogBoxInfo[26].sV5] = FALSE;
			if ((m_stDialogBoxInfo[26].sV6 != -1) && (m_pItemList[m_stDialogBoxInfo[26].sV6] != NULL))
				m_bIsItemDisabled[m_stDialogBoxInfo[26].sV6] = FALSE;

			m_stDialogBoxInfo[26].sV1   = -1;
			m_stDialogBoxInfo[26].sV2   = -1;
			m_stDialogBoxInfo[26].sV3   = -1;
			m_stDialogBoxInfo[26].sV4   = -1;
			m_stDialogBoxInfo[26].sV5   = -1;
			m_stDialogBoxInfo[26].sV6   = -1;
			m_stDialogBoxInfo[26].cStr[0] = 0;
			m_stDialogBoxInfo[26].cStr[1] = 0;
			m_stDialogBoxInfo[26].cStr[4] = 0;
		}
		break;
	}
}

void CGame::ResponseTeleportList(char *pData)
{	char *cp;
	int  *ip, i;
#ifdef _DEBUG
	AddEventList("Teleport ???", 10);
#endif
	cp = pData + 6;
	ip = (int*) cp;
	m_iTeleportMapCount = *ip;
	cp += 4;
	for ( i = 0 ; i < m_iTeleportMapCount ; i++)
	{	ip = (int*)cp;
		m_stTeleportList[i].iIndex = *ip;
		cp += 4;
		ZeroMemory(m_stTeleportList[i].mapname, sizeof(m_stTeleportList[i].mapname) );
		memcpy(m_stTeleportList[i].mapname, cp, 10);
		cp += 10;
		ip = (int*)cp;
		m_stTeleportList[i].iX = *ip;
		cp += 4;
		ip = (int*)cp;
		m_stTeleportList[i].iY = *ip;
		cp += 4;
		ip = (int*)cp;
		m_stTeleportList[i].iCost = *ip;
		cp += 4;
	}
}

void CGame::ResponseChargedTeleport(char *pData)
{	short *sp;
	char *cp;
	short sRejectReason = 0;
	cp = (char*)pData + DEF_INDEX2_MSGTYPE + 2;
	sp = (short*)cp;
	sRejectReason = *sp;

#ifdef _DEBUG
	AddEventList( "charged teleport ?", 10 );
#endif

	switch( sRejectReason )	{
	case 1:
		AddEventList( RESPONSE_CHARGED_TELEPORT1, 10 );
		break;
	case 2:
		AddEventList( RESPONSE_CHARGED_TELEPORT2, 10 );
		break;
	case 3:
		AddEventList( RESPONSE_CHARGED_TELEPORT3, 10 );
		break;
	case 4:
		AddEventList( RESPONSE_CHARGED_TELEPORT4, 10 );
		break;
	case 5:
		AddEventList( RESPONSE_CHARGED_TELEPORT5, 10 );
		break;
	case 6:
		AddEventList( RESPONSE_CHARGED_TELEPORT6, 10 );
		break;
	default:
		AddEventList( RESPONSE_CHARGED_TELEPORT7, 10 );
	}
}

void CGame::NotifyMsg_CannotGiveItem(char *pData)
{
 char * cp, cName[21], cTxt[256];
 WORD * wp, wItemIndex;
 int  * ip, iAmount;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	wItemIndex = *wp;
	cp += 2;

	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[wItemIndex], cStr1, cStr2, cStr3);
	if( iAmount == 1 ) wsprintf(cTxt, NOTIFYMSG_CANNOT_GIVE_ITEM2, cStr1, cName);
	else wsprintf( cTxt, NOTIFYMSG_CANNOT_GIVE_ITEM1, iAmount, cStr1, cName);


	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_DropItemFin_CountChanged(char *pData)
{
 char * cp, cTxt[256];
 WORD * wp, wItemIndex;
 int  * ip, iAmount;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	wItemIndex = *wp;
	cp += 2;

	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[wItemIndex]->m_cName, m_pItemList[wItemIndex]->m_dwAttribute, cStr1, cStr2, cStr3);
	wsprintf(cTxt, NOTIFYMSG_THROW_ITEM1, iAmount, cStr1);

	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_CannotJoinMoreGuildsMan(char * pData)
{
 char * cp, cName[12], cTxt[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);

	wsprintf(cTxt, NOTIFYMSG_CANNOT_JOIN_MOREGUILDMAN1, cName);
	AddEventList(cTxt, 10);
	AddEventList(NOTIFYMSG_CANNOT_JOIN_MOREGUILDMAN2, 10);
}



void CGame::NotifyMsg_DismissGuildsMan(char * pData)
{
 char * cp, cName[12], cTxt[120];
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);

	if( memcmp( m_cPlayerName, cName, 10 ) != 0 ) {
		wsprintf(cTxt, NOTIFYMSG_DISMISS_GUILDMAN1, cName);
		AddEventList(cTxt, 10);
	}
	ClearGuildNameList();
}

void CGame::NotifyMsg_CannotRating(char * pData)
{
 char * cp, cTxt[120];
 WORD * wp, wTime;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	wTime = *wp;
	cp += 2;

	if (wTime == 0) wsprintf(cTxt, NOTIFYMSG_CANNOT_RATING1, wTime*3);
	else wsprintf(cTxt, NOTIFYMSG_CANNOT_RATING2, wTime*3);
	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_CannotRepairItem(char * pData)
{
 char * cp, cTxt[120], cStr1[64], cStr2[64], cStr3[64];
 WORD * wp, wV1, wV2;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
  	wV1 = *wp;
	cp += 2;
	wp = (WORD *)cp;
  	wV2 = *wp;
	cp += 2;
	ZeroMemory( cStr1, sizeof(cStr1) );
	ZeroMemory( cStr2, sizeof(cStr2) );
	ZeroMemory( cStr3, sizeof(cStr3) );
	GetItemName( m_pItemList[wV1], cStr1, cStr2, cStr3 );

	switch (wV2) {
	case 1:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_REPAIR_ITEM1, cStr1 );
		AddEventList(cTxt, 10);
 		break;
	case 2:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_REPAIR_ITEM2, cStr1 );
		AddEventList(cTxt, 10);
 		break;
	}
	m_bIsItemDisabled[wV1] = FALSE;
}

void CGame::NotifyMsg_CannotSellItem(char * pData)
{
 char * cp, cTxt[120], cStr1[64], cStr2[64], cStr3[64];
 WORD * wp, wV1, wV2;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	wp = (WORD *)cp;
  	wV1 = *wp;
	cp += 2;

	wp = (WORD *)cp;
  	wV2 = *wp;
	cp += 2;

	ZeroMemory( cStr1, sizeof(cStr1) );
	ZeroMemory( cStr2, sizeof(cStr2) );
	ZeroMemory( cStr3, sizeof(cStr3) );
	GetItemName( m_pItemList[wV1], cStr1, cStr2, cStr3 );

	switch (wV2) {
	case 1:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_SELL_ITEM1, cStr1);//"
		AddEventList(cTxt, 10);
		break;

	case 2:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_SELL_ITEM2, cStr1);//"
		AddEventList(cTxt, 10);
		break;

	case 3:
		wsprintf(cTxt, NOTIFYMSG_CANNOT_SELL_ITEM3, cStr1);//"
		AddEventList(cTxt, 10);
		AddEventList(NOTIFYMSG_CANNOT_SELL_ITEM4, 10);//"
		break;

	case 4:
		AddEventList(NOTIFYMSG_CANNOT_SELL_ITEM5, 10); // "
		AddEventList(NOTIFYMSG_CANNOT_SELL_ITEM6, 10); // "
		break;
	}
	m_bIsItemDisabled[wV1] = FALSE;
}

void CGame::NotifyMsg_Charisma(char * pData)
{
 DWORD * dwp;
 int  iPrevChar;
 char cTxt[120];

	iPrevChar = m_iCharisma;
	dwp = (DWORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
	m_iCharisma = (int)*dwp;

	if (m_iCharisma > iPrevChar)
	{	wsprintf(cTxt, NOTIFYMSG_CHARISMA_UP, m_iCharisma - iPrevChar);//"
		AddEventList(cTxt, 10);
		PlaySound('E', 21, 0);
	}else
	{	wsprintf(cTxt, NOTIFYMSG_CHARISMA_DOWN, iPrevChar - m_iCharisma);//"
		AddEventList(cTxt, 10);
	}
}

void CGame::NotifyMsg_DropItemFin_EraseItem(char *pData)
{
 char * cp;
 WORD * wp;
 int * ip, iAmount;
 short  sItemIndex;
 char   cTxt[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	wp = (WORD *)cp;
	sItemIndex = *wp;
	cp += 2;

	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[sItemIndex], cStr1, cStr2, cStr3);

	ZeroMemory(cTxt, sizeof(cTxt));
	if (m_bIsItemEquipped[sItemIndex] == TRUE)
	{	wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
		AddEventList(cTxt, 10);
		m_sItemEquipmentStatus[	m_pItemList[sItemIndex]->m_cEquipPos ] = -1;
		m_bIsItemEquipped[sItemIndex] = FALSE;
	}
	if (m_iHP > 0)
	{	wsprintf(cTxt, NOTIFYMSG_THROW_ITEM2, cStr1);
	}else
	{	if (iAmount < 2)
			wsprintf(cTxt, NOTIFYMSG_DROPITEMFIN_ERASEITEM3, cStr1); // "You dropped a %s."
		else // Snoopy fix
		{	wsprintf(cTxt, NOTIFYMSG_DROPITEMFIN_ERASEITEM5, cStr1); // "You dropped %s."
	}	}
	AddEventList(cTxt, 10);
	EraseItem((char)sItemIndex);
	_bCheckBuildItemStatus();
}


void CGame::NotifyMsg_EnemyKillReward(char *pData)
{
 DWORD * dwp;
 short * sp, sGuildRank;
 char  * cp, cName[12], cGuildName[24], cTxt[120];
 int   iExp, iEnemyKillCount, iWarContribution;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	dwp  = (DWORD *)cp;
	iExp = *dwp;
	cp += 4;
	dwp  = (DWORD *)cp;
	iEnemyKillCount = *dwp;
	cp += 4;
	memcpy(cName, cp, 10);
	cp += 10;
	memcpy(cGuildName, cp, 20);
	cp += 20;
	sp  = (short *)cp;
	sGuildRank = *sp;
	cp += 2;
	sp  = (short *)cp;
	iWarContribution = *sp;
	cp += 2;

	if (iWarContribution > m_iWarContribution)
	{	wsprintf(G_cTxt, "%s +%d!", m_pGameMsgList[21]->m_pMsg, iWarContribution - m_iWarContribution);
		SetTopMsg(G_cTxt, 5);
	}else if (iWarContribution < m_iWarContribution)
	{}
	m_iWarContribution = iWarContribution;

	if (sGuildRank == -1)
	{	wsprintf(cTxt, NOTIFYMSG_ENEMYKILL_REWARD1, cName);
		AddEventList(cTxt, 10);
	}else
	{	wsprintf(cTxt, NOTIFYMSG_ENEMYKILL_REWARD2, cName, cGuildName); // Fixed by Snoopy
		AddEventList(cTxt, 10);
	}

/*	if( m_iExp != iExp ) // removed by snoopy because too much msg hide victim's name
	{	if (m_iExp > iExp) wsprintf(cTxt, EXP_DECREASED,m_iExp - iExp);
		else wsprintf(cTxt, EXP_INCREASED,iExp - m_iExp);
		AddEventList(cTxt, 10);
	}*/

	if (m_iEnemyKillCount != iEnemyKillCount)
	{	if (m_iEnemyKillCount > iEnemyKillCount)
		{	wsprintf(cTxt, NOTIFYMSG_ENEMYKILL_REWARD5,m_iEnemyKillCount - iEnemyKillCount);//"Enemy-Kill-Count has been decreased by %dpoints."
			AddEventList(cTxt, 10);
			PlaySound('E', 24, 0); // son perdu 1 EK =(

		}else
		{	wsprintf(cTxt, NOTIFYMSG_ENEMYKILL_REWARD6, iEnemyKillCount - m_iEnemyKillCount);//"Enemy-Kill-Count has been increased by %dpoints."
			AddEventList(cTxt, 10);
			// Rajouté le son E48 en cas de victoire...(gros rire bien gras ....)
			PlaySound('E', 48, 0);
		}
	}else PlaySound('E', 23, 0);

	if( iExp >= 0 ) m_iExp = iExp;
	if( iEnemyKillCount >= 0 ) m_iEnemyKillCount = iEnemyKillCount;
}

void CGame::NotifyMsg_EventFishMode(char * pData)
{
 short sSprite, sSpriteFrame;
 char * cp, cName[21];
 WORD * wp, wPrice;
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

	wp = (WORD *)cp;
	wPrice = *wp;
	cp += 2;

	wp = (WORD *)cp;
	sSprite = (short)*wp;
	cp += 2;

	wp = (WORD *)cp;
	sSpriteFrame = (short)*wp;
	cp += 2;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	EnableDialogBox(24, 0, NULL, wPrice, cName);
	m_stDialogBoxInfo[24].sV3 = sSprite;
	m_stDialogBoxInfo[24].sV4 = sSpriteFrame;

	AddEventList(NOTIFYMSG_EVENTFISHMODE1, 10);
}

void CGame::NotifyMsg_Exp(char * pData)
{
 DWORD * dwp;
 int iPrevExp, * ip;
 char * cp, cTxt[120];

	iPrevExp = m_iExp;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	dwp = (DWORD *)cp;
	m_iExp = (int)*dwp;
	cp += 4;

	ip = (int *)cp;
	m_iRating = *ip;
	cp += 4;

	if (m_iExp > iPrevExp)
	{	wsprintf(cTxt, EXP_INCREASED, m_iExp - iPrevExp);
		AddEventList(cTxt, 10);
	}else
	{	wsprintf(cTxt, EXP_DECREASED, iPrevExp - m_iExp);
		AddEventList(cTxt, 10);
	}
}


void CGame::NotifyMsg_ForceDisconn(char *pData)
{WORD * wpCount;
	wpCount = (WORD *)(pData + 6);
	m_bForceDisconn = TRUE;
	//m_cLogOutCount = (char)*wpCount;
	if( m_bIsProgramActive )
	{	if( m_cLogOutCount < 0 || m_cLogOutCount > 5 ) m_cLogOutCount = 5;
		AddEventList(NOTIFYMSG_FORCE_DISCONN1, 10);
	}else
	{	delete m_pGSock;
		m_pGSock = NULL;
		m_bEscPressed = FALSE;
		if (m_bSoundFlag) m_pESound[38]->bStop();
		if ((m_bSoundFlag) && (m_bMusicStat == TRUE))
		{	StopBGM();	// Snoopy: mp3 support			
			if (m_pBGM != NULL) m_pBGM->bStop();
		}
		if (strlen(G_cCmdLineTokenA) != 0)
			 ChangeGameMode(DEF_GAMEMODE_ONQUIT);
		else ChangeGameMode(DEF_GAMEMODE_ONMAINMENU);
	}
}

void CGame::NotifyMsg_GiveItemFin_CountChanged(char *pData)
{
 char * cp, cName[21], cTxt[256];
 WORD * wp, wItemIndex;
 int  * ip, iAmount;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	wItemIndex = *wp;
	cp += 2;

	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[wItemIndex]->m_cName, m_pItemList[wItemIndex]->m_dwAttribute, cStr1, cStr2, cStr3);
	if( iAmount == 1 ) wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_COUNTCHANGED1, cStr1, cName);
	wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_COUNTCHANGED2, iAmount, cStr1, cName);
	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_GiveItemFin_EraseItem(char *pData)
{
 char * cp;
 WORD * wp;
 int  * ip, iAmount;
 short  sItemIndex;
 char cName[21], cTxt[250];


	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	wp = (WORD *)cp;
	sItemIndex = *wp;
	cp += 2;

	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[sItemIndex]->m_cName, m_pItemList[sItemIndex]->m_dwAttribute, cStr1, cStr2, cStr3);

	if (m_bIsItemEquipped[sItemIndex] == TRUE) {
		wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
		AddEventList(cTxt, 10);

		// v1.42
		m_sItemEquipmentStatus[	m_pItemList[sItemIndex]->m_cEquipPos ] = -1;
		m_bIsItemEquipped[sItemIndex] = FALSE;
	}
	if (strlen(cName) == 0) wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM2, iAmount, cStr1);
	else {
		if (strcmp(cName, "Howard") == 0)
			 wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM3, iAmount, cStr1);
		else if (strcmp(cName, "William") == 0)
			 wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM4, iAmount, cStr1);
		else if (strcmp(cName, "Kennedy") == 0)
			wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM5, iAmount, cStr1);
		else if (strcmp(cName, "Tom") == 0)
			wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM7, iAmount, cStr1);
		else wsprintf(cTxt, NOTIFYMSG_GIVEITEMFIN_ERASEITEM8, iAmount, cStr1, cName);
	}
	AddEventList(cTxt, 10);
	EraseItem((char)sItemIndex);
	_bCheckBuildItemStatus();
}

void CGame::NotifyMsg_GlobalAttackMode(char *pData)
{
 char * cp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	switch (*cp) {
	case 0:
		AddEventList(NOTIFYMSG_GLOBAL_ATTACK_MODE1, 10);
		AddEventList(NOTIFYMSG_GLOBAL_ATTACK_MODE2, 10);
		break;

	case 1:
		AddEventList(NOTIFYMSG_GLOBAL_ATTACK_MODE3, 10);
		break;
	}
	cp++;
}


void CGame::NotifyMsg_HP(char * pData)
{
 DWORD * dwp;
 int iPrevHP;
 char cTxt[120];
 int iPrevMP;

	iPrevHP = m_iHP;
	dwp = (DWORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
	m_iHP = (int)*dwp;

	iPrevMP = m_iMP;
	dwp = (DWORD *)(pData + DEF_INDEX2_MSGTYPE + 6);
	m_iMP = (int)*dwp;

	if (m_iHP > iPrevHP)
	{	if ((m_iHP - iPrevHP) < 10) return;
		wsprintf(cTxt, NOTIFYMSG_HP_UP, m_iHP - iPrevHP);
		AddEventList(cTxt, 10);
		PlaySound('E', 21, 0);
	}else
	{	if ( (m_cLogOutCount > 0) && (m_bForceDisconn==FALSE) )
		{	m_cLogOutCount = -1;
			AddEventList(NOTIFYMSG_HP2, 10);//"Logout count cancels if HP decreases during the countdown."
		}
		m_dwDamagedTime = timeGetTime();
		if (m_iHP < 20) AddEventList(NOTIFYMSG_HP3, 10);
		if ((iPrevHP - m_iHP) < 10) return;
		wsprintf(cTxt, NOTIFYMSG_HP_DOWN, iPrevHP - m_iHP);
		AddEventList(cTxt, 10);
	}
}

void CGame::NotifyMsg_Hunger(char * pData)
{
 char * cp, cHLv;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cHLv = *cp;

	if ((cHLv <= 40) && (cHLv > 30)) AddEventList(NOTIFYMSG_HUNGER1, 10);//"
	if ((cHLv <= 25) && (cHLv > 20)) AddEventList(NOTIFYMSG_HUNGER2, 10);//"
	if ((cHLv <= 20) && (cHLv > 15)) AddEventList(NOTIFYMSG_HUNGER3, 10);//"
	if ((cHLv <= 15) && (cHLv > 10)) AddEventList(NOTIFYMSG_HUNGER4, 10);//"
	if ((cHLv <= 10) && (cHLv >= 0)) AddEventList(NOTIFYMSG_HUNGER5, 10);//"
}

void CGame::NotifyMsg_ItemColorChange(char *pData)
{
 short * sp, sItemIndex, sItemColor;
 char * cp;
 char cTxt[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sItemIndex = *sp;
	cp += 2;

	sp = (short *)cp;
	sItemColor = (short)*sp;
	cp += 2;

	if (m_pItemList[sItemIndex] != NULL) {
		char cStr1[64], cStr2[64], cStr3[64];
		GetItemName( m_pItemList[sItemIndex], cStr1, cStr2, cStr3 );
		if (sItemColor != -1) {
			m_pItemList[sItemIndex]->m_cItemColor = (char)sItemColor;
			wsprintf(cTxt, NOTIFYMSG_ITEMCOLOR_CHANGE1, cStr1);
			AddEventList(cTxt, 10);
		}
		else {
			wsprintf(cTxt, NOTIFYMSG_ITEMCOLOR_CHANGE2, cStr1);
			AddEventList(cTxt, 10);
		}
	}
}

void CGame::NotifyMsg_ItemDepleted_EraseItem(char * pData)
{
 char * cp;
 WORD * wp;
 short  sItemIndex;
 BOOL   bIsUseItemResult;
 char   cTxt[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	wp = (WORD *)cp;
	sItemIndex = *wp;
	cp += 2;

	bIsUseItemResult = (BOOL)*cp;
	cp += 2;

	ZeroMemory(cTxt, sizeof(cTxt));

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[sItemIndex], cStr1, cStr2, cStr3);

	if (m_bIsItemEquipped[sItemIndex] == TRUE) 
	{	wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
		AddEventList(cTxt, 10);
		m_sItemEquipmentStatus[	m_pItemList[sItemIndex]->m_cEquipPos ] = -1;
		m_bIsItemEquipped[sItemIndex] = FALSE;
	}

	ZeroMemory(cTxt, sizeof(cTxt));
	if (   (m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) 
		|| (m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) 
	{	wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM2, cStr1);
	}else 
	{	if (m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) 
		{	if (bIsUseItemResult == TRUE) 
			{	wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM3, cStr1);
			}
		}else if (m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) 
		{	if (bIsUseItemResult == TRUE) 
			{	wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM4, cStr1);
				if ( (m_sPlayerType >= 1) && (m_sPlayerType <= 3) )
					PlaySound('C', 19, 0);
				if ( (m_sPlayerType >= 4) && (m_sPlayerType <= 6) )
					PlaySound('C', 20, 0);
			}
		}else if (m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) 
		{	if (bIsUseItemResult == TRUE) 
			{	wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM3, cStr1);
			}
		}else 
		{	if (bIsUseItemResult == TRUE) 
			{	wsprintf(cTxt, NOTIFYMSG_ITEMDEPlETED_ERASEITEM6, cStr1);
				PlaySound('E', 10, 0);
	}	}	}
	AddEventList(cTxt, 10);

	if (bIsUseItemResult == TRUE) 	m_bItemUsingStatus = FALSE;
	EraseItem((char)sItemIndex);
	_bCheckBuildItemStatus();
}

void CGame::NotifyMsg_ItemLifeSpanEnd(char * pData)
{
 char * cp;
 short * sp, sEquipPos, sItemIndex;
 char cTxt[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	sp = (short *)cp;
	sEquipPos = *sp;
	cp += 2;
	sp = (short *)cp;
	sItemIndex = *sp;
	cp += 2;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName( m_pItemList[sItemIndex], cStr1, cStr2, cStr3 );
	wsprintf(cTxt, NOTIFYMSG_ITEMLIFE_SPANEND1, cStr1);
	AddEventList(cTxt, 10);
	m_sItemEquipmentStatus[	m_pItemList[sItemIndex]->m_cEquipPos ] = -1;
	m_bIsItemEquipped[sItemIndex] = FALSE;
	m_pItemList[sItemIndex]->m_wCurLifeSpan = 0;

	PlaySound('E', 10, 0);
}

void CGame::NotifyMsg_ItemObtained(char * pData)
{
 char * cp;
 short * sp;
 DWORD * dwp;
 int i, j;

 DWORD dwCount, dwAttribute;
 char  cName[21], cItemType, cEquipPos;
 BOOL  bIsEquipped;
 short sSprite, sSpriteFrame, sLevelLimit, sSpecialEV2;
 char  cTxt[120], cGenderLimit, cItemColor;
 WORD  * wp, wWeight, wCurLifeSpan;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cp++;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	dwp = (DWORD *)cp;
	dwCount = *dwp;
	cp += 4;

	cItemType = *cp;
	cp++;

	cEquipPos = *cp;
	cp++;

	bIsEquipped = (BOOL)*cp;
	cp++;

	sp = (short *)cp;
	sLevelLimit = *sp;
	cp += 2;

	cGenderLimit = *cp;
	cp++;

	wp = (WORD *)cp;
	wCurLifeSpan = *wp;
	cp += 2;

	wp = (WORD *)cp;
	wWeight = *wp;
	cp += 2;

	sp = (short *)cp;
	sSprite = *sp;
	cp += 2;

	sp = (short *)cp;
	sSpriteFrame = *sp;
	cp += 2;

	cItemColor = *cp;
	cp++;

	sSpecialEV2 = (short)*cp; // v1.41
	cp++;

	dwp = (DWORD *)cp;
	dwAttribute = *dwp;
	cp += 4;
	/*
	bIsCustomMade = (BOOL)*cp;
	cp++;
	*/

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(cName, dwAttribute, cStr1, cStr2, cStr3);

	ZeroMemory(cTxt, sizeof(cTxt));
	if( dwCount == 1 ) wsprintf(cTxt, NOTIFYMSG_ITEMOBTAINED2, cStr1);
	else wsprintf(cTxt, NOTIFYMSG_ITEMOBTAINED1, dwCount, cStr1);

	AddEventList(cTxt, 10);

	PlaySound('E', 20, 0);

	if ((cItemType == DEF_ITEMTYPE_CONSUME) || (cItemType == DEF_ITEMTYPE_ARROW))
	{	for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pItemList[i] != NULL) && (memcmp(m_pItemList[i]->m_cName, cName, 20) == 0))
		{	m_pItemList[i]->m_dwCount += dwCount;
			m_bIsItemDisabled[i] = FALSE;
			return;
	}	}

  	short nX, nY;
  	for (i = 0; i < DEF_MAXITEMS; i++)
  	{	if ( ( m_pItemList[i] != NULL) && (memcmp(m_pItemList[i]->m_cName, cName, 20) == 0)) 
		{	nX = m_pItemList[i]->m_sX;
			nY = m_pItemList[i]->m_sY;
			break;
		}else
		{	nX = 40;
			nY = 30;
	}	}
 

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] == NULL)
	{	m_pItemList[i] = new class CItem;
		memcpy(m_pItemList[i]->m_cName, cName, 20);
		m_pItemList[i]->m_dwCount = dwCount;
		//m_pItemList[i]->m_sX      =	40;
		//m_pItemList[i]->m_sY      =	30;
		m_pItemList[i]->m_sX      =	nX;
		m_pItemList[i]->m_sY      =	nY;
		bSendCommand(MSGID_REQUEST_SETITEMPOS, NULL, i, nX, nY, NULL, NULL);
		m_pItemList[i]->m_cItemType = cItemType;
		m_pItemList[i]->m_cEquipPos = cEquipPos;
		m_bIsItemDisabled[i]        = FALSE;

		m_bIsItemEquipped[i] = FALSE;
		m_pItemList[i]->m_sLevelLimit  = sLevelLimit;
		m_pItemList[i]->m_cGenderLimit = cGenderLimit;
		m_pItemList[i]->m_wCurLifeSpan = wCurLifeSpan;
		m_pItemList[i]->m_wWeight      = wWeight;
		m_pItemList[i]->m_sSprite      = sSprite;
		m_pItemList[i]->m_sSpriteFrame = sSpriteFrame;
		m_pItemList[i]->m_cItemColor   = cItemColor;
		m_pItemList[i]->m_sItemSpecEffectValue2 = sSpecialEV2; // v1.41
		m_pItemList[i]->m_dwAttribute = dwAttribute;
		//m_pItemList[i]->m_bIsCustomMade = bIsCustomMade;

		_bCheckBuildItemStatus();

		for (j = 0; j < DEF_MAXITEMS; j++)
		if (m_cItemOrder[j] == -1) {
			m_cItemOrder[j] = i;
			return;
		}
		return;
	}
}

void CGame::NotifyMsg_ItemPurchased(char * pData)
{
 char  * cp;
 short * sp;
 DWORD * dwp;
 WORD  * wp;
 int i, j;

 DWORD dwCount;
 char  cName[21], cItemType, cEquipPos, cGenderLimit;
 BOOL  bIsEquipped;
 short sSprite, sSpriteFrame, sLevelLimit;
 WORD  wCost, wWeight, wCurLifeSpan;
 char  cTxt[120], cItemColor;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cp++;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	dwp = (DWORD *)cp;
	dwCount = *dwp;
	cp += 4;

	cItemType = *cp;
	cp++;

	cEquipPos = *cp;
	cp++;

	bIsEquipped = (BOOL)*cp;
	cp++;

	sp = (short *)cp;
	sLevelLimit = *sp;
	cp += 2;

	cGenderLimit = *cp;
	cp++;

 	wp = (WORD *)cp;
	wCurLifeSpan = *wp;
	cp += 2;

	wp = (WORD *)cp;
	wWeight = *wp;
	cp += 2;

	sp = (short *)cp;
	sSprite = *sp;
	cp += 2;

	sp = (short *)cp;
	sSpriteFrame = *sp;
	cp += 2;

	cItemColor = *cp; // v1.4
	cp++;

	wp = (WORD *)cp;
	wCost = *wp;
	ZeroMemory(cTxt, sizeof(cTxt));
	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName( cName, NULL, cStr1, cStr2, cStr3 );
	wsprintf(cTxt, NOTIFYMSG_ITEMPURCHASED, cStr1, wCost);
	AddEventList(cTxt, 10);

	if ( (cItemType == DEF_ITEMTYPE_CONSUME) || (cItemType == DEF_ITEMTYPE_ARROW))
	{	for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pItemList[i] != NULL) && (memcmp(m_pItemList[i]->m_cName, cName, 20) == 0))
		{	m_pItemList[i]->m_dwCount += dwCount;
			return;
	}	}

 short nX, nY;
 for (i = 0; i < DEF_MAXITEMS; i++)
  {	  if ( ( m_pItemList[i] != NULL) && (memcmp(m_pItemList[i]->m_cName, cName, 20) == 0))
	  {	  nX = m_pItemList[i]->m_sX;
		  nY = m_pItemList[i]->m_sY;
		  break;
	  }else
	  {  nX = 40;
		  nY = 30;
  }  }

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pItemList[i] == NULL)
	{	m_pItemList[i] = new class CItem;
		memcpy(m_pItemList[i]->m_cName, cName, 20);
		m_pItemList[i]->m_dwCount      = dwCount;
		//m_pItemList[i]->m_sX           = 40;
		//m_pItemList[i]->m_sY           = 30;
		m_pItemList[i]->m_sX           = nX;
		m_pItemList[i]->m_sY           = nY;
		bSendCommand(MSGID_REQUEST_SETITEMPOS, NULL, i, nX, nY, NULL, NULL);
		m_pItemList[i]->m_cItemType    = cItemType;
		m_pItemList[i]->m_cEquipPos    = cEquipPos;
		m_bIsItemDisabled[i]           = FALSE;
		m_bIsItemEquipped[i]           = FALSE;
		m_pItemList[i]->m_sLevelLimit  = sLevelLimit;
		m_pItemList[i]->m_cGenderLimit = cGenderLimit;
		m_pItemList[i]->m_wCurLifeSpan = wCurLifeSpan;
		m_pItemList[i]->m_wWeight      = wWeight;
		m_pItemList[i]->m_sSprite      = sSprite;
		m_pItemList[i]->m_sSpriteFrame = sSpriteFrame;
		m_pItemList[i]->m_cItemColor   = cItemColor;    // v1.4

		// fixed v1.11
		for (j = 0; j < DEF_MAXITEMS; j++)
		if (m_cItemOrder[j] == -1) {
			m_cItemOrder[j] = i;
			return;
		}

		return;
	}
}

void CGame::NotifyMsg_ItemReleased(char * pData)
{
 char * cp;
 short * sp, sEquipPos, sItemIndex;
 char cTxt[120];

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	sp = (short *)cp;
	sEquipPos = *sp;
	cp += 2;
	sp = (short *)cp;
	sItemIndex = *sp;
	cp += 2;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[sItemIndex], cStr1, cStr2, cStr3);
	wsprintf(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
	AddEventList(cTxt, 10);

/*	if (m_pItemList[sItemIndex]->m_cEquipPos != sEquipPos)
	{	wsprintf(G_cTxt,"NotifyMsg_ItemReleased, sEquipPos sItemIndex mismatch: %s", cStr1);
		DebugLog(G_cTxt);
	}*/


	m_bIsItemEquipped[sItemIndex] = FALSE;
	m_sItemEquipmentStatus[	m_pItemList[sItemIndex]->m_cEquipPos ] = -1;


	if(memcmp(m_pItemList[sItemIndex]->m_cName, "AngelicPendant", 14) == 0) PlaySound('E', 53, 0);
	else PlaySound('E', 29, 0);
}

void CGame::NotifyMsg_ItemRepaired(char * pData)
{
 char * cp, cTxt[120];
 DWORD * dwp, dwItemID, dwLife;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

	dwp = (DWORD *)cp;
	dwItemID = *dwp;
	cp += 4;

	dwp = (DWORD *)cp;
	dwLife = *dwp;
	cp += 4;

	m_pItemList[dwItemID]->m_wCurLifeSpan = (WORD)dwLife;
	m_bIsItemDisabled[dwItemID] = FALSE;
	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName( m_pItemList[dwItemID], cStr1, cStr2, cStr3 );

	wsprintf(cTxt, NOTIFYMSG_ITEMREPAIRED1, cStr1);

	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_ItemToBank(char *pData)
{
 char * cp, cIndex;
 DWORD * dwp, dwCount, dwAttribute;
 char  cName[21], cItemType, cEquipPos, cGenderLimit, cItemColor;
 BOOL  bIsEquipped;
 short * sp, sSprite, sSpriteFrame, sLevelLimit, sItemEffectValue2, sItemSpecEffectValue2;
 WORD  * wp, wWeight, wCurLifeSpan;
 char  cTxt[120];

	cp = (pData + DEF_INDEX2_MSGTYPE + 2);

	cIndex = *cp;
	cp++;

	cp++;

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	dwp = (DWORD *)cp;
	dwCount = *dwp;
	cp += 4;

	cItemType = *cp;
	cp++;

	cEquipPos = *cp;
	cp++;

	bIsEquipped = (BOOL)*cp;
	cp++;

	sp = (short *)cp;
	sLevelLimit = *sp;
	cp += 2;

	cGenderLimit = *cp;
	cp++;

	wp = (WORD *)cp;
	wCurLifeSpan = *wp;
	cp += 2;

	wp = (WORD *)cp;
	wWeight = *wp;
	cp += 2;

	sp = (short *)cp;
	sSprite = *sp;
	cp += 2;

	sp = (short *)cp;
	sSpriteFrame = *sp;
	cp += 2;

	cItemColor = *cp;
	cp++;

	// v1.432
	sp = (short *)cp;
	sItemEffectValue2 = *sp;
	cp += 2;

	dwp = (DWORD *)cp;
	dwAttribute = *dwp;
	cp += 4;
	sItemSpecEffectValue2 = (short) *cp ;
	cp ++ ;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(cName, dwAttribute, cStr1, cStr2, cStr3);


	if (m_pBankList[cIndex] == NULL)
	{	m_pBankList[cIndex] = new class CItem;

		memcpy(m_pBankList[cIndex]->m_cName, cName, 20);
		m_pBankList[cIndex]->m_dwCount = dwCount;

		m_pBankList[cIndex]->m_cItemType = cItemType;
		m_pBankList[cIndex]->m_cEquipPos = cEquipPos;

		m_pBankList[cIndex]->m_sLevelLimit  = sLevelLimit;
		m_pBankList[cIndex]->m_cGenderLimit = cGenderLimit;
		m_pBankList[cIndex]->m_wCurLifeSpan = wCurLifeSpan;
		m_pBankList[cIndex]->m_wWeight      = wWeight;
		m_pBankList[cIndex]->m_sSprite      = sSprite;
		m_pBankList[cIndex]->m_sSpriteFrame = sSpriteFrame;
		m_pBankList[cIndex]->m_cItemColor   = cItemColor;
		m_pBankList[cIndex]->m_sItemEffectValue2  = sItemEffectValue2;
		m_pBankList[cIndex]->m_dwAttribute        = dwAttribute;
		m_pBankList[cIndex]->m_sItemSpecEffectValue2 = sItemSpecEffectValue2 ;

		ZeroMemory(cTxt, sizeof(cTxt));
		if( dwCount == 1 ) wsprintf(cTxt, NOTIFYMSG_ITEMTOBANK3, cStr1);
		else wsprintf(cTxt, NOTIFYMSG_ITEMTOBANK2, dwCount, cStr1);

		if( m_bIsDialogEnabled[14] == TRUE ) m_stDialogBoxInfo[14].sView = DEF_MAXBANKITEMS-12;
		AddEventList(cTxt, 10);
	}
}


void CGame::NotifyMsg_Killed(char * pData)
{ char * cp, cAttackerName[21];
	m_bCommandAvailable = FALSE;
	m_cCommand = DEF_OBJECTSTOP;
	m_iHP = 0;
	m_cCommand = -1;
	// Restart
	m_bItemUsingStatus = FALSE;
	ClearSkillUsingStatus();
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	memcpy(cAttackerName, cp, 20);
	cp += 20;
/*	if (strlen(cAttackerName) == 0) // removed in v2.20 (bug?) Many servers send the info themselves.
		AddEventList(NOTIFYMSG_KILLED1, 10);//"you have died!"
	else
	{	wsprintf(G_cTxt, NOTIFYMSG_KILLED2, cAttackerName);//"You were killed by %s's attack!"
		AddEventList(G_cTxt, 10);
	}*/
	// Snoopy: reduced 3 lines -> 2 lines
	AddEventList(NOTIFYMSG_KILLED1, 10);//"You have died!  Click the restart button in system menu "
	AddEventList(NOTIFYMSG_KILLED3, 10);//"to start again, or click the Log Out button to exit."
	//AddEventList(NOTIFYMSG_KILLED4, 10);//"Log Out
}

// This msg is sent by server when lvl-up
void CGame::NotifyMsg_LevelUp(char * pData)
{char * cp;
 int  * ip;
 int i, iPrevLevel;
 char cTxt[120];

	iPrevLevel = m_iLevel;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);

	ip  = (int *)cp;
	m_iLevel = *ip;
	cp += 4;

	ip   = (int *)cp;
	m_iStr = *ip;
	cp  += 4;

	ip   = (int *)cp;
	m_iVit = *ip;
	cp  += 4;

	ip   = (int *)cp;
	m_iDex = *ip;
	cp  += 4;

	ip   = (int *)cp;
	m_iInt = *ip;
	cp  += 4;

	ip   = (int *)cp;
	m_iMag = *ip;
	cp  += 4;

	ip   = (int *)cp;
	m_iCharisma = *ip;
	cp  += 4;

	// CLEROTH - LU
	m_iLU_Point = m_iLevel*3 - ((m_iStr + m_iVit + m_iDex + m_iInt + m_iMag + m_iCharisma) - 70) - 3;
	m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;

	wsprintf(cTxt, NOTIFYMSG_LEVELUP1, m_iLevel);// "Level up!!! Level %d!"
	AddEventList(cTxt, 10);

	switch (m_sPlayerType) {
	case 1:
	case 2:
	case 3:
		PlaySound('C', 21, 0);
		break;

	case 4:
	case 5:
	case 6:
		PlaySound('C', 22, 0);
		break;
	}

	_RemoveChatMsgListByObjectID(m_sPlayerObjectID);

	for (i = 1; i < DEF_MAXCHATMSGS; i++)
	if (m_pChatMsgList[i] == NULL) {
		ZeroMemory(cTxt, sizeof(cTxt));
		strcpy(cTxt, "Level up!");
		m_pChatMsgList[i] = new class CMsg(23, cTxt, m_dwCurTime);
		m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;

		if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == FALSE) {
			delete m_pChatMsgList[i];
			m_pChatMsgList[i] = NULL;
		}
		return;
	}
}

// CLEROTH - LU
void CGame::NotifyMsg_SettingSuccess(char * pData)
{char * cp;
 int  * ip;
 int iPrevLevel;
 char cTxt[120];
	iPrevLevel = m_iLevel;
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	ip  = (int *)cp;
	m_iLevel = *ip;
	cp += 4;
	ip   = (int *)cp;
	m_iStr = *ip;
	cp  += 4;
	ip   = (int *)cp;
	m_iVit = *ip;
	cp  += 4;
	ip   = (int *)cp;
	m_iDex = *ip;
	cp  += 4;
	ip   = (int *)cp;
	m_iInt = *ip;
	cp  += 4;
	ip   = (int *)cp;
	m_iMag = *ip;
	cp  += 4;
	ip   = (int *)cp;
	m_iCharisma = *ip;
	cp  += 4;
	wsprintf(cTxt, "Your stat has been changed.");
	AddEventList(cTxt, 10);
	// CLEROTH - LU
	m_iLU_Point = m_iLevel*3 - ((m_iStr + m_iVit + m_iDex + m_iInt + m_iMag + m_iCharisma) - 70) - 3;
	m_cLU_Str = m_cLU_Vit = m_cLU_Dex = m_cLU_Int = m_cLU_Mag = m_cLU_Char = 0;
}

void CGame::NotifyMsg_MagicEffectOff(char * pData)
{char * cp;
 WORD * wp;
 short  sMagicType, sMagicEffect;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	sMagicType = (short)*wp;
	cp += 2;
	wp = (WORD *)cp;
	sMagicEffect = (short)*wp;
	cp += 2;
	switch (sMagicType) {
	case DEF_MAGICTYPE_PROTECT:
		switch (sMagicEffect) {
		case 1: // "Protection from arrows has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF1, 10);
			break;
		case 2:	// "Protection from magic has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF2, 10);
			break;
		case 3:	// "Defense shield effect has vanished."
		case 4:	// "Defense shield effect has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF3, 10);
			break;
		case 5:	// "Absolute Magic Protection has been vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF14, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_HOLDOBJECT:
		switch (sMagicEffect) {
		case 1:	// "Hold person magic effect has vanished."
			m_bParalyze = FALSE;
			m_bFullParalyze = FALSE;
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF4, 10);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT // All para
		case 20:	// "Medusa kiss effect has vanished."
			m_bParalyze = FALSE;
			m_bFullParalyze = FALSE;
			AddEventList("Medusa kiss effect has vanished.", 10);
			break;

		default: //  other para level here Add by Snoopy
#endif

		case 2:	// "Paralysis magic effect has vanished."
			m_bParalyze = FALSE;
			m_bFullParalyze = FALSE;
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF5, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_INVISIBILITY:
		switch (sMagicEffect) {
		case 1:	// "Invisibility magic effect has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF6, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_CONFUSE:
		switch (sMagicEffect) {
		case 1:	// "Language confuse magic effect has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF7, 10);
			break;
		case 2:	// "Confusion magic has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF8, 10);
			m_bIsConfusion = FALSE;
			break;
		case 3:	// "Illusion magic has vanished."
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF9, 10);
			m_iIlusionOwnerH = NULL;
			break;
		case 4:	// "At last, you gather your senses." // snoopy
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF15, 10);
			m_bIllusionMVT = FALSE;
			break;
		}
		break;

	case DEF_MAGICTYPE_POISON:
		if (m_bIsPoisoned) AddEventList(NOTIFYMSG_MAGICEFFECT_OFF10, 10);
		m_bIsPoisoned = FALSE;
		break;

	case DEF_MAGICTYPE_BERSERK:
		switch (sMagicEffect) {
		case 1:
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF11, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_POLYMORPH:
		switch (sMagicEffect) {
		case 1:
			AddEventList(NOTIFYMSG_MAGICEFFECT_OFF12, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_ICE:
		AddEventList(NOTIFYMSG_MAGICEFFECT_OFF13, 10);
		break;
	}
}

void CGame::NotifyMsg_MagicEffectOn(char * pData)
{char * cp;
 DWORD * dwp;
 WORD * wp;
 short  sMagicType, sMagicEffect, sOwnerH;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	sMagicType = (short)*wp;
	cp += 2;
	dwp = (DWORD *)cp;
	sMagicEffect = (short)*dwp;
	cp += 4;
	dwp = (DWORD *)cp;
	sOwnerH = (short)*dwp;
	cp += 4;
	switch (sMagicType) {
	case DEF_MAGICTYPE_PROTECT:
		switch (sMagicEffect) {
		case 1: // "You are completely protected from arrows!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON1, 10);
			break;
		case 2: // "You are protected from magic!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON2, 10);
			break;
		case 3: // "Defense ratio increased by a magic shield!"
		case 4: // "Defense ratio increased by a magic shield!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON3, 10);
			break;
		case 5: // "You are completely protected from magic!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON14, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_HOLDOBJECT:
		switch (sMagicEffect) {
		case 1: // "You were bounded by a Hold Person spell! Unable to move!"
			m_bParalyze = TRUE;
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON4, 10);
			break;

#ifdef DEF_EQUILIBRIUM_PROJECT // All para
		case 20: // "You were kissed by a medusa spell! Unable to move a mere finger!"
			m_bParalyze = TRUE;
			m_bFullParalyze = TRUE;
			AddEventList("You were kissed by a medusa spell! Unable to move a mere finger!", 10);
			break;

		case 5: // "You were bounded by the power of the Medusa! Unable to move!"
			m_bParalyze = TRUE;
			AddEventList("You were bounded by the power of the Medusa", 10);
			break;

		default: // Add by Snoopy
#endif
		case 2: // "You were bounded by a Paralysis spell! Unable to move!"
			m_bParalyze = TRUE;
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON5, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_INVISIBILITY:
		switch (sMagicEffect) {
		case 1: // "You are now invisible, no one can see you!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON6, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_CONFUSE:
		switch (sMagicEffect) {
		case 1:	// Confuse Language "No one understands you because of language confusion magic!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON7, 10);
			break;

		case 2: // Confusion "Confusion magic casted, impossible to determine player allegience."
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON8, 10);
			m_bIsConfusion = TRUE;
			break;

		case 3:	// Illusion "Illusion magic casted, impossible to tell who is who!"
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON9, 10);
			_SetIlusionEffect(sOwnerH);
			break;

		case 4:	// IllusionMouvement "You are thrown into confusion, and you are flustered yourself." // snoopy
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON15, 10);
			m_bIllusionMVT = TRUE;
			break;
		}
		break;

	case DEF_MAGICTYPE_POISON:
		AddEventList(NOTIFYMSG_MAGICEFFECT_ON10, 10);
		m_bIsPoisoned = TRUE;
		break;

	case DEF_MAGICTYPE_BERSERK:
		switch (sMagicEffect) {
		case 1:
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON11, 10);
			break;
		}
		break;

	case DEF_MAGICTYPE_POLYMORPH:
		switch (sMagicEffect) {
		case 1:

#ifdef DEF_EQUILIBRIUM_PROJECT // Polymorph texts
			if (m_sPlayerType <= 3)
				AddEventList("Polymorph magic effect, you're now a male!", 10);
			else
				AddEventList("Polymorph magic effect, you became a woman!", 10);
#else
			AddEventList(NOTIFYMSG_MAGICEFFECT_ON12, 10);
#endif

			break;
		}
		break;

	case DEF_MAGICTYPE_ICE:
		AddEventList(NOTIFYMSG_MAGICEFFECT_ON13, 10);
		break;
	}
}

void CGame::NotifyMsg_MagicStudyFail(char * pData)
{
 char * cp, cMagicNum, cName[31], cFailCode;
 char cTxt[120];
 int  * ip, iCost, iReqInt, iReqStr;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cFailCode = *cp;
	cp++;
	cMagicNum = *cp;
	cp++;
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 30);
	cp += 30;
	ip = (int *)cp;
	iCost = *ip;
	cp += 4;
	ip = (int *)cp;
	iReqInt = *ip;
	cp += 4;
/*	// Snoopy: remove special CLEROTH's feature
	ip = (int *)cp;
	iReqStr = *ip;
	cp += 4;
	// CLEROTH
	wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_FAIL4, cName, iCost, iReqInt, iReqStr);
	AddEventList(cTxt, 10);*/

	if (iCost > 0)
	{	wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_FAIL1, cName);
		AddEventList(cTxt, 10);
	}else
	{	wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_FAIL2,  cName);
		AddEventList(cTxt, 10);
		wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_FAIL3, iReqInt);
		AddEventList(cTxt, 10);
	}
}

void CGame::NotifyMsg_MagicStudySuccess(char * pData)
{char * cp, cMagicNum, cName[31];
 char cTxt[120];
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cMagicNum = *cp;
	cp++;
	m_cMagicMastery[cMagicNum] = 1;
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 30);
	wsprintf(cTxt, NOTIFYMSG_MAGICSTUDY_SUCCESS1, cName);
	AddEventList(cTxt, 10);
	PlaySound('E', 23, 0);
}

void CGame::NotifyMsg_MP(char * pData)
{DWORD * dwp;
 int iPrevMP;
 char cTxt[120];
	iPrevMP = m_iMP;
	dwp = (DWORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
	m_iMP = (int)*dwp;
	if (abs(m_iMP - iPrevMP) < 10) return;
	if (m_iMP > iPrevMP)
	{	wsprintf(cTxt, NOTIFYMSG_MP_UP, m_iMP - iPrevMP);//"MP°
		AddEventList(cTxt, 10);
		PlaySound('E', 21, 0);
	}else
	{	wsprintf(cTxt, NOTIFYMSG_MP_DOWN, iPrevMP - m_iMP);//"MP°
		AddEventList(cTxt, 10);
	}
}

void CGame::NotifyMsg_NewGuildsMan(char * pData)
{char * cp, cName[12], cTxt[120];
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	wsprintf(cTxt, NOTIFYMSG_NEW_GUILDMAN1, cName);
	AddEventList(cTxt, 10);
	ClearGuildNameList();
}

void CGame::NotifyMsg_PKcaptured(char *pData)
{char  * cp;
 DWORD * dwp;
 WORD  * wp;
 int     iPKcount, iLevel, iExp, iRewardGold;
 char cTxt[120], cName[12];
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	iPKcount = *wp;
	cp += 2;
	wp = (WORD *)cp;
	iLevel = *wp;
	cp += 2;
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;
	dwp = (DWORD *)cp;
	iRewardGold = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
	iExp = *dwp;
	cp += 4;
	wsprintf(cTxt, NOTIFYMSG_PK_CAPTURED1, iLevel, cName, iPKcount);
	AddEventList(cTxt, 10);
	wsprintf(cTxt, EXP_INCREASED, iExp - m_iExp);
	AddEventList(cTxt, 10);
	wsprintf(cTxt, NOTIFYMSG_PK_CAPTURED3, iExp - m_iExp);
	AddEventList(cTxt, 10);
}

void CGame::NotifyMsg_PKpenalty(char *pData)
{char  * cp;
 DWORD * dwp;
 int     iPKcount, iExp, iStr, iVit, iDex, iInt, iMag, iChr;
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	dwp = (DWORD *)cp;
	iExp = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
	iStr = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
	iVit = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
	iDex = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
	iInt = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
	iMag = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
	iChr = *dwp;
	cp += 4;
	dwp = (DWORD *)cp;
	iPKcount = *dwp;
	cp += 4;
	wsprintf(G_cTxt, NOTIFYMSG_PK_PENALTY1, iPKcount);
	AddEventList(G_cTxt, 10);
	if (m_iExp > iExp)
	{	wsprintf(G_cTxt, NOTIFYMSG_PK_PENALTY2, m_iExp - iExp);
		AddEventList(G_cTxt, 10);
	}
	m_iExp = iExp;
	m_iStr = iStr;
	m_iVit = iVit;
	m_iDex = iDex;
	m_iInt = iInt;
	m_iMag = iMag;
	m_iCharisma = iChr;
	m_iPKCount = iPKcount;
}

void CGame::NotifyMsg_PlayerShutUp(char * pData)
{char * cp, cName[12];
 WORD * wp, wTime;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	wTime = *wp;
	cp += 2;
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;
	if (memcmp(m_cPlayerName, cName, 10) == 0)
		 wsprintf(G_cTxt, NOTIFYMSG_PLAYER_SHUTUP1, wTime);
	else wsprintf(G_cTxt, NOTIFYMSG_PLAYER_SHUTUP2, cName, wTime);

	AddEventList(G_cTxt, 10);
}

void CGame::NotifyMsg_PlayerStatus(BOOL bOnGame, char * pData)
{char cName[12], cMapName[12], * cp;
 WORD * wp ;
 WORD  dx= 1 ,dy = 1;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;
	ZeroMemory(cMapName, sizeof(cMapName));
	memcpy(cMapName, cp, 10);
	cp += 10;
	wp = (WORD * ) cp ;
	dx = (WORD ) *wp ;
	cp += 2 ;
	wp = (WORD * ) cp ;
	dy = (WORD ) *wp ;
	cp += 2 ;
	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	if (bOnGame == TRUE) {
		if (strlen(cMapName) == 0)
			 wsprintf(G_cTxt, NOTIFYMSG_PLAYER_STATUS1, cName);
		else wsprintf(G_cTxt, NOTIFYMSG_PLAYER_STATUS2, cName, cMapName, dx, dy);
	}
	else wsprintf(G_cTxt, NOTIFYMSG_PLAYER_STATUS3, cName);
	AddEventList(G_cTxt, 10);
}


void CGame::NotifyMsg_QuestReward(char *pData)
{short * sp, sWho, sFlag;
 char  * cp, cRewardName[21], cTxt[120];
 int   * ip, iAmount, iIndex, iPreCon;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	sp = (short *)cp;
	sWho = *sp;
	cp += 2;
	sp = (short *)cp;
	sFlag = *sp;
	cp += 2;
	ip = (int *)cp;
	iAmount = *ip;
	cp += 4;
	ZeroMemory(cRewardName, sizeof(cRewardName));
	memcpy(cRewardName, cp, 20);
	cp += 20;
	iPreCon = m_iContribution;
	ip = (int *)cp;
	m_iContribution = *ip;
	m_iContributionPrice = 0;
	cp += 4;

	if (sFlag == 1)
	{	m_stQuest.sWho          = NULL;
		m_stQuest.sQuestType    = NULL;
		m_stQuest.sContribution = NULL;
		m_stQuest.sTargetType   = NULL;
		m_stQuest.sTargetCount  = NULL;
		m_stQuest.sX     = NULL;
		m_stQuest.sY     = NULL;
		m_stQuest.sRange = NULL;
		m_stQuest.sCurrentCount = NULL;
		m_stQuest.bIsQuestCompleted = FALSE;
		ZeroMemory(m_stQuest.cTargetName, sizeof(m_stQuest.cTargetName));
		EnableDialogBox(21, 0, sWho+110, 0);
		iIndex = m_stDialogBoxInfo[21].sV1;
		m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
		iIndex++;
		ZeroMemory(cTxt, sizeof(cTxt));
		if (memcmp(cRewardName, "°æÇèÄ¡", 6) == 0)
		{	if (iAmount > 0) wsprintf(cTxt, NOTIFYMSG_QUEST_REWARD1, iAmount);
		}else
		{	wsprintf(cTxt, NOTIFYMSG_QUEST_REWARD2, iAmount, cRewardName);
		}
		m_pMsgTextList2[iIndex] = new class CMsg(NULL, cTxt, NULL);
		iIndex++;
		m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
		iIndex++;
		ZeroMemory(cTxt, sizeof(cTxt));
		if (iPreCon < m_iContribution)
			 wsprintf(cTxt, NOTIFYMSG_QUEST_REWARD3, m_iContribution - iPreCon);
		else wsprintf(cTxt, NOTIFYMSG_QUEST_REWARD4, iPreCon - m_iContribution);

		m_pMsgTextList2[iIndex] = new class CMsg(NULL, "  ", NULL);
		iIndex++;
	}
	else EnableDialogBox(21, 0, sWho+120, 0);
}

void CGame::NotifyMsg_RatingPlayer(char * pData)
{//int * ip;
 char * cp, cName[12];
 WORD  cValue;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cValue = *cp;
	cp++;
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;
//	ip = (int *)cp;
//	m_iRating = *ip;
	cp += 4;
	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	if (memcmp(m_cPlayerName, cName, 10) == 0)
	{	if (cValue == 1)
		{	 strcpy(G_cTxt, NOTIFYMSG_RATING_PLAYER1);
			 PlaySound('E', 23, 0);
 		}
	}else
	{	if (cValue == 1)
			 wsprintf(G_cTxt, NOTIFYMSG_RATING_PLAYER2, cName);
		else wsprintf(G_cTxt, NOTIFYMSG_RATING_PLAYER3, cName);
	}
	AddEventList(G_cTxt, 10);
}


void CGame::NotifyMsg_ServerChange(char * pData)
{
 char * cp, cWorldServerAddr[16];	//Snoopy: change names for better readability
 int * ip, iWorldServerPort;		//Snoopy: change names for better readability

	ZeroMemory(m_cMapName, sizeof(m_cMapName));
	ZeroMemory(m_cMapMessage, sizeof(m_cMapMessage));
	ZeroMemory(cWorldServerAddr, sizeof(cWorldServerAddr));

	// v1.43
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
    memcpy(m_cMapName, cp, 10);

//	m_cMapIndex = GetOfficialMapName(m_cMapName, m_cMapMessage);
	cp += 10;

	memcpy(cWorldServerAddr, cp, 15);
	cp += 15;
	ip = (int *)cp;
	iWorldServerPort = *ip;
	cp += 4;
	if (m_pGSock != NULL)
	{	delete m_pGSock;
		m_pGSock = NULL;
	}
	if (m_pLSock != NULL)
	{	delete m_pLSock;
		m_pLSock = NULL;
	}
	m_pLSock = new class XSocket(m_hWnd, DEF_SOCKETBLOCKLIMIT);
	if (m_iGameServerMode == 1) // LAN
	{	m_pLSock->bConnect(m_cLogServerAddr, iWorldServerPort, WM_USER_LOGSOCKETEVENT);
	}else
	{	m_pLSock->bConnect(cWorldServerAddr, iWorldServerPort, WM_USER_LOGSOCKETEVENT);
	}
	m_pLSock->bInitBufferSize(30000);

	m_bIsPoisoned = FALSE;

	ChangeGameMode(DEF_GAMEMODE_ONCONNECTING);
	m_dwConnectMode  = MSGID_REQUEST_ENTERGAME;
	//m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW; //Gateway
	m_wEnterGameType = DEF_ENTERGAMEMSGTYPE_NEW_TOWLSBUTMLS;
	ZeroMemory(m_cMsg, sizeof(m_cMsg));
	strcpy(m_cMsg,"55");
}

void CGame::NotifyMsg_SetItemCount(char * pData)
{char  * cp;
 WORD  * wp;
 DWORD * dwp;
 short  sItemIndex;
 DWORD  dwCount;
 BOOL   bIsItemUseResponse;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	sItemIndex = *wp;
	cp += 2;
	dwp = (DWORD *)cp;
	dwCount = *dwp;
	cp += 4;
	bIsItemUseResponse = (BOOL)*cp;
	cp++;
	if (m_pItemList[sItemIndex] != NULL)
	{	m_pItemList[sItemIndex]->m_dwCount = dwCount;
		if (bIsItemUseResponse == TRUE) m_bIsItemDisabled[sItemIndex] = FALSE;
	}
}

void CGame::NotifyMsg_ShowMap(char * pData)
{char * cp;
 WORD * wp, w1, w2;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	w1 = *wp;
	cp += 2;
	wp = (WORD *)cp;
	w2 = *wp;
	cp += 2;
	if (w2 == 0) AddEventList(NOTIFYMSG_SHOW_MAP1, 10);
	else EnableDialogBox(22, NULL, w1, w2 -1);
}

void CGame::NotifyMsg_Skill(char *pData)
{ WORD * wp;
 short sSkillIndex, sValue;
 char * cp;
 char cTxt[120];
 int i;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	sSkillIndex = (short)*wp;
	cp += 2;
	wp = (WORD *)cp;
	sValue = (short)*wp;
	cp += 2;
	_RemoveChatMsgListByObjectID(m_sPlayerObjectID);
	if (m_pSkillCfgList[sSkillIndex]->m_iLevel < sValue)
	{	wsprintf(cTxt, NOTIFYMSG_SKILL1, m_pSkillCfgList[sSkillIndex]->m_cName, sValue - m_pSkillCfgList[sSkillIndex]->m_iLevel);
		AddEventList(cTxt, 10);
		PlaySound('E', 23, 0);
		for (i = 1; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] == NULL)
		{	ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "%s +%d%%", m_pSkillCfgList[sSkillIndex]->m_cName, sValue - m_pSkillCfgList[sSkillIndex]->m_iLevel);
			m_pChatMsgList[i] = new class CMsg(20, cTxt, m_dwCurTime);
			m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;
			if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == FALSE)
			{	delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
			break;
		}
	}else if (m_pSkillCfgList[sSkillIndex]->m_iLevel > sValue) {
		wsprintf(cTxt, NOTIFYMSG_SKILL2, m_pSkillCfgList[sSkillIndex]->m_cName, m_pSkillCfgList[sSkillIndex]->m_iLevel - sValue);
		AddEventList(cTxt, 10);
		PlaySound('E', 24, 0);
		for (i = 1; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] == NULL)
		{	ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "%s -%d%%", m_pSkillCfgList[sSkillIndex]->m_cName, sValue - m_pSkillCfgList[sSkillIndex]->m_iLevel);
			m_pChatMsgList[i] = new class CMsg(20, cTxt, m_dwCurTime);
			m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;
			if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == FALSE)
			{	delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
			break;
	}	}
	m_pSkillCfgList[sSkillIndex]->m_iLevel = sValue;
	m_cSkillMastery[sSkillIndex] = (unsigned char)sValue;
}


void CGame::NotifyMsg_SkillTrainSuccess(char * pData)
{char * cp, cSkillNum, cSkillLevel;
 char cTemp[120];
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cSkillNum = *cp;
	cp++;
	cSkillLevel = *cp;
	cp++;
	ZeroMemory(cTemp, sizeof(cTemp));
	wsprintf(cTemp, NOTIFYMSG_SKILL_TRAIN_SUCCESS1, m_pSkillCfgList[cSkillNum]->m_cName, cSkillLevel);
	AddEventList(cTemp, 10);
	m_pSkillCfgList[cSkillNum]->m_iLevel = cSkillLevel;
	m_cSkillMastery[cSkillNum] = (unsigned char)cSkillLevel;
	PlaySound('E', 23, 0);
}

void CGame::NotifyMsg_SkillUsingEnd(char * pData)
{char * cp;
 WORD * wp, wResult;
	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	wResult = * wp;
	switch (wResult) {
	case NULL:
		AddEventList(NOTIFYMSG_SKILL_USINGEND1, 10);
		break;
	case 1:
		AddEventList(NOTIFYMSG_SKILL_USINGEND2, 10);
		break;
	}
	m_bSkillUsingStatus = FALSE;
}

void CGame::NotifyMsg_SP(char * pData)
{DWORD * dwp;
 int iPrevSP;
	iPrevSP = m_iSP;
	dwp = (DWORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
	m_iSP = (int)*dwp;
	if (abs(m_iSP - iPrevSP) < 10) return;
	if (m_iSP > iPrevSP)
	{	wsprintf(G_cTxt, NOTIFYMSG_SP_UP, m_iSP - iPrevSP);
		AddEventList(G_cTxt, 10);
		PlaySound('E', 21, 0);
	}else
	{	wsprintf(G_cTxt, NOTIFYMSG_SP_DOWN, iPrevSP - m_iSP);
		AddEventList(G_cTxt, 10);
	}
}

void CGame::NotifyMsg_TotalUsers(char * pData)
{	WORD *wp;
	int iTotal;
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
	iTotal = (int)*wp;
	wsprintf(G_cTxt, NOTIFYMSG_TOTAL_USER1, iTotal);
	AddEventList(G_cTxt, 10);
}

void CGame::NotifyMsg_WhisperMode(BOOL bActive, char * pData)
{
	char cName[12], *cp;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	if (bActive == TRUE)
	{
		wsprintf(G_cTxt, NOTIFYMSG_WHISPERMODE1, cName);
		if (m_pWhisperMsg[DEF_MAXWHISPERMSG - 1] != NULL) {
			delete m_pWhisperMsg[DEF_MAXWHISPERMSG - 1];
			m_pWhisperMsg[DEF_MAXWHISPERMSG - 1] = NULL;
		}
		for (int i = DEF_MAXWHISPERMSG - 2; i >= 0; i--) {
			m_pWhisperMsg[i+1] = m_pWhisperMsg[i];
			m_pWhisperMsg[i] = NULL;
		}
		m_pWhisperMsg[0] = new class CMsg(NULL, cName, NULL);
		m_cWhisperIndex = 0;
	}
	else wsprintf(G_cTxt, NOTIFYMSG_WHISPERMODE2, cName);

	AddEventList(G_cTxt, 10);
}

void CGame::DrawDialogBox_CrusadeJob(short msX, short msY)
{short sX, sY;

	sX = m_stDialogBoxInfo[33].sX;
	sY = m_stDialogBoxInfo[33].sY;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);

	switch (m_stDialogBoxInfo[33].cMode) {
	case 1:
		PutAlignedString(sX +24, sX +246, sY +45+20, DRAWDIALOGBOX_CRUSADEJOB1);
		PutAlignedString(sX +24, sX +246, sY +60+20, DRAWDIALOGBOX_CRUSADEJOB2);
		PutAlignedString(sX +24, sX +246, sY +75+20, DRAWDIALOGBOX_CRUSADEJOB3);
		PutAlignedString(sX +24, sX +246, sY +90+20, DRAWDIALOGBOX_CRUSADEJOB4);

		if( m_bCitizen == TRUE )
		{	if( m_bAresden )
			{	if (m_iGuildRank == 0)
				{	if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165))
						 PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB5, 255,255,255);//(Commander)"
 					else PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB5, 4,0,50);//(Commander)"
				}else
				{	if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165))
						 PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB7, 255,255,255);//(Soldier)"
 					else PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB7, 4,0,50);//(Soldier)"
					if (m_iGuildRank != -1)
					{	if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 175) && (msY < sY + 190))
							 PutAlignedString(sX +24, sX +246, sY+175, DRAWDIALOGBOX_CRUSADEJOB9, 255,255,255);//(Constructor)"
 						else PutAlignedString(sX +24, sX +246, sY+175, DRAWDIALOGBOX_CRUSADEJOB9, 4,0,50);//(Constructor)"

				}	}
			}else if( m_bAresden == FALSE )
			{	if (m_iGuildRank == 0)
				{	if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165))
						 PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB5, 255,255,255);//(Commander)"
 					else PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB5, 4,0,50);//(Commander)"
				}else
				{	if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 150) && (msY < sY + 165))
						 PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB7, 255,255,255);//(Soldier)"
 					else PutAlignedString(sX +24, sX +246, sY+150, DRAWDIALOGBOX_CRUSADEJOB7, 4,0,50);//(Soldier)"
					if (m_iGuildRank != -1)
					{	if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 175) && (msY < sY + 190))
							 PutAlignedString(sX +24, sX +246, sY+175, DRAWDIALOGBOX_CRUSADEJOB9, 255,255,255);//(Constructor)"
 						else PutAlignedString(sX +24, sX +246, sY+175, DRAWDIALOGBOX_CRUSADEJOB9, 4,0,50);//(Constructor)"
		}	}	}	}

		PutAlignedString(sX +24, sX +246, sY +290 -40,   DRAWDIALOGBOX_CRUSADEJOB10);
		PutAlignedString(sX +24, sX +246, sY +305 -40,   DRAWDIALOGBOX_CRUSADEJOB17);

		if ((msX > sX + 210) && (msX < sX + 260) && (msY >= sY + 296) && (msY <= sY + 316))
			 PutString_SprFont(sX +50+160, sY +296, "Help", 6,6,20);
		else PutString_SprFont(sX +50+160, sY +296, "Help", 0, 0, 7);
		break;

	case 2:
		PutAlignedString(sX +24, sX +246, sY +90+20, DRAWDIALOGBOX_CRUSADEJOB18);
		switch (m_iCrusadeDuty) {
		case 1: PutAlignedString(sX +24, sX +246, sY+125, DRAWDIALOGBOX_CRUSADEJOB19); break;//"(Soldier)
		case 2: PutAlignedString(sX +24, sX +246, sY+125, DRAWDIALOGBOX_CRUSADEJOB20); break;//"(Constructor)
		case 3: PutAlignedString(sX +24, sX +246, sY+125, DRAWDIALOGBOX_CRUSADEJOB21); break;//"(Commander)
		}

		PutAlignedString(sX +24, sX +246, sY +145, DRAWDIALOGBOX_CRUSADEJOB22);
		if ((msX > sX + 24) && (msX < sX + 246) && (msY > sY + 160) && (msY < sY + 175))
			 PutAlignedString(sX +24, sX +246, sY+160, DRAWDIALOGBOX_CRUSADEJOB23, 255,255,255);
 		else PutAlignedString(sX +24, sX +246, sY+160, DRAWDIALOGBOX_CRUSADEJOB23, 4,0,50);

		PutAlignedString(sX +24, sX +246, sY +175, DRAWDIALOGBOX_CRUSADEJOB25);
		PutAlignedString(sX +24, sX +246, sY +190, DRAWDIALOGBOX_CRUSADEJOB26);

		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;
	}
}

void CGame::_Draw_OnLogin(char *pAccount, char *pPassword, int msX, int msY, int iFrame)
{
 BOOL bFlag = TRUE;
 DWORD dwTime = timeGetTime();

    m_DDraw.ClearBackB4();

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 0,0,0, TRUE);
	DrawVersion();

	if ((iFrame >= 15) && (iFrame <= 20)) m_pSprite[DEF_SPRID_INTERFACE_ND_LOGIN]->PutTransSprite25(39,121, 2, TRUE);
	else if (iFrame > 20) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 39,121, 2, TRUE);

	if (m_cCurFocus != 1) {
		if (m_Misc.bCheckValidName(pAccount) != FALSE)
			 PutString2(180, 162, pAccount, 200,200,200);
		else PutString2(180, 162, pAccount, 200,100,100);
	}
	if ((m_Misc.bCheckValidName(pAccount) == FALSE) || (strlen(pAccount) == 0)) bFlag = FALSE;

	if (m_cCurFocus != 2) {
		if ((m_Misc.bCheckValidString(pPassword) != FALSE))
			 PutString(180, 185, pPassword, RGB(200,200,200), TRUE, 1);
		else PutString(180, 185, pPassword, RGB(200,100,100), TRUE, 1);
	}
	if ((m_Misc.bCheckValidString(pPassword) == FALSE) || (strlen(pPassword) == 0)) bFlag = FALSE;

	if (m_cCurFocus == 1)
		ShowReceivedString();
	else
	if (m_cCurFocus == 2)
		ShowReceivedString(TRUE);

	if (bFlag == TRUE)
	{	if (m_cCurFocus == 3) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 80,282, 3, TRUE);
	}
	if (m_cCurFocus == 4) DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_LOGIN, 256,282,4, TRUE);
	if ((m_bIsHideLocalCursor != TRUE) && (msX != 0) && (msY != 0)) {
	m_pSprite[DEF_SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	}
}

void CGame::ShowEventList(DWORD dwTime)
{ int i;

	m_DDraw._GetBackBufferDC();
	for (i = 0; i < 6; i++)
	if ((dwTime - m_stEventHistory[i].dwTime) < 5000)
	{	switch (m_stEventHistory[i].cColor) {
		case 0:
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(225,225,225), FALSE, 1, TRUE);
			break;
		case 1:
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(130,255,130), FALSE, 1, TRUE);
			break;
		case 2:
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(255,130,130), FALSE, 1, TRUE);
			break;
		case 3:
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(130,130,255), FALSE, 1, TRUE);
			break;
		case 4:
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(230, 230, 130), FALSE, 1, TRUE);
			break;
		case 10:
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(180,255,180), FALSE, 1, TRUE);
			break;
		case 20:
			PutString(10, 10 + i*15, m_stEventHistory[i].cTxt, RGB(150,150,170), FALSE, 1, TRUE);
			break;
		}
	}

	for (i = 0; i < 6; i++)
	if ((dwTime - m_stEventHistory2[i].dwTime) < 5000)
	{	switch (m_stEventHistory2[i].cColor) {
		case 0:
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(225,225,225), FALSE, 1, TRUE);
			break;
		case 1:
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(130,255,130), FALSE, 1, TRUE);
			break;
		case 2:
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(255,130,130), FALSE, 1, TRUE);
			break;
		case 3:
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(130,130,255), FALSE, 1, TRUE);
			break;
		case 4:
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(230, 230, 130), FALSE, 1, TRUE);
			break;
		case 10:
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(180,255,180), FALSE, 1, TRUE);
			break;
		case 20:
			PutString(10, 322 + i*15, m_stEventHistory2[i].cTxt, RGB(150,150,170), FALSE, 1, TRUE);
			break;
	}	}
	if (m_bSkillUsingStatus	== TRUE)
	{	PutString(280 -29, 280 -52, SHOW_EVENT_LIST1, RGB(235,235,235), FALSE, 1, TRUE);
	}
	m_DDraw._ReleaseBackBufferDC();
}

void CGame::RequestTeleportAndWaitData()
{	// Snoopy: removed that, Noob Dungeon is now at farm...
	/*if (strcmp(m_cMapName, "aresden") == 0)
	{	if ( ((m_sPlayerX == 188) && (m_sPlayerY == 105))  ||
			 ((m_sPlayerX == 187) && (m_sPlayerY == 105))  ||
			 ((m_sPlayerX == 187) && (m_sPlayerY == 106))  ||
			 ((m_sPlayerX == 186) && (m_sPlayerY == 106))  ||
			 ((m_sPlayerX == 186) && (m_sPlayerY == 107))  )
		{	if ( (m_iLevel < 30) || (m_iLevel>80) )
			{	AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA1, 10);
				return;
	}	}	}
	if (strcmp(m_cMapName, "elvine") == 0)
	{	if ( ((m_sPlayerX == 218) && (m_sPlayerY == 109))  ||
			 ((m_sPlayerX == 217) && (m_sPlayerY == 109))  ||
			 ((m_sPlayerX == 217) && (m_sPlayerY == 110))  ||
			 ((m_sPlayerX == 216) && (m_sPlayerY == 110))  ||
			 ((m_sPlayerX == 216) && (m_sPlayerY == 111))  )
		{	if ( (m_iLevel < 30) || (m_iLevel>80) )
			{	AddEventList(REQUEST_TELEPORT_AND_WAIT_DATA1, 10);
				return;
	}	}	}*/
	bSendCommand(MSGID_REQUEST_TELEPORT, NULL, NULL, NULL, NULL, NULL, NULL);
	ChangeGameMode(DEF_GAMEMODE_ONWAITINGINITDATA);
}

void CGame::InitDataResponseHandler(char * pData)
{
 int * ip, i;
 short * sp, sX, sY;
 char  * cp, cMapFileName[32], cTxt[120], cPreCurLocation[12];
 BOOL  bIsObserverMode;
 HANDLE hFile;
 DWORD  dwFileSize;

	ZeroMemory( cPreCurLocation, sizeof(cPreCurLocation) );
	m_bParalyze = FALSE;
	m_bFullParalyze = FALSE;
	m_bHackMoveBlocked = FALSE;
	m_pMapData->Init();

	m_sMonsterID = 0;
	m_dwMonsterEventTime = 0;

	DisableDialogBox(7);
	DisableDialogBox(11);
	DisableDialogBox(13);
	DisableDialogBox(14);
	DisableDialogBox(16);
	DisableDialogBox(22);
	DisableDialogBox(20);
	DisableDialogBox(21);
	DisableDialogBox(23);
	DisableDialogBox(51); // Gail's diag

	m_cCommand = DEF_OBJECTSTOP;
	//m_bCommandAvailable = TRUE;
	m_cCommandCount = 0;
	m_bIsGetPointingMode = FALSE;
	m_iPointCommandType  = -1;
	m_iIlusionOwnerH = NULL;
	m_cIlusionOwnerType = NULL;
	m_bIsTeleportRequested = FALSE;
	m_bIsConfusion = FALSE;
	m_bSkillUsingStatus = FALSE;

	m_bItemUsingStatus = FALSE ;

	m_cRestartCount = -1;
	m_dwRestartCountTime = NULL;

	for (i = 0; i < DEF_MAXEFFECTS; i++) 
	{	if (m_pEffectList[i] != NULL) delete m_pEffectList[i];
		m_pEffectList[i] = NULL;
	}

	for (i = 0; i < DEF_MAXWHETHEROBJECTS; i++) 
	{	m_stWhetherObject[i].sX    = 0;
		m_stWhetherObject[i].sBX   = 0;
		m_stWhetherObject[i].sY    = 0;
		m_stWhetherObject[i].cStep = 0;
	}

	for (i = 0; i < DEF_MAXGUILDNAMES; i++) 
	{	m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		ZeroMemory(m_stGuildName[i].cCharName, sizeof(m_stGuildName[i].cCharName));
		ZeroMemory(m_stGuildName[i].cGuildName, sizeof(m_stGuildName[i].cGuildName));
	}

	for (i = 0; i < DEF_MAXCHATMSGS; i++) {
		if (m_pChatMsgList[i] != NULL) delete m_pChatMsgList[i];
		m_pChatMsgList[i] = NULL;
	}

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	// PlayerObjectID
	sp = (short *)cp;
	m_sPlayerObjectID = *sp;
	cp += 2;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerType = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerAppr1 = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerAppr2 = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerAppr3 = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerAppr4 = *sp;
	cp += 2;

	ip = (int *)cp; // v1.4
	m_iPlayerApprColor = *ip;
	cp += 4;

	// CLEROTH - BLACK FIX
	ip = (int *)cp;
	m_iPlayerStatus = *ip;
	cp += 4;

	//Snoopy MIM fix
	if ((m_iPlayerStatus & 0x00200000) == 0x00200000) 
	{	m_bIllusionMVT = TRUE;	
	}else
	{	m_bIllusionMVT = FALSE;
	}

	ZeroMemory(m_cMapName, sizeof(m_cMapName));
	ZeroMemory(m_cMapMessage, sizeof(m_cMapMessage));
	memcpy(m_cMapName, cp, 10);
	m_cMapIndex = GetOfficialMapName(m_cMapName, m_cMapMessage);	
	m_bIsHeldenianMap  = ((m_cMapIndex == 35) || (m_cMapIndex == 36) || (m_cMapIndex == 37));

	if( m_cMapIndex < 0 )
	{	m_stDialogBoxInfo[9].sSizeX = -1;
		m_stDialogBoxInfo[9].sSizeY = -1;
	}else
	{	m_stDialogBoxInfo[9].sSizeX = 128;
		m_stDialogBoxInfo[9].sSizeY = 128;
	}
	cp += 10;

	strcpy( cPreCurLocation, m_cCurLocation );
	ZeroMemory(m_cCurLocation, sizeof(m_cCurLocation));
	memcpy(m_cCurLocation, cp, 10);
	cp += 10;

	G_cSpriteAlphaDegree = *cp;
	cp++;

	m_cWhetherStatus = *cp;
	cp++;
	switch (G_cSpriteAlphaDegree) { //Snoopy:  Xmas bulbs
	// Will be sent by server if DayTime is 3 (and a snowy weather)
	case 1:	m_bIsXmas = FALSE; break;
	case 2: m_bIsXmas = FALSE; break;
	case 3: // Snoopy Special night with chrismas bulbs
		if (m_cWhetherStatus >3) m_bIsXmas = TRUE;
		else m_bIsXmas = FALSE;
		G_cSpriteAlphaDegree = 2;
		break;
	}
	ip = (int *)cp;
	m_iContribution = *ip;
	m_iContributionPrice = 0;
	cp += 4;
	bIsObserverMode = (BOOL)*cp;
	cp++;
	ip = (int *)cp;
	m_iRating = *ip;
	cp += 4;
	ip = (int *)cp;
	m_iHP = *ip;
	cp += 4;
    m_cDiscount = (char )*cp;
    cp++;

	if (m_cWhetherStatus != NULL)
		 SetWhetherStatus(TRUE, m_cWhetherStatus);
	else SetWhetherStatus(FALSE, m_cWhetherStatus);

	ZeroMemory(cMapFileName, sizeof(cMapFileName));
	strcat(cMapFileName, "mapdata\\");
	// CLEROTH - MW MAPS
	if(memcmp(m_cMapName,"defaultmw", 9)==0)
	{	strcat(cMapFileName, "mw\\defaultmw");
	}else
	{	strcat(cMapFileName, m_cMapName);
	}

	strcat(cMapFileName, ".amd");
	m_pMapData->OpenMapDataFile(cMapFileName);

	m_pMapData->m_sPivotX = sX;
	m_pMapData->m_sPivotY = sY;

	m_sPlayerX   = sX + 14 + 5;
	m_sPlayerY   = sY + 12 + 5;

	m_cPlayerDir = 5;

	if (bIsObserverMode == FALSE)
	{	m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
							                  m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor, // v1.4
											  m_iPlayerStatus, m_cPlayerName,
											  DEF_OBJECTSTOP, NULL, NULL, NULL);
	}

	m_sViewDstX = m_sViewPointX = (sX+4+5)*32;
	m_sViewDstY = m_sViewPointY = (sY+5+5)*32;
	_ReadMapData(sX + 4 + 5, sY + 5 + 5, cp);
	m_bIsRedrawPDBGS = TRUE;
    // ------------------------------------------------------------------------+
	wsprintf(cTxt, INITDATA_RESPONSE_HANDLER1, m_cMapMessage);
	AddEventList(cTxt, 10);

	m_stDialogBoxInfo[6].sX  =  150;
    m_stDialogBoxInfo[6].sY  =  130;

	if (   ( memcmp( m_cCurLocation, "middleland"	,10 ) == 0 )
		|| ( memcmp( m_cCurLocation, "dglv2"		, 5 ) == 0 )
		|| ( memcmp( m_cCurLocation, "middled1n"	, 9 ) == 0 ))
    	EnableDialogBox(6, NULL,NULL, NULL);

// Snoopy: removed for v351 compatibility. Maybe usefull later...
/*	BOOL bPrevSafe, bNowSafe;
	if( memcmp( cPreCurLocation, m_cLocation, 3 ) == 0 )
		bPrevSafe = TRUE;
	else bPrevSafe = FALSE;

	if( memcmp( m_cCurLocation, m_cLocation, 3 ) == 0 )
		bNowSafe = TRUE;
	else bNowSafe = FALSE;

	if( memcmp( m_cCurLocation, "2nd", 3 ) == 0 ) bNowSafe = TRUE;
	if( m_iPKCount != 0 ) bNowSafe = FALSE;

	if( bPrevSafe )
	{	if( bNowSafe == FALSE ) SetTopMsg(DEF_MSG_DANGERZONE, 5);
	}else
	{	if( bNowSafe ) SetTopMsg(DEF_MSG_SAFEZONE, 5);
	}*/

    // ------------------------------------------------------------------------+

	ChangeGameMode(DEF_GAMEMODE_ONMAINGAME);
	m_DDraw.ClearBackB4();

	//v1.41
	if ((m_sPlayerAppr2 & 0xF000) != 0)
		 m_bIsCombatMode = TRUE;
	else m_bIsCombatMode = FALSE;

	//v1.42
	if (m_bIsFirstConn == TRUE) 
	{	m_bIsFirstConn = FALSE;
		hFile = CreateFile("contents\\contents1000.txt", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
			dwFileSize = 0;
		else 
		{	dwFileSize = GetFileSize(hFile, NULL);
			CloseHandle(hFile);
		}
		bSendCommand(MSGID_REQUEST_NOTICEMENT, NULL, NULL, (int)dwFileSize, NULL, NULL, NULL);
	}
	//cp += 2;
}

void CGame::MotionEventHandler(char * pData)
{WORD  * wp, wEventType, wObjectID;
 short * sp, sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4, sV1, sV2, sV3, sPrevAppr2;
 int iStatus;
 char  * cp, cDir, cName[12];
 int   * ip, iApprColor, iLoc;
 char    cTxt[120];
 int i;
	ZeroMemory(cName, sizeof(cName));
	sV1 = sV2 = sV3 = NULL;
	wp   = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wEventType = *wp;
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	wp = (WORD *)cp;
	wObjectID = *wp;
	cp += 2;
	iLoc = 0;
	if (wObjectID < 30000)
	{	if (wObjectID < 10000) 	// Player
		{	sp  = (short *)cp;
			sX = *sp;
			cp += 2;
			sp  = (short *)cp;
			sY = *sp;
			cp += 2;
			sp  = (short *)cp;
			sType = *sp;
			cp += 2;
			cDir = *cp;
			cp++;
			memcpy(cName, cp, 10);
			cp += 10;
			sp  = (short *)cp;
			sAppr1 = *sp;
			cp += 2;
			sp  = (short *)cp;
			sAppr2 = *sp;
			cp += 2;
			sp  = (short *)cp;
			sAppr3 = *sp;
			cp += 2;
			sp  = (short *)cp;
			sAppr4 = *sp;
			cp += 2;
			ip = (int *)cp; // v1.4
			iApprColor = *ip;
			cp += 4;

			// CLEROTH - CRASH BUG ( STATUS )
			ip  = (int *)cp;
			iStatus = *ip;
			cp += 4;

			iLoc = *cp;
			cp++;
		}else 	// Npc or mob
		{	sp  = (short *)cp;
			sX = *sp;
			cp += 2;
			sp  = (short *)cp;
			sY = *sp;
			cp += 2;
			sp  = (short *)cp;
			sType = *sp;
			cp += 2;
			cDir = *cp;
			cp++;
			memcpy(cName, cp, 5);
			cp += 5;
			sAppr1 = sAppr3 = sAppr4 = 0;
			sp  = (short *)cp;
			sAppr2 = *sp;
			cp += 2;
			ip  = (int *)cp;
			iStatus = *ip;
			cp += 4;
			iLoc = *cp;
			cp++;
		}
	}else
	{	switch (wEventType) {
		case DEF_OBJECTMAGIC:
		case DEF_OBJECTDAMAGEMOVE:
		case DEF_OBJECTDAMAGE:
			cDir = *cp;
			cp++;
			sV1 = (short)*cp; //Damage
			cp++;
			sV2 = (short)*cp; //
			cp++;
  			break;

		case DEF_OBJECTDYING:
			cDir = *cp;
			cp++;
			sV1 = (short)*cp; //Damage
			cp++;
			sV2 = (short)*cp; //
			cp++;
			sp  = (short *)cp;
			sX = *sp;
			cp += 2;
			sp  = (short *)cp;
			sY = *sp;
			cp += 2;
			break;

		case DEF_OBJECTATTACK:
			cDir = *cp;
			cp++;
			sV1 = *cp;
			cp++;
			sV2 = *cp;
			cp++;
			sp = (short *)cp;
			sV3 = *sp;
			cp += 2;
			break;

		default:
			cDir = *cp;
			cp++;
			break;
	}	}

	if ((wEventType == DEF_OBJECTNULLACTION) && (memcmp(cName, m_cPlayerName, 10) == 0))
	{	m_sPlayerType   = sType;
		m_sPlayerAppr1  = sAppr1;
		sPrevAppr2      = m_sPlayerAppr2;
		m_sPlayerAppr2  = sAppr2;
		m_sPlayerAppr3  = sAppr3;
		m_sPlayerAppr4  = sAppr4;
		m_iPlayerApprColor = iApprColor;
		m_iPlayerStatus    = iStatus;
		if ((sPrevAppr2 & 0xF000) == 0)
		{	if ((sAppr2 & 0xF000) != 0)
			{	AddEventList(MOTION_EVENT_HANDLER1, 10);
				m_bIsCombatMode = TRUE;
			}
		}else
		{	if ((sAppr2 & 0xF000) == 0)
			{	AddEventList(MOTION_EVENT_HANDLER2, 10);
				m_bIsCombatMode = FALSE;
		}	}
		if (m_cCommand != DEF_OBJECTRUN) m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, (char)wEventType, sV1, sV2, sV3, iLoc);
	}else m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, iStatus, cName, (char)wEventType, sV1, sV2, sV3, iLoc);

	switch (wEventType) {
	case DEF_OBJECTMAGIC: // Casting
		_RemoveChatMsgListByObjectID(wObjectID - 30000);

		for (i = 1; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] == NULL)
		{	ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "%s!", m_pMagicCfgList[sV1]->m_cName);
			m_pChatMsgList[i] = new class CMsg(41, cTxt, m_dwCurTime);
			m_pChatMsgList[i]->m_iObjectID = wObjectID - 30000;
			if (m_pMapData->bSetChatMsgOwner(wObjectID - 30000, -10, -10, i) == FALSE)
			{	delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
			return;
		}
		break;

	case DEF_OBJECTDYING:
		_RemoveChatMsgListByObjectID(wObjectID - 30000);
		for (i = 1; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] == NULL)
		{	ZeroMemory(cTxt, sizeof(cTxt));

#ifdef DEF_EQUILIBRIUM_PROJECT // damage Criticals a 200+

			if (sV1 < 0) sV1 = 256 + sV1;
			if (sV1 >= 200)	strcpy(cTxt, COMMAND_PROCESSOR6); // "Critical!"
			else 			wsprintf(cTxt, "-%dPts!", sV1); //pts			
			int iFontType;
			if ((sV1 >= 0) && (sV1 < 20))		iFontType = 21;
			else if ((sV1 >= 20) && (sV1 < 50)) iFontType = 22;
			else if (sV1 >= 50)	iFontType = 23;
#else
			if (sV1 > 0)
				wsprintf(cTxt, "-%dPts!", sV1); //pts
			else strcpy(cTxt, COMMAND_PROCESSOR6); // "Critical!"
			int iFontType;
			if ((sV1 >= 0) && (sV1 < 12))		iFontType = 21;
			else if ((sV1 >= 12) && (sV1 < 40)) iFontType = 22;
			else if ((sV1 >= 40) || (sV1 < 0))	iFontType = 23;
#endif
			m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
			m_pChatMsgList[i]->m_iObjectID = wObjectID - 30000;
			if (m_pMapData->bSetChatMsgOwner(wObjectID - 30000, -10, -10, i) == FALSE)
			{	delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
			return;
		}
		break;

	case DEF_OBJECTDAMAGEMOVE:
	case DEF_OBJECTDAMAGE:
		if (memcmp(cName, m_cPlayerName, 10) == 0)
		{	m_bIsGetPointingMode = FALSE;
			m_iPointCommandType	 = -1;
			m_stMCursor.sCursorFrame = 0;
			ClearSkillUsingStatus();
		}
		_RemoveChatMsgListByObjectID(wObjectID - 30000);

		for (i = 1; i < DEF_MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] == NULL)
		{	ZeroMemory(cTxt, sizeof(cTxt));

#ifdef DEF_EQUILIBRIUM_PROJECT // damages critical a 200+
			if (sV1 != 0)
			{	if (sV1 < 0) sV1 = 256 + sV1;
				
				if (sV1 >= 200)	strcpy(cTxt, COMMAND_PROCESSOR6); // "Critical!"
				else 			wsprintf(cTxt, "-%dPts", sV1); //pts
				int iFontType;
				if ((sV1 >= 0) && (sV1 < 20))		iFontType = 21;
				else if ((sV1 >= 20) && (sV1 < 50)) iFontType = 22;
				else if (sV1 >= 50)	iFontType = 23;

				m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
			}else
			{	strcpy(cTxt, " * Failed! *");
				m_pChatMsgList[i] = new class CMsg(22, cTxt, m_dwCurTime);
				PlaySound('C', 17, 0);
			}

#else
			if (sV1 != 0)
			{	if (sV1 > 0)
					wsprintf(cTxt, "-%dPts", sV1); //pts
				else strcpy(cTxt, COMMAND_PROCESSOR6); // "Critical!"
				int iFontType;
				if ((sV1 >= 0) && (sV1 < 12))		iFontType = 21;
				else if ((sV1 >= 12) && (sV1 < 40)) iFontType = 22;
				else if ((sV1 >= 40) || (sV1 < 0))	iFontType = 23;

				m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
			}else
			{	strcpy(cTxt, " * Failed! *");
				m_pChatMsgList[i] = new class CMsg(22, cTxt, m_dwCurTime);
				PlaySound('C', 17, 0);
			}
#endif
			m_pChatMsgList[i]->m_iObjectID = wObjectID - 30000;
			if (m_pMapData->bSetChatMsgOwner(wObjectID - 30000, -10, -10, i) == FALSE)
			{	delete m_pChatMsgList[i];
				m_pChatMsgList[i] = NULL;
			}
			return;
		}
		break;
	}
}

void CGame::DrawDialogBox_Commander(int msX, int msY) // Snoopy: Fixed for 351
{short sX, sY, szX, szY, MapSzX, MapSzY;
 DWORD dwTime = G_dwGlobalTime;
 double dV1, dV2, dV3;
 int i, tX, tY;
	sX = m_stDialogBoxInfo[36].sX;
	sY = m_stDialogBoxInfo[36].sY;
	szX = m_stDialogBoxInfo[36].sSizeX;
	if ((dwTime - m_dwCommanderCommandRequestedTime) > 1000*10)
	{	_RequestMapStatus("middleland", 3);
		_RequestMapStatus("middleland", 1);
		m_dwCommanderCommandRequestedTime = dwTime;
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY-5, 0, FALSE, m_bDialogTrans); // Main image
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 15, FALSE, m_bDialogTrans);

	switch (m_stDialogBoxInfo[36].cMode) {
	case 0: // Main dlg
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20,          sY + 340, 3, dwTime); // btn
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50,      sY + 340, 1, dwTime); // btn
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100,     sY + 340, 2, dwTime); // btn
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150,     sY + 340, 30,dwTime); // Btn TP
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 +74, sY + 340, 4, dwTime); // btn ?
		//PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_COMMANDER1);//"Middleland warfare building structure situation"
		PutAlignedString(sX, sX + szX, sY + 37, DRAW_DIALOGBOX_COMMANDER1);//"Middleland warfare building structure situation"

		if (   (msX >= sX +20) && (msX <= sX +20 +46)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY + 340, 17, dwTime);
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER2, 255,255,255);//"Middleland teleport position set"
		}else if ( (msX >= sX +20 +50) && (msX <= sX +20 +46 +50)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY + 340, 15, dwTime);
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER3, 255,255,255);//"Teleport to the selected area"
		}else if ( (msX >= sX +20 +100) && (msX <= sX +20 +46 +100)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52)) {
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100, sY + 340, 16, dwTime);
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER4, 255,255,255);//"Recall warfare units"
		}else if ((msX >= sX +20 +150) && (msX <= sX +20 +46 +150)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150, sY + 340, 24,dwTime);
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER5, 255,255,255);//"Middleland construction building set"
		}else if ( (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 18, dwTime);
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER6, 255,255,255);//"Commander's duty help"
		}
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, FALSE, m_bDialogTrans);// Map
		break;

	case 1: // Set TP
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 340, 20, dwTime); //btn <-
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 4, dwTime);  //btn ?
		PutAlignedString(sX, sX + szX, sY + 40,  DRAW_DIALOGBOX_COMMANDER7); // "Click and select the teleport location."

		if (   (msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 340, 19, dwTime);
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER8, 255,255,255);
		}else if ( (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 18, dwTime);
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER9, 255,255,255);
		}
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, FALSE, m_bDialogTrans);

		if (   (msX >= sX + 15) && (msX <= sX + 15 + 278)
			&& (msY >= sY + 60) && (msY <= sY + 60 + 272)) // shows TP posit on map following the mouse
		{	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, msX, msY, 42, FALSE, TRUE);
		}
		break;

	case 2: // Use TP
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50,  sY + 340, 1, dwTime);       // Btn TP
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 340, 20, dwTime); // Btn <-
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 4, dwTime);  // Btn ?
		PutAlignedString(sX, sX + szX, sY + 40,  DRAW_DIALOGBOX_COMMANDER10); // "Teleport to the selected area"

		if (   (msX >= sX +20 +50) && (msX <= sX +20 +46 +50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50,  sY + 340, 15, dwTime);
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER11, 255,255,255);
		}else if ( (msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 340, 19, dwTime);
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER12, 255,255,255);
		}else if ( (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 18, dwTime);
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER13, 255,255,255);
		}
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, FALSE, m_bDialogTrans);
		break;

	case 3: // Choose summon
		if( (m_bCitizen == TRUE) && (m_bAresden == TRUE) )
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY +220, 6, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY +220, 5, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100, sY +220, 7, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150, sY +220, 35, dwTime);
		}else if ( (m_bCitizen == TRUE) && (m_bAresden == FALSE) )
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY +220, 9, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY +220, 8, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100, sY +220, 7, dwTime);
			m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150, sY +220, 35, dwTime);
		}
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 340, 20, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 4, dwTime);

		PutAlignedString(sX, sX + szX, sY + 40,  DRAW_DIALOGBOX_COMMANDER14); // "Recall warfare units"

		wsprintf(G_cTxt, "%s %d",DRAW_DIALOGBOX_COMMANDER15, m_iConstructionPoint);
		PutAlignedString(sX, sX +323, sY +190,  G_cTxt);

		if( (m_bCitizen == TRUE) && (m_bAresden == TRUE) )
		{	if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 3000)
				{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY +220, 11, dwTime);
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER16, 255,255,255);//"¹(Battle Golem)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER17, 255,255,255);//"3000"
			}else if ((msX >= sX +20 +50) && (msX <= sX +20 +50 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 2000)
				{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY +220, 10, dwTime);
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER18, 255,255,255);//"(Temple Knight)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER19, 255,255,255);//"2000"
			}else if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 1000)
				{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100, sY +220, 12, dwTime);
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER20, 255,255,255);//"(Light War Beetle)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER21, 255,255,255);//" 1000"
			}else if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
			{ 	if (m_iConstructionPoint >= 5000)
				{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150, sY +220, 29, dwTime);
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER22, 255,255,255);//"(Catapult)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER23, 255,255,255);// 1500"
			}else if ((msX >= sX +20) && (msX <= sX +380) && (msY > sY +140) && (msY < sY +160))
			{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER24, 255,255,255);
			}else if ((msX >= sX +20) && (msX <= sX +380) && (msY > sY +160) && (msY < sY +175))
			{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER25, 255,255,255);
			}else if ( (msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50)
					&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
			{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 340, 19, dwTime);
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER26, 255,255,255);
			}else if ( (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
					&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
			{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 18, dwTime);
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER27, 255,255,255); //"Warfare units recall related help"
			}
		}else if ( (m_bCitizen == TRUE) && (m_bAresden == FALSE) )
		{	if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 3000)
				{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY +220, 14, dwTime);
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER28, 255,255,255);//"(God's Hand Knight Cavalry)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER29, 255,255,255);//"3000"
			}else if ( (msX >= sX +20 +50) && (msX <= sX +20 +50 +45)
					&& (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 2000)
				{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY +220, 13, dwTime);
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER30, 255,255,255);//"°(God's Hand Knight)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER31, 255,255,255);//"2000"
			}else if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 1000)
				{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100, sY +220, 12, dwTime);
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER32, 255,255,255);//"(Light War Beetle)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER33, 255,255,255);//" 1000"
			}else if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
			{	if (m_iConstructionPoint >= 5000)
				{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150, sY +220, 29, dwTime);
				}
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER34, 255,255,255);//"(Catapult)"
				PutString2(msX +20, msY +50, DRAW_DIALOGBOX_COMMANDER35, 255,255,255);//" 1500"
			}else if ((msX >= sX +20) && (msX <= sX +380) && (msY > sY +140) && (msY < sY +160))
			{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER36, 255,255,255);
			}else if ((msX >= sX +20) && (msX <= sX +380) && (msY > sY +160) && (msY < sY +175))
			{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER37, 255,255,255);
			}else if ( (msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50)
					&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
			{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 340, 19, dwTime);
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER38, 255,255,255);

			}else if ( (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
					&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
			{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 18, dwTime);
				PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER39, 255,255,255);
		}	}
		PutAlignedString(sX, sX +323, sY +80,  DRAW_DIALOGBOX_COMMANDER40);
		PutAlignedString(sX, sX +323, sY +95,  DRAW_DIALOGBOX_COMMANDER41);
		PutAlignedString(sX, sX +323, sY +110, DRAW_DIALOGBOX_COMMANDER42);

		switch (m_stDialogBoxInfo[36].sV1) {
		case 0:
			PutAlignedString(sX, sX +323, sY +140,  DRAW_DIALOGBOX_COMMANDER43, 255, 255, 255);//"Guard Mode"
			PutAlignedString(sX, sX +323, sY +160,  DRAW_DIALOGBOX_COMMANDER44, 4,0,50);//"Hold Mode"
			break;
		case 1:
			PutAlignedString(sX, sX +323, sY +140,  DRAW_DIALOGBOX_COMMANDER43, 4,0,50);//"Guard Mode"
			PutAlignedString(sX, sX +323, sY +160,  DRAW_DIALOGBOX_COMMANDER44, 255, 255, 255);//"Hold Mode"
			break;
		}
		break;

	case 4: // Set Construction point
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 340, 20, dwTime);
		m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 4, dwTime);
		PutAlignedString(sX, sX + szX, sY + 40,  DRAW_DIALOGBOX_COMMANDER47); // "Select the construction area and click."

		if (   (msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 340, 19, dwTime);
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER48, 255,255,255); // "Returns to commander's main menu"
		}else if ( (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 18, dwTime);
			PutString2(msX +20, msY +35, DRAW_DIALOGBOX_COMMANDER49, 255,255,255); // "Construction area set related help"
		}
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21);
		if (   (msX >= sX + 15) && (msX <= sX + 15 + 278)
			&& (msY >= sY + 60) && (msY <= sY + 60 + 272)) // shows posit on map following the mouse
		{	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, msX, msY, 41, FALSE, TRUE);
		}
		break;
	}

	switch (m_stDialogBoxInfo[36].cMode) {
	case 0: // Main
	case 1: // Set TP
	case 2: // Use TP
	case 4: // Set construc
		szX = NULL;
		szY = NULL;
		MapSzX = NULL;
		MapSzY = NULL;
		if (strcmp(m_cStatusMapName, "aresden") == 0)
		{	szX = 250;
			szY = 250;
		}else if (strcmp(m_cStatusMapName, "elvine") == 0)
		{	szX = 250;
			szY = 250;
		}else if (strcmp(m_cStatusMapName, "middleland") == 0)
		{	szX = 279;
			szY = 280;
			MapSzX = 524;
			MapSzY = 524;
		}
		if (szX != NULL)
		{	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++)
			if (m_stCrusadeStructureInfo[i].cType != NULL)
			{	dV1 = (double)MapSzX;
				dV2 = (double)m_stCrusadeStructureInfo[i].sX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;
				dV1 = (double)MapSzY;
				dV2 = (double)m_stCrusadeStructureInfo[i].sY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;
				switch (m_stCrusadeStructureInfo[i].cType) {
				case 38:
					if (m_stCrusadeStructureInfo[i].cSide == 1)
						 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 39, FALSE, TRUE); // Base
					else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 37, FALSE, TRUE);
					break;
				case 36:
				case 37:
				case 39:
					if (m_stCrusadeStructureInfo[i].cSide == 1)
						 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 38, FALSE, TRUE); // Base
					else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 36, FALSE, TRUE);
					break;
				case 42:
					DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 40); // ManaStone
					break;
			}	}
			if (m_iTeleportLocX != -1)
			{	dV1 = (double)MapSzX;
				dV2 = (double)m_iTeleportLocX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;
				dV1 = (double)MapSzY;
				dV2 = (double)m_iTeleportLocY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;
				if ((m_stDialogBoxInfo[36].cMode == 1) && (tY >= 30) && (tY <= 494)) // Place the TP
				{	  DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 42, FALSE, TRUE); //TP
				}else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 42, FALSE, TRUE); //TP
			}
			if ((m_stDialogBoxInfo[36].cMode != 2) && (m_iConstructLocX != -1))
			{	dV1 = (double)MapSzX;
				dV2 = (double)m_iConstructLocX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;
				dV1 = (double)MapSzY;
				dV2 = (double)m_iConstructLocY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 41, FALSE, TRUE); // Contr pt
			}
			if (strcmp(m_cMapName, "middleland") == 0)
			{	dV1 = (double)MapSzX;//m_pMapData->m_sMapSizeX;
				dV2 = (double)m_sPlayerX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;
				dV1 = (double)MapSzY;//m_pMapData->m_sMapSizeY;
				dV2 = (double)m_sPlayerY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 43); // Player place
		}	}
		if (m_stDialogBoxInfo[36].cMode != 3)
		{	if (   (msX >= sX + 15) && (msX <= sX + 15 +278)
				&& (msY >= sY + 60) && (msY <= sY + 60 +272)) // Draw mouse coordinates
			{	dV1 = (double)(msX - (sX + 15));
				dV2 = (double)MapSzX;//(752.0f);
				dV3 = (dV2*dV1)/szX;//280.0f;
				tX = (int)dV3;
				dV1 = (double)(msY - (sY + 60));
				dV2 = (double)MapSzX;//(680.0f);
				dV3 = (dV2*dV1)/szY;//253.0f;
				tY = (int)dV3;
				if (tX < 30) tX = 30;
				if (tY < 30) tY = 30;
				if (tX > MapSzX-30) tX = MapSzX-30;
				if (tY > MapSzY-30) tY = MapSzY-30;
				wsprintf(G_cTxt, "%d,%d", tX, tY);
				PutString_SprFont3(msX + 10, msY -10, G_cTxt, m_wR[13]*4, m_wG[13]*4, m_wB[13]*4, FALSE, 2);
		}	}
		break;
	}
}

void CGame::DrawDialogBox_Constructor(int msX, int msY) // Snoopy: Fixed for 351
{short sX, sY, szX, szY, MapSzX, MapSzY;
 DWORD dwTime = G_dwGlobalTime;
 double dV1, dV2, dV3;
 int tX, tY;
 char cMapName[12];
	sX = m_stDialogBoxInfo[37].sX;
	sY = m_stDialogBoxInfo[37].sY;
	szX = m_stDialogBoxInfo[37].sSizeX;
	if ((dwTime - m_dwCommanderCommandRequestedTime) > 1000*10)
	{	_RequestMapStatus("middleland", 1);
		m_dwCommanderCommandRequestedTime = dwTime;
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY-5, 0, FALSE, m_bDialogTrans); // Main image
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 16, FALSE, m_bDialogTrans);

	switch (m_stDialogBoxInfo[37].cMode) {
	case 0: // Main dlg
		if (m_iConstructLocX != -1)
		{	ZeroMemory(cMapName, sizeof(cMapName));
			GetOfficialMapName(m_cConstructMapName, cMapName);
			wsprintf(G_cTxt, DRAW_DIALOGBOX_CONSTRUCTOR1, cMapName, m_iConstructLocX, m_iConstructLocY);
			PutAlignedString(sX, sX + szX, sY + 40, G_cTxt);
		}else PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_CONSTRUCTOR2); //"Construction unavailable: Unable to construct"
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, FALSE, m_bDialogTrans); // Map

		if (   (msX >= sX +20) && (msX <= sX +20 +46)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY + 340, 24, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY + 340, 30, dwTime);

		if (   (msX >= sX +20 +50) && (msX <= sX +20 +46 +50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY + 340, 15, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY + 340,  1, dwTime);

		if (   (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{     m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 18, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340,  4, dwTime);

		if (   (msX >= sX +20) && (msX <= sX +20 +46)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR3, 255,255,255);
		}else if ( (msX >= sX +20 +50) && (msX <= sX +20 +46 +50)
				&& (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR4, 255,255,255);
		}else if ( (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
				&& (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR5, 255,255,255);
		}
		break;

	case 1: // Select building
		PutAlignedString(sX, sX +szX, sY +40,  DRAW_DIALOGBOX_CONSTRUCTOR6); //"Select war building"
		PutAlignedString(sX, sX +323, sY +80,  DRAW_DIALOGBOX_CONSTRUCTOR7); //"Constructs the war building here."
		PutAlignedString(sX, sX +323, sY +95,  DRAW_DIALOGBOX_CONSTRUCTOR8); //"Press the building icon and"
		PutAlignedString(sX, sX +323, sY +110, DRAW_DIALOGBOX_CONSTRUCTOR9); //"the base will be formed and slowly finished"
		PutAlignedString(sX, sX +323, sY +125, DRAW_DIALOGBOX_CONSTRUCTOR10);//"Attack the building with Pickaxe."
		PutAlignedString(sX, sX +323, sY +140, DRAW_DIALOGBOX_CONSTRUCTOR11);//"Building is not activated"
		PutAlignedString(sX, sX +323, sY +155, DRAW_DIALOGBOX_CONSTRUCTOR12);//"while constructing."

		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY +220, 27, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY +220, 33, dwTime);

		if ((msX >= sX +20 +50) && (msX <= sX +20 +50 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY +220, 28, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY +220, 34, dwTime);

		if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100, sY +220, 26, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100, sY +220, 32, dwTime);

		if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150, sY +220, 25, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150, sY +220, 31, dwTime);

		if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 19, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 322, 20, dwTime);

		if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 18, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 322, 4, dwTime);

		if ((msX >= sX +20) && (msX <= sX +20 +46) && (msY >= sY +220) && (msY <= sY +220 +50))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR13, 255,255,255);//"(Mana Collector)"
		}else if ((msX >= sX +20 +50) && (msX <= sX +20 +50 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR14, 255,255,255);//"(Detector)"
		}else if ((msX >= sX +20 +100) && (msX <= sX +20 +100 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR15, 255,255,255);//"(Arrow Guard Tower)"
		}else if ((msX >= sX +20 +150) && (msX <= sX +20 +150 +45) && (msY >= sY +220) && (msY <= sY +220 +50))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR16, 255,255,255);//(Cannon Guard Tower)"
		}else if ((msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50) && (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR17, 255,255,255);
		}else if ((msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74) && (msY >= sY + 322) && (msY <= sY + 322 + 52))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR18, 255,255,255);
		}
		break;

	case 2: // Teleport
		PutAlignedString(sX, sX + szX, sY + 40,  DRAW_DIALOGBOX_CONSTRUCTOR19); //"Teleport to position that commander pointed"
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, FALSE, m_bDialogTrans); // map

		if (   (msX >= sX +20 +50) && (msX <= sX +20 +46 +50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY + 340, 15, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +50, sY + 340, 1, dwTime);

		if (   (msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 340, 19, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +100 + 74, sY + 340, 20, dwTime);

		if (   (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 18, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 4, dwTime);

		if ((msX >= sX +20 +50) && (msX <= sX +20 +46 +50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR20, 255,255,255);
		}else if ( (msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR21, 255,255,255);
		}else if ( (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_CONSTRUCTOR22, 255,255,255);
		}
		break;
	}

	switch (m_stDialogBoxInfo[37].cMode) {
	case 0: // Main dlg
	case 2: // TP
		szX = NULL;
		szY = NULL;
		MapSzX = NULL;
		MapSzY = NULL;
		if (strcmp(m_cStatusMapName, "aresden") == 0)
		{	szX = 250;
			szY = 250;
		}else if (strcmp(m_cStatusMapName, "elvine") == 0)
		{	szX = 250;
			szY = 250;
		}else if (strcmp(m_cStatusMapName, "middleland") == 0)
		{	szX = 279;
			szY = 280;
			MapSzX = 524;
			MapSzY = 524;
		}
		if (szX != 0)
		{	for (int i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++)
			if (m_stCrusadeStructureInfo[i].cType == 42)
			{	dV1 = (double)MapSzX;
				dV2 = (double)m_stCrusadeStructureInfo[i].sX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;
				dV1 = (double)MapSzY;
				dV2 = (double)m_stCrusadeStructureInfo[i].sY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;
				switch (m_stCrusadeStructureInfo[i].cType) {
				case 42:
					DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 40); // ManaStone
					break;
			}	}
			if (m_iTeleportLocX != -1)
			{	dV1 = (double)MapSzX;
				dV2 = (double)m_iTeleportLocX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;
				dV1 = (double)MapSzY;
				dV2 = (double)m_iTeleportLocY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 42, FALSE, TRUE); //TP
			}
			if ((m_stDialogBoxInfo[37].cMode != 2) && (m_iConstructLocX != -1))
			{	dV1 = (double)MapSzX;
				dV2 = (double)m_iConstructLocX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;
				dV1 = (double)MapSzY;
				dV2 = (double)m_iConstructLocY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 41, FALSE, TRUE); // Contr pt
			}
			if (strcmp(m_cMapName, "middleland") == 0)
			{	dV1 = (double)MapSzX;//m_pMapData->m_sMapSizeX;
				dV2 = (double)m_sPlayerX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;
				dV1 = (double)MapSzY;//m_pMapData->m_sMapSizeY;
				dV2 = (double)m_sPlayerY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 43); // Player place
		}	}
		if (   (msX >= sX + 15) && (msX <= sX + 15 +278)
			&& (msY >= sY + 60) && (msY <= sY + 60 +272))  // Draw mouse coordinates
		{	dV1 = (double)(msX - (sX + 15));
			dV2 = (double)MapSzX;//(752.0f);
			dV3 = (dV2*dV1)/szX;//280.0f;
			tX = (int)dV3;
			dV1 = (double)(msY - (sY + 60));
			dV2 = (double)MapSzX;//(680.0f);
			dV3 = (dV2*dV1)/szY;//253.0f;
			tY = (int)dV3;
			if (tX < 30) tX = 30;
			if (tY < 30) tY = 30;
			if (tX > MapSzX-30) tX = MapSzX-30;
			if (tY > MapSzY-30) tY = MapSzY-30;
			wsprintf(G_cTxt, "%d,%d", tX, tY);
			PutString_SprFont3(msX + 10, msY -10, G_cTxt, m_wR[13]*4, m_wG[13]*4, m_wB[13]*4, FALSE, 2);
		}
		break;
	}
}

void CGame::DrawDialogBox_Soldier(int msX, int msY) // Snoopy: Fixed for 351
{short sX, sY, szX, szY, MapSzX, MapSzY;
 DWORD dwTime = G_dwGlobalTime;
 char cMapName[120];
 double dV1, dV2, dV3;
 int tX, tY;
	sX = m_stDialogBoxInfo[38].sX;
	sY = m_stDialogBoxInfo[38].sY;
	szX = m_stDialogBoxInfo[38].sSizeX;
	if ((dwTime - m_dwCommanderCommandRequestedTime) > 1000*10)
	{	_RequestMapStatus("middleland", 1);
		m_dwCommanderCommandRequestedTime = dwTime;
	}

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY-5, 0, FALSE, m_bDialogTrans);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, FALSE, m_bDialogTrans);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 17, FALSE, m_bDialogTrans); // Crusade Soldier Menu Text

	switch (m_stDialogBoxInfo[38].cMode) {
	case 0: // Main dlg, Map
		if (m_iTeleportLocX != -1)
		{	ZeroMemory(cMapName, sizeof(cMapName));
			GetOfficialMapName(m_cTeleportMapName, cMapName);
			wsprintf(G_cTxt, DRAW_DIALOGBOX_SOLDIER1, cMapName, m_iTeleportLocX, m_iTeleportLocY);
			PutAlignedString(sX, sX + szX, sY + 40, G_cTxt);					// "Teleport position: %s near %d, %d"
		}else PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_SOLDIER2); //"Teleport position is not set."

		if (   (msX >= sX +20) && (msX <= sX +20 +46)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY + 340, 15, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY + 340, 1, dwTime);

		if (   (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 18, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 4, dwTime);

		if (   (msX >= sX +20) && (msX <= sX +20 +46)
			&& (msY >= sY +340) && (msY <= sY + 340 + 52))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_SOLDIER3, 255,255,255); // "Teleport to position that commander pointed"
		}else if ( (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
				&& (msY >= sY +340) && (msY <= sY + 340 + 52))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_SOLDIER4, 255,255,255); // "Help for soldier"
		}
		break;

	case 1: // TP now
		PutAlignedString(sX, sX + szX, sY + 40,  DRAW_DIALOGBOX_SOLDIER5); // "Teleport to position that commander pointed"
		if (   (msX >= sX +20) && (msX <= sX +20 +46)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY + 340, 15, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20, sY + 340, 1, dwTime);

		if (   (msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	  m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74 -50, sY + 340, 19, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74 -50, sY + 340, 20, dwTime);

		if (   (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{     m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 18, dwTime);
		}else m_pSprite[DEF_SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX +20 +150 + 74, sY + 340, 4, dwTime);

		if (   (msX >= sX +20) && (msX <= sX +20 +46)
			&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_SOLDIER6, 255,255,255);
		}else if ( (msX >= sX +20 +150 + 74 -50) && (msX <= sX +20 +46 +150 + 74 -50)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_SOLDIER7, 255,255,255);
		}else if ( (msX >= sX +20 +150 + 74) && (msX <= sX +20 +46 +150 + 74)
				&& (msY >= sY + 340) && (msY <= sY + 340 + 52))
		{	PutString2(msX +20, msY +35, DRAW_DIALOGBOX_SOLDIER8, 255,255,255);//"Help for teleport"
		}
		break;
	}

	switch (m_stDialogBoxInfo[38].cMode) {
	case 0: // Main
	case 1: // TP
		szX = NULL;
		szY = NULL;
		MapSzX = NULL;
		MapSzY = NULL;
		if (strcmp(m_cStatusMapName, "aresden") == 0)
		{	szX = 250;
			szY = 250;
		}else if (strcmp(m_cStatusMapName, "elvine") == 0)
		{	szX = 250;
			szY = 250;
		}else if (strcmp(m_cStatusMapName, "middleland") == 0)
		{	szX = 279;
			szY = 280;	  // Fix for ML
			MapSzX = 524; // Fix for ML
			MapSzY = 524; // Fix for ML
		}
		if (szX != 0)
		{	for (int i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++)
			if (m_stCrusadeStructureInfo[i].cType == 42)
			{	dV1 = (double)MapSzX;
				dV2 = (double)m_stCrusadeStructureInfo[i].sX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;
				dV1 = (double)MapSzY;
				dV2 = (double)m_stCrusadeStructureInfo[i].sY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;
				switch (m_stCrusadeStructureInfo[i].cType) {
				case 42:
					DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 40); // ManaStone
					break;
			}	}
			if (m_iTeleportLocX != -1)
			{	dV1 = (double)MapSzX;
				dV2 = (double)m_iTeleportLocX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;
				dV1 = (double)MapSzY;
				dV2 = (double)m_iTeleportLocY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 42, FALSE, TRUE); //TP
			}
			if (strcmp(m_cMapName, "middleland") == 0)
			{	dV1 = (double)MapSzX;//m_pMapData->m_sMapSizeX;
				dV2 = (double)m_sPlayerX;
				dV3 = (dV2*(double)szX)/dV1;
				tX  = (int)dV3;
				dV1 = (double)MapSzY;//m_pMapData->m_sMapSizeY;
				dV2 = (double)m_sPlayerY;
				dV3 = (dV2*(double)szY)/dV1;
				tY  = (int)dV3;
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_CRUSADE, sX +tX + 15, sY +tY + 60, 43); // Player place
		}	}
		if (   (msX >= sX + 15) && (msX <= sX + 15 +278)
			&& (msY >= sY + 60) && (msY <= sY + 60 +272))  // Draw mouse coordinates
		{	dV1 = (double)(msX - (sX + 15));
			dV2 = (double)MapSzX;//(752.0f);
			dV3 = (dV2*dV1)/szX;//280.0f;
			tX = (int)dV3;
			dV1 = (double)(msY - (sY + 60));
			dV2 = (double)MapSzX;//(680.0f);
			dV3 = (dV2*dV1)/szY;//253.0f;
			tY = (int)dV3;
			if (tX < 30) tX = 30;
			if (tY < 30) tY = 30;
			if (tX > MapSzX-30) tX = MapSzX-30;
			if (tY > MapSzY-30) tY = MapSzY-30;
			wsprintf(G_cTxt, "%d,%d", tX, tY);
			PutString_SprFont3(msX + 10, msY -10, G_cTxt, m_wR[13]*4, m_wG[13]*4, m_wB[13]*4, FALSE, 2);
		}
		break;
	}
}

void CGame::GrandMagicResult(char *pMapName, int iV1, int iV2, int iV3, int iV4, int iHP1, int iHP2, int iHP3, int iHP4)
{int i, iTxtIdx=0;
 char cTemp[120];

	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{	if (m_pMsgTextList[i] != NULL)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = NULL;
	}

	for (i = 0; i < 92; i++)
	if (m_pGameMsgList[i] == NULL) return;

	if (strcmp(pMapName, "aresden") == 0)
	{	m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[2]->m_pMsg, NULL);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[3]->m_pMsg, NULL);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, " ", NULL);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[4]->m_pMsg, iV1);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[5]->m_pMsg, iV2);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[6]->m_pMsg, iV3);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[58]->m_pMsg, iV4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, " ", NULL);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d %d %d %d", NOTIFY_MSG_STRUCTURE_HP, iHP1,iHP2,iHP3,iHP4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, " ", NULL);

		if (iV2 == 0) {
			if( (m_bCitizen == TRUE) && (m_bAresden == FALSE) )
			{	PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[59]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[60]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[61]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[62]->m_pMsg, NULL);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
			}else if ( (m_bCitizen == TRUE) && (m_bAresden == TRUE) )
			{	PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[69]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[70]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[71]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[72]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[73]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[74]->m_pMsg, NULL);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
			}else PlaySound('E', 25, 0, 0);
		}else
		{	if (iV1 != 0)
			{	if( (m_bCitizen == TRUE) && (m_bAresden == FALSE) )
				{	PlaySound('E', 23, 0, 0);
					PlaySound('C', 21, 0, 0);
					PlaySound('C', 22, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[63]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[64]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[65]->m_pMsg, NULL);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
				}else if ( (m_bCitizen == TRUE) && (m_bAresden == TRUE) )
				{	PlaySound('E', 24, 0, 0);
					PlaySound('C', 12, 0, 0);
					PlaySound('C', 13, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[75]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[76]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[77]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[78]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[79]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[80]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[81]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[82]->m_pMsg, NULL);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
				}else PlaySound('E', 25, 0, 0);
			}else
			{	if( (m_bCitizen == TRUE) && (m_bAresden == FALSE) )
				{	PlaySound('E', 23, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[66]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[67]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[68]->m_pMsg, NULL);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
				}else if ( (m_bCitizen == TRUE) && (m_bAresden == TRUE) )
				{	PlaySound('E', 24, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[83]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[84]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[85]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[86]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[87]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[88]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[89]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[90]->m_pMsg, NULL);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
				}else PlaySound('E', 25, 0, 0);
		}	}
	}else if (strcmp(pMapName, "elvine") == 0)
	{	m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[7]->m_pMsg, NULL);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[8]->m_pMsg, NULL);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, " ", NULL);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[4]->m_pMsg, iV1);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[5]->m_pMsg, iV2);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[6]->m_pMsg, iV3);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d", m_pGameMsgList[58]->m_pMsg, iV4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, " ", NULL);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%s %d %d %d %d", NOTIFY_MSG_STRUCTURE_HP, iHP1,iHP2,iHP3,iHP4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, cTemp, NULL);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, " ", NULL);

		if (iV2 == 0) {
			if ( (m_bCitizen == TRUE) && (m_bAresden == TRUE) )
			{	PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[59]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[60]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[61]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[62]->m_pMsg, NULL);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
			}else if ( (m_bCitizen == TRUE) && (m_bAresden == FALSE) )
			{	PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[69]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[70]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[71]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[72]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[73]->m_pMsg, NULL);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[74]->m_pMsg, NULL);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
			}else PlaySound('E', 25, 0, 0);
		}else
		{	if (iV1 != 0) {
				if ( (m_bCitizen == TRUE) && (m_bAresden == TRUE) )
				{	PlaySound('E', 23, 0, 0);
					PlaySound('C', 21, 0, 0);
					PlaySound('C', 22, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[63]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[64]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[65]->m_pMsg, NULL);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
				}else if ( (m_bCitizen == TRUE) && (m_bAresden == FALSE) )
				{	PlaySound('E', 24, 0, 0);
					PlaySound('C', 12, 0, 0);
					PlaySound('C', 13, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[75]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[76]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[77]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[78]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[79]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[80]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[81]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[82]->m_pMsg, NULL);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
				}else PlaySound('E', 25, 0, 0);
			}else
			{	if ( (m_bCitizen == TRUE) && (m_bAresden == TRUE) )
				{	PlaySound('E', 23, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[66]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[67]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[68]->m_pMsg, NULL);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
				}
				else if ( (m_bCitizen == TRUE) && (m_bAresden == FALSE) )
				{	PlaySound('E', 24, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[83]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[84]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[85]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[86]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[87]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[88]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[89]->m_pMsg, NULL);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(NULL, m_pGameMsgList[90]->m_pMsg, NULL);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
				}else PlaySound('E', 25, 0, 0);
	}	}	}

	EnableDialogBox(18, NULL, NULL, NULL);
}

void CGame::DrawDialogBox_Help(int msX, int msY)
{ short sX, sY, szX;

	sX = m_stDialogBoxInfo[35].sX;
	sY = m_stDialogBoxInfo[35].sY;
	szX = m_stDialogBoxInfo[35].sSizeX;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);

	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*0) && (msY < sY +50+15*1))
		 PutAlignedString(sX, sX+szX, sY + 50 +15*0, DRAW_DIALOGBOX_HELP2, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*0, DRAW_DIALOGBOX_HELP2, 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*1) && (msY < sY +50+15*2))
		 PutAlignedString(sX, sX+szX, sY + 50 +15*1, DRAW_DIALOGBOX_HELP1, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*1, DRAW_DIALOGBOX_HELP1, 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*2) && (msY < sY +50+15*3))
		PutAlignedString(sX, sX+szX, sY + 50 +15*2, DRAW_DIALOGBOX_HELP3, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*2, DRAW_DIALOGBOX_HELP3, 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*3) && (msY < sY +50+15*4))
		PutAlignedString(sX, sX+szX, sY + 50 +15*3, DRAW_DIALOGBOX_HELP4, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*3, DRAW_DIALOGBOX_HELP4, 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*4) && (msY < sY +50+15*5))
		PutAlignedString(sX, sX+szX, sY + 50 +15*4, DRAW_DIALOGBOX_HELP5, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*4, DRAW_DIALOGBOX_HELP5, 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*5) && (msY < sY +50+15*6))
		PutAlignedString(sX, sX+szX, sY + 50 +15*5, DRAW_DIALOGBOX_HELP6, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*5, DRAW_DIALOGBOX_HELP6, 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*6) && (msY < sY +50+15*7))
		PutAlignedString(sX, sX+szX, sY + 50 +15*6, DRAW_DIALOGBOX_HELP7, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*6, DRAW_DIALOGBOX_HELP7, 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*7) && (msY < sY +50+15*8))
		PutAlignedString(sX, sX+szX, sY + 50 +15*7, DRAW_DIALOGBOX_HELP8, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*7, DRAW_DIALOGBOX_HELP8, 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*8) && (msY < sY +50+15*9))
		PutAlignedString(sX, sX+szX, sY + 50 +15*8, DRAW_DIALOGBOX_HELP9, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*8, DRAW_DIALOGBOX_HELP9, 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*9) && (msY < sY +50+15*10))
		PutAlignedString(sX, sX+szX, sY + 50 +15*9, DRAW_DIALOGBOX_HELP10, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*9, DRAW_DIALOGBOX_HELP10, 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*10) && (msY < sY +50+15*11))
		PutAlignedString(sX, sX+szX, sY + 50 +15*10, DRAW_DIALOGBOX_HELP11, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*10, DRAW_DIALOGBOX_HELP11, 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*11) && (msY < sY +50+15*12))
		PutAlignedString(sX, sX+szX, sY + 50 +15*11,DRAW_DIALOGBOX_HELP12, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*11,DRAW_DIALOGBOX_HELP12, 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*12) && (msY < sY +50+15*13))
		PutAlignedString(sX, sX+szX, sY + 50 +15*12,"F.A.Q.", 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*12,"F.A.Q.", 4, 0, 50);
	if ((msX >= sX+25) && (msX <= sX+248) && (msY >= sY +50+15*13) && (msY < sY +50+15*14))
		PutAlignedString(sX, sX+szX, sY + 50 +15*13,DRAW_DIALOGBOX_HELP13, 255, 255, 255);
	else PutAlignedString(sX, sX+szX, sY + 50 +15*13,DRAW_DIALOGBOX_HELP13, 4, 0, 50);

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
}

void CGame::DrawDialogBox_ItemUpgrade(int msX, int msY)
{int i, sX, sY, iValue;
 char cItemColor, cStr1[120], cStr2[120], cStr3[120];
 DWORD dwTime = timeGetTime();

	sX = m_stDialogBoxInfo[34].sX;
	sY = m_stDialogBoxInfo[34].sY;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT , sX, sY, 5); //Item Upgrade Text

	switch (m_stDialogBoxInfo[34].cMode) {
	case 1://Gizon box Drag item needed to be upgraded"
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 30, DRAW_DIALOGBOX_ITEMUPGRADE1); // Drag item needed to be upgraded"
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 45, DRAW_DIALOGBOX_ITEMUPGRADE2); // "from the inventory. Then press"
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 60, DRAW_DIALOGBOX_ITEMUPGRADE3); // 'Upgrade' button."
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 46);

#ifdef DEF_EQUILIBRIUM_PROJECT // Needed Upgrade pt
		wsprintf(G_cTxt, "Gizon points available : %d:", m_iGizonItemUpgradeLeft);
		PutAlignedString(sX + 24, sX + 248, sY + 100, G_cTxt);
		if (m_stDialogBoxInfo[34].sV1 != -1)
		{	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			// Server doesnt send this value, so I made it send as bit 24 of attribute
			//iValue = pow(2, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sItemSpecEffectValue3);
			iValue = (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_dwAttribute & 0x0F000000) >> 24;

			// Angelic Cost
			if (   (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos >= 11)
				&& (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cItemType == 1))	
			{	if(   (memcmp(m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cName, "AngelicPandent(STR)", 19) == 0)
					|| (memcmp(m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cName, "AngelicPandent(DEX)", 19) == 0)
					|| (memcmp(m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cName, "AngelicPandent(INT)", 19) == 0)
					|| (memcmp(m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cName, "AngelicPandent(MAG)", 19) == 0))
				{	iValue = (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_dwAttribute & 0xF0000000) >> 28;
					switch (iValue) {
					case 0:	iValue = 2; break;
					case 1: iValue = 4; break;
					case 2: iValue = 6; break;
					case 3: iValue = 8; break;
					case 4: iValue = 10; break;
					case 5: iValue = 12; break;
					case 6: iValue = 14; break;
					case 7: iValue = 16; break;
					case 8: iValue = 18; break;
					case 9: iValue = 20; break;
					case 10: iValue = 22; break;
					case 11: iValue = 24; break;
					case 12: iValue = 26; break;
					case 13: iValue = 28; break;
					case 14: iValue = 30; break;
					}
					wsprintf( G_cTxt, "Angelic upgrade gizon cost: %d", iValue );
					if( m_iGizonItemUpgradeLeft < iValue )
						 PutAlignedString(sX + 24, sX + 248, sY + 115, G_cTxt, 195,25,25);
					else PutAlignedString(sX + 24, sX + 248, sY + 115, G_cTxt);
				}	
			}else if (iValue == 0) // Unknown cost
			{	PutAlignedString(sX + 24, sX + 248, sY + 115, "cost 1st upg: 1, 2nd: 2, 3rd: 4, 4th: 8 ...");
			}else
			{	// Faudra modifier le serveur en consequence!
				iValue = pow(2, iValue);
				wsprintf( G_cTxt, "Indicative needed gizon: %d", iValue );
				if ((msX > sX +24) && (msX < sX +248) && (msY > sY + 115 ) && (msY < sY +130))
				{	PutAlignedString(sX + 24, sX + 248, sY + 115, "(indicative value, can be higher)");
					ZeroMemory(G_cTxt, sizeof(G_cTxt));
				}else if( m_iGizonItemUpgradeLeft < iValue )
					 PutAlignedString(sX + 24, sX + 248, sY + 115, G_cTxt, 195,25,25);
				else PutAlignedString(sX + 24, sX + 248, sY + 115, G_cTxt);
			}

#else
		wsprintf(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE11, m_iGizonItemUpgradeLeft);		// "Item upgrade point : %d"
		PutAlignedString(sX + 24, sX + 248, sY + 100, G_cTxt);
		if (m_stDialogBoxInfo[34].sV1 != -1)
		{	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			iValue = (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_dwAttribute & 0xF0000000) >> 28;
			iValue = iValue*(iValue+6)/8 + 2;
			if (   (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos >= 11)
				&& (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cItemType == 1))	
			{	if(   (memcmp(m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cName, "AngelicPandent(STR)", 19) == 0)
					|| (memcmp(m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cName, "AngelicPandent(DEX)", 19) == 0)
					|| (memcmp(m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cName, "AngelicPandent(INT)", 19) == 0)
					|| (memcmp(m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cName, "AngelicPandent(MAG)", 19) == 0))
				{	iValue = (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_dwAttribute & 0xF0000000) >> 28;
					switch (iValue) {
					case 0:	iValue = 10; break;
					case 1: iValue = 11; break;
					case 2: iValue = 13; break;
					case 3: iValue = 16; break;
					case 4: iValue = 20; break;
					case 5: iValue = 25; break;
					case 6: iValue = 31; break;
					case 7: iValue = 38; break;
					case 8: iValue = 46; break;
					case 9: iValue = 55; break;
			}	}	}
			wsprintf( G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE12, iValue ); //"Needed upgrade point : %d"
			if( m_iGizonItemUpgradeLeft < iValue )
				 PutAlignedString(sX + 24, sX + 248, sY + 115, G_cTxt, 195,25,25);
			else PutAlignedString(sX + 24, sX + 248, sY + 115, G_cTxt);
#endif

			i = m_stDialogBoxInfo[34].sV1;
			cItemColor = m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cItemColor;
			if (   (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
				|| (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_RHAND)
				|| (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
			}else
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
			}
			ZeroMemory(cStr1, sizeof(cStr1));
			ZeroMemory(cStr2, sizeof(cStr2));
			ZeroMemory(cStr3, sizeof(cStr3));
			GetItemName(m_pItemList[m_stDialogBoxInfo[34].sV1], cStr1, cStr2, cStr3);
			PutAlignedString(sX + 24, sX + 248, sY +230 +20, cStr1);
			PutAlignedString(sX + 24, sX + 248, sY +245 +20, cStr2);
			PutAlignedString(sX + 24, sX + 248, sY +260 +20, cStr3);
			if( m_iGizonItemUpgradeLeft < iValue )
				DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 46);
			else
			{	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
					DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY +DEF_BTNPOSY, 47);
				else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY +DEF_BTNPOSY, 46);
			}
		}
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 46);
		// Cancel
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 2: // in progress
		PutAlignedString(sX + 24, sX + 248, sY + 55 + 30 + 282 -117 -170, DRAW_DIALOGBOX_ITEMUPGRADE5);
		PutAlignedString(sX + 24, sX + 248, sY + 55 + 45 + 282 -117 -170, DRAW_DIALOGBOX_ITEMUPGRADE6);
		if (m_stDialogBoxInfo[34].sV1 != -1)
		{	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			i = m_stDialogBoxInfo[34].sV1;
			cItemColor = m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cItemColor;
			if (   (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
				|| (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_RHAND)
				|| (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182
					, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
			}else
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182
					, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
			}
			if ((rand() % 5) == 0) m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutTransSprite25(sX + 134, sY +182, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, dwTime);
			ZeroMemory(cStr1, sizeof(cStr1));
			ZeroMemory(cStr2, sizeof(cStr2));
			ZeroMemory(cStr3, sizeof(cStr3));
			GetItemName(m_pItemList[m_stDialogBoxInfo[34].sV1], cStr1, cStr2, cStr3);
			PutAlignedString(sX + 24, sX + 248, sY +230 +20, cStr1);
			PutAlignedString(sX + 24, sX + 248, sY +245 +20, cStr2);
			PutAlignedString(sX + 24, sX + 248, sY +260 +20, cStr3);
		}
		if (((dwTime - m_stDialogBoxInfo[34].dwV1)/1000 > 4) && (m_stDialogBoxInfo[34].dwV1 != NULL))
		{	m_stDialogBoxInfo[34].dwV1 = NULL;
			bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_UPGRADEITEM, NULL, m_stDialogBoxInfo[34].sV1, NULL, NULL, NULL);
		}
		break;

	case 3: // Congratulations
		PutAlignedString(sX + 24, sX + 248, sY + 55 + 30 + 282 -117 -170, DRAW_DIALOGBOX_ITEMUPGRADE7);//"Congratulation! item upgrade"
		PutAlignedString(sX + 24, sX + 248, sY + 55 + 45 + 282 -117 -170, DRAW_DIALOGBOX_ITEMUPGRADE8);//"has been succeeded."
		if (m_stDialogBoxInfo[34].sV1 != -1) 
		{	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			i = m_stDialogBoxInfo[34].sV1;
			cItemColor = m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cItemColor;
			if (   (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
				|| (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_RHAND)
				|| (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182
					, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
			}else
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182
					, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
			}
			ZeroMemory(cStr1, sizeof(cStr1));
			ZeroMemory(cStr2, sizeof(cStr2));
			ZeroMemory(cStr3, sizeof(cStr3));
			GetItemName(m_pItemList[m_stDialogBoxInfo[34].sV1], cStr1, cStr2, cStr3);
			PutAlignedString(sX + 24, sX + 248, sY +230 +20, cStr1);
			PutAlignedString(sX + 24, sX + 248, sY +245 +20, cStr2);
			PutAlignedString(sX + 24, sX + 248, sY +260 +20, cStr3);
		}
		// OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 4: // Failed
		PutAlignedString(sX + 24, sX + 248, sY + 55 + 30 + 282 -117 -170, DRAW_DIALOGBOX_ITEMUPGRADE9);//"Item upgrade has failed."
		if ((m_stDialogBoxInfo[34].sV1 != -1) && (m_pItemList[m_stDialogBoxInfo[34].sV1] == NULL))
		{	PlaySound('E', 24, 0, 0);
			m_stDialogBoxInfo[34].cMode = 7;
			return;
		}
		if (m_stDialogBoxInfo[34].sV1 != -1)
		{	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			i = m_stDialogBoxInfo[34].sV1;
			cItemColor = m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cItemColor;
			if (   (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
				|| (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_RHAND)
				|| (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182
					, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
			}else
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182
					, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
			}
			ZeroMemory(cStr1, sizeof(cStr1));
			ZeroMemory(cStr2, sizeof(cStr2));
			ZeroMemory(cStr3, sizeof(cStr3));
			GetItemName(m_pItemList[m_stDialogBoxInfo[34].sV1], cStr1, cStr2, cStr3);
			PutAlignedString(sX + 24, sX + 248, sY +230 +20, cStr1);
			PutAlignedString(sX + 24, sX + 248, sY +245 +20, cStr2);
			PutAlignedString(sX + 24, sX + 248, sY +260 +20, cStr3);
		}

		// OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

#ifdef DEF_EQUILIBRIUM_PROJECT // Item upgrade DrawBox Menu global
	case 5: // select Stone/ Gizon
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 25, "Select enchantment's kind:");

		if ((msX > sX +24) && (msX < sX +248) && (msY > sY +80) && (msY < sY +95))
		{	PutAlignedString(sX + 24, sX + 248, sY + 80,  "Normal item upgrade", 255,255,255);
			PutAlignedString(sX + 24, sX + 248, sY + 150, "Upgrading a normal item.");
			PutAlignedString(sX + 24, sX + 248, sY + 170, "With weapon upgrading,");
			PutAlignedString(sX + 24, sX + 248, sY + 185, "Stone of Xelima is needed.");
			PutAlignedString(sX + 24, sX + 248, sY + 200, "With armor items upgrading,");
			PutAlignedString(sX + 24, sX + 248, sY + 215, "Stone of Merien is needed." );

			PutAlignedString(sX + 24, sX + 248, sY + 255, "* Ancient or Strong items");
			PutAlignedString(sX + 24, sX + 248, sY + 270, " cannot be upgraded this way.");
		}else PutAlignedString(sX + 24, sX + 248, sY + 80, "Normal item upgrade", 4,0,50);

		if ((msX > sX +24) && (msX < sX +248) && (msY > sY +100) && (msY < sY +115))
		{	PutAlignedString(sX + 24, sX + 248, sY + 100, "Item enchantment", 255,255,255);
			PutAlignedString(sX + 24, sX + 248, sY + 150, "Enchant a manufactured item.");
			PutAlignedString(sX + 24, sX + 248, sY + 170, "A single Magic Oil is needed");
			PutAlignedString(sX + 24, sX + 248, sY + 185, "to enchant the item. You may");
			PutAlignedString(sX + 24, sX + 248, sY + 200, "use an Elixir to obtain a");
			PutAlignedString(sX + 24, sX + 248, sY + 215, "stated item, and a Ball to");
			PutAlignedString(sX + 24, sX + 248, sY + 230, "enhance the enchantment.");

			PutAlignedString(sX + 24, sX + 248, sY + 255, "* Only manufuctured items");
			PutAlignedString(sX + 24, sX + 248, sY + 270, " can be enchanted this way.");
		}else PutAlignedString(sX + 24, sX + 248, sY + 100, "Item enchantment", 4,0,50);

		if ((msX > sX +24) && (msX < sX +248) && (msY > sY +120) && (msY < sY +135))
		{	PutAlignedString(sX + 24, sX + 248, sY + 120, "Gizon item upgrade", 255,255,255);
			PutAlignedString(sX + 24, sX + 248, sY + 150, "Improving stated item.");
			PutAlignedString(sX + 24, sX + 248, sY + 170, "In order to improve stated items,");
			PutAlignedString(sX + 24, sX + 248, sY + 185, "enough gizon points are required.");
			PutAlignedString(sX + 24, sX + 248, sY + 200, "Each successive upgrade will");
			PutAlignedString(sX + 24, sX + 248, sY + 215, "double the needed points.");

			PutAlignedString(sX + 24, sX + 248, sY + 255, "* Only already enchanted items");
			PutAlignedString(sX + 24, sX + 248, sY + 270, " can be improved this way.");
		}else PutAlignedString(sX + 24, sX + 248, sY + 120, "Gizon item upgrade", 4,0,50);


#else
	case 5: // select Stone/ Gizon
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 45, DRAW_DIALOGBOX_ITEMUPGRADE13); // "Select which kind of items to upgrade."
		if ((msX > sX +24) && (msX < sX +248) && (msY > sY +100) && (msY < sY +115))
		{	PutAlignedString(sX + 24, sX + 248, sY + 100, DRAW_DIALOGBOX_ITEMUPGRADE14, 255,255,255); // "Normal item upgrade"
			PutAlignedString(sX + 24, sX + 248, sY + 150, DRAW_DIALOGBOX_ITEMUPGRADE16); // "Upgrading a normal item."
			PutAlignedString(sX + 24, sX + 248, sY + 165, DRAW_DIALOGBOX_ITEMUPGRADE17); // "With upgrading weapon"
			PutAlignedString(sX + 24, sX + 248, sY + 180, DRAW_DIALOGBOX_ITEMUPGRADE18); // "items, Stone of Xelima"
			PutAlignedString(sX + 24, sX + 248, sY + 195, DRAW_DIALOGBOX_ITEMUPGRADE19); // "is needed. With upgrading"
			PutAlignedString(sX + 24, sX + 248, sY + 210, DRAW_DIALOGBOX_ITEMUPGRADE20); // "armor items, Stone of"
			PutAlignedString(sX + 24, sX + 248, sY + 225, DRAW_DIALOGBOX_ITEMUPGRADE21); // "Merien is needed."
			PutAlignedString(sX + 24, sX + 248, sY + 255, DRAW_DIALOGBOX_ITEMUPGRADE26); // "* Majestic items cannot be"
			PutAlignedString(sX + 24, sX + 248, sY + 270, DRAW_DIALOGBOX_ITEMUPGRADE27); // "upgraded with this performance."
		}else PutAlignedString(sX + 24, sX + 248, sY + 100, DRAW_DIALOGBOX_ITEMUPGRADE14, 4,0,50); // "Normal item upgrade"
		if ((msX > sX +24) && (msX < sX +248) && (msY > sY +120) && (msY < sY +135))
		{	PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_ITEMUPGRADE15, 255,255,255); // "Majestic item upgrade"
			PutAlignedString(sX + 24, sX + 248, sY + 150, DRAW_DIALOGBOX_ITEMUPGRADE22); // "Upgrading majestic items."
			PutAlignedString(sX + 24, sX + 248, sY + 165, DRAW_DIALOGBOX_ITEMUPGRADE23); // "In order to upgrade majestic items,"
			PutAlignedString(sX + 24, sX + 248, sY + 180, DRAW_DIALOGBOX_ITEMUPGRADE24); // "enough upgrade points for"
			PutAlignedString(sX + 24, sX + 248, sY + 195, DRAW_DIALOGBOX_ITEMUPGRADE25); // "majestic items are required."
			PutAlignedString(sX + 24, sX + 248, sY + 225, DRAW_DIALOGBOX_ITEMUPGRADE28); // "* Normal items cannot be"
			PutAlignedString(sX + 24, sX + 248, sY + 240, DRAW_DIALOGBOX_ITEMUPGRADE29); // "upgraded with this performance."
		}else PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_ITEMUPGRADE15, 4,0,50); // "Majestic item upgrade"
#endif
		// Cancel
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 6: // Stone upgrade
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 30, DRAW_DIALOGBOX_ITEMUPGRADE31); // "After bring a normal item to"
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 45, DRAW_DIALOGBOX_ITEMUPGRADE32); //
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 60, DRAW_DIALOGBOX_ITEMUPGRADE33); //
		if( m_stDialogBoxInfo[34].sV2 == 0 )
		{	PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, DRAW_DIALOGBOX_ITEMUPGRADE41, 195,25,25);//"You can upgrade only armor."
		}else
		{	wsprintf(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE34, m_stDialogBoxInfo[34].sV2);//"The number of upgrade(weapon): %d"
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, G_cTxt);
		}
		if( m_stDialogBoxInfo[34].sV3 == 0 )
		{	PutAlignedString(sX + 24, sX + 248, sY + 20 + 95, DRAW_DIALOGBOX_ITEMUPGRADE42, 195,25,25);//"You can upgrade only weapon."
		}else
		{	wsprintf(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE35, m_stDialogBoxInfo[34].sV3);//"The number of upgrade(armor): %d"
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 95, G_cTxt);
		}

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 46);

		if (m_stDialogBoxInfo[34].sV1 != -1)
		{	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			i = m_stDialogBoxInfo[34].sV1;
			cItemColor = m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cItemColor;
			if (   (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
				|| (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_RHAND)
				|| (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182
					, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
			}else
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182
					, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
			}

			ZeroMemory(cStr1, sizeof(cStr1));
			ZeroMemory(cStr2, sizeof(cStr2));
			ZeroMemory(cStr3, sizeof(cStr3));
			GetItemName(m_pItemList[m_stDialogBoxInfo[34].sV1], cStr1, cStr2, cStr3);
			PutAlignedString(sX + 24, sX + 248, sY +230 +20, cStr1);
			PutAlignedString(sX + 24, sX + 248, sY +245 +20, cStr2);
			PutAlignedString(sX + 24, sX + 248, sY +260 +20, cStr3);
			if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
				 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 47);
			else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 46);
		}
		// Cancel
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;

	case 7: // lost item
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 130, DRAW_DIALOGBOX_ITEMUPGRADE36);//"Due to the failure of upgrade, the"
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 145, DRAW_DIALOGBOX_ITEMUPGRADE37);//"item is gone. Try next time!"
		// OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 8: // impossible deja au max
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 130, DRAW_DIALOGBOX_ITEMUPGRADE38);//"Upgrading the item is not possible any more."
		// OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 9: // impossible
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 130, DRAW_DIALOGBOX_ITEMUPGRADE39);//"Upgrading the item is not possible."
		// OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 10: // plus de gizons
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 130, DRAW_DIALOGBOX_ITEMUPGRADE40);//"A point to upgrade items is not present"
		// OK
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

#ifdef DEF_EQUILIBRIUM_PROJECT

	case 11: // Alchemy upgrade
		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 30, "After bringing a manuf item to");
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 45, "enchant from the inventory,");
		PutAlignedString(sX + 24, sX + 248, sY + 20 + 60, "press the 'Upgrade' button.");

		if (m_pItemList[m_stDialogBoxInfo[34].sV4] == NULL) m_stDialogBoxInfo[34].sV4 = -1;
		if (m_stDialogBoxInfo[34].sV4 != -1)
		{	ZeroMemory(G_cTxt, sizeof(G_cTxt));
			if (strcmp (m_pItemList[m_stDialogBoxInfo[34].sV4]->m_cName, "Stone") == 0)
			{	PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, "You may enchant a weapon as Ancient.");
			}else if (strcmp (m_pItemList[m_stDialogBoxInfo[34].sV4]->m_cName, "SharpnessOil") == 0)
			{	PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, "You may enchant a weapon as Sharp,");
				PutAlignedString(sX + 24, sX + 248, sY + 20 + 95, "or an armor as Mana converting.");
			}else if (strcmp (m_pItemList[m_stDialogBoxInfo[34].sV4]->m_cName, "AgilityOil") == 0)
			{	PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, "You may enchant a weapon as Agile,");
				PutAlignedString(sX + 24, sX + 248, sY + 20 + 95, "or an armor as Light");
			}else if (strcmp (m_pItemList[m_stDialogBoxInfo[34].sV4]->m_cName, "PoisonOil") == 0)
			{	PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, "You may Poison a weapon.");
			}else if (strcmp (m_pItemList[m_stDialogBoxInfo[34].sV4]->m_cName, "BerzerkOil") == 0)
			{	PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, "You may enchant a weapon as Critical,");
				PutAlignedString(sX + 24, sX + 248, sY + 20 + 95, "or an armor as Critical Increase.");
			}else if (strcmp (m_pItemList[m_stDialogBoxInfo[34].sV4]->m_cName, "TruthOil") == 0)
			{	PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, "You may enchant a weapon as Righteous.");
			}
		}else
		{	PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, "You need Magic Oil in bag to enchant!");
		}

		DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 46);

		if (m_stDialogBoxInfo[34].sV1 != -1)
		{	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			i = m_stDialogBoxInfo[34].sV1;
			cItemColor = m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cItemColor;
			if (   (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_LHAND)
				|| (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_RHAND)
				|| (m_pItemList[m_stDialogBoxInfo[34].sV1]->m_cEquipPos == DEF_EQUIPPOS_TWOHAND))
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182
					, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wWR[cItemColor] -m_wR[0], m_wWG[cItemColor] -m_wG[0], m_wWB[cItemColor] -m_wB[0], dwTime);
			}else
			{	m_pSprite[DEF_SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY +182
					, m_pItemList[m_stDialogBoxInfo[34].sV1]->m_sSpriteFrame, m_wR[cItemColor] -m_wR[0], m_wG[cItemColor] -m_wG[0], m_wB[cItemColor] -m_wB[0], dwTime);
			}

			ZeroMemory(cStr1, sizeof(cStr1));
			ZeroMemory(cStr2, sizeof(cStr2));
			ZeroMemory(cStr3, sizeof(cStr3));
			GetItemName(m_pItemList[m_stDialogBoxInfo[34].sV1], cStr1, cStr2, cStr3);
			PutAlignedString(sX + 24, sX + 248, sY +230 +20, cStr1);
			PutAlignedString(sX + 24, sX + 248, sY +245 +20, cStr2);
			PutAlignedString(sX + 24, sX + 248, sY +260 +20, cStr3);
			if (   (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX)
				&& (msY >= sY + DEF_BTNPOSY)  && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY)
				&& (m_stDialogBoxInfo[34].sV4 != -1))
				 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 47);
			else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 46);
		}
		// Cancel
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 17);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 16);
		break;


	case 12: // 12 Need stone!
		PutAlignedString(sX + 24, sX + 248, sY + 100, "Xelima or Merien stone needed!", 195,25,25);
		PutAlignedString(sX + 24, sX + 248, sY + 150, "When upgrading weapons,");
		PutAlignedString(sX + 24, sX + 248, sY + 165, "Stone of Xelima is needed.");
		PutAlignedString(sX + 24, sX + 248, sY + 180, "When upgrading armor items,");
		PutAlignedString(sX + 24, sX + 248, sY + 195, "Stone of Merien is needed." );
		// Cancel
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 13: // 13 remove stones!
		PutAlignedString(sX + 24, sX + 248, sY + 100, "Remove Xelima or Merien stone!", 195,25,25);
		PutAlignedString(sX + 24, sX + 248, sY + 150, "When enchanting manuf items,");
		PutAlignedString(sX + 24, sX + 248, sY + 165, "or upgrading enchanted items,");
		PutAlignedString(sX + 24, sX + 248, sY + 180, "Stone of Xelima or Merien must");
		PutAlignedString(sX + 24, sX + 248, sY + 195, "be removed from your bag.");
		// Cancel
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 14: // 14 No Oil present
		PutAlignedString(sX + 24, sX + 248, sY + 100, "Magic Oil needed!", 195,25,25);
		PutAlignedString(sX + 24, sX + 248, sY + 150, "When enchanting manuf items,");
		PutAlignedString(sX + 24, sX + 248, sY + 165, "a Magic Oil must be placed");
		PutAlignedString(sX + 24, sX + 248, sY + 180, "in your bag.");
		// Cancel
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 15: // 15 too much Oil error
		PutAlignedString(sX + 24, sX + 248, sY + 100, "Too much Magic Oils!", 195,25,25);
		PutAlignedString(sX + 24, sX + 248, sY + 150, "When enchanting manuf items,");
		PutAlignedString(sX + 24, sX + 248, sY + 165, "a SINGLE Magic Oil must be");
		PutAlignedString(sX + 24, sX + 248, sY + 180, "found in your bag.");
		// Cancel
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 16: // 16 too much Elixir error
		PutAlignedString(sX + 24, sX + 248, sY + 100, "Too much Magic Elixirs!", 195,25,25);
		PutAlignedString(sX + 24, sX + 248, sY + 150, "When enchanting manuf items,");
		PutAlignedString(sX + 24, sX + 248, sY + 165, "a SINGLE Magic Elixir must");
		PutAlignedString(sX + 24, sX + 248, sY + 180, "be found in your bag.");
		// Cancel
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

	case 17: // 17 remove Oils
		PutAlignedString(sX + 24, sX + 248, sY + 100, "Remove Magic Oil(s)!", 195,25,25);
		PutAlignedString(sX + 24, sX + 248, sY + 150, "In order to improve stated items,");
		PutAlignedString(sX + 24, sX + 248, sY + 165, "you must remove any Magic Oil");
		PutAlignedString(sX + 24, sX + 248, sY + 180, "or Strange Stone from your bag.");
		// Cancel
		if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + DEF_BTNPOSY) && (msY <= sY + DEF_BTNPOSY + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
		else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
		break;

#endif
	}
}

LONG CGame::GetRegKey(HKEY key, LPCTSTR subkey, LPTSTR retdata)
{   HKEY hkey;
    LONG retval = RegOpenKeyEx(key, subkey, 0, KEY_QUERY_VALUE, &hkey);
    if (retval == ERROR_SUCCESS)
	{  long datasize = MAX_PATH;
        TCHAR data[MAX_PATH];
        RegQueryValue(hkey, NULL, data, &datasize);
        lstrcpy(retdata,data);
        RegCloseKey(hkey);
    }
    return retval;
}

void CGame::GoHomepage()
{	LPCTSTR	url;
	url = MSG_HOMEPAGE;
	int		showcmd = SW_SHOW;
	char	key[MAX_PATH + MAX_PATH];
	SendMessage( G_hWnd, WM_ACTIVATEAPP, 0, 0 );
    // First try ShellExecute()
    HINSTANCE result = ShellExecute(NULL, "open", url, NULL,NULL, showcmd);

    // If it failed, get the .htm regkey and lookup the program
    if ((UINT)result <= HINSTANCE_ERROR)
	{  if (GetRegKey(HKEY_CLASSES_ROOT, ".htm", key) == ERROR_SUCCESS)
		{   lstrcat(key, "\\shell\\open\\command");

            if (GetRegKey(HKEY_CLASSES_ROOT,key,key) == ERROR_SUCCESS)
			{  char *pos;
                pos = strstr(key, "\"%1\"");
                if (pos == NULL)					// No quotes found
				{  pos = strstr(key, "%1");			// Check for %1, without quotes
                    if (pos == NULL)				// No parameter at all...
                        pos = key+lstrlen(key)-1;
                    else *pos = '\0';				// Remove the parameter
                }else    *pos = '\0';				// Remove the parameter
                lstrcat(pos, " ");
                lstrcat(pos, url);
                result = (HINSTANCE) WinExec(key,showcmd);
    }   }   }
}

// num : 1 - F2, 2 - F3
void CGame::UseShortCut( int num )
{int index;
	if( num < 3 ) index = num+1;
	else index = num+7;
	if(m_cGameMode != DEF_GAMEMODE_ONMAINGAME) return;
	if (m_bCtrlPressed == TRUE)
	{	if (m_sRecentShortCut == -1)
		{	AddEventList(MSG_SHORTCUT1, 10);
			wsprintf( G_cTxt, MSG_SHORTCUT2, index );// [F%d]
			AddEventList(G_cTxt, 10);
			wsprintf( G_cTxt, MSG_SHORTCUT3, index );// [Control]-[F%d]
			AddEventList(G_cTxt, 10);
		}else
		{	m_sShortCut[num] = m_sRecentShortCut;
			if (m_sShortCut[num] < 100)
			{	if (m_pItemList[m_sShortCut[num]] == NULL)
				{	m_sShortCut[num] = -1;
					m_sRecentShortCut = -1;
					return;
				}
				char cStr1[64], cStr2[64], cStr3[64];
				ZeroMemory(cStr1, sizeof(cStr1));
				ZeroMemory(cStr2, sizeof(cStr2));
				ZeroMemory(cStr3, sizeof(cStr3));

				GetItemName(m_pItemList[m_sShortCut[num]], cStr1, cStr2, cStr3);
				wsprintf(G_cTxt, MSG_SHORTCUT4, cStr1, cStr2, cStr3, index);// (%s %s %s) [F%d]
				AddEventList(G_cTxt, 10);
			}else if (m_sShortCut[num] >= 100)
			{	if (m_pMagicCfgList[m_sShortCut[num]-100] == NULL)
				{	m_sShortCut[num] = -1;
					m_sRecentShortCut = -1;
					return;
				}
				wsprintf(G_cTxt, MSG_SHORTCUT5, m_pMagicCfgList[m_sShortCut[num]-100]->m_cName, index);// %s) [F%d]
				AddEventList(G_cTxt, 10);
		}	}
	}else
	{	if (m_sShortCut[num] == -1)
		{	AddEventList(MSG_SHORTCUT1, 10);
			wsprintf( G_cTxt, MSG_SHORTCUT2, index );// [F%d]
			AddEventList(G_cTxt, 10);
			wsprintf( G_cTxt, MSG_SHORTCUT3, index );// [Control]-[F%d]
			AddEventList(G_cTxt, 10);
		}else if (m_sShortCut[num] < 100)
		{	ItemEquipHandler((char)m_sShortCut[num]);
		}
		else if (m_sShortCut[num] >= 100) UseMagic(m_sShortCut[num]-100);
	}
}

int CGame::iGetManaCost(int iMagicNo)
{	int i, iManaSave, iManaCost, iTemp;
	iManaSave = 0;
	if( iMagicNo < 0 || iMagicNo >= 100 ) return 1;
	for( i=0; i<DEF_MAXITEMS ; i++ )
	{	if( m_pItemList[i] == NULL ) continue;
		if( m_bIsItemEquipped[i] == TRUE )
		{	if(      strcmp( m_pItemList[i]->m_cName, "MagicWand(MS10)" ) == 0)		iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "MagicWand(MS20)" ) == 0)		iManaSave += 20;
			else if( strcmp( m_pItemList[i]->m_cName, "MagicWand(MS30-LLF)" ) == 0) iManaSave += 30;
			else if( strcmp( m_pItemList[i]->m_cName, "WizMagicWand(MS10)" ) == 0)	iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "WizMagicWand(MS20)" ) == 0)	iManaSave += 20;
			else if( strcmp( m_pItemList[i]->m_cName, "MagicNecklace(MS10)" ) == 0) iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "DarkMageMagicStaff" ) == 0)	iManaSave += 25;
			else if( strcmp( m_pItemList[i]->m_cName, "DarkMageMagicStaffW" ) == 0) iManaSave += 25;
			else if( strcmp( m_pItemList[i]->m_cName, "DarkMageMagicWand" ) == 0)	iManaSave += 28;
			else if( strcmp( m_pItemList[i]->m_cName, "NecklaceOfLiche") ==0)   	iManaSave += 15;
			// Snoopy: v351 wands
			else if( strcmp( m_pItemList[i]->m_cName, "DarkMageTempleWand" ) == 0)	iManaSave += 28;
			else if( strcmp( m_pItemList[i]->m_cName, "BerserkWand(MS.20)" ) == 0)	iManaSave += 20;
			else if( strcmp( m_pItemList[i]->m_cName, "BerserkWand(MS.10)" ) == 0)	iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "KlonessWand(MS.20)" ) == 0)	iManaSave += 20;
			else if( strcmp( m_pItemList[i]->m_cName, "KlonessWand(MS.10)" ) == 0)	iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "ResurWand(MS.20)" ) == 0)	iManaSave += 20;
			else if( strcmp( m_pItemList[i]->m_cName, "ResurWand(MS.10)" ) == 0)	iManaSave += 10;

			else if( strcmp( m_pItemList[i]->m_cName, "MagicNecklace(MS12)" ) == 0)	iManaSave += 12;
			else if( strcmp( m_pItemList[i]->m_cName, "MagicNecklace(MS14)" ) == 0)	iManaSave += 14;
			else if( strcmp( m_pItemList[i]->m_cName, "MagicNecklace(MS16)" ) == 0)	iManaSave += 16;
			else if( strcmp( m_pItemList[i]->m_cName, "MagicNecklace(MS18)" ) == 0)	iManaSave += 18;

#ifdef DEF_EQUILIBRIUM_PROJECT	// Equilibrium Project Items
			else if( strcmp( m_pItemList[i]->m_cName, "WandMS10" ) == 0)			iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "WandMS20" ) == 0)			iManaSave += 20;
			else if( strcmp( m_pItemList[i]->m_cName, "WandMS30" ) == 0)			iManaSave += 30;
			else if( strcmp( m_pItemList[i]->m_cName, "WizardMS10" ) == 0)			iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "WizardMS20" ) == 0)			iManaSave += 20;
			else if( strcmp( m_pItemList[i]->m_cName, "MasterMS25" ) == 0)			iManaSave += 25;
			else if( strcmp( m_pItemList[i]->m_cName, "WarlordMS28" ) == 0)			iManaSave += 28;
			else if( strcmp( m_pItemList[i]->m_cName, "KlonessMS20" ) == 0)			iManaSave += 20;
			else if( strcmp( m_pItemList[i]->m_cName, "KlonessMS28" ) == 0)			iManaSave += 28;
			else if( strcmp( m_pItemList[i]->m_cName, "ResurWandMS20" ) == 0)		iManaSave += 20;
			else if( strcmp( m_pItemList[i]->m_cName, "WandMShield" ) == 0)			iManaSave += 15;
			else if( strcmp( m_pItemList[i]->m_cName, "LichMS10" ) == 0)			iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "BloodWandMS40" ) == 0)		iManaSave += 10;
			else if( strcmp( m_pItemList[i]->m_cName, "NeckMS10" ) == 0)			
			{	iManaSave += 10;
				// Merien Upgraded items
				iTemp = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				iManaSave += iTemp;	
			}else if( strcmp( m_pItemList[i]->m_cName, "NeckMS15" ) == 0)	
			{	iManaSave += 15;
				// Merien Upgraded items			
				iTemp = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				iManaSave += iTemp;	
			}else if( strcmp( m_pItemList[i]->m_cName, "LicheArmorW" ) == 0)	
			{	iManaSave += 10;	
				// Merien Upgraded items			
				iTemp = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				iManaSave += iTemp;	
			}else if( strcmp( m_pItemList[i]->m_cName, "LicheArmorM" ) == 0)	
			{	iManaSave += 10;				
				// Merien Upgraded items	
				iTemp = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				iManaSave += iTemp;	
			}
#endif

	}	}			
	// Snoopy: MS max = 80%
	if (iManaSave > 80) iManaSave = 80;
	iManaCost = m_pMagicCfgList[iMagicNo]->m_sValue1;
	if (m_bIsSafeAttackMode) iManaCost += (iManaCost/2) - (iManaCost / 10);
	if (iManaSave > 0)
	{	double dV1 = (double)iManaSave;
		double dV2 = (double)(dV1 / 100.0f);
		double dV3 = (double)iManaCost;
		dV1 = dV2 * dV3;
		dV2 = dV3 - dV1;
		iManaCost = (int)dV2;
	}
	if( iManaCost < 1 ) iManaCost = 1;
	return iManaCost;
}

void CGame::UseMagic(int iMagicNo)
{	if( iMagicNo < 0 || iMagicNo >= 100 ) return;
	if ((m_cMagicMastery[iMagicNo] == NULL) || (m_pMagicCfgList[iMagicNo] == NULL)) return;

	// Casting
	if (m_iHP <= 0) return;
	if (m_bIsGetPointingMode == TRUE) return;
	if (iGetManaCost(iMagicNo) > m_iMP) return;
	if (_bIsItemOnHand() == TRUE)
	{	AddEventList(DLGBOX_CLICK_MAGIC1, 10);
		return;
	}
	if (m_bSkillUsingStatus == TRUE)
	{	AddEventList(DLGBOX_CLICK_MAGIC2, 10);
		return;
	}
	if ((m_sPlayerAppr2 & 0xF000) == 0) bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_TOGGLECOMBATMODE, NULL, NULL, NULL, NULL, NULL);
	m_cCommand = DEF_OBJECTMAGIC;
	m_iCastingMagicType = iMagicNo;
	m_sMagicShortCut    = iMagicNo;
	m_sRecentShortCut   = iMagicNo + 100;
	m_iPointCommandType = iMagicNo + 100;
	//m_bIsGetPointingMode = TRUE;
	DisableDialogBox(3);
}


void CGame::ReleaseEquipHandler(char cEquipPos)
{	char cStr1[64], cStr2[64], cStr3[64];
	//DebugLog("Debug: ReleaseEquipHandler: ...........");

	if( m_sItemEquipmentStatus[cEquipPos] < 0 ) return;
	// Remove Angelic Stats
	if (   (cEquipPos >= 11)
		&& (m_pItemList[m_sItemEquipmentStatus[cEquipPos]]->m_cItemType == 1))
	{	char cItemID = m_sItemEquipmentStatus[cEquipPos];
		if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(STR)", 19) == 0)
		{	m_iAngelicStr = 0;
		}else if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(DEX)", 19) == 0)
		{	m_iAngelicDex = 0;
		}else if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(INT)", 19) == 0)
		{	m_iAngelicInt = 0;
		}else if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(MAG)", 19) == 0)
		{	m_iAngelicMag = 0;
	}	}

	GetItemName(m_pItemList[m_sItemEquipmentStatus[cEquipPos]], cStr1, cStr2, cStr3);
	wsprintf(G_cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
	AddEventList(G_cTxt, 10);

/*	wsprintf(G_cTxt,"Debug: ReleaseEquipHandler: %s", cStr1);
	DebugLog(G_cTxt);*/

	m_bIsItemEquipped[m_sItemEquipmentStatus[cEquipPos]] = FALSE;
	m_sItemEquipmentStatus[cEquipPos] = -1;
}

void CGame::ItemEquipHandler(char cItemID)
{	if (bCheckItemOperationEnabled(cItemID) == FALSE) return;
	if (m_bIsItemEquipped[cItemID] == TRUE) return;
	if (m_pItemList[cItemID]->m_cEquipPos == DEF_EQUIPPOS_NONE)
	{	AddEventList(BITEMDROP_CHARACTER3, 10);//"The item is not available."
		return;
	}
	if ( m_pItemList[cItemID]->m_wCurLifeSpan == 0 )
	{	AddEventList(BITEMDROP_CHARACTER1, 10); //"The item is exhausted. Fix it to use it."
		return;
	}
	if (m_pItemList[cItemID]->m_wWeight / 100 > m_iStr + m_iAngelicStr)
	{	AddEventList(BITEMDROP_CHARACTER2, 10);
		return;
	}
	if (((m_pItemList[cItemID]->m_dwAttribute & 0x00000001) == 0) && (m_pItemList[cItemID]->m_sLevelLimit > m_iLevel)   )
	{	AddEventList(BITEMDROP_CHARACTER4, 10);
		return;
	}
	if (m_bSkillUsingStatus == TRUE)
	{	AddEventList(BITEMDROP_CHARACTER5, 10);
		return;
	}
	if (m_pItemList[cItemID]->m_cGenderLimit != 0)
	{	switch (m_sPlayerType) {
		case 1:
		case 2:
		case 3:
			if (m_pItemList[cItemID]->m_cGenderLimit != 1)
			{	AddEventList(BITEMDROP_CHARACTER6, 10);
				return;
			}
			break;
		case 4:
		case 5:
		case 6:
			if (m_pItemList[cItemID]->m_cGenderLimit != 2)
			{	AddEventList(BITEMDROP_CHARACTER7, 10);
				return;
			}
			break;
	}	}

	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_EQUIPITEM, NULL, cItemID, NULL, NULL, NULL);
	m_sRecentShortCut = cItemID;

	ReleaseEquipHandler(m_pItemList[cItemID]->m_cEquipPos);
	switch( m_pItemList[cItemID]->m_cEquipPos )	{
	case DEF_EQUIPPOS_HEAD:
	case DEF_EQUIPPOS_BODY:
	case DEF_EQUIPPOS_ARMS:
	case DEF_EQUIPPOS_PANTS:
	case DEF_EQUIPPOS_BOOTS:
	case DEF_EQUIPPOS_BACK:
		ReleaseEquipHandler(DEF_EQUIPPOS_FULLBODY);
		break;
	case DEF_EQUIPPOS_FULLBODY:
		ReleaseEquipHandler(DEF_EQUIPPOS_HEAD);
		ReleaseEquipHandler(DEF_EQUIPPOS_BODY);
		ReleaseEquipHandler(DEF_EQUIPPOS_ARMS);
		ReleaseEquipHandler(DEF_EQUIPPOS_PANTS);
		ReleaseEquipHandler(DEF_EQUIPPOS_BOOTS);
		ReleaseEquipHandler(DEF_EQUIPPOS_BACK);
		break;
	case DEF_EQUIPPOS_LHAND:
	case DEF_EQUIPPOS_RHAND:
		ReleaseEquipHandler(DEF_EQUIPPOS_TWOHAND);
		break;
	case DEF_EQUIPPOS_TWOHAND:
		ReleaseEquipHandler(DEF_EQUIPPOS_RHAND);
		ReleaseEquipHandler(DEF_EQUIPPOS_LHAND);
		break;
	}

	m_sItemEquipmentStatus[ m_pItemList[cItemID]->m_cEquipPos ] = cItemID;
	m_bIsItemEquipped[cItemID] = TRUE;

/*	wsprintf(G_cTxt,"Debug Equiped Item: %s", m_pItemList[cItemID]->m_cName);
	DebugLog(G_cTxt);*/



	// Add Angelic Stats
	if (   (m_pItemList[cItemID]->m_cItemType == 1)
		&& (m_pItemList[cItemID]->m_cEquipPos >= 11))
	{	int iAngelValue = 0;
		if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(STR)", 19) == 0)
		{	iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			m_iAngelicStr = iAngelValue;
		}else if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(DEX)", 19) == 0)
		{	iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			m_iAngelicDex = iAngelValue;
		}else if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(INT)", 19) == 0)
		{	iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			m_iAngelicInt = iAngelValue;
		}else if(memcmp(m_pItemList[cItemID]->m_cName, "AngelicPandent(MAG)", 19) == 0)
		{	iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			m_iAngelicMag = iAngelValue;
	}	}

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
	wsprintf(G_cTxt, BITEMDROP_CHARACTER9, cStr1);
	AddEventList(G_cTxt, 10);
	PlaySound('E', 28, 0);
}

/*********************************************************************************************************************
**  void CheckActiveAura(short sX, short sY, DWORD dwTime, short sOwnerType)( initially Cleroth fixed by Snoopy )	**
**  description			: Generates special auras around players													**
**						: v351 implements this in each drawn function,beter to regroup in single function.			**
**********************************************************************************************************************/
void CGame::CheckActiveAura(short sX, short sY, DWORD dwTime, short sOwnerType)
{	// Used at the beginning of character drawing
	// DefenseShield
	if ((_tmp_iStatus & 0x02000000) != 0)
		//m_pEffectSpr[80]->PutTransSprite(sX+75, sY+107, _tmp_iEffectFrame%17, dwTime);
		m_pEffectSpr[80]->PutTransSprite50(sX+75, sY+107, _tmp_iEffectFrame%17, dwTime);

	// Protection From Magic
	if ((_tmp_iStatus & 0x04000000) != 0)
		//m_pEffectSpr[79]->PutTransSprite(sX+101, sY+135, _tmp_iEffectFrame%15, dwTime);
		m_pEffectSpr[79]->PutTransSprite70(sX+101, sY+135, _tmp_iEffectFrame%15, dwTime);

	// Protection From Arrow
	if ((_tmp_iStatus & 0x08000000) != 0)
		//m_pEffectSpr[72]->PutTransSprite(sX, sY+35, _tmp_iEffectFrame%30, dwTime);
		m_pEffectSpr[72]->PutTransSprite70(sX, sY+35, _tmp_iEffectFrame%30, dwTime);

	// Illusion
	if ((_tmp_iStatus & 0x01000000) != 0)
		//m_pEffectSpr[73]->PutTransSprite(sX+125, sY+95, _tmp_iEffectFrame%24, dwTime);
		m_pEffectSpr[73]->PutTransSprite70(sX+125, sY+130 - _iAttackerHeight[sOwnerType], _tmp_iEffectFrame%24, dwTime);

	// Illusion movement
	if ((_tmp_iStatus & 0x00200000) != 0)
		//m_pEffectSpr[151]->PutTransSprite(sX+90, sY+55, _tmp_iEffectFrame%24, dwTime);
		m_pEffectSpr[151]->PutTransSprite70(sX+90, sY+90 - _iAttackerHeight[sOwnerType], _tmp_iEffectFrame%24, dwTime);

/*	// Hero Flag (Heldenian)  Flameches d'entangle
	if ((_tmp_iStatus & 0x00020000) != 0)
		m_pEffectSpr[87]->PutTransSprite70(sX+53, sY+54, _tmp_iEffectFrame%29, dwTime);*/
}

/*********************************************************************************************************************
**  void CheckActiveAura2(short sX, short sY, DWORD dwTime,  _tmp_sOwnerType) ( initially Cleroth fixed by Snoopy )	**
**  description			: Generates poison aura around players. This one should be use later...						**
**						: v351 implements this in each drawn function,beter to regroup in single function.			**
**********************************************************************************************************************/
void CGame::CheckActiveAura2(short sX, short sY, DWORD dwTime, short sOwnerType)
{	// Poison
	if ((_tmp_iStatus & 0x80) != 0)
		//m_pEffectSpr[81]->PutTransSprite(sX+115, sY+85, _tmp_iEffectFrame%21, dwTime);
		m_pEffectSpr[81]->PutTransSprite70(sX+115, sY+120 - _iAttackerHeight[sOwnerType], _tmp_iEffectFrame%21, dwTime);
//	_iAttackerHeight[]

	if ((m_bIsHeldenianMode == TRUE) && (m_bIsHeldenianMap == TRUE))
	// En heldenian, seul le BloodyMantle est possible
	// mais le hero est aussi possible 
	{	if ((_tmp_iStatus & 0x00400000) != 0)			// BloodyMantle
			m_pEffectSpr[107]->PutTransSprite70(sX-5, sY, _tmp_iEffectFrame%15, dwTime);
		else if ((_tmp_iStatus & 0x00800000) != 0)		// Magic Mantle
			m_pEffectSpr[114]->PutTransSprite70(sX-5, sY, _tmp_iEffectFrame%15, dwTime);
		else if ((_tmp_iStatus & 0x00010000) != 0)		// ArrowMantle
			m_pEffectSpr[115]->PutTransSprite70(sX-5, sY, _tmp_iEffectFrame%15, dwTime);	

		if ((_tmp_iStatus & 0x00020000) != 0)
		m_pEffectSpr[87]->PutTransSprite70(sX+53, sY+54, _tmp_iEffectFrame%29, dwTime);
	}else
	// Hors Heldenian, l'effêt Hero est impossible, donc il donnera des Mantles au lieu de Slate effect
	{	if ((_tmp_iStatus & 0x00020000) != 0) // Si Hero Flag ==> Mantles
		{	if ((_tmp_iStatus & 0x00400000) != 0)			// BloodyMantle
				m_pEffectSpr[107]->PutTransSprite70(sX-5, sY, _tmp_iEffectFrame%8, dwTime);
			else if ((_tmp_iStatus & 0x00800000) != 0)		// Magic Mantle
				m_pEffectSpr[114]->PutTransSprite70(sX-5, sY, _tmp_iEffectFrame%8, dwTime);
			else if ((_tmp_iStatus & 0x00010000) != 0)		// ArrowMantle
				m_pEffectSpr[115]->PutTransSprite70(sX-5, sY, _tmp_iEffectFrame%8, dwTime);
			else 
				m_pEffectSpr[87]->PutTransSprite70(sX+53, sY+54, _tmp_iEffectFrame%29, dwTime);
		}else /// sinon ==> Slates
		{	if ((_tmp_iStatus & 0x00400000) != 0) // Slate red  (HP)  Flame au sol
				m_pEffectSpr[149]->PutTransSprite70(sX+90, sY+120, _tmp_iEffectFrame%15, dwTime);
		
			if ((_tmp_iStatus & 0x00800000) != 0) // Slate Blue (Mana) Bleu au sol
				m_pEffectSpr[150]->PutTransSprite70(sX+1, sY+26, _tmp_iEffectFrame%15, dwTime);
		
			if ((_tmp_iStatus & 0x00010000) != 0) // Slate Green (XP) Mauve au sol
				m_pEffectSpr[148]->PutTransSprite70(sX, sY+32, _tmp_iEffectFrame%23, dwTime);
	}	}

}

// 3.51 Level Up Dialog - Changes stats Using Majestic points - Diuuude
void CGame::DrawDialogBox_ChangeStatsMajestic(short msX, short msY)
{
 short sX, sY, szX;
 DWORD dwTime = m_dwCurTime;
 char cTxt[120];
 int iStats;
	sX = m_stDialogBoxInfo[42].sX;
	sY = m_stDialogBoxInfo[42].sY;
	szX = m_stDialogBoxInfo[42].sSizeX;

	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_TEXT, sX, sY, 2);
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME4, sX+16, sY+100, 4);

	PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_LEVELUP_SETTING14);
	PutAlignedString(sX, sX + szX, sY + 65, DRAW_DIALOGBOX_LEVELUP_SETTING15);

	// Majestic Points Left - Display in green if > 0
	PutString(sX + 20,  sY + 85, DRAW_DIALOGBOX_LEVELUP_SETTING16, RGB(0,0,0));
	wsprintf(cTxt, "%d", m_iGizonItemUpgradeLeft);
	if (m_iGizonItemUpgradeLeft > 0)
	{	PutString(sX + 73,  sY + 102, cTxt, RGB(0,255,0));
	}else
	{	PutString(sX + 73,  sY + 102, cTxt, RGB(0,0,0));
	}
	// Display only MouseOver Button for - (+ is disabled)
	// Strength
	PutString(sX + 24, sY + 125, DRAW_DIALOGBOX_LEVELUP_SETTING4, RGB(5,5,5));
	wsprintf(cTxt, "%d", m_iStr);
	PutString(sX + 109, sY + 125, cTxt, RGB(25,35,25));
	iStats = m_iStr + m_cLU_Str;
	wsprintf(cTxt, "%d", iStats);
	if (iStats < m_iStr)
	{	PutString(sX + 162, sY + 125, cTxt, RGB(255,0,0));
	}else
	{	PutString(sX + 162, sY + 125, cTxt, RGB(25,35,25));
	}
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 127) && (msY <= sY + 133))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 127, 6, dwTime);

	// Vitality
	PutString(sX + 24, sY + 144, DRAW_DIALOGBOX_LEVELUP_SETTING5, RGB(5,5,5));
	wsprintf(cTxt, "%d", m_iVit);
	PutString(sX + 109, sY + 144, cTxt, RGB(25,35,25));
	iStats = m_iVit + m_cLU_Vit;
	wsprintf(cTxt, "%d", iStats);
	if (iStats < m_iVit)
	{	PutString(sX + 162, sY + 144, cTxt, RGB(255,0,0));
	}else
	{	PutString(sX + 162, sY + 144, cTxt, RGB(25,35,25));
	}
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 146) && (msY <= sY + 152))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 146, 6, dwTime);

	// Dexterity
	PutString(sX + 24, sY + 163, DRAW_DIALOGBOX_LEVELUP_SETTING6, RGB(5,5,5));
	wsprintf(cTxt, "%d", m_iDex);
	PutString(sX + 109, sY + 163, cTxt, RGB(25,35,25));
	iStats = m_iDex + m_cLU_Dex;
	wsprintf(cTxt, "%d", iStats);
	if (iStats < m_iDex)
	{	PutString(sX + 162, sY + 163, cTxt, RGB(255,0,0));
	}else
	{	PutString(sX + 162, sY + 163, cTxt, RGB(25,35,25));
	}
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 165) && (msY <= sY + 171))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 165, 6, dwTime);

	// Intelligence
	PutString(sX + 24, sY + 182, DRAW_DIALOGBOX_LEVELUP_SETTING7, RGB(5,5,5));
	wsprintf(cTxt, "%d", m_iInt);
	PutString(sX + 109, sY + 182, cTxt, RGB(25,35,25));
	iStats = m_iInt + m_cLU_Int;
	wsprintf(cTxt, "%d", iStats);
	if (iStats < m_iInt)
	{	PutString(sX + 162, sY + 182, cTxt, RGB(255,0,0));
	}else
	{	PutString(sX + 162, sY + 182, cTxt, RGB(25,35,25));
	}
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 184) && (msY <= sY + 190))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 184, 6, dwTime);

	// Magic
	PutString(sX + 24, sY + 201, DRAW_DIALOGBOX_LEVELUP_SETTING8, RGB(5,5,5));
	wsprintf(cTxt, "%d", m_iMag);
	PutString(sX + 109, sY + 201, cTxt, RGB(25,35,25));
	iStats = m_iMag + m_cLU_Mag;
	wsprintf(cTxt, "%d", iStats);
	if (iStats < m_iMag)
	{	PutString(sX + 162, sY + 201, cTxt, RGB(255,0,0));
	}else
	{	PutString(sX + 162, sY + 201, cTxt, RGB(25,35,25));
	}
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 203) && (msY <= sY + 209))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 203, 6, dwTime);

	// Charisma
	PutString(sX + 24, sY + 220, DRAW_DIALOGBOX_LEVELUP_SETTING9, RGB(5,5,5));
	wsprintf(cTxt, "%d", m_iCharisma);
	PutString(sX + 109, sY + 220, cTxt, RGB(25,35,25));
	iStats = m_iCharisma + m_cLU_Char;
	wsprintf(cTxt, "%d", iStats);
	if (iStats < m_iCharisma)
	{	PutString(sX + 162, sY + 220, cTxt, RGB(255,0,0));
	}else
	{	PutString(sX + 162, sY + 220, cTxt, RGB(25,35,25));
	}
	if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 222) && (msY <= sY + 228))
		m_pSprite[DEF_SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 222, 6, dwTime);

	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 17);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_LBTNPOSX, sY + DEF_BTNPOSY, 16);

	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 1);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + DEF_RBTNPOSX, sY + DEF_BTNPOSY, 0);
}


// 3.51 LevelUp Box - Change stats using Majestic - Diuuude
void CGame::DlgBoxClick_ChangeStatsMajestic(short msX, short msY)
{
 short sX, sY;

	sX = m_stDialogBoxInfo[42].sX;
	sY = m_stDialogBoxInfo[42].sY;

	if ((cStateChange1 != 0) || (cStateChange2 != 0) || (cStateChange3 != 0))
	// Strength UP - Diuuude
	{	if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 127) && (msY <= sY + 133) && (m_cLU_Str < 0))
		{	if (cStateChange1 == DEF_STR)
			{	cStateChange1 = 0;
				m_cLU_Str += 1;
				m_iLU_Point -= 1;
			}else if (cStateChange2 == DEF_STR)
			{	cStateChange2 = 0;
				m_cLU_Str += 1;
				m_iLU_Point -= 1;
			}else if (cStateChange3 == DEF_STR)
			{	cStateChange3 = 0;
				m_cLU_Str += 1;
				m_iLU_Point -= 1;
			}
			PlaySound('E', 14, 5);
		}

		// Vitality UP - Diuuude
		if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 146) && (msY <= sY + 152) && (m_cLU_Vit < 0)) {
			if (cStateChange1 == DEF_VIT)
			{	cStateChange1 = 0;
				m_cLU_Vit += 1;
				m_iLU_Point -= 1;
			}else if (cStateChange2 == DEF_VIT)
			{	cStateChange2 = 0;
				m_cLU_Vit += 1;
				m_iLU_Point -= 1;
			}else if (cStateChange3 == DEF_VIT)
			{	cStateChange3 = 0;
				m_cLU_Vit += 1;
				m_iLU_Point -= 1;
			}
			PlaySound('E', 14, 5);
		}

		// Dexterity UP - Diuuude
		if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 165) && (msY <= sY + 171) && (m_cLU_Dex < 0)) {
			if (cStateChange1 == DEF_DEX){
				cStateChange1 = 0;
				m_cLU_Dex += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange2 == DEF_DEX){
				cStateChange2 = 0;
				m_cLU_Dex += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange3 == DEF_DEX){
				cStateChange3 = 0;
				m_cLU_Dex += 1;
				m_iLU_Point -= 1;
			}
			PlaySound('E', 14, 5);
		}

		// Intelligence UP - Diuuude
		if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 184) && (msY <= sY + 190) && (m_cLU_Int < 0)) {
			if (cStateChange1 == DEF_INT){
				cStateChange1 = 0;
				m_cLU_Int += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange2 == DEF_INT){
				cStateChange2 = 0;
				m_cLU_Int += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange3 == DEF_INT){
				cStateChange3 = 0;
				m_cLU_Int += 1;
				m_iLU_Point -= 1;
			}
			PlaySound('E', 14, 5);
		}

		// Magic UP - Diuuude
		if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 203) && (msY <= sY + 209) && (m_cLU_Mag < 0)) {
			if (cStateChange1 == DEF_MAG){
				cStateChange1 = 0;
				m_cLU_Mag += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange2 == DEF_MAG){
				cStateChange2 = 0;
				m_cLU_Mag += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange3 == DEF_MAG){
				cStateChange3 = 0;
				m_cLU_Mag += 1;
				m_iLU_Point -= 1;
			}
			PlaySound('E', 14, 5);
		}

		// Charisma UP - Diuuude
		if ((msX >= sX + 195) && (msX <= sX + 205) && (msY >= sY + 222) && (msY <= sY + 228) && (m_cLU_Char < 0)) {
			if (cStateChange1 == DEF_CHR){
				cStateChange1 = 0;
				m_cLU_Char += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange2 == DEF_CHR){
				cStateChange2 = 0;
				m_cLU_Char += 1;
				m_iLU_Point -= 1;
			}
			else if (cStateChange3 == DEF_CHR){
				cStateChange3 = 0;
				m_cLU_Char += 1;
				m_iLU_Point -= 1;
			}
			PlaySound('E', 14, 5);
		}
	}

	if ((cStateChange1 == 0) || (cStateChange2 == 0) || (cStateChange3 == 0) && (m_iGizonItemUpgradeLeft > 0))
	{	// Strength DOWN - Diuuude
		if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 127) && (msY <= sY + 133) && (m_iStr > 10))
		{	if (cStateChange1 == 0)
			{	cStateChange1 = DEF_STR;
				m_cLU_Str -= 1;
				m_iLU_Point += 1;
			}else if (cStateChange2 == 0)
			{	cStateChange2 = DEF_STR;
				m_cLU_Str -= 1;
				m_iLU_Point += 1;
			}else
			{	cStateChange3 = DEF_STR;
				m_cLU_Str -= 1;
				m_iLU_Point += 1;
			}
			PlaySound('E', 14, 5);
		}

		// Vitality DOWN - Diuuude
		if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 146) && (msY <= sY + 152) && (m_iVit > 10)) {
			if (cStateChange1 == 0){
				cStateChange1 = DEF_VIT;
				m_cLU_Vit -= 1;
				m_iLU_Point += 1;
			}
			else if (cStateChange2 == 0){
				cStateChange2 = DEF_VIT;
				m_cLU_Vit -= 1;
				m_iLU_Point += 1;
			}
			else{
				cStateChange3 = DEF_VIT;
				m_cLU_Vit -= 1;
				m_iLU_Point += 1;
			}
			PlaySound('E', 14, 5);
		}

		// Dexterity DOWN - Diuuude
		if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 165) && (msY <= sY + 171) && (m_iDex > 10)) {
			if (cStateChange1 == 0){
				cStateChange1 = DEF_DEX;
				m_cLU_Dex -= 1;
				m_iLU_Point += 1;
			}
			else if (cStateChange2 == 0){
				cStateChange2 = DEF_DEX;
				m_cLU_Dex -= 1;
				m_iLU_Point += 1;
			}
			else{
				cStateChange3 = DEF_DEX;
				m_cLU_Dex -= 1;
				m_iLU_Point += 1;
			}
			PlaySound('E', 14, 5);
		}

		// Intelligence DOWN - Diuuude
		if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 184) && (msY <= sY + 190) && (m_iInt > 10))
		{	if (cStateChange1 == 0)
			{	cStateChange1 = DEF_INT;
				m_cLU_Int -= 1;
				m_iLU_Point += 1;
			}else if (cStateChange2 == 0)
			{	cStateChange2 = DEF_INT;
				m_cLU_Int -= 1;
				m_iLU_Point += 1;
			}else
			{	cStateChange3 = DEF_INT;
				m_cLU_Int -= 1;
				m_iLU_Point += 1;
			}
			PlaySound('E', 14, 5);
		}

		// Magic DOWN - Diuuude
		if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 203) && (msY <= sY + 209) && (m_iMag > 10)) {
			if (cStateChange1 == 0){
				cStateChange1 = DEF_MAG;
				m_cLU_Mag -= 1;
				m_iLU_Point += 1;
			}
			else if (cStateChange2 == 0){
				cStateChange2 = DEF_MAG;
				m_cLU_Mag -= 1;
				m_iLU_Point += 1;
			}
			else{
				cStateChange3 = DEF_MAG;
				m_cLU_Mag -= 1;
				m_iLU_Point += 1;
			}
			PlaySound('E', 14, 5);
		}

		// Charisma DOWN - Diuuude
		if ((msX >= sX + 210) && (msX <= sX + 220) && (msY >= sY + 222) && (msY <= sY + 228) && (m_iCharisma > 10)) {
			if (cStateChange1 == 0){
				cStateChange1 = DEF_CHR;
				m_cLU_Char -= 1;
				m_iLU_Point += 1;
			}
			else if (cStateChange2 == 0){
				cStateChange2 = DEF_CHR;
				m_cLU_Char -= 1;
				m_iLU_Point += 1;
			}
			else{
				cStateChange3 = DEF_CHR;
				m_cLU_Char -= 1;
				m_iLU_Point += 1;
			}
			PlaySound('E', 14, 5);
		}
	}else
	{	if ((msX >= sX + DEF_RBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY))
		{	// Send command to HG - Diuuude
			bSendCommand(MSGID_STATECHANGEPOINT, NULL, NULL, NULL, NULL, NULL, NULL);
			DisableDialogBox(42);
			PlaySound('E', 14, 5);
	}	}
	if ((msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_LBTNPOSX + DEF_BTNSZX) && (msY > sY + DEF_BTNPOSY) && (msY < sY + DEF_BTNPOSY + DEF_BTNSZY)) {
		DisableDialogBox(42);
		PlaySound('E', 14, 5);
	}
}

void CGame::DrawAngel(int iSprite, short sX, short sY, char cFrame, DWORD dwTime)
{	if  ((_tmp_iStatus & 0x1000) != 0) m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT+iSprite]->PutSpriteFast(sX, sY, cFrame, dwTime);  //AngelicPendant(STR)
	else if ((_tmp_iStatus & 0x2000) != 0) m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT+(50*1)+iSprite]->PutSpriteFast(sX, sY, cFrame, dwTime); //AngelicPendant(DEX)
	else if ((_tmp_iStatus & 0x4000) != 0) m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT+(50*2)+iSprite]->PutSpriteFast(sX, sY-20, cFrame, dwTime);//AngelicPendant(INT)
	else if ((_tmp_iStatus & 0x8000) != 0) m_pSprite[DEF_SPRID_TUTELARYANGELS_PIVOTPOINT+(50*3)+iSprite]->PutSpriteFast(sX, sY-20, cFrame, dwTime);//AngelicPendant(MAG)

}
/*********************************************************************************************************************
**  int CGame::bHasHeroSet( short m_sAppr3, short m_sAppr3, char OwnerType)		( Snoopy )							**
**  description			:: check weather the object (is character) is using a hero set (1:war, 2:mage)				**
**********************************************************************************************************************/
int CGame::bHasHeroSet(short Appr3, short Appr4, char OwnerType)
{	char cArmor, cLeg, cBerk, cHat;
	cArmor = (Appr3 & 0xF000) >> 12;
	cLeg   = (Appr3 & 0x0F00) >> 8;
	cHat   = (Appr3 & 0x00F0) >> 4;
	cBerk  =  Appr3 & 0x000F;
	switch (OwnerType){
	case 1:
	case 2:
	case 3:
		if ((cArmor == 8) &&(cLeg == 5)&&(cHat == 9) &&(cBerk == 3)) return (1); // Warr elv M
		if ((cArmor == 9) &&(cLeg == 6)&&(cHat == 10)&&(cBerk == 4)) return (1); // Warr ares M
		if ((cArmor == 10)&&(cLeg == 5)&&(cHat == 11)&&(cBerk == 3)) return (2); // Mage elv M
		if ((cArmor == 11)&&(cLeg == 6)&&(cHat == 12)&&(cBerk == 4)) return (2); // Mage ares M
		break;
	case 4:
	case 5:
	case 6: // fixed
		if ((cArmor == 9) &&(cLeg == 6)&&(cHat == 9) &&(cBerk == 4)) return (1); //warr elv W
		if ((cArmor == 10)&&(cLeg == 7)&&(cHat == 10)&&(cBerk == 5)) return (1); //warr ares W
		if ((cArmor == 11)&&(cLeg == 6)&&(cHat == 11)&&(cBerk == 4)) return (2); //mage elv W
		if ((cArmor == 12)&&(cLeg == 7)&&(cHat == 12)&&(cBerk == 5)) return (2); //mage ares W
		break;
	}
	return 0;
}
/*********************************************************************************************************************
**  void ShowHeldenianVictory( short sSide)				( Snoopy )													**
**  description			: Shows the Heldenian's End window															**
**********************************************************************************************************************/
void CGame::ShowHeldenianVictory(short sSide)
{	int i, iPlayerSide;
	DisableDialogBox(18);
	for (i = 0; i < DEF_TEXTDLGMAXLINES; i++)
	{	if (m_pMsgTextList[i] != NULL)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = NULL;
	}
	if( m_bCitizen == FALSE ) iPlayerSide = 0;
	else if (m_bAresden == TRUE) iPlayerSide = 1;
	else if (m_bAresden == FALSE) iPlayerSide = 2;
	switch (sSide) {
	case 0:
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[0] = new class CMsg(NULL, "Heldenian holy war has been closed!", NULL);
		m_pMsgTextList[1] = new class CMsg(NULL, " ", NULL);
		m_pMsgTextList[2] = new class CMsg(NULL, "Heldenian Holy war ended", NULL);
		m_pMsgTextList[3] = new class CMsg(NULL, "in a tie.", NULL);
		break;
	case 1:
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[0] = new class CMsg(NULL, "Heldenian holy war has been closed!", NULL);
		m_pMsgTextList[1] = new class CMsg(NULL, " ", NULL);
		m_pMsgTextList[2] = new class CMsg(NULL, "Heldenian Holy war ended", NULL);
		m_pMsgTextList[3] = new class CMsg(NULL, "in favor of Aresden.", NULL);
		break;
	case 2:
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[0] = new class CMsg(NULL, "Heldenian holy war has been closed!", NULL);
		m_pMsgTextList[1] = new class CMsg(NULL, " ", NULL);
		m_pMsgTextList[2] = new class CMsg(NULL, "Heldenian Holy war ended", NULL);
		m_pMsgTextList[3] = new class CMsg(NULL, "in favor of Elvine.", NULL);
		break;
	}
	m_pMsgTextList[4] = new class CMsg(NULL, " ", NULL);

	if (   ((iPlayerSide != 1) && (iPlayerSide != 2))   // Player not a normal citizen
		|| (sSide == 0))								// or no winner
	{	PlaySound('E', 25, 0, 0);
		m_pMsgTextList[5] = new class CMsg(NULL, " ", NULL);
		m_pMsgTextList[6] = new class CMsg(NULL, " ", NULL);
		m_pMsgTextList[7] = new class CMsg(NULL, " ", NULL);
		m_pMsgTextList[8] = new class CMsg(NULL, " ", NULL);
	}else
	{ 	if (sSide == iPlayerSide)
		{	PlaySound('E', 23, 0, 0);
			PlaySound('C', 21, 0, 0);
			PlaySound('C', 22, 0, 0);
			m_pMsgTextList[5] = new class CMsg(NULL, "Congratulation.", NULL);
			m_pMsgTextList[6] = new class CMsg(NULL, "As cityzen of victory,", NULL);
			m_pMsgTextList[7] = new class CMsg(NULL, "You will recieve a reward.", NULL);
			m_pMsgTextList[8] = new class CMsg(NULL, "      ", NULL);
		}else
		{	PlaySound('E', 24, 0, 0);
			PlaySound('C', 12, 0, 0);
			PlaySound('C', 13, 0, 0);
			m_pMsgTextList[5] = new class CMsg(NULL, "To our regret", NULL);
			m_pMsgTextList[6] = new class CMsg(NULL, "As cityzen of defeat,", NULL);
			m_pMsgTextList[7] = new class CMsg(NULL, "You cannot recieve any reward.", NULL);
			m_pMsgTextList[8] = new class CMsg(NULL, "     ", NULL);
	}	}
	for (i = 9; i < 18; i++)
		m_pMsgTextList[i] = new class CMsg(NULL, " ", NULL);
	EnableDialogBox(18, NULL, NULL, NULL);
	DisableDialogBox(36);
	DisableDialogBox(37);
	DisableDialogBox(38);
}

/*********************************************************************************************************************
**  void DrawDialogBox_Resurect(short msX, short msY) 				( Snoopy )										**
**  description			: Asks the player if he accepts resurection													**
**********************************************************************************************************************/
void CGame::DrawDialogBox_Resurect(short msX, short msY)
{short sX, sY;
//00476D02  |. 68 A4474C00    PUSH 004C47A4                    ;  ASCII "Someone intend to resurrect you."
//00476D41  |. 68 8C474C00    PUSH 004C478C                    ;  ASCII "Will you revive here?"
	sX = m_stDialogBoxInfo[50].sX;
	sY = m_stDialogBoxInfo[50].sY;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME1, sX, sY, 2);

	PutString(sX + 50, sY + 20, "Someone intend to resurrect you.", RGB(4,0,50));
	PutString(sX + 80, sY + 35, "Will you revive here?", RGB(4,0,50));

	if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + 55) && (msY <= sY + 55 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 55 ,19);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 55 , 18);

	if ((msX >= sX + 170 ) && (msX <= sX + 170 + DEF_BTNSZX ) && (msY >= sY + 55 ) && (msY <= sY + 55 + DEF_BTNSZY))
			 DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 170 , sY + 55 , 3);
	else DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_BUTTON, sX + 170, sY + 55 , 2);
}

/*********************************************************************************************************************
**  void DlgBoxClick_ItemDrop(short msX, short msY)			( Snoopy )												**
**  description			: Response of the player if he accepts resurection or not									**
**********************************************************************************************************************/
void CGame::DlgBoxClick_Resurect(short msX, short msY)
{short sX, sY;
//#define MSGID_REQUEST_RESURRECTPLAYER_YES				0x0FC94214
//#define MSGID_REQUEST_RESURRECTPLAYER_NO				0x0FC94215
	sX = m_stDialogBoxInfo[50].sX;
	sY = m_stDialogBoxInfo[50].sY;
	if ((msX >= sX + 30) && (msX <= sX + 30 + DEF_BTNSZX) && (msY >= sY + 55) && (msY <= sY + 55 + DEF_BTNSZY))
	{   // yes
		bSendCommand(MSGID_REQUEST_RESURRECTPLAYER_YES, 0, 0, 0, 0 ,0, NULL, 0);
		DisableDialogBox(50);
	}else if ((msX >= sX + 170 ) && (msX <= sX + 170 + DEF_BTNSZX ) && (msY >= sY + 55 ) && (msY <= sY + 55 + DEF_BTNSZY))
	{	// no
		bSendCommand(MSGID_REQUEST_RESURRECTPLAYER_NO, 0, 0, 0, 0 ,0, NULL, 0);
		DisableDialogBox(50);
	}
}

/*********************************************************************************************************************
**  void 	ResponseHeldenianTeleportList(char *pData)									(  Snoopy )					**
**  description			: Gail's TP																					**
**********************************************************************************************************************/
void CGame::ResponseHeldenianTeleportList(char *pData)
{	char *cp;
	int  *ip, i;
#ifdef _DEBUG
	AddEventList("Teleport ???", 10);
#endif
	cp = pData + 6;
	ip = (int*) cp;
	m_iTeleportMapCount = *ip;
	cp += 4;
	for ( i = 0 ; i < m_iTeleportMapCount ; i++)
	{	ip = (int*)cp;
		m_stTeleportList[i].iIndex = *ip;
		cp += 4;
		ZeroMemory(m_stTeleportList[i].mapname, sizeof(m_stTeleportList[i].mapname) );
		memcpy(m_stTeleportList[i].mapname, cp, 10);
		cp += 10;
		ip = (int*)cp;
		m_stTeleportList[i].iX = *ip;
		cp += 4;
		ip = (int*)cp;
		m_stTeleportList[i].iY = *ip;
		cp += 4;
		ip = (int*)cp;
		m_stTeleportList[i].iCost = *ip;
		cp += 4;
	}
}

/*********************************************************************************************************************
**  void DrawDialogBox_CMDHallMenu(short msX, short msY)			( Snoopy )										**
**  description			: Draw the diag																				**
**********************************************************************************************************************/
void CGame::DrawDialogBox_CMDHallMenu(short msX, short msY)
{short sX, sY, szX;
 char cTxt[120];
	sX = m_stDialogBoxInfo[51].sX;
	sY = m_stDialogBoxInfo[51].sY;
	szX = m_stDialogBoxInfo[51].sSizeX;
	DrawNewDialogBox(DEF_SPRID_INTERFACE_ND_GAME2, sX, sY, 2);

	switch (m_stDialogBoxInfo[51].cMode) {
	case 0: // initial diag
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 70) && (msY < sY + 95))
			 PutAlignedString(sX, sX + szX, sY + 70, "Teleport to Battle Field", 255,255,255);
		else PutAlignedString(sX, sX + szX, sY + 70, "Teleport to Battle Field", 4,0,50);

		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 95) && (msY < sY + 120))
			 PutAlignedString(sX, sX + szX, sY + 95, "Hire a soldier", 255,255,255);
		else PutAlignedString(sX, sX + szX, sY + 95, "Hire a soldier", 4,0,50);

		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 120) && (msY < sY + 145))
			 PutAlignedString(sX, sX + szX, sY + 120, "Taking Flags", 255,255,255);
		else PutAlignedString(sX, sX + szX, sY + 120, "Taking Flags", 4,0,50);
		// Angels
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 145) && (msY < sY + 170))
			 PutAlignedString(sX, sX + szX, sY + 145, "Receive a Tutelary Angel", 255,255,255);
		else PutAlignedString(sX, sX + szX, sY + 145, "Receive a Tutelary Angel", 4,0,50);
		break;

	case 1: // TP diag
		if( m_iTeleportMapCount > 0 )
		{	//PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_CITYHALL_MENU69, 55,25,25); // "Teleporting to dungeon level 2."
			//PutAlignedString(sX, sX + szX, sY + 80, DRAW_DIALOGBOX_CITYHALL_MENU70, 55,25,25); // "5000Gold is required"
			//PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU71, 55,25,25); //
			//PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_CITYHALL_MENU72, 55,25,25);//
			PutString2(sX + 35, sY + 250, DRAW_DIALOGBOX_CITYHALL_MENU72_1, 55,25,25);//"Civilians cannot go some area."
			for( int i=0 ; i<m_iTeleportMapCount ; i++ )
			{	ZeroMemory( cTxt, sizeof(cTxt) );
				GetOfficialMapName( m_stTeleportList[i].mapname, cTxt );
				wsprintf( G_cTxt, DRAW_DIALOGBOX_CITYHALL_MENU77, cTxt, m_stTeleportList[i].iCost );
				if( (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 130 + i*15) && (msY <= sY + 144 + i*15) )
					 PutAlignedString(sX, sX + szX, sY + 130 + i*15, G_cTxt, 255, 255, 255);
				else PutAlignedString(sX, sX + szX, sY + 130 + i*15, G_cTxt,  250,  250,  0);
			}
		}else if( m_iTeleportMapCount == -1 )
		{	PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU73, 55,25,25);//"Now it's searching for possible area"
			PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_CITYHALL_MENU74, 55,25,25);//"to teleport."
			PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_CITYHALL_MENU75, 55,25,25);//"Please wait for a moment."
		}else
		{	PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_CITYHALL_MENU76, 55,25,25);//"There is no area that you can teleport."
		}
		break;

	case 2: // Soldier diag
		PutAlignedString(sX, sX + szX, sY + 45, "You will hire a soldier by summon points", 255,255,255);
		if ((m_iConstructionPoint >= 2000) && (m_bIsCrusadeMode == FALSE))
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 70) && (msY < sY + 95))
				 PutAlignedString(sX, sX + szX, sY + 70, "Sorceress             2000 Point", 255,255,255);
			else PutAlignedString(sX, sX + szX, sY + 70, "Sorceress             2000 Point", 4,0,50);
		}else PutAlignedString(sX, sX + szX, sY + 70, "Sorceress             2000 Point", 65,65,65);

		if ((m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == FALSE))
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 95) && (msY < sY + 120))
			 PutAlignedString(sX, sX + szX, sY + 95, "Ancient Temple Knight 3000 Point", 255,255,255);
			else PutAlignedString(sX, sX + szX, sY + 95, "Ancient Temple Knight 3000 Point", 4,0,50);
		}else PutAlignedString(sX, sX + szX, sY + 95, "Ancient Temple Knight 3000 Point", 65,65,65);

		if ((m_iConstructionPoint >= 1500) && (m_bIsCrusadeMode == FALSE))
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 120) && (msY < sY + 145))
				PutAlignedString(sX, sX + szX, sY + 120, "Elf Master            1500 Point", 255,255,255);
			else PutAlignedString(sX, sX + szX, sY + 120, "Elf Master            1500 Point", 4,0,50);
		}else PutAlignedString(sX, sX + szX, sY + 120, "Elf Master            1500 Point", 65,65,65);

		if ((m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == FALSE))
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 145) && (msY < sY + 171))
				PutAlignedString(sX, sX + szX, sY + 145, "Dark Shadow Knight    3000 Point", 255,255,255);
			else PutAlignedString(sX, sX + szX, sY + 145, "Dark Shadow Knight    3000 Point", 4,0,50);
		}else PutAlignedString(sX, sX + szX, sY + 145, "Dark Shadow Knight    3000 Point", 65,65,65);

		if ((m_iConstructionPoint >= 4000) && (m_bIsCrusadeMode == FALSE))
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 170) && (msY < sY + 195))
				PutAlignedString(sX, sX + szX, sY + 170, "Heavy Battle Tank     4000 Point", 255,255,255);
			else PutAlignedString(sX, sX + szX, sY + 170, "Heavy Battle Tank     4000 Point", 4,0,50);
		}else PutAlignedString(sX, sX + szX, sY + 170, "Heavy Battle Tank     4000 Point", 65,65,65);

		if ((m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == FALSE))
		{	if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 195) && (msY < sY + 220))
				PutAlignedString(sX, sX + szX, sY + 195, "Barbarian             3000 Point", 255,255,255);
			else PutAlignedString(sX, sX + szX, sY + 195, "Barbarian             3000 Point", 4,0,50);
		}else PutAlignedString(sX, sX + szX, sY + 195, "Barbarian             3000 Point", 65,65,65);


#ifdef DEF_EQUILIBRIUM_PROJECT // max summon pts Heldenian
		//PutAlignedString(sX, sX + szX, sY + 220,"You should join a guild to hire soldiers.", 4,0,50);
		wsprintf(G_cTxt,"Summon points : %d", m_iConstructionPoint);
		PutAlignedString(sX, sX + szX, sY + 250, G_cTxt, 4,0,50);
		PutAlignedString(sX, sX + szX, sY + 280, "Maximum summon points : 20000 points.", 4,0,50);
#else
		PutAlignedString(sX, sX + szX, sY + 220,"You should join a guild to hire soldiers.", 4,0,50);
		wsprintf(G_cTxt,"Summon points : %d", m_iConstructionPoint);
		PutAlignedString(sX, sX + szX, sY + 250, G_cTxt, 4,0,50);
		PutAlignedString(sX, sX + szX, sY + 280, "Maximum summon points : 12000 points.", 4,0,50);
#endif
		PutAlignedString(sX, sX + szX, sY + 300, "Maximum hiring number : 5 ", 4,0,50);
		break;

	case 3: // Hire a Flag Diag
		PutAlignedString(sX, sX + szX, sY + 45,"You may acquire Flags with EK points.", 4,0,50);
		PutAlignedString(sX, sX + szX, sY + 70,"Price is 10 EK per Flag.", 4,0,50);
		if( (msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 140) && (msY <= sY + 165) )
			PutAlignedString(sX, sX + szX, sY + 140, "Take a Flag", 255,255,255);
		else
			PutAlignedString(sX, sX + szX, sY + 140, "Take a Flag", 250,250,0);
		break;

	case 4: // Tutelar Angel Diag

#ifdef DEF_EQUILIBRIUM_PROJECT // Pandents
		PutAlignedString(sX, sX + szX, sY + 45, "Obtain a tutelary Angel", 4,0,50);
		PutAlignedString(sX, sX + szX, sY + 80, "You need 5 gizon to get a Tutelary Angel.", 4,0,50);
		PutAlignedString(sX, sX + szX, sY + 105, "Would you like to buy a Tutelary Angel?", 4,0,50);
		wsprintf(G_cTxt, "Gizon points available : %d:", m_iGizonItemUpgradeLeft);
#else
		PutAlignedString(sX, sX + szX, sY + 45, "5 magesty points will be deducted", 4,0,50);
		PutAlignedString(sX, sX + szX, sY + 80, "upon receiving the Pendant of Tutelary Angel.", 4,0,50);
		PutAlignedString(sX, sX + szX, sY + 105, "Would you like to receive the Tutelary Angel?", 4,0,50);
		wsprintf(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE11, m_iGizonItemUpgradeLeft);// "Item upgrade point : %d"
#endif
		
		PutAlignedString(sX, sX + szX, sY + 140, G_cTxt, 0,0,0);

		if (   (msX > sX + 35) && (msX < sX + 220) && (msY > sY + 175) && (msY < sY + 200)
			&& (m_iGizonItemUpgradeLeft >4))
			 PutAlignedString(sX, sX + szX, sY + 175, "Tutelary Angel (STR) will be handed out.", 255,255,255);
		else PutAlignedString(sX, sX + szX, sY + 175, "Tutelary Angel (STR) will be handed out.", 250,250,0);

		if (   (msX > sX + 35) && (msX < sX + 220) && (msY > sY + 200) && (msY < sY + 225)
			&& (m_iGizonItemUpgradeLeft >4))
			 PutAlignedString(sX, sX + szX, sY + 200, "Tutelary Angel (DEX) will be handed out.", 255,255,255);
		else PutAlignedString(sX, sX + szX, sY + 200, "Tutelary Angel (DEX) will be handed out.", 250,250,0);

		if (   (msX > sX + 35) && (msX < sX + 220) && (msY > sY + 225) && (msY < sY + 250)
			&& (m_iGizonItemUpgradeLeft >4))
			 PutAlignedString(sX, sX + szX, sY + 225, "Tutelary Angel (INT) will be handed out.", 255,255,255);
		else PutAlignedString(sX, sX + szX, sY + 225, "Tutelary Angel (INT) will be handed out.", 250,250,0);

		if (   (msX > sX + 35) && (msX < sX + 220) && (msY > sY + 250) && (msY < sY + 275)
			&& (m_iGizonItemUpgradeLeft >4))
			 PutAlignedString(sX, sX + szX, sY + 250, "Tutelary Angel (MAG) will be handed out.", 255,255,255);
		else PutAlignedString(sX, sX + szX, sY + 250, "Tutelary Angel (MAG) will be handed out.", 250,250,0);

		break;
	}
}

/*********************************************************************************************************************
**  void DlgBoxClick_CMDHallMenu(short msX, short msY)			( Snoopy )											**
**  description			: Response of the player if he accepts resurection or not									**
**********************************************************************************************************************/
void CGame::DlgBoxClick_CMDHallMenu(short msX, short msY)
{short sX, sY;
	sX = m_stDialogBoxInfo[51].sX;
	sY = m_stDialogBoxInfo[51].sY;
	switch (m_stDialogBoxInfo[51].cMode) {
	case 0: // initial diag
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 70) && (msY < sY + 95))
		{	m_stDialogBoxInfo[51].cMode = 1; // TP diag
			m_iTeleportMapCount = -1;
			bSendCommand(MSGID_REQUEST_HELDENIAN_TP_LIST, NULL, NULL, NULL, NULL, NULL, NULL);
			PlaySound('E', 14, 5);
		}
		if ((msX > sX + 35) && (msX < sX + 220) && (msY > sY + 95) && (msY < sY + 120))
		{	m_stDialogBoxInfo[51].cMode = 2; // Soldier Diag
			PlaySound('E', 14, 5);
		}
		if (   (msX > sX + 35) && (msX < sX + 220) && (msY > sY + 120) && (msY < sY + 145)
			/*&& (m_iEnemyKillCount >= 3)*/)
		{	m_stDialogBoxInfo[51].cMode = 3; // Flag Diag
			PlaySound('E', 14, 5);
		}
		if (   (msX > sX + 35) && (msX < sX + 220) && (msY > sY + 120) && (msY < sY + 145)
			/*&& (m_iEnemyKillCount >= 3)*/)
		{	m_stDialogBoxInfo[51].cMode = 3; // Flag Diag
			PlaySound('E', 14, 5);
		}

		if (   (msX > sX + 35) && (msX < sX + 220) && (msY > sY + 145) && (msY < sY + 170)
			/*&& (m_iGizonItemUpgradeLeft >= 5)*/)
		{	m_stDialogBoxInfo[51].cMode = 4; // Flag Diag
			PlaySound('E', 14, 5);
		}


	case 1: // TP now
		if( m_iTeleportMapCount > 0 )
		{	for( int i=0 ; i<m_iTeleportMapCount ; i++ )
			{	if( (msX >= sX + DEF_LBTNPOSX) && (msX <= sX + DEF_RBTNPOSX + DEF_BTNSZX) && (msY >= sY + 130 + i*15) && (msY <= sY + 144 + i*15) )
				{	bSendCommand(MSGID_REQUEST_HELDENIAN_TP, NULL, NULL, m_stTeleportList[i].iIndex, NULL, NULL, NULL);
					DisableDialogBox(51);
					return;
		}	}	}
		break;

	case 2: // Buy a soldier scroll
		if (   (msX >= sX + 35) && (msX <= sX + 220) && (msY > sY + 70) && (msY < sY + 95)
			&& (m_iConstructionPoint >= 2000) && (m_bIsCrusadeMode == FALSE)) // Sorceress
		{	bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 875, 1, 2, 3, 4, "Gail", 5);
			PlaySound('E', 14, 5);
		}
		if (   (msX >= sX + 35) && (msX <= sX + 220) && (msY > sY + 95) && (msY < sY + 120)
			&& (m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == FALSE)) // ATK
		{	bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 876, 0, 0, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}
		if (   (msX >= sX + 35) && (msX <= sX + 220) && (msY > sY + 120) && (msY < sY + 145)
			&& (m_iConstructionPoint >= 1500) && (m_bIsCrusadeMode == FALSE)) // Elf
		{	bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 877, 0, 0, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}
		if (   (msX >= sX + 35) && (msX <= sX + 220) && (msY > sY + 145) && (msY < sY + 170)
			&& (m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == FALSE)) // DSK
		{	bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 878, 0, 0, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}
		if (   (msX >= sX + 35) && (msX <= sX + 220) && (msY > sY + 170) && (msY < sY + 195)
			&& (m_iConstructionPoint >= 4000) && (m_bIsCrusadeMode == FALSE)) // HBT
		{	bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 879, 0, 0, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}
		if (   (msX >= sX + 35) && (msX <= sX + 220) && (msY > sY + 195) && (msY < sY + 220)
			&& (m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == FALSE)) // Barbarian
		{	bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 880, 0, 0, 0, 0, "Gail", 0);
			PlaySound('E', 14, 5);
		}
		break;

	case 3: // Buy a Flag
		if (   (msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 140) && (msY <= sY + 165)
			&& (m_iEnemyKillCount >=3))
		{	bSendCommand(MSGID_COMMAND_COMMON, DEF_COMMONTYPE_REQ_GETOCCUPYFLAG, 0, 0, 0, 0, 0, 0);
			PlaySound('E', 14, 5);
		}
		break;

	case 4: // Buy an Angel
		if (   (msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 175) && (msY <= sY + 200)
			&& ( m_iGizonItemUpgradeLeft>=5))
		{	bSendCommand(MSGID_REQUEST_ANGEL, NULL, NULL, 1, NULL, NULL, "Gail", NULL);
			PlaySound('E', 14, 5);
		}
		if (   (msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 200) && (msY <= sY + 225)
			&& ( m_iGizonItemUpgradeLeft>=5))
		{	bSendCommand(MSGID_REQUEST_ANGEL, NULL, NULL, 2, NULL, NULL, "Gail", NULL);
			PlaySound('E', 14, 5);
		}
		if (   (msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 225) && (msY <= sY + 250)
			&& ( m_iGizonItemUpgradeLeft>=5))
		{	bSendCommand(MSGID_REQUEST_ANGEL, NULL, NULL, 3, NULL, NULL, "Gail", NULL);
			PlaySound('E', 14, 5);
		}
		if (   (msX >= sX + 35) && (msX <= sX + 220) && (msY >= sY + 250) && (msY <= sY + 275)
			&& ( m_iGizonItemUpgradeLeft>=5))
		{	bSendCommand(MSGID_REQUEST_ANGEL, NULL, NULL, 4, NULL, NULL, "Gail", NULL);
			PlaySound('E', 14, 5);
		}

		break;
	}
}
/*********************************************************************************************************************
**  bool DKGlare(int iWeaponIndex, int iWeaponIndex, int *iWeaponGlare)	( Snoopy )									**
**  description			: test glowing condition for DK set															**
**********************************************************************************************************************/
void CGame::DKGlare(int iWeaponColor, int iWeaponIndex, int *iWeaponGlare)
{	if (iWeaponColor != 9) return;
	if (   ((iWeaponIndex >= DEF_SPRID_WEAPON_M + 64*14)&&(iWeaponIndex < DEF_SPRID_WEAPON_M + 64*14 + 56)) //msw3
		|| ((iWeaponIndex >= DEF_SPRID_WEAPON_W + 64*14)&&(iWeaponIndex < DEF_SPRID_WEAPON_W + 64*14 + 56))) //wsw3
	{	*iWeaponGlare = 3;
	}else if (  ((iWeaponIndex >= DEF_SPRID_WEAPON_M + 64*37)&&(iWeaponIndex < DEF_SPRID_WEAPON_M + 64*37 + 56)) //MStaff3
		|| ((iWeaponIndex >= DEF_SPRID_WEAPON_W + 64*37)&&(iWeaponIndex < DEF_SPRID_WEAPON_W + 64*37 + 56)))//WStaff3
	{	*iWeaponGlare = 2;
	}
}
/*********************************************************************************************************************
**  void DrawDruncncity()	( Snoopy )																				**
**  description			: 	Placeholder for Druncncity effects (nota: bubbles already coded)						**
**********************************************************************************************************************/
void CGame::DrawDruncncity()
{	//DebugLog("druncncity");
}

// Manque ondulations et coloration des persos en verdatre....
// Druncncity:
/*401E60  /$ 83EC 7C            SUB ESP,7C
00401E63  |. 56                 PUSH ESI
00401E64  |. 8BF1               MOV ESI,ECX
00401E66  |. 8B86 10000300      MOV EAX,DWORD PTR DS:[ESI+30010]
00401E6C  |. 85C0               TEST EAX,EAX
00401E6E  |. 75 05              JNZ SHORT 00401E75
00401E70  |. 5E                 POP ESI
00401E71  |. 83C4 7C            ADD ESP,7C
00401E74  |. C3                 RETN
00401E75  |> 6A 00              PUSH 0
00401E77  |. 8D5424 08          LEA EDX,DWORD PTR SS:[ESP+8]
00401E7B  |. 6A 01              PUSH 1
00401E7D  |. C74424 0C 7C000000 MOV DWORD PTR SS:[ESP+C],7C
00401E85  |. 8B08               MOV ECX,DWORD PTR DS:[EAX]
00401E87  |. 52                 PUSH EDX
00401E88  |. 6A 00              PUSH 0
00401E8A  |. 50                 PUSH EAX
00401E8B  |. FF51 64            CALL NEAR DWORD PTR DS:[ECX+64]
00401E8E  |. 85C0               TEST EAX,EAX
00401E90  |. 74 07              JE SHORT 00401E99
00401E92  |. 33C0               XOR EAX,EAX
00401E94  |. 5E                 POP ESI
00401E95  |. 83C4 7C            ADD ESP,7C
00401E98  |. C3                 RETN
00401E99  |> 8B4C24 0C          MOV ECX,DWORD PTR SS:[ESP+C]
00401E9D  |. 8B4424 28          MOV EAX,DWORD PTR SS:[ESP+28]
00401EA1  |. 8B5424 10          MOV EDX,DWORD PTR SS:[ESP+10]
00401EA5  |. 83C1 D8            ADD ECX,-28
00401EA8  |. 50                 PUSH EAX                                ; /Arg3
00401EA9  |. 51                 PUSH ECX                                ; |Arg2
00401EAA  |. 8B8E DC010300      MOV ECX,DWORD PTR DS:[ESI+301DC]        ; |
00401EB0  |. 52                 PUSH EDX                                ; |Arg1
00401EB1  |. E8 4AF2FFFF        CALL 00401100                           ; \Original.00401100
00401EB6  |. 8B86 10000300      MOV EAX,DWORD PTR DS:[ESI+30010]
00401EBC  |. 6A 00              PUSH 0
00401EBE  |. 50                 PUSH EAX
00401EBF  |. 8B08               MOV ECX,DWORD PTR DS:[EAX]
00401EC1  |. FF91 80000000      CALL NEAR DWORD PTR DS:[ECX+80]
00401EC7  |. B8 01000000        MOV EAX,1
00401ECC  |. 5E                 POP ESI
00401ECD  |. 83C4 7C            ADD ESP,7C
00401ED0  \. C3                 RETN*/

/*00401100  /$ 81EC C0010000      SUB ESP,1C0                             ;   colore le personage
00401106  |. 53                 PUSH EBX
00401107  |. 56                 PUSH ESI
00401108  |. 8BF1               MOV ESI,ECX
0040110A  |. 33DB               XOR EBX,EBX
0040110C  |. 8B8C24 D4010000    MOV ECX,DWORD PTR SS:[ESP+1D4]
00401113  |. 3BCB               CMP ECX,EBX
00401115  |. 0F84 CE030000      JE 004014E9
0040111B  |. 55                 PUSH EBP
0040111C  |. 8BAC24 D0010000    MOV EBP,DWORD PTR SS:[ESP+1D0]
00401123  |. 0FAFAC24 D4010000  IMUL EBP,DWORD PTR SS:[ESP+1D4]
0040112B  |. 57                 PUSH EDI
0040112C  |. 896C24 14          MOV DWORD PTR SS:[ESP+14],EBP
00401130  |. 8D442D 00          LEA EAX,DWORD PTR SS:[EBP+EBP]
00401134  |. 894424 10          MOV DWORD PTR SS:[ESP+10],EAX
00401138  |. 50                 PUSH EAX
00401139  |. 8B46 34            MOV EAX,DWORD PTR DS:[ESI+34]
0040113C  |. 51                 PUSH ECX
0040113D  |. 50                 PUSH EAX
0040113E  |. FF15 E0C04B00      CALL NEAR DWORD PTR DS:[4BC0E0]         ;  Original.00401000
00401144  |. BA 06000000        MOV EDX,6
00401149  |. B9 03000000        MOV ECX,3
0040114E  |. 899424 80000000    MOV DWORD PTR SS:[ESP+80],EDX
00401155  |. 899424 84000000    MOV DWORD PTR SS:[ESP+84],EDX
0040115C  |. 899424 88000000    MOV DWORD PTR SS:[ESP+88],EDX
00401163  |. 899424 8C000000    MOV DWORD PTR SS:[ESP+8C],EDX
0040116A  |. 899424 90000000    MOV DWORD PTR SS:[ESP+90],EDX
00401171  |. 899424 94000000    MOV DWORD PTR SS:[ESP+94],EDX
00401178  |. 899424 98000000    MOV DWORD PTR SS:[ESP+98],EDX
0040117F  |. 899424 9C000000    MOV DWORD PTR SS:[ESP+9C],EDX
00401186  |. 899424 A0000000    MOV DWORD PTR SS:[ESP+A0],EDX
0040118D  |. 899424 A4000000    MOV DWORD PTR SS:[ESP+A4],EDX
00401194  |. BF 04000000        MOV EDI,4
00401199  |. B8 05000000        MOV EAX,5
0040119E  |. BA 02000000        MOV EDX,2
004011A3  |. 83C4 0C            ADD ESP,0C
004011A6  |. 894C24 18          MOV DWORD PTR SS:[ESP+18],ECX
004011AA  |. 894C24 1C          MOV DWORD PTR SS:[ESP+1C],ECX
004011AE  |. 894C24 20          MOV DWORD PTR SS:[ESP+20],ECX
004011B2  |. 894C24 24          MOV DWORD PTR SS:[ESP+24],ECX
004011B6  |. 894C24 28          MOV DWORD PTR SS:[ESP+28],ECX
004011BA  |. 897C24 2C          MOV DWORD PTR SS:[ESP+2C],EDI
004011BE  |. 897C24 30          MOV DWORD PTR SS:[ESP+30],EDI
004011C2  |. 897C24 34          MOV DWORD PTR SS:[ESP+34],EDI
004011C6  |. 897C24 38          MOV DWORD PTR SS:[ESP+38],EDI
004011CA  |. 897C24 3C          MOV DWORD PTR SS:[ESP+3C],EDI
004011CE  |. 897C24 40          MOV DWORD PTR SS:[ESP+40],EDI
004011D2  |. 897C24 44          MOV DWORD PTR SS:[ESP+44],EDI
004011D6  |. 897C24 48          MOV DWORD PTR SS:[ESP+48],EDI
004011DA  |. 894424 4C          MOV DWORD PTR SS:[ESP+4C],EAX
004011DE  |. 894424 50          MOV DWORD PTR SS:[ESP+50],EAX
004011E2  |. 894424 54          MOV DWORD PTR SS:[ESP+54],EAX
004011E6  |. 894424 58          MOV DWORD PTR SS:[ESP+58],EAX
004011EA  |. 894424 5C          MOV DWORD PTR SS:[ESP+5C],EAX
004011EE  |. 894424 60          MOV DWORD PTR SS:[ESP+60],EAX
004011F2  |. 894424 64          MOV DWORD PTR SS:[ESP+64],EAX
004011F6  |. 894424 68          MOV DWORD PTR SS:[ESP+68],EAX
004011FA  |. 894424 6C          MOV DWORD PTR SS:[ESP+6C],EAX
004011FE  |. 894424 70          MOV DWORD PTR SS:[ESP+70],EAX
00401202  |. 898424 9C000000    MOV DWORD PTR SS:[ESP+9C],EAX
00401209  |. 898424 A0000000    MOV DWORD PTR SS:[ESP+A0],EAX
00401210  |. 898424 A4000000    MOV DWORD PTR SS:[ESP+A4],EAX
00401217  |. 898424 A8000000    MOV DWORD PTR SS:[ESP+A8],EAX
0040121E  |. 898424 AC000000    MOV DWORD PTR SS:[ESP+AC],EAX
00401225  |. 898424 B0000000    MOV DWORD PTR SS:[ESP+B0],EAX
0040122C  |. 898424 B4000000    MOV DWORD PTR SS:[ESP+B4],EAX
00401233  |. 898424 B8000000    MOV DWORD PTR SS:[ESP+B8],EAX
0040123A  |. 898424 BC000000    MOV DWORD PTR SS:[ESP+BC],EAX
00401241  |. 89BC24 C0000000    MOV DWORD PTR SS:[ESP+C0],EDI
00401248  |. 89BC24 C4000000    MOV DWORD PTR SS:[ESP+C4],EDI
0040124F  |. 89BC24 C8000000    MOV DWORD PTR SS:[ESP+C8],EDI
00401256  |. 89BC24 CC000000    MOV DWORD PTR SS:[ESP+CC],EDI
0040125D  |. 89BC24 D0000000    MOV DWORD PTR SS:[ESP+D0],EDI
00401264  |. 89BC24 D4000000    MOV DWORD PTR SS:[ESP+D4],EDI
0040126B  |. 89BC24 D8000000    MOV DWORD PTR SS:[ESP+D8],EDI
00401272  |. 89BC24 DC000000    MOV DWORD PTR SS:[ESP+DC],EDI
00401279  |. 89BC24 E0000000    MOV DWORD PTR SS:[ESP+E0],EDI
00401280  |. 898C24 E4000000    MOV DWORD PTR SS:[ESP+E4],ECX
00401287  |. 898C24 E8000000    MOV DWORD PTR SS:[ESP+E8],ECX
0040128E  |. 898C24 EC000000    MOV DWORD PTR SS:[ESP+EC],ECX
00401295  |. 898C24 F0000000    MOV DWORD PTR SS:[ESP+F0],ECX
0040129C  |. 898C24 F4000000    MOV DWORD PTR SS:[ESP+F4],ECX
004012A3  |. 898C24 F8000000    MOV DWORD PTR SS:[ESP+F8],ECX
004012AA  |. 898C24 FC000000    MOV DWORD PTR SS:[ESP+FC],ECX
004012B1  |. 898C24 00010000    MOV DWORD PTR SS:[ESP+100],ECX
004012B8  |. 899424 04010000    MOV DWORD PTR SS:[ESP+104],EDX
004012BF  |. 899424 08010000    MOV DWORD PTR SS:[ESP+108],EDX
004012C6  |. 899424 0C010000    MOV DWORD PTR SS:[ESP+10C],EDX
004012CD  |. 899424 10010000    MOV DWORD PTR SS:[ESP+110],EDX
004012D4  |. 898C24 BC010000    MOV DWORD PTR SS:[ESP+1BC],ECX
004012DB  |. 898C24 C0010000    MOV DWORD PTR SS:[ESP+1C0],ECX
004012E2  |. 898C24 C4010000    MOV DWORD PTR SS:[ESP+1C4],ECX
004012E9  |. 898C24 C8010000    MOV DWORD PTR SS:[ESP+1C8],ECX
004012F0  |. 898C24 CC010000    MOV DWORD PTR SS:[ESP+1CC],ECX
004012F7  |. B8 01000000        MOV EAX,1
004012FC  |. 33C9               XOR ECX,ECX
004012FE  |. 3BEB               CMP EBP,EBX
00401300  |. 899424 14010000    MOV DWORD PTR SS:[ESP+114],EDX
00401307  |. 899424 18010000    MOV DWORD PTR SS:[ESP+118],EDX
0040130E  |. 899424 1C010000    MOV DWORD PTR SS:[ESP+11C],EDX
00401315  |. 899424 20010000    MOV DWORD PTR SS:[ESP+120],EDX
0040131C  |. 899424 24010000    MOV DWORD PTR SS:[ESP+124],EDX
00401323  |. 898424 28010000    MOV DWORD PTR SS:[ESP+128],EAX
0040132A  |. 898424 2C010000    MOV DWORD PTR SS:[ESP+12C],EAX
00401331  |. 898424 30010000    MOV DWORD PTR SS:[ESP+130],EAX
00401338  |. 898424 34010000    MOV DWORD PTR SS:[ESP+134],EAX
0040133F  |. 898424 38010000    MOV DWORD PTR SS:[ESP+138],EAX
00401346  |. 898424 3C010000    MOV DWORD PTR SS:[ESP+13C],EAX
0040134D  |. 898424 40010000    MOV DWORD PTR SS:[ESP+140],EAX
00401354  |. 898424 44010000    MOV DWORD PTR SS:[ESP+144],EAX
0040135B  |. 898424 48010000    MOV DWORD PTR SS:[ESP+148],EAX
00401362  |. 898424 4C010000    MOV DWORD PTR SS:[ESP+14C],EAX
00401369  |. 898424 50010000    MOV DWORD PTR SS:[ESP+150],EAX
00401370  |. 899C24 54010000    MOV DWORD PTR SS:[ESP+154],EBX
00401377  |. 899C24 58010000    MOV DWORD PTR SS:[ESP+158],EBX
0040137E  |. 899C24 5C010000    MOV DWORD PTR SS:[ESP+15C],EBX
00401385  |. 899C24 60010000    MOV DWORD PTR SS:[ESP+160],EBX
0040138C  |. 899C24 64010000    MOV DWORD PTR SS:[ESP+164],EBX
00401393  |. 899C24 68010000    MOV DWORD PTR SS:[ESP+168],EBX
0040139A  |. 899C24 6C010000    MOV DWORD PTR SS:[ESP+16C],EBX
004013A1  |. 899C24 70010000    MOV DWORD PTR SS:[ESP+170],EBX
004013A8  |. 899C24 74010000    MOV DWORD PTR SS:[ESP+174],EBX
004013AF  |. 899C24 78010000    MOV DWORD PTR SS:[ESP+178],EBX
004013B6  |. 898424 7C010000    MOV DWORD PTR SS:[ESP+17C],EAX
004013BD  |. 898424 80010000    MOV DWORD PTR SS:[ESP+180],EAX
004013C4  |. 898424 84010000    MOV DWORD PTR SS:[ESP+184],EAX
004013CB  |. 898424 88010000    MOV DWORD PTR SS:[ESP+188],EAX
004013D2  |. 898424 8C010000    MOV DWORD PTR SS:[ESP+18C],EAX
004013D9  |. 898424 90010000    MOV DWORD PTR SS:[ESP+190],EAX
004013E0  |. 898424 94010000    MOV DWORD PTR SS:[ESP+194],EAX
004013E7  |. 898424 98010000    MOV DWORD PTR SS:[ESP+198],EAX
004013EE  |. 898424 9C010000    MOV DWORD PTR SS:[ESP+19C],EAX
004013F5  |. 899424 A0010000    MOV DWORD PTR SS:[ESP+1A0],EDX
004013FC  |. 899424 A4010000    MOV DWORD PTR SS:[ESP+1A4],EDX
00401403  |. 899424 A8010000    MOV DWORD PTR SS:[ESP+1A8],EDX
0040140A  |. 899424 AC010000    MOV DWORD PTR SS:[ESP+1AC],EDX
00401411  |. 899424 B0010000    MOV DWORD PTR SS:[ESP+1B0],EDX
00401418  |. 899424 B4010000    MOV DWORD PTR SS:[ESP+1B4],EDX
0040141F  |. 899424 B8010000    MOV DWORD PTR SS:[ESP+1B8],EDX
00401426  |. 0F8E A1000000      JLE 004014CD
0040142C  |> 83F9 0A            /CMP ECX,0A
0040142F  |. 7D 10              |JGE SHORT 00401441
00401431  |. 8B56 34            |MOV EDX,DWORD PTR DS:[ESI+34]
00401434  |. 8B46 30            |MOV EAX,DWORD PTR DS:[ESI+30]
00401437  |. 66:8B144A          |MOV DX,WORD PTR DS:[EDX+ECX*2]
0040143B  |. 66:891448          |MOV WORD PTR DS:[EAX+ECX*2],DX
0040143F  |. EB 7F              |JMP SHORT 004014C0
00401441  |> 8BC1               |MOV EAX,ECX
00401443  |. BD 80020000        |MOV EBP,280
00401448  |. 99                 |CDQ
00401449  |. F7FD               |IDIV EBP
0040144B  |. 3BD3               |CMP EDX,EBX
0040144D  |. 75 11              |JNZ SHORT 00401460
0040144F  |. 8B6E 38            |MOV EBP,DWORD PTR DS:[ESI+38]
00401452  |. 45                 |INC EBP
00401453  |. 8BC5               |MOV EAX,EBP
00401455  |. 896E 38            |MOV DWORD PTR DS:[ESI+38],EBP
00401458  |. 83F8 6E            |CMP EAX,6E
0040145B  |. 7C 03              |JL SHORT 00401460
0040145D  |. 895E 38            |MOV DWORD PTR DS:[ESI+38],EBX
00401460  |> 3BD7               |CMP EDX,EDI
00401462  |. 7D 19              |JGE SHORT 0040147D
00401464  |. 8B46 38            |MOV EAX,DWORD PTR DS:[ESI+38]
00401467  |. 395484 18          |CMP DWORD PTR SS:[ESP+EAX*4+18],EDX
0040146B  |. 7E 10              |JLE SHORT 0040147D
0040146D  |. 8B56 34            |MOV EDX,DWORD PTR DS:[ESI+34]
00401470  |. 8B46 30            |MOV EAX,DWORD PTR DS:[ESI+30]
00401473  |. 66:8B144A          |MOV DX,WORD PTR DS:[EDX+ECX*2]
00401477  |. 66:891448          |MOV WORD PTR DS:[EAX+ECX*2],DX
0040147B  |. EB 43              |JMP SHORT 004014C0
0040147D  |> 81FA 7B020000      |CMP EDX,27B
00401483  |. 7E 20              |JLE SHORT 004014A5
00401485  |. 8B46 38            |MOV EAX,DWORD PTR DS:[ESI+38]
00401488  |. 8B4484 18          |MOV EAX,DWORD PTR SS:[ESP+EAX*4+18]
0040148C  |. 05 7B020000        |ADD EAX,27B
00401491  |. 3BC2               |CMP EAX,EDX
00401493  |. 7D 10              |JGE SHORT 004014A5
00401495  |. 8B56 34            |MOV EDX,DWORD PTR DS:[ESI+34]
00401498  |. 8B46 30            |MOV EAX,DWORD PTR DS:[ESI+30]
0040149B  |. 66:8B144A          |MOV DX,WORD PTR DS:[EDX+ECX*2]
0040149F  |. 66:891448          |MOV WORD PTR DS:[EAX+ECX*2],DX
004014A3  |. EB 1B              |JMP SHORT 004014C0
004014A5  |> 8B46 38            |MOV EAX,DWORD PTR DS:[ESI+38]
004014A8  |. 8BD1               |MOV EDX,ECX
004014AA  |. 8B6C84 18          |MOV EBP,DWORD PTR SS:[ESP+EAX*4+18]
004014AE  |. 8B46 34            |MOV EAX,DWORD PTR DS:[ESI+34]
004014B1  |. 2BD5               |SUB EDX,EBP
004014B3  |. 8B6E 30            |MOV EBP,DWORD PTR DS:[ESI+30]
004014B6  |. 66:8B5450 08       |MOV DX,WORD PTR DS:[EAX+EDX*2+8]
004014BB  |. 66:89544D 00       |MOV WORD PTR SS:[EBP+ECX*2],DX
004014C0  |> 8B4424 14          |MOV EAX,DWORD PTR SS:[ESP+14]
004014C4  |. 41                 |INC ECX
004014C5  |. 3BC8               |CMP ECX,EAX
004014C7  |.^0F8C 5FFFFFFF      \JL 0040142C
004014CD  |> 8B4424 10          MOV EAX,DWORD PTR SS:[ESP+10]
004014D1  |. 8B4E 30            MOV ECX,DWORD PTR DS:[ESI+30]
004014D4  |. 8B9424 DC010000    MOV EDX,DWORD PTR SS:[ESP+1DC]
004014DB  |. 50                 PUSH EAX                                ; /Arg3
004014DC  |. 51                 PUSH ECX                                ; |Arg2
004014DD  |. 52                 PUSH EDX                                ; |Arg1
004014DE  |. FF15 E0C04B00      CALL NEAR DWORD PTR DS:[4BC0E0]         ; \Original.00401000
004014E4  |. 83C4 0C            ADD ESP,0C
004014E7  |. 5F                 POP EDI
004014E8  |. 5D                 POP EBP
004014E9  |> 5E                 POP ESI
004014EA  |. 5B                 POP EBX
004014EB  |. 81C4 C0010000      ADD ESP,1C0
004014F1  \. C2 0C00            RETN 0C*/

/*********************************************************************************************************************
**  void CGame::Abaddon_corpse(int sX, int sY);		( Snoopy )														**
**  description			: Placeholder for abaddon's death lightnings												**
**********************************************************************************************************************/
void CGame::Abaddon_corpse(int sX, int sY)
{	int ir = (rand()%20)-10;
	_DrawThunderEffect(sX+30 , 0, sX+30 , sY-10 , ir, ir, 1);
	_DrawThunderEffect(sX+30 , 0, sX+30 , sY-10 , ir+2, ir, 2);
	_DrawThunderEffect(sX+30 , 0, sX+30 , sY-10 , ir-2, ir, 2);
	ir = (rand()%20)-10;
	_DrawThunderEffect(sX-20 , 0, sX-20 , sY-35 , ir, ir, 1);
	_DrawThunderEffect(sX-20 , 0, sX-20 , sY-35 , ir+2, ir, 2);
	_DrawThunderEffect(sX-20 , 0, sX-20 , sY-35 , ir-2, ir, 2);
	ir = (rand()%20)-10;
	_DrawThunderEffect(sX-10 , 0, sX-10 , sY+30	, ir, ir, 1);
	_DrawThunderEffect(sX-10 , 0, sX-10 , sY+30	, ir+2, ir+2, 2);
	_DrawThunderEffect(sX-10 , 0, sX-10 , sY+30	, ir-2, ir+2, 2);
	ir = (rand()%20)-10;
	_DrawThunderEffect(sX+50 , 0, sX+50 , sY+35	, ir, ir, 1);
	_DrawThunderEffect(sX+50 , 0, sX+50 , sY+35	, ir+2, ir+2, 2);
	_DrawThunderEffect(sX+50 , 0, sX+50 , sY+35	, ir-2, ir+2, 2);
	ir = (rand()%20)-10;
	_DrawThunderEffect(sX+65 , 0, sX+65 , sY-5	, ir, ir, 1);
	_DrawThunderEffect(sX+65 , 0, sX+65 , sY-5	, ir+2, ir+2, 2);
	_DrawThunderEffect(sX+65 , 0, sX+65 , sY-5	, ir-2, ir+2, 2);
	ir = (rand()%20)-10;
	_DrawThunderEffect(sX+45 , 0, sX+45 , sY-50	, ir, ir, 1);
	_DrawThunderEffect(sX+45 , 0, sX+45 , sY-50	, ir+2, ir+2, 2);
	_DrawThunderEffect(sX+45 , 0, sX+45 , sY-50	, ir-2, ir+2, 2);

	for (int x=sX-50; x<=sX+100; x+= rand()%35)
	for (int y=sY-30; y<=sY+50; y+= rand()%45)
	{	ir = (rand()%20)-10;
		_DrawThunderEffect(x , 0, x , y, ir, ir, 2);
	}
}

/*********************************************************************************************************************
**  void DebugLog(char * cStr)			( Snoopy )																	**
**  description			: writes data into "Debug.txt"																**
**********************************************************************************************************************/
void CGame::DebugLog(char * cStr)
{FILE * pFile;
 char cBuffer[512];
 SYSTEMTIME SysTime;
	pFile = fopen("Debug.txt", "at");
	if (pFile == NULL) return;
	ZeroMemory(cBuffer, sizeof(cBuffer));
	GetLocalTime(&SysTime);
	wsprintf(cBuffer, "(%4d:%2d:%2d_%2d:%2d:%2d) - ", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute,SysTime.wSecond);
	strcat(cBuffer, cStr);
	strcat(cBuffer, "\n");
	fwrite(cBuffer, 1, strlen(cBuffer), pFile);
	fclose(pFile);
}
#ifdef DEF_ANTI_HACK
/*********************************************************************************************************************
**  void CGame::CheckProcesses()	( Snoopy )																		**
**  description			: 	Check if forbiden precesses running (1st, evident function)								**
**********************************************************************************************************************/
bool CGame::CheckProcesses()
{HANDLE hSnapShot;
 PROCESSENTRY32 uProcess;
 BOOL r;
 BOOL bFound = FALSE;
 char *UprocessName, *Ufoundprocess;
    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL,0);
    uProcess.dwSize = (DWORD) sizeof(PROCESSENTRY32);
    r = Process32First(hSnapShot, &uProcess);
    do
    {  	Ufoundprocess = _strupr( uProcess.szExeFile );
		if ( strcmp(Ufoundprocess, "SPEEDERXP.EXE") == 0 )	bFound = TRUE;
		if ( strcmp(Ufoundprocess, "MM.EXE") == 0 )			bFound = TRUE;
		if ( strcmp(Ufoundprocess, "WPE PRO.EXE") == 0 )	bFound = TRUE;
		if ( strcmp(Ufoundprocess, "TEHELGAME.EXE") == 0 )	bFound = TRUE;
		if ( strcmp(Ufoundprocess, "HELGAME.EXE") == 0 )	bFound = TRUE;
		if ( strcmp(Ufoundprocess, "SPEED HACK.EXE") == 0 ) bFound = TRUE;
		if ( strcmp(Ufoundprocess, "SPEEDHACKNT.EXE") == 0) bFound = TRUE;
		if ( strcmp(Ufoundprocess, "ASPEEDER.EXE") == 0 )	bFound = TRUE;
		if ( strcmp(Ufoundprocess, "WPEPRO.EXE") == 0 )		bFound = TRUE;
		//DebugLog(uProcess.szExeFile);
        r = Process32Next(hSnapShot, &uProcess);
    } while ( r );
    CloseHandle(hSnapShot);
	if (bFound == TRUE)
	{	SetTopMsg("You may not move due to an illegal program running in your PC.", 8);
	}
	m_bHackMoveBlocked = bFound;
    return (bFound);
}
/*********************************************************************************************************************
**  void CGame::DoCRC()	( Snoopy )																					**
**  description			: 	Computes Client's CRC to send to server.												**
**********************************************************************************************************************/
#include <imagehlp.h>
void CGame::DoCRC()
{	IMAGE_DOS_HEADER        image_dos_header;
	IMAGE_NT_HEADERS        image_nt_headers;
	IMAGE_SECTION_HEADER    image_section_header;
	int iAddress;

	// Decode PE header
	PCHAR pMem;						// pMem is pointer to storage of PE file in memory
	//pMem = (char *) 0x00400000;
	pMem = (char *) 0x002DA15C + m_iMangler; // = 0x00400000

	// get DOS header
   IMAGE_DOS_HEADER * pDosHeader = (IMAGE_DOS_HEADER *)pMem;

    // get NT header
   IMAGE_NT_HEADERS * pNtHeaders = (IMAGE_NT_HEADERS*)((DWORD)pMem+pDosHeader->e_lfanew);

    // find an offset to the main PE header ...
   IMAGE_FILE_HEADER * pFileHeader = 
       (IMAGE_FILE_HEADER *)(((LPBYTE)pMem) + 
                     pDosHeader->e_lfanew + 
                     sizeof(IMAGE_NT_SIGNATURE));

   // ... and optional PE header
   IMAGE_OPTIONAL_HEADER * pOptHeader = 
       (IMAGE_OPTIONAL_HEADER *)(((LPBYTE)pFileHeader) + 
                     IMAGE_SIZEOF_FILE_HEADER);

   IMAGE_SECTION_HEADER * sectionHeader = 
       (IMAGE_SECTION_HEADER *)(((LPBYTE)pOptHeader) + 
                    pFileHeader->SizeOfOptionalHeader);

	byte *buf = new byte [sectionHeader->SizeOfRawData]; // Ne scanne pas la section .data

	memcpy( buf, (void *)(pMem + sectionHeader->VirtualAddress), sectionHeader->SizeOfRawData);
	

	// CRC the buffer
	m_CRCdemo.Init_CRC32_Table();

	m_dwCRC32 =   m_CRCdemo.Get_CRC((char*)buf, (int)sectionHeader->SizeOfRawData);



	
	/* 
	memcpy(&image_dos_header,		pMem,								sizeof(IMAGE_DOS_HEADER));
	memcpy(&image_nt_headers,		pMem + image_dos_header.e_lfanew,	sizeof(IMAGE_NT_HEADERS));
	iAddress = (int)pMem + image_dos_header.e_lfanew + sizeof(IMAGE_NT_HEADERS);
	memcpy(&image_section_header, (void *) iAddress, sizeof(IMAGE_SECTION_HEADER));
	// Copy memory to buffer
	byte *buf = new byte [image_section_header.SizeOfRawData]; // Ne scanne pas la section .data	
		ZeroMemory(buf, sizeof(buf));	
	memcpy( buf, (void *)(pMem + image_section_header.VirtualAddress), image_section_header.SizeOfRawData);
	// CRC the buffer
	m_CRCdemo.Init_CRC32_Table();
	m_dwCRC32 =   m_CRCdemo.Get_CRC((char*)buf, (int)image_section_header.SizeOfRawData);
	*/


	// Remove 0x0000 cases
    if ( (m_dwCRC32 & 0x0000FFFF) == 0x0000FFFF) m_dwCRC32 += 0x01000000;
    if ( (m_dwCRC32 & 0xFFFF0000) == 0xFFFF0000) m_dwCRC32 += 0x00000010;
	m_wCRC16_1 = m_dwCRC32 >> 16;
	m_wCRC16_2 = (m_dwCRC32 << 16)>> 16;

	// Prevent 0x0000
	if (m_wCRC16_1 == 0) 
	{	m_wCRC16_1 = 0x1C10;
	}
	if (m_wCRC16_2 == 0)
	{	m_wCRC16_2 = 0x2C10;
	}
	// Prevent equality...
	if (m_wCRC16_1 == m_wCRC16_2) 
	{	if (m_wCRC16_2 == 0x11C1) m_wCRC16_2 = 0x2C12;
		else m_wCRC16_1 = 0x11C1;
	}


/*	wsprintf(G_cTxt,"Debug :1:%d    2:%d    3:%d    4:%d"
				, (int) pMem + (int) sectionHeader->VirtualAddress
				, (int) sectionHeader->SizeOfRawData
				, m_wCRC16_1
				, m_wCRC16_2);
	DebugLog(G_cTxt);*/


}
#endif

/*********************************************************************************************************************
**  void Buel(int iAngelType)	( Snoopy )	// Reversed by Snoopy												**
**  description			: 															**
**********************************************************************************************************************/




